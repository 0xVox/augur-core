# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [addToWhitelist:[int256]:int256, assertIsWhitelisted:[int256]:int256, assertOnlySpecifiedCaller:[int256,int256]:_, changeMode:[int256]:int256, emergencyStop:[]:int256, getMode:[]:int256, getOwner:[]:int256, lookup:[int256]:int256, onlyInEmergency:[]:_, release:[]:int256, removeFromWhitelist:[int256,int256]:int256, setValue:[int256,int256]:int256, stopInEmergency:[]:_, suicide:[int256,int256,int256]:int256, switchModeSoOnlyEmergencyStopsAndEscapeHatchesCanBeUsed:[]:_, transferOwnership:[int256,int256,int256,int256]:int256, updateController:[int256,int256]:int256]

data controller
data key

def any():
    if (self.controller and self.key):
        # we need to call this method and specify a location in memory (offset 0) to store the results so we can use it later. if we let the compiler do it, it sometimes re-orders the call to _after_ our calldatacopy call which results in the compiler generated bytecode blowing away a chunk of our memory
        ~mstore(0, self.controller.lookup(self.key))
        # this copies the method signature and parameters into memory starting at offset 32 (offset [0-32) is used above)
        ~calldatacopy(32, 0, ~calldatasize())
        # call the library contract at the method signature provided and with the parameters provided, then write the results into memory at offset 0.
        # TODO: figure out how much gas is used up to this point and replace the -10000
        ~delegatecall(msg.gas - 10000, ~mload(0), 32, ~calldatasize(), 0, 32)
        # return the result of the library call to the caller, limited to 32-bytes returned
        ~return(0, 32)

def setup(controller, key):
    self.controller = controller
    self.key = key
