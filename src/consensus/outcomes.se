import expiringEvents as EXPEVENTS
import reporting as REPORTING
import fxpFunctions as FXP
import events as EVENTS

def resolve(branch, period, num_events, num_reports):
    with scaled = array(num_events):
        with scaled_max = array(num_events):
            with scaled_min = array(num_events):
                with j = 0:
                    while j < num_events:
                        with event = EXPIRING.getEvent(branch, period, j):
                            if 2^64*EVENTS.getMaxValue(event) != YES and EVENTS.getNumOutcomes(event) == 2:
                                scaled[j] = 1
                                scaled_min[j] = 2^64*EVENTS.getMinValue(event)
                                scaled_max[j] = 2^64*EVENTS.getMaxValue(event)
                            # categorical, but we can make it behave as a scalar for all intents and purposes here
                            elif(EVENTS.getNumOutcomes(event)>2):
                                scaled[j] = 1
                                scaled_min[j] = 2^64
                                scaled_max[j] = 2^64*EVENTS.getNumOutcomes(event)
                            else:
                                scaled[j] = 0
                                scaled_min[j] = NO
                                scaled_max[j] = YES
                        j += 1
                    with outcomes = array(num_events):
                        outcomes = slice(self.consensus(branch, scaled, scaled_max, scaled_min, num_reports, num_events, period, outitems=num_events), items=0, items=num_events)
                        EXPIRING.setOutcomesFinal(branch, period, outcomes)
                        return(1)

def consensus(branch, scaled:arr, scaled_max:arr, scaled_min:arr, num_reports, num_events, period):
            with outcomes_raw = array(num_events):
                with smooth_rep = array(num_reports):
                    n = 0
                    while n < num_reports:
                        smooth_rep[n] = REPORTING.getRepByIndex(branch, n)
                    with i = 0:
                        while i < num_events:
                            if scaled[i] == 1:
                                with active_reports = array(num_reports):
                                    with j = 0:
                                        while j < num_reports:
                                            active_reports[j] = EXPEVENTS.getReport(branch, period, REPORTING.getReporterID(branch, j), i)
                                            j += 1
                                    outcomes_raw[i] = fixed_multiply(weighted_median(active_reports, smooth_rep), scaled_max[i] - scaled_min[i]) + scaled_min[i]
                            else:
                                with j = 0:
                                    while j < num_reports:
                                        outcomes_raw[i] += catch(fixed_multiply(smooth_rep[j], reports[j*num_events + i]))
                                        j += 1
                            i += 1
                        return(outcomes_raw, items=num_events)

macro ONE: 2^64

macro YES: 2^65
macro NO: 2^64
macro BAD: 3 * 2^63

macro CATCH_TOLERANCE: 2^64 / 10

# Sum elements of array
macro sum($a):
    with $len = len($a):
        with $total = 0:
            with $i = 0:
                while $i < $len:
                    $total += $a[$i]
                    $i += 1
                $total

# Absolute value
macro abs($n):
    if($n<0, -$n, $n)


# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE), NO, if($x > BAD + CATCH_TOLERANCE, YES, BAD))
    # if $x < BAD - CATCH_TOLERANCE:
    #     c = NO
    # elif $x > BAD + CATCH_TOLERANCE:
    #     c = YES
    # else:
    #     c = BAD
    # c

# Absolute value of all array elements
macro array_abs($a):
    with $len = len($a):
        with $absval = array($len):
            with $i = 0:
                while $i < $len:
                    $absval[$i] = abs($a[$i])
                    $i += 1
                $absval

# Minimum value of array
macro minimum($a):
    with $min = $a[0]:
        with $i = 1:
            with $len = len($a):
                while $i < $len:
                    if $a[$i] < $min:
                        $min = $a[$i]
                    $i += 1
                $min

# Maximum value of array
macro maximum($a):
    with $max = $a[0]:
        with $i = 1:
            with $len = len($a):
                while $i < $len:
                    if $a[$i] > $max:
                        $max = $a[$i]
                    $i += 1
                $max

# Find index corresponding to the maximum value of an array
macro findmax($a):
    with $len = len($a):
        with $max = $a[0]:
            with $maxidx = 0:
                with $i = 1:
                    while $i < $len:
                        if $a[$i] > $max:
                            $maxval = $a[$i]
                            $maxidx = $i
                        $i += 1
                    $maxidx        

# Fixed-point multiplication
macro fixed_multiply($x, $y):
    $x * $y / ONE

# Fixed-point division
macro fixed_divide($x, $y):
    $x * ONE / $y

macro concat($a, $b):
    with $c = array(len($a)+len($b)):
        mcopy($c, $a, items=len($a))
        mcopy($c+(items=len($a)), $b, items=len($b))
        $c

macro swap($a, $i, $j):
    with $t = $a[$i]:
        $a[$i] = $a[$j]
        $a[$j] = $t

macro paired_qsort($a, $b):
    with $len = len($a):
        with $c = concat($a, $b):
            with $stack = array($len):
                with $top = 0:
                    with $h = 0:
                        with $l = 0:
                            with $x = 0:
                                with $i = 0:
                                    with $j = 0:
                                        $stack[0] = 0
                                        $stack[1] = $len - 1
                                        $top = 1
                                        while $top >= 0:
                                            $h = $stack[$top]
                                            $l = $stack[$top - 1]
                                            $top -= 2
                                            $x = $c[$h]
                                            $i = $l - 1
                                            $j = $l
                                            
                                            while $j <= $h - 1:
                                                if $c[$j] <= $x:
                                                    $i += 1
                                                    swap($c, $i, $j)
                                                    swap($c, $i + $len, $j + $len)
                                                $j += 1
                                            
                                            swap($c, $i+1, $h)
                                            swap($c, $i + $len + 1, $h + $len)
                                            if $i > $l:
                                                $stack[$top + 1] = $l
                                                $stack[$top + 2] = $i
                                                $top += 2
                                            if $i + 2 < $h:
                                                $stack[$top + 1] = $i + 2
                                                $stack[$top + 2] = $h
                                                $top += 2
                                        $c

# Weighted median of an array
macro weighted_median($data, $weights):
    with n = len($data):
        with done = 0:
            with midpoint = sum($weights) / 2:
                with j = 0:
                    while j < num_present[i]:
                        if $weights[j] > midpoint:
                            with maxidx = findmax($weights):
                                wmedian = $data[maxidx]
                            done = 1
                        j += 1
                if done == 0:
                    with sorted = paired_qsort($data, $weights):
                        with sorted_data = array(n):
                            with sorted_weights = array(n):
                                with j = 0:
                                    while j < n:
                                        sorted_data[j] = sorted[j]
                                        sorted_weights[j] = sorted[j + n]
                                        j += 1
                                with cumulative_weight = 0:
                                    with idx = 0:
                                        while cumulative_weight <= midpoint:
                                            idx += 1
                                            cumulative_weight += sorted_weights[idx-1]
                                        cumulative_weight -= sorted_weights[idx-1]
                                        # conservative machine epsilon: 
                                        # 0x1197998 = 18446744 = ONE / 10^12
                                        if abs(cumulative_weight - midpoint) < 0x1197998:
                                            wmedian = (sorted_data[idx-2] + sorted_data[idx-1]) / 2
                                        else:
                                            wmedian = sorted_data[idx-1]
                wmedian