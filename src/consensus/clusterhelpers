import expiringEvents as EXPEVENTS
import reporting as REPORTING
import clusterhelper as CLUSTER
import fxpFunctions as FXP

data best = -1
data bestDist = 2^255
# list of clusterIDs
data bestClusters[]
data i

data clusternodes[](vec[], numReporters, meanVec[], repInCluster, repVector[], reporterIndexVec[], distance)
data numClusters

# what happens if someone makes a new rep acc. during consensus
data repVector[]

def setBest(best):
    self.best = best
    return(1)

def setBestDist(dist):
    self.bestDist = dist
    return(1)

def setNumClusters(num):
    self.numClusters = num
    return(1)

def L2dist(x:arr, y:arr, numEvents):
    i = 0
    distSquare = 0
    while i < numEvents:
        distSquare += ((x[i] - y[i])^2)/2^64
        i += 1
    return(self.sqrt(distSquare))

def sqrt(n):
    approx = n/2
    better = (approx + n*2^64/approx)/2
    i = 0
    while i < 11:
        approx = better
        better = (approx + n*2^64/approx)/2
        i += 1
    return approx

def newMean(cluster, numEvents, branch, reportingPeriod):
	numReporters = self.clusternodes[cluster].numReporters
	weighted = array(numReporters)
	i = 0
	while i < numReporters:
		weighted[i] = array(numReporters)
		reporterID = REPORTING.getReporterID(branch, self.clusternodes[cluster]reporterIndexVec[i]):
		weighted[i] = EXPEVENTS.getReporterBallot(branch, reportingPeriod, reporterID, outitems=numEvents)
		e = 0
		while e < numEvents:
			weighted[i][e] = weighted[i][e] * REPORTING.getRepBalance(branch, reporterID) / 2^64
			e += 1
		i += 1
	mean = array(numEvents)
	i = 0
	totalRep = self.clusternodes[cluster].repInCluster
	while i < numEvents:
		r = 0
		while r < numReporters:
			mean[i] += weighted[r][i]
			r += 1
		mean[i] = mean[i]*2^64 / totalRep
		i += 1
	return(mean: arr)

def cluster(branch, votePeriod, numEvents, numReporters, fresh, threshold):
    if(fresh):
        self.i = 0
    memI = self.i
    while (memI < numReporters and tx.gas>200000):
        cmax = -1
        shortestDist = 2**255
        n = 0
        report = array(numEvents)
        reporterID = REPORTING.getReporterID(branch, memI)
        report = EXPEVENTS.getReporterBallot(branch, votePeriod, reporterID, outitems=numEvents)
        while n < numClusters:
            if(n!=0):
                dist = CLUSTER.L2dist(report, self.clusternodes[n].meanVec)
                if dist<shortestDist:
                    cmax = n
                    shortestDist = dist
            n += 1
        rep = REPORTING.getRepBalance(branch, reporterID)
        if(cmax!=-1 and shortestDist<threshold):
            self.clusternodes[cmax].reporterIndexVec[self.clusternodes[cmax].numReporters] = i
            self.clusternodes[cmax].repInCluster += rep
            self.clusternodes[cmax].repVector[self.clusternodes[cmax].numReporters] = rep
            self.clusternodes[cmax].numReporters += 1
            self.clusternodes[cmax].meanVec[] = array(mean(cmax))
        else:
            save(self.clusternodes[self.numClusters].meanVec[0], report, chars=32*numEvents)
            self.clusternodes[self.numClusters].numReporters = 1
            self.clusternodes[self.numClusters].repInCluster = rep
            self.clusternodes[self.numClusters].reporterIndexVec[0] = i
            self.clusternodes[self.numClusters].repVector[0] = rep
            self.numClusters += 1
        memI += 1
    self.i = memI
    if(self.i!=numReporters):
        return(0)
    if(process(len(features), times, thresholdm numEvents)):
        return(2)
    return(1)

def process(numReporters, times, threshold, numEvents):
    mode = 0
    numInMode = 0
    i = 0
    while i < self.numClusters:
        if(self.clusternodes[i].repInCluster > numInMode):
            numInMode = self.clusternodes[i].repInCluster
            #! if two modes (e.g. _exact same # of rep on both, so 2 equal sized clusters w/ same magnitude)
                # and pick the one as the mode cluster which is more similar to outcomes
            mode = i
        i += 1

    #outcomes = np.ma.average(features, axis=0, weights=rep)

    # detect how far the "truthers" are away from actual outcomes
    # then choose closer mode as final truth cluster
    #if(self.L2dist(load(self.clusternodes[mode].meanVec[0], chars=32*numEvents), outcomes)<bestDist):
    #    bestDist = L2dist(mode.meanVec, outcomes)
    #    best = mode
    #    bestClusters = clusters
    #if(L2dist(mode.meanVec,outcomes)>1.07 and times==1):
    #    possAltCluster = cluster(features,rep,2,threshold*3)
    #    return(possAltCluster)

    i = 0
    while i < self.numClusters:
        self.clusternodes[i].dist = self.L2dist(load(self.clusternodes[i].meanVec[0], chars=32*numEvents),load(self.clusternodes[mode].meanVec[0], chars=32*numEvents))
        i+=1
    distVector = array(numReporters)
    i = 0
    while i < self.numClusters:
        n = 0
        while n < self.clusternodes[i].numReporters:
            distVector[self.clusternodes[i].reporterIndexVec[n]] = self.clusternodes[i].dist
            n+=1
        i+=1

    repVector = array(numReporters)
    maxDist = maximum(distVector)
    i = 0
    while i < self.numReporters:
        repVector[i] = 2^64 - distVector[i]*2^64/(maxDist + 1)
        i+=1

    save()

    return(normalize(repVector): arr)

# Maximum value of array
macro maximum($a):
    with $max = $a[0]:
        with $i = 1:
            with $len = len($a):
                while $i < $len:
                    if $a[$i] > $max:
                        $max = $a[$i]
                    $i += 1
                $max

# Proportional distance from zero (fixed-point input)
macro normalize($a):
    with $len = len($a):
        with $total = 0:
            with $i = 0:
                while $i < $len:
                    $total += $a[$i]
                    $i += 1
                with $wt = array($len):
                    with $i = 0:
                        while $i < $len:
                            $wt[$i] = $a[$i] * 2^64 / $total
                            $i += 1
                        $wt