macro ONE: 2^64
macro BAD: 3 * 2^63
macro BOND: 42 * ONE

#def init():
    # create branch with a reporter with a event

def init():
    self.Branches[1010101].currentVotePeriod = (block.number / 1800) - 1 
    self.Branches[1010101].periodLength = 1800
    self.Branches[1010101].minTradingFee = 2^57
    self.branchListCount = 1
    self.branchList[0] = 1010101
    # test initial funds
    self.cashcoinBalances[tx.origin] = 100000*2^64
    description = text("Root branch")
    save(self.Info[1010101].description[0], description, chars=len(description))
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Info[1010101].descriptionLength = len(description)
    self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
    self.Reporting[1010101].reputation[0].repValue = 47*2^64
    self.Reporting[1010101].reputation[0].reporterID = tx.origin
    self.Reporting[1010101].numberReporters = 1
    self.Reporting[1010101].totalRep += 47*2^64

def makeEvent():
    description = text("lol")
    # expires in period 0
    x = self.createEvent(1010101, description, 1, 1, 2, 2, 1)
    self.incrementPeriod(1010101)
    return(x)

def dispatch(branch):
    #if !self.getStep(branch) and !QUORUM.checkQuorum(branch):
    #    return(-1)
    with period = self.getVotePeriod(branch):
        with num_events = self.getNumberEvents(branch, period):
            with num_reports = self.getNumberReporters(branch):
                with step = self.getStep(branch):
                    if step == 5:
                        self.payout(branch, period, num_events, num_reports)
                        self.setStep(branch, 0) # reset step
                        self.incrementPeriod(branch)
                        return(period + 1)
                    elif step == 0:
                        self.setTotalReputation(branch, period, self.getTotalRep(branch))
                    elif step == 1:
                        self.initCluster(branch, period, num_events, num_reports, 1)
                    elif step == 2:
                        threshold = (self.fx_log(num_events*2^64)*2^64/42475197863169474560)*2^64 / 32650737010465906688
                        if(threshold==0):
                            threshold = 5534023222112865280
                        # if not done, keep doing step two before incrementing the step
                        if(!self.cluster(branch, period, num_events, num_reports, 0, threshold)):
                            return(2)
                    elif step == 3:
                        self.smooth(branch, num_reports, num_events)
                    elif step == 4:
                        self.resolve(branch, period, num_events, num_reports)
                    self.incrementStep(branch)
                    return(step + 1)

# first call in a consensus cycle is fresh, else 0
def initCluster(branch, votePeriod, numEvents, numReporters, fresh):
    threshold = (self.fx_log(numEvents*2^64)*2^64/42475197863169474560)*2^64 / 32650737010465906688
    if(threshold==0):
        threshold = 5534023222112865280
    self.setBest(-1)
    self.setBestDist(2**254)
    self.setNumClusters(0)
    self.setI(0)
    return(1)

macro fetch($a, $n):
    with $memarray = array($n):
        with $i = 0:
            while $i < $n:
                $memarray[$i] = $a[$i]
                $i += 1
            $memarray

def cluster(branch, votePeriod, numEvents, numReporters, fresh, threshold):
    if(fresh):
        self.i = 0
    memI = self.i
    while (memI < numReporters and msg.gas>200000):
        cmax = -1
        shortestDist = 2**254
        n = 0
        report = array(numEvents)
        reporterID = self.getReporterID(branch, memI)
        report = self.getReporterBallot(branch, votePeriod, reporterID, outitems=numEvents)
        while n < self.numClusters:
            if(memI!=0):
                dist = self.L2dist(report, load(self.clusternodes[n].meanVec[0], items=numEvents), numEvents)
                if dist<shortestDist:
                    cmax = n
                    shortestDist = dist
            n += 1
        rep = self.getRepBalance(branch, reporterID)
        if(cmax!=-1 and shortestDist<threshold):
            self.clusternodes[cmax].reporterIndexVec[self.clusternodes[cmax].numReporters] = memI
            self.clusternodes[cmax].repInCluster += rep
            self.clusternodes[cmax].repVector[self.clusternodes[cmax].numReporters] = rep
            self.clusternodes[cmax].numReporters += 1
            newMean = array(numEvents)
            newMean = self.newMean(cmax, numEvents, branch, votePeriod, outitems=numEvents)
            save(self.clusternodes[cmax].meanVec[0], newMean, items=numEvents)
        else:
            save(self.clusternodes[self.numClusters].meanVec[0], report, items=numEvents)
            self.clusternodes[self.numClusters].numReporters = 1
            self.clusternodes[self.numClusters].repInCluster = rep
            self.clusternodes[self.numClusters].reporterIndexVec[0] = memI
            self.clusternodes[self.numClusters].repVector[0] = rep
            self.numClusters += 1
        memI += 1
    self.i = memI
    if(self.i!=numReporters):
        return(0)
    if(self.process(numReporters, 0, threshold, numEvents)):
        return(2)
    else:
        return(0)

def process(numReporters, times, threshold, numEvents):
    mode = 0
    numInMode = 0
    i = 0
    while i < self.numClusters:
        if(self.clusternodes[i].repInCluster > numInMode):
            numInMode = self.clusternodes[i].repInCluster
            #! if two modes (e.g. _exact same # of rep on both, so 2 equal sized clusters w/ same magnitude)
            # and pick the one as the mode cluster which is more similar to outcomes
            mode = i
        i += 1

    #outcomes = np.ma.average(features, axis=0, weights=rep)

    # detect how far the "truthers" are away from actual outcomes
    # then choose closer mode as final truth cluster
    #if(self.L2dist(load(self.clusternodes[mode].meanVec[0], chars=32*numEvents), outcomes)<bestDist):
    #    bestDist = L2dist(mode.meanVec, outcomes)
    #    best = mode
    #    bestClusters = clusters
    #if(L2dist(mode.meanVec,outcomes)>1.07 and times==1):
    #    possAltCluster = cluster(features,rep,2,threshold*3)
    #    return(possAltCluster)

    i = 0
    while i < self.numClusters:
        self.clusternodes[i].distance = self.L2dist(load(self.clusternodes[i].meanVec[0], items=numEvents),load(self.clusternodes[mode].meanVec[0], items=numEvents))
        i+=1
    distVector = array(numReporters)
    i = 0
    while i < self.numClusters:
        n = 0
        while n < self.clusternodes[i].numReporters:
            distVector[self.clusternodes[i].reporterIndexVec[n]] = self.clusternodes[i].distance
            n+=1
        i+=1

    repVector = array(numReporters)
    maxDist = maximum(distVector)
    i = 0
    while i < numReporters:
        # should not be 1 but 2^64
        # try fetching distance from the cluster
        repVector[i] = 2^64 - distVector[i]*2^64/(maxDist + 1)
        i+=1

    save(self.repVector[0], repVector, items=numReporters)
    return(1)


def smooth(branch, num_reports, num_events):
    # Weighted sum of old and new reputation vectors.
    # New: row_reward_weighted
    # Old: reputation
    adjusted_scores = array(num_reports)
    adjusted_scores = self.getRepVector(num_reports, outitems=num_reports)

    reputation = array(num_reports)
    i = 0
    while i < num_reports:
        reputation[i] = self.getRepByIndex(branch, i)
        i += 1

    reputation = normalize(reputation)

    with row_reward_weighted = array(num_reports):
        with i = 0:
            while i < num_reports:
                row_reward_weighted[i] = reputation[i]
                i += 1
        # Overwrite the inital declaration IF there wasn't perfect consensus.
        if minimum(adjusted_scores) != 2^64:
            with mean_weight = mean(row_reward_weighted):
                with i = 0:
                    while i < num_reports:
                        row_reward_weighted[i] = adjusted_scores[i] * row_reward_weighted[i] / mean_weight
                        i += 1
            row_reward_weighted = normalize(row_reward_weighted)
        # Freshly-calculated reward (in reputation)
        # (0.2 is the adjustable parameter "alpha", hard-coding it for now)
        with smooth_rep = array(num_reports):
            with i = 0:
                while i < num_reports:
                    smooth_rep[i] = row_reward_weighted[i]*2/10 + reputation[i]*8/10
                    i += 1
            smooth_rep = normalize(smooth_rep)
            with i = 0:
                with totalRep = self.getTotalReputation(branch):
                    while i < num_reports:
                        self.setRep(branch, i, smooth_rep[i]*totalRep/2**64)
                        i += 1
            return(1)

def payout(branch, period, num_events, num_reports):
    with outcomes = array(num_events):
        outcomes = slice(self.getOutcomesFinal(branch, period, outitems=num_events), items=0, items=num_events)
        # get event ID for each event by taking the x index in the reports arrays
        # - shoving it in reporting.events[] and getting the corresponding ID
        with j = 0:
            while j < num_events:
                with event = self.getEvent(branch, period, j):
                    # then take outcomes_final and set each event outcome
                    # (BAD and BOND macros defined in consensus/constants.se)
                    self.setOutcome(event, outcomes[j])
                    if outcomes[j] != BAD:
                        # return bond
                        self.subtractCash(event, BOND)
                        self.addCash(self.getCreator(event), BOND)
                    else:
                        # give event bond money to reporters
                        self.subtractCash(event, BOND)
                        self.addCash(branch, BOND)
                j += 1
        # - need to loop through rep holders and distribute 50% of branch fees to
        #   reporters' cashcoin addresses
        with totalRep = self.getTotalReputation(branch):
            with i = 0:
                while i < num_reports:
                    self.addCash(self.getReporterID(branch, i), fixed_multiply(self.balance(branch), self.getRepByIndex(branch, i)*2^64/totalRep))
                    i += 1
                self.subtractCash(branch, self.balance(branch))
    return(1)

# Proportional distance from zero (fixed-point input)
macro normalize($a):
    with $len = len($a):
        with $total = 0:
            with $i = 0:
                while $i < $len:
                    $total += $a[$i]
                    $i += 1
                with $wt = array($len):
                    with $i = 0:
                        while $i < $len:
                            $wt[$i] = $a[$i] * 2^64 / $total
                            $i += 1
                        $wt

# Minimum value of array
macro minimum($a):
    with $min = $a[0]:
        with $i = 1:
            with $len = len($a):
                while $i < $len:
                    if $a[$i] < $min:
                        $min = $a[$i]
                    $i += 1
                $min

# Sum elements of array
macro sum($a):
    with $len = len($a):
        with $total = 0:
            with $i = 0:
                while $i < $len:
                    $total += $a[$i]
                    $i += 1
                $total

# Arithmetic mean
macro mean($a):
    sum($a) / len($a)

# Fixed-point multiplication
macro fixed_multiply($x, $y):
    $x * $y / ONE

def resolve(branch, period, num_events, num_reports):
    with scaled = array(num_events):
        with scaled_max = array(num_events):
            with scaled_min = array(num_events):
                with j = 0:
                    while j < num_events:
                        with event = self.getEvent(branch, period, j):
                            if 2^64*self.getMaxValue(event) != YES and self.getNumOutcomes(event) == 2:
                                scaled[j] = 1
                                scaled_min[j] = 2^64*self.getMinValue(event)
                                scaled_max[j] = 2^64*self.getMaxValue(event)
                            # categorical, but we can make it behave as a scalar for all intents and purposes here
                            elif(self.getNumOutcomes(event)>2):
                                scaled[j] = 1
                                scaled_min[j] = 2^64
                                scaled_max[j] = 2^64*self.getNumOutcomes(event)
                            else:
                                scaled[j] = 0
                                scaled_min[j] = NO
                                scaled_max[j] = YES
                        j += 1
                    with outcomes = array(num_events):
                        outcomes = slice(self.calcOutcomes(branch, scaled, scaled_max, scaled_min, num_reports, num_events, period, outitems=num_events), items=0, items=num_events)
                        self.setOutcomesFinal(branch, period, outcomes)
                        return(1)

def calcOutcomes(branch, scaled:arr, scaled_max:arr, scaled_min:arr, num_reports, num_events, period):
    totalRep = self.getTotalReputation(branch)
    with outcomes_raw = array(num_events):
        with smooth_rep = array(num_reports):
            n = 0
            while n < num_reports:
                smooth_rep[n] = self.getRepByIndex(branch, n)
                n += 1
            smooth_rep = normalize(smooth_rep)
            reportMatrix = array(num_reports)
            i = 0
            while i < num_reports:
                reporter = self.getReporterID(1010101,i)
                reportMatrix[i] = array(num_events)
                reportMatrix[i] = self.getReporterBallot(1010101, period, reporter, outitems=num_events)
                i += 1
            with i = 0:
                while i < num_events:
                    if scaled[i] == 1:
                        with active_reports = array(num_reports):
                            with j = 0:
                                while j < num_reports:
                                    active_reports[j] = reportMatrix[j][i]
                                    j += 1
                            outcomes_raw[i] = fixed_multiply(weighted_median(active_reports, smooth_rep), scaled_max[i] - scaled_min[i]) + scaled_min[i]
                    else:
                        with j = 0:
                            while j < num_reports:
                                outcomes_raw[i] += fixed_multiply(smooth_rep[j], reportMatrix[j][i])
                                j += 1
                        # weighted avg
                        outcomes_raw[i] = catch(outcomes_raw[i])
                    i += 1
                return(outcomes_raw: arr)

macro ONE: 2^64

macro YES: 2^65
macro NO: 2^64
macro BAD: 3 * 2^63

# this is 10%, should be 15% in final version
macro CATCH_TOLERANCE: 2^64 / 10

# Sum elements of array
macro sum($a):
    with $len = len($a):
        with $total = 0:
            with $i = 0:
                while $i < $len:
                    $total += $a[$i]
                    $i += 1
                $total

# Absolute value
macro abs($n):
    if($n<0, -$n, $n)


# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE), NO, if($x > BAD + CATCH_TOLERANCE, YES, BAD))
    # if $x < BAD - CATCH_TOLERANCE:
    #     c = NO
    # elif $x > BAD + CATCH_TOLERANCE:
    #     c = YES
    # else:
    #     c = BAD
    # c

# Absolute value of all array elements
macro array_abs($a):
    with $len = len($a):
        with $absval = array($len):
            with $i = 0:
                while $i < $len:
                    $absval[$i] = abs($a[$i])
                    $i += 1
                $absval

# Maximum value of array
macro maximum($a):
    with $max = $a[0]:
        with $i = 1:
            with $len = len($a):
                while $i < $len:
                    if $a[$i] > $max:
                        $max = $a[$i]
                    $i += 1
                $max

# Find index corresponding to the maximum value of an array
macro findmax($a):
    with $len = len($a):
        with $max = $a[0]:
            with $maxidx = 0:
                with $i = 1:
                    while $i < $len:
                        if $a[$i] > $max:
                            $maxval = $a[$i]
                            $maxidx = $i
                        $i += 1
                    $maxidx        

# Fixed-point multiplication
macro fixed_multiply($x, $y):
    $x * $y / ONE

# Fixed-point division
macro fixed_divide($x, $y):
    $x * ONE / $y

macro concat($a, $b):
    with $c = array(len($a)+len($b)):
        mcopy($c, $a, items=len($a))
        mcopy($c+(items=len($a)), $b, items=len($b))
        $c

macro swap($a, $i, $j):
    with $t = $a[$i]:
        $a[$i] = $a[$j]
        $a[$j] = $t

macro paired_qsort($a, $b):
    with $len = len($a):
        with $c = concat($a, $b):
            with $stack = array($len):
                with $top = 0:
                    with $h = 0:
                        with $l = 0:
                            with $x = 0:
                                with $i = 0:
                                    with $j = 0:
                                        $stack[0] = 0
                                        $stack[1] = $len - 1
                                        $top = 1
                                        while $top >= 0:
                                            $h = $stack[$top]
                                            $l = $stack[$top - 1]
                                            $top -= 2
                                            $x = $c[$h]
                                            $i = $l - 1
                                            $j = $l
                                            
                                            while $j <= $h - 1:
                                                if $c[$j] <= $x:
                                                    $i += 1
                                                    swap($c, $i, $j)
                                                    swap($c, $i + $len, $j + $len)
                                                $j += 1
                                            
                                            swap($c, $i+1, $h)
                                            swap($c, $i + $len + 1, $h + $len)
                                            if $i > $l:
                                                $stack[$top + 1] = $l
                                                $stack[$top + 2] = $i
                                                $top += 2
                                            if $i + 2 < $h:
                                                $stack[$top + 1] = $i + 2
                                                $stack[$top + 2] = $h
                                                $top += 2
                                        $c

# Weighted median of an array
macro weighted_median($data, $weights):
    with n = len($data):
        with done = 0:
            with midpoint = sum($weights) / 2:
                with j = 0:
                    while j < num_present[i]:
                        if $weights[j] > midpoint:
                            with maxidx = findmax($weights):
                                wmedian = $data[maxidx]
                            done = 1
                        j += 1
                if done == 0:
                    with sorted = paired_qsort($data, $weights):
                        with sorted_data = array(n):
                            with sorted_weights = array(n):
                                with j = 0:
                                    while j < n:
                                        sorted_data[j] = sorted[j]
                                        sorted_weights[j] = sorted[j + n]
                                        j += 1
                                with cumulative_weight = 0:
                                    with idx = 0:
                                        while cumulative_weight <= midpoint:
                                            idx += 1
                                            cumulative_weight += sorted_weights[idx-1]
                                        cumulative_weight -= sorted_weights[idx-1]
                                        # conservative machine epsilon: 
                                        # 0x1197998 = 18446744 = ONE / 10^12
                                        if abs(cumulative_weight - midpoint) < 0x1197998:
                                            wmedian = (sorted_data[idx-2] + sorted_data[idx-1]) / 2
                                        else:
                                            wmedian = sorted_data[idx-1]
                wmedian

# Proportional distance from zero (fixed-point input)
macro normalize($a):
    with $len = len($a):
        with $total = 0:
            with $i = 0:
                while $i < $len:
                    $total += $a[$i]
                    $i += 1
                with $wt = array($len):
                    with $i = 0:
                        while $i < $len:
                            $wt[$i] = $a[$i] * 2^64 / $total
                            $i += 1
                        $wt

data best
data bestDist
# list of clusterIDs
data bestClusters[]
data i

data clusternodes[](numReporters, meanVec[], repInCluster, repVector[], reporterIndexVec[], distance)
data numClusters

data repVector[]

def getNumReportersCluster(id):
    return(self.clusternodes[id].numReporters)

def getMeanVec(id, length):
    return(load(self.clusternodes[id].meanVec[0], items=length): arr)

def getRepInCluster(id):
    return(self.clusternodes[id].repInCluster)

def getClusterRepVector(id):
    return(fetch(self.clusternodes[id].repVector, self.clusternodes[id].numReporters): arr)

def getReporterIndexVec(id):
    return(fetch(self.clusternodes[id].reporterIndexVec, self.clusternodes[id].numReporters): arr)

def getDist(id):
    return(self.clusternodes[id].distance)

def setBest(best):
    self.best = best
    return(1)

def setBestDist(dist):
    self.bestDist = dist
    return(1)

def setNumClusters(num):
    self.numClusters = num
    return(1)

def setI(i):
    self.i = i
    return(1)

def L2dist(x:arr, y:arr, numEvents):
    i = 0
    distSquare = 0
    while i < numEvents:
        distSquare += ((x[i] - y[i])^2)/2^64
        i += 1
    return(self.sqrt(distSquare))

def sqrt(n):
    val = n
    i = 0
    while i < 11:
        val = (val + n*2^64/val)/2
        i += 1
    return val

def newMean(cluster, numEvents, branch, reportingPeriod):
    numReporters = self.clusternodes[cluster].numReporters
    weighted = array(numReporters)
    i = 0
    while i < numReporters:
        weighted[i] = array(numEvents)
        reporterID = self.getReporterID(branch, self.clusternodes[cluster].reporterIndexVec[i])
        weighted[i] = self.getReporterBallot(branch, reportingPeriod, reporterID, outitems=numEvents)
        e = 0
        rep = self.getRepBalance(branch, reporterID)
        while e < numEvents:
            weighted[i][e] = weighted[i][e] * rep / 2^64
            e += 1
        i += 1
    mean = array(numEvents)
    i = 0
    totalRep = self.clusternodes[cluster].repInCluster
    while i < numEvents:
        r = 0
        while r < numReporters:
            mean[i] += weighted[r][i]
            r += 1
        mean[i] = mean[i]*2^64 / totalRep
        i += 1
    return(mean: arr)

def getRepVector(numReporters):
    return(load(self.repVector[0], items=numReporters): arr)

# Maximum value of array
macro maximum($a):
    with $max = $a[0]:
        with $i = 1:
            with $len = len($a):
                while $i < $len:
                    if $a[$i] > $max:
                        $max = $a[$i]
                    $i += 1
                $max

# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation 
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

# Events' index is the eventID
# a binary outcome has 0 for min && 1 for max value, but consensus will return 2^64 and 2^65 respectively
# so for voting 1 and 2 in fxp. need to be given for binaries, not 0 & 1
# S&P 500 scalar would be say 0 && 4700, respectively
# categorical markets have fixed point min and max
 # so max-min/numOutcomes is interval between outcomes (useful for ui, e.g. 1 is >50, 2 is >100, etc.)
# need outcomes returned as 1*2^64, 2*2^64, etc... indeterminate as 3*2^63
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes)

def getEventInfo(event):
    info = array(6)
    info[0] = self.Events[event].branch
    info[1] = self.Events[event].expirationDate
    info[2] = self.Events[event].outcome
    info[3] = self.Events[event].minValue
    info[4] = self.Events[event].maxValue
    info[5] = self.Events[event].numOutcomes
    return(info: arr)

def getEventBranch(event):
    return(self.Events[event].branch)

def getExpiration(event):
    return(self.Events[event].expirationDate)

def getOutcome(event):
    return(self.Events[event].outcome)

def getMinValue(event):
    return(self.Events[event].minValue)

def getMaxValue(event):
    return(self.Events[event].maxValue)

def getNumOutcomes(event):
    return(self.Events[event].numOutcomes)

def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes):
    # check that msg.sender is one of our function contracts
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    if(self.Events[ID].expirationDate==0):
        self.Events[ID].branch = branch
        self.Events[ID].expirationDate = expirationDate
        self.Events[ID].minValue = minValue
        self.Events[ID].maxValue = maxValue
        self.Events[ID].numOutcomes = numOutcomes
        return(1)
    else:
        return(0)

def setOutcome(ID, outcome):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    self.Events[ID].outcome = outcome
    return(1)

# [branchID][votingPeriod]
# v_size = numReports * numEvents
# reportsFilled, reportsMask, weightedCenteredData, loadingVector, scores, set1, set2, old,
# new1, new2, adjPrinComp, smoothRep, outcomesFinal, consensusReward is all consensus data
# reporters is [reporterID][eventNum]
# reporthash is [reporterID] = hash
data EventsExpDates[][](numberEvents, events[], totalRepReported, totalReputation, reporters[][], reportHash[], vSize, reportsFilled[], reportsMask[], weightedCenteredData[], covarianceMatrixRow[], deflated[], loadingVector[], latent, scores[], set1[], set2[], old[], new1[], new2[], adjPrinComp[], smoothRep[], outcomesFinal[], reporterPayouts[])

# atm voters who do vote are req. to vote on all things in their respective ballots (even if just a 0 / no vote)
# ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[w/eVotingPeriodShouldBe].numberEvents
# w/ this function you can get the eventIDs and report on outcomes 
 # make sure in this function to check that the report value is not >maxvalue or <minvalue for the event
# ui will want to alert users of any hey we're behind but atm you should really be voting on this voting period situation (anything meeting the req. of vote if we were caught up)
# @returns a ballot of events (UI needs to vote w/ a ballot of reports in this order per corresponding event)
# @return all events in a branch and expiration period
def getEvents(branch, expDateIndex):
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        i += 1
    return(events: arr)

def getNumberEvents(branch, expDateIndex):
    return(self.EventsExpDates[branch][expDateIndex].numberEvents)

def getEvent(branch, expDateIndex, eventIndex):
    return(self.EventsExpDates[branch][expDateIndex].events[eventIndex])

def getTotalReputation(branch, expDateIndex):
    return(self.EventsExpDates[branch][expDateIndex].totalReputation)

def getTotalRepReported(branch, expDateIndex):
    return(self.EventsExpDates[branch][expDateIndex].totalRepReported)

def getReporterBallot(branch, expDateIndex, reporterID):
    return(load(self.EventsExpDates[branch][expDateIndex].reporters[reporterID][0], items=self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

def getReport(branch, expDateIndex, reporterID, reportNum):
    return(self.EventsExpDates[branch][expDateIndex].reporters[reporterID][reportNum])

def getReportHash(branch, expDateIndex, reporter):
    return(self.EventsExpDates[branch][expDateIndex].reportHash[reporter])

def getVSize(branch, expDateIndex):
    return(self.EventsExpDates[branch][expDateIndex].vSize)

def getReportsFilled(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].reportsFilled[0], chars=32*self.EventsExpDates[branch][expDateIndex].vSize): arr)

def getReportsMask(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].reportsMask[0], chars=32*self.EventsExpDates[branch][expDateIndex].vSize): arr)

def getWeightedCenteredData(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].weightedCenteredData[0], chars=32*self.EventsExpDates[branch][expDateIndex].vSize): arr)

def getCovarianceMatrixRow(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].covarianceMatrixRow[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

def getDeflated(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].deflated[0], chars=32*self.EventsExpDates[branch][expDateIndex].vSize): arr)

def getLoadingVector(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].loadingVector[0], chars=32*(self.EventsExpDates[branch][expDateIndex].numberEvents+2)): arr)

def getLatent(branch, expDateIndex):
    return(self.EventsExpDates[branch][expDateIndex].latent)

def getScores(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].scores[0], chars=32*(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)

def getSetOne(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].set1[0], chars=32*(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)

def getSetTwo(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].set2[0], chars=32*(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)

def returnOld(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].old[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

def getNewOne(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].new1[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

def getNewTwo(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].new2[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

def getAdjPrinComp(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].adjPrinComp[0], chars=32*(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)

def getSmoothRep(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].smoothRep[0], chars=32*(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)

def getOutcomesFinal(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].outcomesFinal[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

def getReporterPayouts(branch, expDateIndex):
    return(load(self.EventsExpDates[branch][expDateIndex].reporterPayouts[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

# check that msg.sender is one of our function contracts
def addEvent(branch, futurePeriod, eventID):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID
    self.EventsExpDates[branch][futurePeriod].numberEvents += 1
    return(1)

def setTotalRepReported(branch, expDateIndex, repReported):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    self.EventsExpDates[branch][expDateIndex].totalRepReported = repReported
    return(1)

def setTotalReputation(branch, expDateIndex, totalReputation):
    self.EventsExpDates[branch][expDateIndex].totalReputation = totalReputation
    return(1)

def setReporterBallot(branch, expDateIndex, reporterID, report: arr, reputation):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].reporters[reporterID][0], report, items=len(report))
    self.EventsExpDates[branch][expDateIndex].totalRepReported += reputation
    return(1)

def setVSize(branch, expDateIndex, vSize):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    self.EventsExpDates[branch][expDateIndex].vSize = vSize
    return(1)

def setReportsFilled(branch, expDateIndex, reportsFilled: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].reportsFilled[0], reportsFilled, chars=32*len(reportsFilled))
    return(1)

def setReportsMask(branch, expDateIndex, reportsMask: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].reportsMask[0], reportsMask, chars=32*len(reportsMask))
    return(1)

def setWeightedCenteredData(branch, expDateIndex, weightedCenteredData: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].weightedCenteredData[0], weightedCenteredData, chars=32*len(weightedCenteredData))
    return(1)

def setCovarianceMatrixRow(branch, expDateIndex, covarianceMatrixRow: arr):
    #if !self.whitelist.check(msg.sender):
     #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].covarianceMatrixRow[0], covarianceMatrixRow, chars=32*len(covarianceMatrixRow))
    return(1)

def setDeflated(branch, expDateIndex, deflated: arr):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    save(self.EventsExpDates[branch][expDateIndex].deflated[0], deflated, chars=32*len(deflated))
    return(1)

def setLoadingVector(branch, expDateIndex, loadingVector: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].loadingVector[0], loadingVector, chars=32*len(loadingVector))
    return(1)

def setLatent(branch, expDateIndex, latent):
    #if !self.whitelist.check(msg.sender):
    #   return(-1)
    self.EventsExpDates[branch][expDateIndex].latent = latent
    return(1)

def setScores(branch, expDateIndex, scores: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].scores[0], scores, chars=32*len(scores))
    return(1)

def setSetOne(branch, expDateIndex, setOne: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].set1[0], setOne, chars=32*len(setOne))
    return(1)

def setSetTwo(branch, expDateIndex, setTwo: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].set2[0], setTwo, chars=32*len(setTwo))
    return(1)

def setOld(branch, expDateIndex, setOld: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].old[0], setOld, chars=32*len(setOld))
    return(1)

def setNewOne(branch, expDateIndex, newOne: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].new1[0], newOne, chars=32*len(newOne))
    return(1)

def setNewTwo(branch, expDateIndex, newTwo: arr):
    # if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].new2[0], newTwo, chars=32*len(newTwo))
    return(1)

def setAdjPrinComp(branch, expDateIndex, adjPrinComp: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].adjPrinComp[0], adjPrinComp, chars=32*len(adjPrinComp))
    return(1)

def setSmoothRep(branch, expDateIndex, smoothRep: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].smoothRep[0], smoothRep, chars=32*len(smoothRep))
    return(1)

def setOutcomesFinal(branch, expDateIndex, outcomesFinal: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].outcomesFinal[0], outcomesFinal, chars=32*len(outcomesFinal))
    return(1)

def setReporterPayouts(branch, expDateIndex, reporterPayouts: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    save(self.EventsExpDates[branch][expDateIndex].reporterPayouts[0], reporterPayouts, chars=32*len(reporterPayouts))
    return(1)

def setReportHash(branch, expDateIndex, reporter, reportHash):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    self.EventsExpDates[branch][expDateIndex].reportHash[reporter] = reportHash
    return(1)

def moveEventsToCurrentPeriod(branch, currentVotePeriod, currentPeriod):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    x = 0
    while(x < self.EventsExpDates[branch][currentVotePeriod-1].numberEvents):
        self.EventsExpDates[branch][currentPeriod].events[self.EventsExpDates[branch][currentPeriod].numberEvents] = self.EventsExpDates[branch][currentVotePeriod-1].events[x]
        self.EventsExpDates[branch][currentPeriod].numberEvents += 1
        # sub and set old period event to 0 poss.?
        x += 1
    return(1)

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the current vote period (should always be 1 behind block.number/periodlength or current EventsExpDates index)
# period parameter for reporting
# currentExpPeriod = (block.number / self.Branches[branch].periodLength)
# currentExpPeriod - 1 is what's up for reporting at any given time
data Branches[](currentVotePeriod, periodLength, step, substep, markets[], numMarkets, minTradingFee)

data branchList[]

data branchListCount


def getVotePeriod(branch):
    return(self.Branches[branch].currentVotePeriod)

def getPeriodLength(branch):
    return(self.Branches[branch].periodLength)

def getStep(branch):
    return(self.Branches[branch].step)

# @return all markets in a branch
def getMarkets(branch):
    numMarkets = self.Branches[branch].numMarkets
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[i]
        i += 1
    return(markets: arr)

def getNumMarkets(branch):
    return(self.Branches[branch].numMarkets)

def getMinTradingFee(branch):
    return(self.Branches[branch].minTradingFee)

# @return all branches
def getBranches(): 
    b = 0
    numBranches = self.branchListCount
    branches = array(numBranches)
    while b < numBranches:
        branches[b] = self.branchList[b]
        b += 1
    return(branches: arr)

def getNumBranches():
    return(self.branchListCount)

def getBranch(branchNumber):
    return(self.branchList[branchNumber])

# check that msg.sender is one of our function contracts
def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    if(self.Branches[ID].periodLength==0):
        self.Branches[ID].currentVotePeriod = currentVotePeriod
        self.Branches[ID].periodLength = periodLength
        self.Branches[ID].minTradingFee = minTradingFee
        self.branchList[self.branchListCount] = ID
        self.branchListCount += 1
        return(1)
    else:
        return(0)

# check that msg.sender is one of our function contracts
def incrementStep(branch):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    self.Branches[branch].step += 1
    return(1)

def setStep(branch, step):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    self.Branches[branch].step = step
    return(1)

def incrementPeriod(branch):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    self.Branches[branch].currentVotePeriod += 1
    return(1)

# check that msg.sender is one of our function contracts
def addMarket(branch, market):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    numMarkets = self.Branches[branch].numMarkets
    self.Branches[branch].markets[numMarkets] = market
    self.Branches[branch].numMarkets += 1
    return(1)

def getSubstep(branch):
    return(self.Branches[branch].substep)

def incrementSubstep(branch):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Branches[branch].substep += 1
    return(1)

def setSubstep(branch, substep):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Branches[branch].substep = substep
    return(1)

macro fx_floor_log2($x):
    with $y = $x / 0x10000000000000000:
        with $lo = 0:
            with $hi = 191:
                with $mid = ($hi + $lo)/2:
                    while (($lo + 1) != $hi):
                        if $y < 2**$mid:
                            $hi = $mid
                        else:
                            $lo = $mid
                        $mid = ($hi + $lo)/2
                    $lo

macro fx_log2_small($x):
    with $result = -0x48A49EAD9B2CD16BE:
        with $temp = $x:
            $result += 0x124DC64B2741E5F083*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x36A569D528A96FF419*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x880785B1DE09970584*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x10AF33C52EB996E92A6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x19FD6E8AC1305DD6D3F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x2086485A91622AE7378*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x210382DF5A3175686B4*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1B58D71F02D9DA4F7B6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1288E14C2FB8C4C1595*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0xA44C5BBEB599D5AB38*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A0E619C630B69BC17*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1AE8CAEA63CF2593A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x7C3EF5A5BFC21BA1F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1BD202FA82B683802*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A90858A0731AD74*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x8CB3CD4376E76EF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA6B8F8E68CD877*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result - 0x5D5316875D9E3*$temp / 0x10000000000000000

macro fx_log2($x):
    with $y = fx_floor_log2($x):
        with $z = $x / 2**$y:
            $y * 0x10000000000000000 + fx_log2_small($z)

macro fx_log($x):
    fx_log2($x) * 0x10000000000000000 / 0x171547652B82FE177

macro fx_exp2_small($x):
    with $result = 0x10000000000000000:
        with $temp = $x:
            $result += 0xB17217F7D1CF79AC*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x3D7F7BFF058B1D56*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xE35846B82505F32*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x276556DF749D7C6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x5761FF9E294A6F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA184897C5558D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xFFE5FE24386C*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x162C023B2A1D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1B5250C02BF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E4D3F1A83*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E87B8E21*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1C768AA3*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x164F0A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result + 0x1B08D3*$temp / 0x10000000000000000

macro fx_exp2($x):
    with $y = $x / 0x10000000000000000:
        with $z = $x % 0x10000000000000000:
            fx_exp2_small($z) * 2**$y

macro fx_exp($x):
    fx_exp2($x * 0x10000000000000000 / 0xB17217F7D1CF79AC)

def fx_exp(x):
    return(fx_exp(x))

def fx_log(x):
    return(fx_log(x))

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep)

# @return reputation value
def getRepByIndex(branch, repIndex):
    return(self.Reporting[branch].reputation[repIndex].repValue)

# @return reputation value
def getRepBalance(branch, address):
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].reputation[repIndex].repValue)

def getReporterID(branch, index):
    return(self.Reporting[branch].reputation[index].reporterID)

def getTotalRep(branch):
    return(self.Reporting[branch].totalRep)

# will return 0s for array values after it's looped through all the ones you
# have an actual balance in
def getReputation(address):
    branchListCount = self.getNumBranches()
    if(address):
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    else:
        address = tx.origin
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    return(branches: arr)

def getNumberReporters(branch):
    return(self.Reporting[branch].numberReporters)

def repIDToIndex(branch, repID):
    return(self.Reporting[branch].repIDtoIndex[repID])

def hashReport(report: arr, salt):
        hashInfo = array(len(report) + 2)
        hashInfo[0] = tx.origin
        hashInfo[1] = salt
        i = 2
        while i < (len(report) + 2):
            hashInfo[i] = report[i-2]
            i += 1
        reportHash = sha256(hashInfo, chars=32*len(hashInfo))
        return(reportHash)

# check that msg.sender is one of our function contracts
def setInitialReporters(parent, branchID):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # first vote period won't be until after the current (in this case first) basket of things has expired
        # if floor(blockNum / periodLength) is say 5 and eventsExpDates[5]
        # the current vote period should be on things from eventsExpDates 4 (when making a new branch this vote period will just fail quorem, and current vote period will be incrememented)
        # then once blockNum / periodLength is say 6 and eventsExpDates[6]
        # votePeriod 4 should close and the currentVotePeriod should be from
        # eventsExpDates 5 (anyone can call the consensus function for voteperiod 4 at this point)
    i = 0
    while i < self.Reporting[parent].numberReporters:
        reporterID = self.Reporting[parent].reputation[i].reporterID
        self.Reporting[branchID].reputation[i].reporterID = reporterID
        self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
        self.Reporting[branchID].repIDtoIndex[reporterID] = i
        i+=1
    self.Reporting[branchID].numberReporters = i
    return(1)

def addReporter(branch, sender):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    reporterIndex = self.Reporting[branch].numberReporters
    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex
    self.Reporting[branch].reputation[reporterIndex].repValue = 0
    self.Reporting[branch].reputation[reporterIndex].reporterID = sender
    self.Reporting[branch].numberReporters += 1
    return(1)

def addRep(branch, index, value):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue += value
    return(1)

def subtractRep(branch, index, value):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue -= value
    return(1)

def setRep(branch, index, newRep):
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    oldRep = self.Reporting[branch].reputation[index].repValue
    self.Reporting[branch].reputation[index].repValue = newRep
    self.Reporting[branch].totalRep += newRep - oldRep
    return(1)

# returns whether a quorem has a matured event
# if there aren't enough events in a vote period eventsexpdate, push them to the current period and increment the vote period
# @return 0 if fail, 1 if success
def checkQuorum(branch):
    currentVotePeriod = self.getVotePeriod(branch)
    currentPeriod = (block.number / self.getPeriodLength(branch))
    # provided the currentPeriod is >=2 periods past the things we're going to rbcr on
    # we can then conclude it has matured && people have had time to vote
    matured = 0
    enoughEvents = 0
    enoughUpcoming = 0
    if (currentPeriod >= (currentVotePeriod+2)):
        matured = 1

    # min future decisions at stake - 200 - else branch stalls (do same thing we do if min ballot/event size isn't met,
    # push events into current period and hopefully more people will create decisions so it can actually be voted on, else repeat)
    # should 0 out stuff in if statement here
    upcomingDecisions = 0
    b = currentVotePeriod
    while b < (currentVotePeriod+100):
        upcomingDecisions += self.getNumberEvents(branch, b)
        b += 1

    # normally < 30 and < 500 respectively, lowered for testing
    if ((self.getNumberEvents(branch, currentVotePeriod) < 5 || upcomingDecisions < 10) && matured):
        self.incrementPeriod(branch)
        self.setStep(branch, 0)
        self.setSubstep(branch, 0)
        currentVotePeriod = self.getVotePeriod(branch)
        self.moveEventsToCurrentPeriod(branch, currentVotePeriod, currentPeriod)
    else:
        if(self.getTotalRepReported(branch, currentVotePeriod)==0 && matured):
            self.incrementPeriod(branch)
            self.setStep(branch, 0)
            self.setSubstep(branch, 0)
            currentVotePeriod = self.getVotePeriod(branch)
            self.moveEventsToCurrentPeriod(branch, currentVotePeriod, currentPeriod)
            enoughEvents = 0
            enoughUpcoming = 0
        else:
            enoughEvents = 1
            enoughUpcoming = 1

    if(matured && enoughEvents && enoughUpcoming):
        return(1)
    else:
        return(0)
        # return([currentPeriod, currentVotePeriod, matured, self.getNumberEvents(branch, currentVotePeriod), upcomingDecisions]:arr)


# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](description[2048], descriptionLength, creator, creationFee)


def getDescription(ID):
    length=self.Info[ID].descriptionLength
    return(load(self.Info[ID].description[0], chars=length): str)

def getDescriptionLength(ID):
    return(self.Info[ID].descriptionLength)

def getCreator(ID):
    return(self.Info[ID].creator)

def getCreationFee(ID):
    return(self.Info[ID].creationFee)

# @return 1 if success, 0 if creator already exists
def setInfo(ID, description: str, creator, fee):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    # check that msg.sender is one of our function contracts
    if(self.Info[ID].creator == 0):
        save(self.Info[ID].description[0], description, chars=len(description))
        self.Info[ID].descriptionLength = len(description)
        self.Info[ID].creationFee = fee
        self.Info[ID].creator = creator
        return(1)
    else:
        return(0)

data cashcoinBalances[]


# @return: cash balance of address
def balance(address):
    return(self.cashcoinBalances[address])

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
# so cashcoin fees could just go to root branch, or we could not have fees besides 
# gas fee to do a send transaction
# @return: value sent, 0 if fails
def send(recver, value):
    sender = tx.origin
    senderBalance = self.cashcoinBalances[sender]
    if(senderBalance >= value):
        self.cashcoinBalances[sender] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# @return value of cash sent; fail is 0
def sendFrom(recver, value, from):
    if(from!=tx.origin):
        return(0)
    senderBalance = self.cashcoinBalances[from]
    if(senderBalance >= value):
        self.cashcoinBalances[from] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# make sure only coming from specific contracts
def subtractCash(ID, amount):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.cashcoinBalances[ID] -= amount
    return(1)

def addCash(ID, amount):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.cashcoinBalances[ID] += amount
    return(1)

def setCash(address, balance):
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    self.cashcoinBalances[address] = balance
    return(1)

# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0
# to 11.0 would be 11 outcomes (if incremented by 0.1)
# need to make sure these values are ok
# @return eventID if success
# error messages otherwise
    # -1: we're either already past that date, branch doesn't exist, or description is bad
    # 0: not enough money to pay fees or event already exists
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes, blockNumber):
    periodLength = self.getPeriodLength(branch)
    if periodLength && description != 0 && expDate > block.number:
        eventinfo = string(9*32 + len(description))
        eventinfo[0] = EVENT                                        #typecode
        eventinfo[1] = branch                                       #branchID
        eventinfo[2] = expDate                                      #expiration date
        eventinfo[3] = tx.origin                                    #creator address
        eventinfo[4] = 42*2^64                                      #creation fee
        eventinfo[5] = minValue                                     #minimum outcome value
        eventinfo[6] = maxValue                                     #maximum outcome value
        eventinfo[7] = numOutcomes                                  #number of outcomes
        eventinfo[8] = blockNumber
        mcopy(eventinfo + 9*32, description, len(description))
        eventID = sha256(eventinfo, chars=len(eventinfo))
    else:
        return(-1)

    # fee to ask a question rises if voter participation (rep reported) falls, if it's really high, the fee is lowered (participationFactor is a fixedpoint number)
    currentVotePeriod = self.getVotePeriod(branch)
    participationFactor = (self.getTotalRepReported(branch, currentVotePeriod-2) * 2^64) / self.getTotalRepReported(branch, currentVotePeriod-1)
    if participationFactor == 0:
        participationFactor = 1

    # send fee and bond
    if self.balance(tx.origin) >= (42*2^64 + participationFactor*45):
        if !self.getCreator(eventID) && !self.getEventBranch(eventID) && self.send(eventID, 42*2^64) && self.send(branch, participationFactor*45):
            # see which future period it expires in && put the event in that bin
            # event voting periods - expDate / periodLength gives you the voting period #
            futurePeriod = expDate / periodLength
            if self.setInfo(eventID, description, tx.origin, participationFactor*45) && self.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes) && self.addEvent(branch, futurePeriod, eventID):
                return(eventID)
            else:
                return(0)
        else:
            return(0)
    else:
        return(0)