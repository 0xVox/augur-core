# can you atk clustering w/ ordering atk if so use mbsas instead of bsas

A consensus spec:
i) check report validity (1-2 binary, if someone gives a value > or < scalar range or > or < categorical num outcomes, round up/down to 0 or 1 respectively) - done
    i.i) make sure no blank reports in a ballot - done
ii) convert scalar / categorical to range 0-1 when submitting report
    iia) if scalar/categorical is a real .5 convert to .5*2^64+1, if indeterminate keep as .5*2^64 - in UI
    iib) if scalar/categorical is a real 0 convert to 0*2^64+1, else if no response, keep as 0 - in UI
1) do clustering
    1a) completely missing ballots should just be not clustered - find distance for one of them, penalize the rest accordingly - not done yet
2) normalize to 1 and get new "this" rep vector
    2a) prior to this, multiply by prev. rep vector over mean
    2b) take old rep multiply by .80 add to new rep *.2 (smoothing part)
3) using this, calc. outcomes 1, 1.5, 2 for binary using weighed avg / catch param (.1 or .15)
    3a) scalar outcomes & categoricals use weighted median - done
    3b) if .5 due to catch param push back once (as .5 outcome), if same on next consensus no more push backs, # that's the outcome (or we could audit here or do certainty based audits)
    3c) detect b via a "times voted on" var
    3d) when doing outcomes, only do weighted avg / median on people who actually reported on that event, i.e. # don't include people who reported 0 / no report
    note: do outcomes w/ smooth rep (not just "new rep"), and calculate using tolerance, use weighted med. for scalars
    3e) then scale scaled back up to w/e value - ditto for categorical (need to mult by range and add min i think) for categorical range is numOutcomes - 1, min is 1
    3f) save outcomes
4) Payout reporters & event bonds


# what if someone doesn't report + sends their rep to a different account
# or what if someone makes a new account entirely during reporting period
# or what if an acc has 0 rep

Params:
Smoothing param
Catch param

def dispatch(branch):
    if !BRANCHES.getStep(branch) and !QUORUM.checkQuorum(branch):
        return(-1)
    with period = BRANCHES.getVotePeriod(branch):
        with num_events = EXPIRING.getNumberEvents(branch, period):
            with num_reports = REPORTING.getNumberReporters(branch):
                with flatsize = num_events * num_reports:
                    with step = BRANCHES.getStep(branch):
                        if step == 4:
                            REDEEM_PAYOUT.payout(branch, period, num_events, num_reports, flatsize)
                            BRANCHES.setStep(branch, 0) # reset step
                            BRANCHES.incrementPeriod(branch)
                            return(period + 1)
                        elif step == 0:
                            EXPIRING.setTotalReputation(branch, period, REPORTING.getTotalRep(branch))
                            REDEEM_INTERPOLATE.read_ballots(branch, period, num_events, num_reports, flatsize)
                        elif step == 1:
                            REDEEM_CENTER.clustering(branch, period, num_events, num_reports, flatsize)
                        elif step == 2:
                            REDEEM_RESOLVE.smooth(branch, period, num_events, num_reports, flatsize)
                        elif step == 3:
                            REDEEM_RESOLVE.resolve(branch, period, num_events, num_reports, flatsize)
                        BRANCHES.incrementStep(branch)
                        return(step + 1)

def payout(branch, period, num_events, num_reports, flatsize):
    with smooth_rep = array(num_reports):
        smooth_rep = slice(EXPIRING.getSmoothRep(branch, period, outitems=num_reports), items=0, items=num_reports)
        with reports_mask = array(flatsize):
            reports_mask = slice(EXPIRING.getReportsMask(branch, period, outitems=flatsize), items=0, items=flatsize)
            with outcomes = array(num_events):
                outcomes = slice(EXPIRING.getOutcomesFinal(branch, period, outitems=num_events), items=0, items=num_events)
                with reporter_payouts = array(num_reports):
                    reporter_payouts = slice(PAYOUT.payout(outcomes, smooth_rep, reports_mask, num_reports, num_events, outitems=num_reports), items=0, items=num_reports)

                    # get event ID for each event by taking the x index in the reports arrays
                    # - shoving it in reporting.events[] and getting the corresponding ID
                    with j = 0:
                        while j < num_events:
                            with event = EXPIRING.getEvent(branch, period, j):

                                # then take outcomes_final and set each event outcome
                                # (BAD and BOND macros defined in consensus/constants.se)
                                EVENTS.setOutcome(event, outcomes[j])
                                if outcomes[j] != BAD:

                                    # return bond
                                    CASH.subtractCash(event, BOND)
                                    CASH.addCash(INFO.getCreator(event), BOND)
                                else:

                                    # give event bond money to reporters
                                    CASH.subtractCash(event, BOND)
                                    CASH.addCash(branch, BOND)
                            j += 1
                    # - need to loop through rep holders and distribute 50% of branch fees to
                    #   reporters' cashcoin addresses 
                    # - also need to take reporter_payouts and redistribute reputation in the
                    #   Reporting structure accordingly
                    EXPIRING.setReporterPayouts(branch, period, reporter_payouts)
                    with i = 0:
                        while i < num_reports:
                            REPORTING.setRep(branch, i, fixed_multiply(reporter_payouts[i], EXPIRING.getTotalReputation(branch, period)))
                            CASH.addCash(REPORTING.getReporterID(branch, i), fixed_multiply(CASH.balance(branch), reporter_payouts[i]))
                            i += 1
                        CASH.subtractCash(branch, CASH.balance(branch))
                        return(1)



macro ONE: 2^64

macro YES: 2^65
macro NO: 2^64
macro BAD: 3 * 2^63

macro COINS: 10^6

macro CATCH_TOLERANCE: 2^64 / 10

# Sum elements of array
macro sum($a):
    with $len = len($a):
        with $total = 0:
            with $i = 0:
                while $i < $len:
                    $total += $a[$i]
                    $i += 1
                $total

# Arithmetic mean
macro mean($a):
    sum($a) / len($a)

# Absolute value
macro abs($n):
    if($n<0, -$n, $n)

# Proportional distance from zero, inputs are fixed point
macro get_weight($a):
    with $len = len($a):
        with $total = 0:
            with $i = 0:
                while $i < $len:
                    $a[$i] = abs($a[$i])
                    $total += $a[$i]
                    $i += 1
                with $wt = array($len):
                    with $i = 0:
                        while $i < $len:
                            $wt[$i] = $a[$i] * ONE / $total
                            $i += 1
                        $wt

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE), NO, if($x > BAD + CATCH_TOLERANCE, YES, BAD))
    # if $x < BAD - CATCH_TOLERANCE:
    #     c = NO
    # elif $x > BAD + CATCH_TOLERANCE:
    #     c = YES
    # else:
    #     c = BAD
    # c

# Absolute value of all array elements
macro array_abs($a):
    with $len = len($a):
        with $absval = array($len):
            with $i = 0:
                while $i < $len:
                    $absval[$i] = abs($a[$i])
                    $i += 1
                $absval

# Minimum value of array
macro minimum($a):
    with $min = $a[0]:
        with $i = 1:
            with $len = len($a):
                while $i < $len:
                    if $a[$i] < $min:
                        $min = $a[$i]
                    $i += 1
                $min

# Maximum value of array
macro maximum($a):
    with $max = $a[0]:
        with $i = 1:
            with $len = len($a):
                while $i < $len:
                    if $a[$i] > $max:
                        $max = $a[$i]
                    $i += 1
                $max

# Find index corresponding to the maximum value of an array
macro findmax($a):
    with $len = len($a):
        with $max = $a[0]:
            with $maxidx = 0:
                with $i = 1:
                    while $i < $len:
                        if $a[$i] > $max:
                            $maxval = $a[$i]
                            $maxidx = $i
                        $i += 1
                    $maxidx        

# Fixed-point multiplication
macro fixed_multiply($x, $y):
    $x * $y / ONE

# Fixed-point division
macro fixed_divide($x, $y):
    $x * ONE / $y

macro concat($a, $b):
    with $c = array(len($a)+len($b)):
        mcopy($c, $a, items=len($a))
        mcopy($c+(items=len($a)), $b, items=len($b))
        $c

macro swap($a, $i, $j):
    with $t = $a[$i]:
        $a[$i] = $a[$j]
        $a[$j] = $t

macro paired_qsort($a, $b):
    with $len = len($a):
        with $c = concat($a, $b):
            with $stack = array($len):
                with $top = 0:
                    with $h = 0:
                        with $l = 0:
                            with $x = 0:
                                with $i = 0:
                                    with $j = 0:
                                        $stack[0] = 0
                                        $stack[1] = $len - 1
                                        $top = 1
                                        while $top >= 0:
                                            $h = $stack[$top]
                                            $l = $stack[$top - 1]
                                            $top -= 2
                                            $x = $c[$h]
                                            $i = $l - 1
                                            $j = $l
                                            
                                            while $j <= $h - 1:
                                                if $c[$j] <= $x:
                                                    $i += 1
                                                    swap($c, $i, $j)
                                                    swap($c, $i + $len, $j + $len)
                                                $j += 1
                                            
                                            swap($c, $i+1, $h)
                                            swap($c, $i + $len + 1, $h + $len)
                                            if $i > $l:
                                                $stack[$top + 1] = $l
                                                $stack[$top + 2] = $i
                                                $top += 2
                                            if $i + 2 < $h:
                                                $stack[$top + 1] = $i + 2
                                                $stack[$top + 2] = $h
                                                $top += 2
                                        $c

# Weighted median of an array
macro weighted_median($data, $weights):
    with n = len($data):
        with done = 0:
            with midpoint = sum($weights) / 2:
                with j = 0:
                    while j < num_present[i]:
                        if $weights[j] > midpoint:
                            with maxidx = findmax($weights):
                                wmedian = $data[maxidx]
                            done = 1
                        j += 1
                if done == 0:
                    with sorted = paired_qsort($data, $weights):
                        with sorted_data = array(n):
                            with sorted_weights = array(n):
                                with j = 0:
                                    while j < n:
                                        sorted_data[j] = sorted[j]
                                        sorted_weights[j] = sorted[j + n]
                                        j += 1
                                with cumulative_weight = 0:
                                    with idx = 0:
                                        while cumulative_weight <= midpoint:
                                            idx += 1
                                            cumulative_weight += sorted_weights[idx-1]
                                        cumulative_weight -= sorted_weights[idx-1]
                                        # conservative machine epsilon: 
                                        # 0x1197998 = 18446744 = ONE / 10^12
                                        if abs(cumulative_weight - midpoint) < 0x1197998:
                                            wmedian = (sorted_data[idx-2] + sorted_data[idx-1]) / 2
                                        else:
                                            wmedian = sorted_data[idx-1]
                wmedian

# Outer product of vectors
macro outer_product($u, $v):
    with $usz = len($u):
        with $p = array($usz^2):
            with $i = 0:
                while $i < $usz:
                    with $j = 0:
                        while $j < $usz:
                            $p[$i*$usz + $j] += $u[$i] * $v[$j] / ONE
                            $j += 1
                    $i += 1
                $p

# Flattened fixed-point matrix multiplication
macro matrix_multiply($a, $arows, $acols, $b, $brows, $bcols):
    with $c = array($arows*$bcols):
        with $i = 0:
            while $i < $arows:
                with $j = 0:
                    while $j < $bcols:
                        with $k = 0:
                            while $k < $acols:
                                $c[$i*$bcols + $j] += $a[$i*$acols + $k] * $b[$k*$bcols + $j] / ONE
                                $k += 1
                        $j += 1
                $i += 1
            $c