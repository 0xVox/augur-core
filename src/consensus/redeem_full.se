# This software (Augur) allows buying and selling event options in Ethereum.
#
# Copyright (c) 2015 Forecast Foundation
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# If you have questions, please contact Joey Krug (joey@augur.net) or
# Jack Peterson (jack@augur.net).

import events
import expiringEvents
import reporting
import branches
import cash
import info
import interpolate
import center
import score
import adjust
import resolve
import payout



# - loop through reputation && check if in reporters, if so use their
#   report, if not use the fillin / not reported report (all zeroes)
# - use this to make a giant array of reports to pass to self.consensus
# - want to pass reports for each 0 indexed event in order (so we get
#   reports from an actual reporter)
# (if they didn't vote we set their array for each event to 0,0,0,0,0,0, etc...)
def redeem(branch, period, num_events, num_reports, flatsize, mockNumber):
    # if !WHITELIST.check(msg.sender):
    #     return(-1)
    if mockNumber == 0:
        binary_mock(branch, period)
    else:
        scalar_mock(branch, period)
    with reputation = array(num_reports):
        with reports = array(flatsize):
            with flatsize_x_2 = flatsize * 2:
                with i = 0:
                    while i < num_reports:
                        with reporterID = reporting.getReporterID(branch, i):
                            reputation[i] = reporting.getRepBalance(branch, reporterID)
                            # - checks to see if each reporter actually voted on events
                            # - if they didn't vote (simply check if they voted on first event)
                            #     do nothing (these values will be 0 by default due to Serpent array styles)
                            #     else if the reporter did report on events put their ballot into the reports array
                            with ballot = expiringEvents.getReporterBallot(branch, period, i, outsz=num_events):
                                if ballot != 0:
                                    with j = 0:
                                        while j < num_events:
                                            reports[i*num_events + j] = ballot[j]
                                            j += 1
                        i += 1
                with scaled = array(num_events):
                    with scaled_max = array(num_events):
                        with scaled_min = array(num_events):
                            with j = 0:
                                while j < num_events:
                                    with event = expiringEvents.getEvent(branch, period, j):
                                        # YES, NO, ONE, etc. macros defined in consensus/constants.se
                                        if fix(events.getMaxValue(event)) != YES:
                                            scaled[j] = 1
                                            # TODO convert maxValue and minValue to fixed-point in storage
                                            scaled_max[j] = fix(events.getMaxValue(event))
                                            scaled_min[j] = fix(events.getMinValue(event))
                                        else:
                                            scaled[j] = 0
                                            scaled_min[j] = NO
                                            scaled_max[j] = YES
                                    j += 1
                            with reports_interp = interpolate.interpolate(reports, reputation, scaled, scaled_max, scaled_min, outsz=flatsize_x_2):
                                expiringEvents.setVSize(branch, period, flatsize)
                                reports_filled = slice(reports_interp, items=0, items=flatsize)
                                expiringEvents.setReportsFilled(branch, period, reports_filled)
                                expiringEvents.setReportsMask(branch, period, slice(reports_interp, items=flatsize, items=flatsize_x_2))
                                # return(reports_filled:arr)
                                # return(1)

    #############
    # center.se #
    #############

    # center
    with reputation = array(num_reports):
        with i = 0:
            while i < num_reports:
                reputation[i] = reporting.getRepByIndex(branch, i)
                i += 1
        with scaled = array(num_events):
            with scaled_max = array(num_events):
                with scaled_min = array(num_events):
                    with j = 0:
                        while j < num_events:
                            with event = expiringEvents.getEvent(branch, period, j):
                                if fix(events.getMaxValue(event)) != YES:
                                    scaled[j] = 1
                                    scaled_min[j] = fix(events.getMinValue(event))
                                    scaled_max[j] = fix(events.getMaxValue(event))
                                else:
                                    scaled[j] = 0
                                    scaled_min[j] = NO
                                    scaled_max[j] = YES
                            j += 1
                    with reports_filled = expiringEvents.getReportsFilled(branch, period, outsz=flatsize):
                        with lflatsize = flatsize + num_events + 2:
                            with result = center.center(reports_filled, reputation, scaled, scaled_max, scaled_min, MAX_ITERATIONS, MAX_COMPONENTS, outsz=lflatsize):
                                wcd = slice(result, items=0, items=flatsize)
                                expiringEvents.setWeightedCenteredData(branch, period, wcd)
                                loading_vector = slice(result, items=flatsize, items=lflatsize)
                                expiringEvents.setLoadingVector(branch, period, loading_vector)
                                # return(expiringEvents.getWeightedCenteredData(branch, period, outsz=flatsize):arr)
                                # return(expiringEvents.getLoadingVector(branch, period, outsz=num_events+2):arr)
                                # return(1)

    # covariance
    with reputation = array(num_reports):
        with i = 0:
            while i < num_reports:
                reputation[i] = reporting.getRepByIndex(branch, i)
                i += 1
        with reptokens = center.tokenize(reputation, num_reports, outsz=num_reports):
            with wcd = expiringEvents.getWeightedCenteredData(branch, period, outsz=flatsize):
                with covrow = center.covariance(wcd, reptokens, num_reports, num_events, outsz=num_events):
                    expiringEvents.setCovarianceMatrixRow(branch, period, covrow)
                    expiringEvents.setDeflated(branch, period, wcd)
                    # return(expiringEvents.getCovarianceMatrixRow(branch, period, outsz=num_events):arr)
                    # return(expiringEvents.getDeflated(branch, period, outsz=flatsize):arr)
                    # return(1)

    ############
    # score.se #
    ############

    m = 0
    while m < MAX_COMPONENTS:

        # blank
        # loading vector (eigenvector) has num_events + 2 elements:
        #   - second-to-last element: number of iterations remaining
        #   - last element: number of components (eigenvectors) remaining
        with ne_plus_2 = num_events + 2:
            # - if element ne_plus_2 is zero, we're on the first component, so set the last
            #   element equal to MAX_COMPONENTS
            # - otherwise, decrement the last element
            with loading_vector = expiringEvents.getLoadingVector(branch, period, outsz=num_events+2):
                if loading_vector[num_events+1] == 0:
                    expiringEvents.setLoadingVector(branch, period, score.blank(MAX_COMPONENTS, MAX_ITERATIONS, num_events, outsz=ne_plus_2))
                else:
                    expiringEvents.setLoadingVector(branch, period, score.blank(loading_vector[num_events+1]-1, MAX_ITERATIONS, num_events, outsz=ne_plus_2))
                # branches.incrementSubstep(branch)
                # return(expiringEvents.getLoadingVector(branch, period, outsz=ne_plus_2):arr)
                # return(1)

        # loadings
        n = 0
        while n < MAX_ITERATIONS:
            with ne_plus_2 = num_events + 2:
                with loading_vector = expiringEvents.getLoadingVector(branch, period, outsz=ne_plus_2):
                    with deflated =  expiringEvents.getDeflated(branch, period, outsz=flatsize):
                        with reputation = array(num_reports):
                            with i = 0:
                                while i < num_reports:
                                    reputation[i] = reporting.getRepByIndex(branch, i)
                                    i += 1
                            # Iteratively diagonalize the weighted centered data matrix,
                            # deflating (subtracting out the eigenvectors) the matrix after each
                            # eigenvector is found
                            loading_vector = score.loadings(loading_vector, deflated, reputation, num_reports, num_events, outsz=ne_plus_2)
                            expiringEvents.setLoadingVector(branch, period, loading_vector)
                            # if loading_vector[num_events] == 0:
                            #     return(0)
                            # else:
                            #     return(1)
            n += 1
        # return(expiringEvents.getLoadingVector(branch, period, outsz=num_events+2):arr)

        # latent
        with loading_vector = expiringEvents.getLoadingVector(branch, period, outsz=num_events+2):
            with covrow = expiringEvents.getCovarianceMatrixRow(branch, period, outsz=num_events):
                expiringEvents.setLatent(branch, period, score.latent(covrow, loading_vector, num_events))
                expiringEvents.setCovarianceMatrixRow(branch, period, covrow)
                # log_fixed(expiringEvents.getLatent(branch, period))
                # return(expiringEvents.getCovarianceMatrixRow(branch, period, outsz=num_events):arr)
                # return(1)

        # deflate
        with loading_vector = expiringEvents.getLoadingVector(branch, period, outsz=num_events+2):
            with deflated = expiringEvents.getDeflated(branch, period, outsz=flatsize):
                deflated = score.deflate(loading_vector, deflated, num_reports, num_events, outsz=flatsize)
                expiringEvents.setDeflated(branch, period, deflated)
                # return(expiringEvents.getDeflated(branch, period, outsz=flatsize):arr)
                # return(1)

        # score
        with loading_vector = expiringEvents.getLoadingVector(branch, period, outsz=num_events+2):
            with wcd =  expiringEvents.getWeightedCenteredData(branch, period, outsz=flatsize):
                with latent = expiringEvents.getLatent(branch, period):
                    with scores = expiringEvents.getScores(branch, period, outsz=num_reports):
                        scores = score.score(scores, loading_vector, wcd, latent, num_reports, num_events, outsz=num_reports)
                        expiringEvents.setScores(branch, period, scores)
                        # if loading_vector[num_events+1] == 0:
                        #     return(0)
                        # else:
                        #     return(1)
        m += 1
    # return(expiringEvents.getScores(branch, period, outsz=num_reports):arr)

    #############
    # adjust.se #
    #############

    # reputation_delta
    with scores = expiringEvents.getScores(branch, period, outsz=num_reports):
        with nr_x_2 = num_reports * 2:
            with sets = ADJUST.reputation_delta(scores, num_reports, num_events, outsz=nr_x_2):
                expiringEvents.setSetOne(branch, period, slice(sets, items=0, items=num_reports))
                expiringEvents.setSetTwo(branch, period, slice(sets, items=num_reports, items=nr_x_2))
                # return(expiringEvents.getSetOne(branch, period, outsz=num_reports):arr)
                # return(expiringEvents.getSetTwo(branch, period, outsz=num_reports):arr)
                # return(1)

    # weighted_delta
    with reports_filled = expiringEvents.getReportsFilled(branch, period, outsz=flatsize):
        with reputation = array(num_reports):
            with i = 0:
                while i < num_reports:
                    reputation[i] = reporting.getRepByIndex(branch, i)
                    i += 1
                with set1 = expiringEvents.getSetOne(branch, period, outsz=num_reports):
                    with set2 = expiringEvents.getSetTwo(branch, period, outsz=num_reports):
                        with ne_x_3 = num_events * 3:
                            with ne_x_2 = num_events * 2:
                                with wsets = ADJUST.weighted_delta(set1, set2, reputation, reports_filled, num_reports, num_events, outsz=ne_x_3):
                                    expiringEvents.setOld(branch, period, slice(wsets, items=0, items=num_events))
                                    expiringEvents.setNewOne(branch, period, slice(wsets, items=num_events, items=ne_x_2))
                                    expiringEvents.setNewTwo(branch, period, slice(wsets, items=ne_x_2, items=ne_x_3))
                                    # return(expiringEvents.returnOld(branch, period, outsz=num_events):arr)
                                    # return(expiringEvents.getNewOne(branch, period, outsz=num_events):arr)
                                    # return(expiringEvents.getNewTwo(branch, period, outsz=num_events):arr)
                                    # return(1)

    # select_scores
    with old = expiringEvents.returnOld(branch, period, outsz=num_events):
        with new1 = expiringEvents.getNewOne(branch, period, outsz=num_events):
            with new2 = expiringEvents.getNewTwo(branch, period, outsz=num_events):
                with set1 = expiringEvents.getSetOne(branch, period, outsz=num_reports):
                    with set2 = expiringEvents.getSetTwo(branch, period, outsz=num_reports):
                        with scores = expiringEvents.getScores(branch, period, outsz=num_reports):
                            with adjusted_scores = ADJUST.select_scores(old, new1, new2, set1, set2, scores, num_reports, num_events, outsz=num_reports):
                                expiringEvents.setAdjPrinComp(branch, period, adjusted_scores)
                                # return(expiringEvents.getAdjPrinComp(branch, period, outsz=num_reports):arr)
                                # return(1)

    ##############
    # resolve.se #
    ##############

    with reputation = array(num_reports):
        with i = 0:
            while i < num_reports:
                reputation[i] = reporting.getRepByIndex(branch, i)
                i += 1
            with adjusted_scores = expiringEvents.getAdjPrinComp(branch, period, outsz=num_reports):
                with smooth_rep = resolve.smooth(adjusted_scores, reputation, num_reports, num_events, outsz=num_reports):
                    expiringEvents.setSmoothRep(branch, period, smooth_rep)
                    # return(expiringEvents.getSmoothRep(branch, period, outsz=num_reports):arr)
                    # return(1)

    with reports_filled = expiringEvents.getReportsFilled(branch, period, outsz=flatsize):
        with smooth_rep = expiringEvents.getSmoothRep(branch, period, outsz=num_reports):
            with scaled = array(num_events):
                with scaled_max = array(num_events):
                    with scaled_min = array(num_events):
                        with j = 0:
                            while j < num_events:
                                with event = expiringEvents.getEvent(branch, period, j):
                                    if fix(events.getMaxValue(event)) != YES:
                                        scaled[j] = 1
                                        scaled_min[j] = fix(events.getMinValue(event))
                                        scaled_max[j] = fix(events.getMaxValue(event))
                                    else:
                                        scaled[j] = 0
                                        scaled_min[j] = NO
                                        scaled_max[j] = YES
                                j += 1
                            with outcomes = resolve.resolve(smooth_rep, reports_filled, scaled, scaled_max, scaled_min, num_reports, num_events, outsz=num_events):
                                expiringEvents.setOutcomesFinal(branch, period, outcomes)
                                # return(expiringEvents.getOutcomesFinal(branch, period, outsz=num_events):arr)
                                # return(1)

    #############
    # payout.se #
    #############

    with smooth_rep = expiringEvents.getSmoothRep(branch, period, outsz=num_reports):
        with reports_mask = expiringEvents.getReportsMask(branch, period, outsz=flatsize):
            with outcomes = expiringEvents.getOutcomesFinal(branch, period, outsz=num_events):
                with reporter_payouts = payout.payout(outcomes, smooth_rep, reports_mask, num_reports, num_events, outsz=num_reports):
                    # get event ID for each event by taking the x index in the reports arrays
                    # - shoving it in reporting.events[] && getting the cooresponding ID
                    with j = 0:
                        while j < num_events:
                            with event = expiringEvents.getEvent(branch, period, j):
                                # then take outcomes_final && set each event outcome
                                # (BAD and BOND macros defined in consensus/constants.se)
                                events.setOutcome(event, outcomes[j])
                                if outcomes[j] != BAD:
                                    # return bond
                                    # Q: should the subtractCash be from the event's ID?
                                    cash.subtractCash(event, BOND)
                                    cash.addCash(info.getCreator(event), BOND)
                                else:
                                    # give event bond money to reporters
                                    cash.subtractCash(event, BOND)
                                    cash.addCash(branch, BOND)
                            j += 1
                    # - need to loop through rep holders && distribute 50% of branch fees to
                    #   reporters' cashcoin addresses
                    # - also need to take reporter_payouts && redistribute reputation in the
                    #   Reporting structure accordingly
                    with i = 0:
                        # TODO double-check that the cash in and out adds up to 0
                        while i < num_reports:
                            reporting.setRep(branch, i, fixed_multiply(reporter_payouts[i], 21000000))
                            cash.addCash(reporting.getReporterID(branch, i), fixed_multiply(cash.balance(branch), reporter_payouts[i]))
                            i += 1
                        cash.subtractCash(branch, cash.balance(branch))
                        return(reporter_payouts:arr)
                        # return(1)

inset('../../macros/constants.se')
inset('../../macros/fixed.se')
inset('../../macros/arrays.se')
inset('../../macros/logging.se')
inset('../../macros/mock.se')