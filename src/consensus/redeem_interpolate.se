# This software (Augur) allows buying and selling event options in Ethereum.
#
# Copyright (c) 2015 Forecast Foundation 
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# If you have questions, please contact Joey Krug (joey@augur.net) or
# Jack Peterson (jack@augur.net).

import events as EVENTS
import expiringEvents as EXPIRING
import reporting as REPORTING
import branches as BRANCHES
import interpolate as INTERPOLATE

# - loop through reputation && check if in reporters, if so use their
#   report, if not use the fillin / not reported report (all zeroes)
# - use this to make a giant array of reports to pass to self.consensus
# - want to pass reports for each 0 indexed event in order (so we get
#   reports from an actual reporter)
# (if they didn't vote we set their array for each event to 0,0,0,0,0,0, etc...)
def interpolate(branch, period, num_events, num_reports, flatsize):
    with reputation = array(num_reports):
        with reports = array(flatsize):
            with flatsize_x_2 = flatsize * 2:
                with i = 0:
                    while i < num_reports:
                        with reporterID = REPORTING.getReporterID(branch, i):
                            reputation[i] = REPORTING.getRepBalance(branch, reporterID)
                            # - checks to see if each reporter actually voted on events
                            # - if they didn't vote (simply check if they voted on first event)
                            #     do nothing (these values will be 0 by default due to Serpent array styles)
                            #     else if the reporter did report on events put their ballot into the reports array
                            with ballot = array(num_events):
                                ballot = slice(EXPIRING.getReporterBallot(branch, period, reporterID, outsz=num_events), items=0, items=num_events)
                                if ballot[0] != 0:
                                    with j = 0:
                                        while j < num_events:
                                            reports[i*num_events + j] = ballot[j]
                                            j += 1
                        i += 1
                with scaled = array(num_events):
                    with scaled_max = array(num_events):
                        with scaled_min = array(num_events):
                            with j = 0:
                                while j < num_events:
                                    with event = EXPIRING.getEvent(branch, period, j):
                                        # YES, NO, ONE, etc. macros defined in consensus/constants.se
                                        if fix(EVENTS.getMaxValue(event)) != YES and EVENTS.getNumOutcomes(event) == 2:
                                            scaled[j] = 1
                                            # TODO convert maxValue and minValue to fixed-point in storage
                                            scaled_max[j] = fix(EVENTS.getMaxValue(event))
                                            scaled_min[j] = fix(EVENTS.getMinValue(event))
                                        else:
                                            scaled[j] = 0
                                            scaled_min[j] = NO
                                            scaled_max[j] = YES
                                    j += 1
                            with reports_interp = array(flatsize_x_2):
                                reports_interp = slice(INTERPOLATE.interpolate(reports, reputation, scaled, scaled_max, scaled_min, outsz=flatsize_x_2), items=0, items=flatsize_x_2)
                                EXPIRING.setVSize(branch, period, flatsize)
                                EXPIRING.setReportsFilled(branch, period, slice(reports_interp, items=0, items=flatsize))
                                EXPIRING.setReportsMask(branch, period, slice(reports_interp, items=flatsize, items=flatsize_x_2))
                                return(1)

inset('macros/constants.se')
inset('macros/fixed.se')
inset('macros/arrays.se')
