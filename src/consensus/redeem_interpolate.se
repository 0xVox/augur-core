# This software (Augur) allows buying and selling event options in Ethereum.
#
# Copyright (c) 2015 Forecast Foundation 
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# If you have questions, please contact Joey Krug (joey@augur.net) or
# Jack Peterson (jack@augur.net).

import events as EVENTS
import expiringEvents as EXPIRING
import reporting as REPORTING
import branches as BRANCHES
import interpolate as INTERPOLATE

data Interpolate[][](numberReporters, reputation[])

def get_reputation_vector(branch, period):
    return(load(self.Interpolate[branch][period].reputation[0], chars=32*self.Interpolate[branch][period].numberReporters): arr)

def set_reputation_vector(branch, period, reputation: arr):
    #if(!self.whitelist.check(msg.sender)):
    #   return(-1)
    self.Interpolate[branch][period].numberReporters = len(reputation)
    save(self.Interpolate[branch][period].reputation[0], reputation, chars=32*len(reputation))
    return(1)

# - loop through reputation && check if in reporters, if so use their
#   report, if not use the fillin / not reported report (all zeroes)
# - use this to make a giant array of reports to pass to self.consensus
# - want to pass reports for each 0 indexed event in order (so we get
#   reports from an actual reporter)
# (if they didn't vote we set their array for each event to 0,0,0,0,0,0, etc...)
def read_ballots(branch, period, num_events, num_reports, flatsize):
    with reputation = array(num_reports):
        with reports = array(flatsize):
            with i = 0:
                while i < num_reports:
                    with reporterID = REPORTING.getReporterID(branch, i):
                        reputation[i] = REPORTING.getRepBalance(branch, reporterID)
                        # - checks to see if each reporter actually voted on events
                        # - if they didn't vote (simply check if they voted on first event)
                        #     do nothing (these values will be 0 by default due to Serpent array styles)
                        #     else if the reporter did report on events put their ballot into the reports array
                        reports[i*num_events] = slice(EXPIRING.getReporterBallot(branch, period, reporterID, outsz=num_events), items=0, items=1)
                        if reports[i*num_events] != 0:
                            with ballot = array(num_events - 1):
                                ballot = slice(EXPIRING.getReporterBallot(branch, period, reporterID, outsz=num_events), items=1, items=num_events)
                                with j = 1:
                                    while j < num_events:
                                        reports[i*num_events + j] = ballot[j - 1]
                                        j += 1
                    i += 1
                EXPIRING.setReportsFilled(branch, period, reports)
                self.set_reputation_vector(branch, period, reputation)
                return(1)

def interpolate(branch, period, num_events, num_reports, flatsize):
    with reputation = array(num_reports):
        reputation = slice(self.get_reputation_vector(branch, period, outsz=num_reports), items=0, items=num_reports)
        with reports = array(flatsize):
            reports = slice(EXPIRING.getReportsFilled(branch, period, outsz=flatsize), items=0, items=flatsize)
            with flatsize_x_2 = flatsize * 2:
                # with scaled = array(num_events):
                #     with scaled_max = array(num_events):
                #         with scaled_min = array(num_events):
                #             with j = 0:
                #                 while j < num_events:
                #                     with event = EXPIRING.getEvent(branch, period, j):
                #                         # YES, NO, ONE, etc. macros defined in consensus/constants.se
                #                         if fix(EVENTS.getMaxValue(event)) != YES and EVENTS.getNumOutcomes(event) == 2:
                #                             scaled[j] = 1
                #                             # TODO convert maxValue and minValue to fixed-point in storage
                #                             scaled_max[j] = fix(EVENTS.getMaxValue(event))
                #                             scaled_min[j] = fix(EVENTS.getMinValue(event))
                #                         # else:
                #                         #     scaled[j] = 0
                #                         #     scaled_min[j] = NO
                #                         #     scaled_max[j] = YES
                #                     j += 1
                with reports_interp = array(flatsize_x_2):
                    reports_interp = slice(INTERPOLATE.interpolate(reports, reputation, outsz=flatsize_x_2), items=0, items=flatsize_x_2)
                    # reports_interp = slice(INTERPOLATE.interpolate(reports, reputation, scaled, scaled_max, scaled_min, outsz=flatsize_x_2), items=0, items=flatsize_x_2)
                    EXPIRING.setVSize(branch, period, flatsize)
                    EXPIRING.setReportsFilled(branch, period, slice(reports_interp, items=0, items=flatsize))
                    EXPIRING.setReportsMask(branch, period, slice(reports_interp, items=flatsize, items=flatsize_x_2))
                    return(1)

inset('macros/constants.se')
inset('macros/fixed.se')
inset('macros/arrays.se')
