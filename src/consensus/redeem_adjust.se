# This software (Augur) allows buying and selling event options in Ethereum.
#
# Copyright (c) 2015 Forecast Foundation 
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# If you have questions, please contact Joey Krug (joey@augur.net) or
# Jack Peterson (jack@augur.net).

import reporting as REPORTING
import expiringEvents as EXPIRING
import adjust as ADJUST

def reputation_delta(branch, period, num_events, num_reports, flatsize):
    with scores = array(num_reports):
        scores = slice(EXPIRING.getScores(branch, period, outsz=num_reports), items=0, items=num_reports)
        with nr_x_2 = num_reports * 2:
            with sets = array(nr_x_2):
                sets = slice(ADJUST.reputation_delta(scores, num_reports, num_events, outsz=nr_x_2), items=0, items=nr_x_2)
                # with setOne = array(num_reports):
                #     with k = 0:
                #         while k < num_reports:
                #             setOne[k] = sets[k]
                #             k += 1
                #     with setTwo = array(num_reports):
                #         with k = 0:
                #             while k < num_reports:
                #                 setTwo[k] = sets[k + num_reports]
                #                 k += 1
                #         EXPIRING.setSetOne(branch, period, setOne)
                #         EXPIRING.setSetTwo(branch, period, setTwo)                        
                EXPIRING.setSetOne(branch, period, slice(sets, items=0, items=num_reports))
                EXPIRING.setSetTwo(branch, period, slice(sets, items=num_reports, items=nr_x_2))
                return(1)

def weighted_delta(branch, period, num_events, num_reports, flatsize):
    with reports_filled = array(flatsize):
        reports_filled = slice(EXPIRING.getReportsFilled(branch, period, outsz=flatsize), items=0, items=flatsize)
        with reputation = array(num_reports):
            with i = 0:
                while i < num_reports:
                    reputation[i] = REPORTING.getRepByIndex(branch, i)
                    i += 1
                with set1 = array(num_reports):
                    set1 = slice(EXPIRING.getSetOne(branch, period, outsz=num_reports), items=0, items=num_reports)
                    with set2 = array(num_reports):
                        set2 = slice(EXPIRING.getSetTwo(branch, period, outsz=num_reports), items=0, items=num_reports)
                        with ne_x_3 = num_events * 3:
                            with ne_x_2 = num_events * 2:
                                with wsets = array(ne_x_3):
                                    wsets = slice(ADJUST.weighted_delta(set1, set2, reputation, reports_filled, num_reports, num_events, outsz=ne_x_3), items=0, items=ne_x_3)
                                    # with old = array(num_events):
                                    #     with k = 0:
                                    #         while k < num_events:
                                    #             old[k] = wsets[k]
                                    #             k += 1
                                    #     with newOne = array(num_events):
                                    #         with k = 0:
                                    #             while k < num_events:
                                    #                 newOne[k] = wsets[k + num_events]
                                    #                 k += 1
                                    #         with newTwo = array(num_events):
                                    #             with k = 0:
                                    #                 while k < num_events:
                                    #                     newTwo[k] = wsets[k + 2*num_events]
                                    #                     k += 1
                                    #             EXPIRING.setOld(branch, period, old)
                                    #             EXPIRING.setNewOne(branch, period, newOne)
                                    #             EXPIRING.setNewTwo(branch, period, newTwo)
                                    EXPIRING.setOld(branch, period, slice(wsets, items=0, items=num_events))
                                    EXPIRING.setNewOne(branch, period, slice(wsets, items=num_events, items=ne_x_2))
                                    EXPIRING.setNewTwo(branch, period, slice(wsets, items=ne_x_2, items=ne_x_3))
                                    return(1)

def select_scores(branch, period, num_events, num_reports, flatsize):
    with old = array(num_events):
        old = slice(EXPIRING.returnOld(branch, period, outsz=num_events), items=0, items=num_events)
        with new1 = array(num_events):
            new1 = slice(EXPIRING.getNewOne(branch, period, outsz=num_events), items=0, items=num_events)
            with new2 = array(num_events):
                new2 = slice(EXPIRING.getNewTwo(branch, period, outsz=num_events), items=0, items=num_events)
                with set1 = array(num_reports):
                    set1 = slice(EXPIRING.getSetOne(branch, period, outsz=num_reports), items=0, items=num_reports)
                    with set2 = array(num_reports):
                        set2 = slice(EXPIRING.getSetTwo(branch, period, outsz=num_reports), items=0, items=num_reports)
                        with scores = array(num_reports):
                            scores = slice(EXPIRING.getScores(branch, period, outsz=num_reports), items=0, items=num_reports)
                            with adjusted_scores = array(num_reports):
                                adjusted_scores = slice(ADJUST.select_scores(old, new1, new2, set1, set2, scores, num_reports, num_events, outsz=num_reports), items=0, items=num_reports)
                                EXPIRING.setAdjPrinComp(branch, period, adjusted_scores)
                                return(1)

inset('macros/constants.se')
inset('macros/fixed.se')
