# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Storage of all data associated with reporters
# takes reporterID as key, fxpValue is rep amount
data reporting[2**160]

# owner [account balance is coming from], then spender, e.g. approvedToSpend[owner][spender]
# returns amount spender can spend
data approvedToSpend[2**160][2**160]

# whether the contract has been finished seeding
data seeded
# keeps track of total rep in the system
data totalSupply
# token name for display
data name
# token symbol for display
data symbol
# amount of decimals per unit of rep
data decimals

event Transfer(from:indexed, to:indexed, fxpValue)
event Approval(owner:indexed, spender:indexed, fxpValue)

# 18 decimals
macro ONE:
    10 ** 18

macro refund():
    if(msg.value > 0):
        if(!send(msg.sender, msg.value)):
            throw()

def init():
    self.name = "Reputation"
    self.symbol = "REP"
    self.decimals = 18

def any():
    refund()

# Transfer rep
# @return fxpValue of reputation sent, 0 if not enough reputation
def transfer(receiver: address, fxpValue: uint256):
    senderBalance = self.reporting[msg.sender]
    if(senderBalance < fxpValue or fxpValue <= 0 or !self.seeded):
        throw()
    if(!safeToSubtract(self.reporting[msg.sender], fxpValue) or !safeToAdd(self.reporting[receiver], fxpValue)):
        throw()
    self.reporting[msg.sender] -= fxpValue
    self.reporting[receiver] += fxpValue
    log(type = Transfer, msg.sender, receiver, fxpValue)
    return(1)

# TransferFrom per token api allowing another contract to withdraw on user's behalf
# also allows transfer if sent from the real owner
# fails unless from has authorized sender
def transferFrom(from: address, receiver: address, fxpValue: uint256):
    senderBalance = self.reporting[from]
    if(senderBalance < fxpValue or fxpValue <= 0 or fxpValue > self.approvedToSpend[from][msg.sender] or !self.seeded):
        throw()
    if(!safeToSubtract(self.reporting[from], fxpValue) or !safeToAdd(self.reporting[receiver], fxpValue)):
        throw()
    self.approvedToSpend[from][msg.sender] -= fxpValue
    self.reporting[from] -= fxpValue
    self.reporting[receiver] += fxpValue
    log(type = Transfer, from, receiver, fxpValue)
    return(1)
    
# Allows spender to withdraw from your rep account
def approve(spender: address, amount: uint256):
    if(amount <= 0):
        return(0)
    self.approvedToSpend[msg.sender][spender] = amount
    log(type = Approval, msg.sender, spender, amount)
    return(1)

# Sets the initial distribution of rep
def setSaleDistribution(addresses: address[], balances: uint256[]):
    i = 0
    if(len(addresses) != len(balances)):
        throw()
    while(i <= len(addresses)):
        if(!self.reporting[addresses[i]] && !self.seeded):
            self.reporting[addresses[i]] = balances[i]
            self.totalSupply += balances[i]
            log(type = Transfer, 0, addresses[i], balances[i])
        i += 1
    if(self.totalSupply == 11000000 * ONE):
        self.seeded = 1
    return(1)

# Returns amount spender can withdraw from owner
def allowance(owner: address, spender: address):
    return(self.approvedToSpend[owner][spender])

def totalSupply():
    return(self.totalSupply)

# @return reputation fxpValue
def balanceOf(address: address):
    return(self.reporting[address])

def getName():
    return(self.name)
    
def getDecimals():
    return(self.decimals)
    
def getSymbol():
    return(self.symbol)

def getSeeded():
    return(self.seeded)

macro throw():
    i = 0
    while(1):
        i +=1

# safe adders idea pulled from piper merriam's btcrelay audit
macro safeToAdd($a, $b):
    (($a + $b) >= $a)

macro safeToSubtract($a, $b):
    ($b <= $a)
