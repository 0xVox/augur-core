import expiringEvents as EXPIRING
import reporting as REPORTING
import events as EVENTS
import fxpFunctions as FXP
import events as EVENTS
import makeReports as MAKEREPORTS
import branches as BRANCHES
import markets as MARKETS
import sendReputation as SENDREP

# round two consensus data
data bondPaid[]
data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, final)

# branches takes a branchID
  # denominator takes a vote period
  # penalized takes for a given period a user / address reported for a certain event and num of events they reported on in that period in total
    # penalizedUpTo is the latest period they've done the penalization for
  # fees collected states whether for a given period a user collected fees
  # rep collected states whether for a given period a user collected rep
data branches[](denominator[], penalized[][](event[], num, penalizedUpTo), feesCollected[], repCollected[])

#1. Record rep at start of report period
#2. Penalize for each event
#3. Each reporter needs to do this for all events they reported on, if not get docked
#4. At the end of some period make so users have to claim rep
#5. If you don't do it for all events, autolose 20% rep (b/c you're trying to cheat)
# Errors:
  # -1: pushed back event already resolved, so can't redistribute rep based off of its original expected expiration period
  # -2: already past first half of new period and needed to penalize before then
def penalizeWrong(branch, event):
  lastPeriod = BRANCHES.getVotePeriod(branch)-1
  periodLength = BRANCHES.getPeriodLength(branch)
  residual = block.number % periodLength
  if(residual > periodLength/2):
    return(-2)
  if(EVENTS.getOriginalExpiration(event)!=EVENTS.getExpiration(event) && MARKETS.getPushedForward(market)):
    if(lastPeriod==EVENTS.getOriginalExpiration(event)/BRANCHES.getPeriodLength(branch)):
      return(-1)
  outcome = EVENTS.getOutcome(event)
  reportValue = MAKEREPORTS.getReport(branch, lastPeriod, event)
	p = self.getProportionCorrect(event)
  oldRep = MAKEREPORTS.getBeforeRep(branch, period)
	if(!self.penalized[lastPeriod][tx.origin].event[event] && BRANCHES.getVotePeriod(branch) > period && reportValue && outcome!=0):
		# wrong
		if(reportValue > outcome+2**64*.01 or reportValue < outcome-2**64*.01):
			if(scalar(event) or categorical(event) or outcome==3*2**64):
				p = -(abs(reportValue - EVENTS.getMedian(event))/2) + 2**64
			newRep = oldRep*(2*p - 2**64)/2**64
		# right
		else:
			if(scalar(event) or categorical(event) or outcome==3*2**64):
				p = -(abs(reportValue - EVENTS.getMedian(event))/2) + 2**64
			newRep = oldRep*(2*(2**64-p)**2 / p + 2**64)
		#smoothedRep = oldRep*.8 + newRep*.2
    smoothedRep = oldRep * 14757395258967642112/2**64 + newRep * 3689348814741910528/2**64
		MAKEREPORTS.setAfterRep(branch, lastPeriod, oldRep + (smoothedRep - oldRep))
    repChange = smoothedRep - oldRep
    if(repChange < 0):
      sendToRedistribPool

		if(MAKEREPORTS.getNumReportsActual(branch, lastPeriod)==self.penalized[lastPeriod][tx.origin].num):
        self.penalized[lastPeriod][tx.origin].doneAllEvents = 1
        # find delta between this last period and last penalized up to
        self.penalizedUpTo[branch][tx.origin] = lastPeriod
        # dock 20% for each period they didn't penalize on
  	    smoothedRep = oldRep*(14757395258967642112)/2**64
  	    # and send it to branch for penalty rep collection
    self.penalized[lastPeriod][tx.origin].event[event] = 1
    self.penalized[lastPeriod][tx.origin].num += 1
		return(1)
  else:
    return(0)

def proportionCorrect(event, branch, period):
	p = 0
	outcome = EVENTS.getOutcome(event)
	if(outcome!=0):
		# binary
		if(EVENTS.getNumOutcomes(event)==2 and 2**64*EVENTS.getMaxValue(event)==2**65 and 2**64*EVENTS.getMinValue(event)==2**64):
			# subtract 1 to get it from 0 to 1
			avgOutcome = EVENTS.getUncaughtOutcome(event) - 2**64
			# say we have outcome of 0, avg is .4, what is p?
      # p is .6 or 60%
			if(outcome == 2**64):
				p = 2**64 - avgOutcome
			# say we have outcome of 1, avg is .8, what is p (proportion correct)?
			# p is .8 or 80%
			if(outcome == 2 * 2**64):
				p = avgOutcome
			if(outcome == 3 * 2**63):
			  return(0)
	  return(p)
	else:
		return(0)

# -2: needs to be second half of reporting period to claim rep [1st half is when redistribution is done]
  # after this window, any unclaimed rep is pushed to the next period's redistrib. pool via the first make report submission
def collectRep(branch):
  periodLength = BRANCHES.getPeriodLength(branch)
  residual = block.number % periodLength
  if(residual < periodLength/2):
    return(-2)
  if(!repRedistributionDone(branch, tx.origin)):
      redistributeRep(branch)
  lastPeriod = BRANCHES.getVotePeriod(branch)-1
  repReported = EXPEVENTS.getTotalRepReported(branch, lastPeriod)
	if(!self.repCollected[lastPeriod][tx.origin] && reportedThisPeriod):
		newRep = MAKEREPORTS.getAfterRep(branch, lastPeriod)
    gainedRep = newRep * 2**64 / denominator * self.repInRedistribPool(period) / 2**64
    if(lostRep):
      newRep = MAKEREPORTS.getAfterRep(branch, period) + gainedRep
    if(gainedRep):
      newRep = MAKEREPORTS.getBeforeRep(branch, period) + gainedRep
		REPORTING.setRep(branch, REPORTING.repIDToIndex(branch, tx.origin), newRep)
	  self.repCollected[lastPeriod][tx.origin] = 1
    rep = fixed_multiply(REPORTING.getInitialRep(branch, lastPeriod), REPORTING.getReputation(msg.sender)*2**64/repReported)
    REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, tx.origin), rep)
	  REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, branch), rep)
	 
	  initial rep 
	  before rep
	  after rep
	  total rep reported
	 	return(1)
	else:
		return(0)


#lazily evaluated claiming of trading fees
def collectFees(branch):
  if(!repRedistributionDone(branch, tx.origin)):
      redistributeRep(branch)
  lastPeriod = BRANCHES.getVotePeriod(branch)-1
  repReported = EXPEVENTS.getTotalRepReported(branch, lastPeriod)
  if(!self.feesCollected[lastPeriod][msg.sender] && reportedThisPeriod)
    cash = BRANCHES.getInitialBalance(branch, lastPeriod) * REPORTING.getReputation(msg.sender) / repReported
	  CASH.addCash(tx.origin, cash)
	  CASH.subtractCash(branch, cash)
	  self.feesCollected[lastPeriod][msg.sender] = 1
	return(1)

# anti cheat provide ballot and randomNum mechanism steal deposit
# Returns:
  # 0: not a valid claim
  # -2: reporter doesn't exist
def slashRep(branch, votePeriod, salt, report, reporter, eventID):
  realHash = EXPEVENTS.getReportHash(branch, votePeriod, reporter, eventID)
  hashInfo = array(4)
  hashInfo[0] = reporter
  hashInfo[1] = salt
  hashInfo[2] = report
  hashInfo[3] = eventID
  reportHash = sha256(hashInfo, chars=32*len(hashInfo))
  if(reportHash!=realHash):
      return(0)
  else:
    reporterIndex = REPORTING.repIDToIndex(branch, reporter)
    trutherIndex = REPORTING.repIDToIndex(branch, tx.origin)
    trutherBalance = REPORTING.getRepBalance(branch, tx.origin)
    # if the truther's rep. account doesn't exist, make one
    if(REPORTING.getReporterID(branch, trutherIndex)!=tx.origin):
        trutherIndex = REPORTING.getNumberReporters(branch)
        REPORTING.addReporter(branch, tx.origin)
    if(REPORTING.getReporterID(branch, reporterIndex)!=reporter):
        return(-2)
    reporterBalance = REPORTING.getRepBalance(branch, reporter)
    REPORTING.setRep(branch, reporterIndex, 0)
    REPORTING.setRep(branch, trutherIndex, (trutherBalance + reporterBalance*2**63 / 2**64))
  return(reporterBalance)

def incrementPeriodAfterReporting(branch):
	# do this after reporting is finished
	if(periodOver(branch)):
		BRANCHES.incrementPeriod(branch)
		return(1)
	else:
		return(0)
		
### Helper functions:

macro abs($a):
	if($a<0):
		$a = -$a
	$a

def getProportionCorrect(event):
  return(self.proportionCorrect[event])

macro periodOver($branch):
  
#hasDoneRRForLazyEventsAndWrongAnsForAllPastPeriods
macro repRedistributionDone($reporter, $branch):
  if penalizeduptolast period and lazyrruptolastperiod
macro redistributeRep($branch):
  if(oldPeriodsTooLateToPenalize && userDidntPenalizeForAllInOldPeriods):
    # dock 20% for each period they didn't penalize on
  	smoothedRep = oldRep*.8
  	# and send it to branch for penalty rep collection

macro scalar($event):
    ((EVENTS.getMaxValue($event)!=2 || EVENTS.getMinValue($event)!=1) && EVENTS.getNumOutcomes($event)==2)
    
macro binary($event):
    (EVENTS.getNumOutcomes($event)==2 and 2**64*EVENTS.getMaxValue($event)==2**65 and EVENTS.getMinValue($event)==1)
    
macro categorical($event):
    (EVENTS.getNumOutcomes($event)>2)

# test bonded pushed forward event/market though not ready to be resolved
  # code in penalize for that:
    #elif(rejected && rejectedPeriodOver && && actuallyrejected && MAKEREPORTS.getReport(branch, lastPeriodperiod, event) && !self.penalized[lastPeriod][tx.origin].event[event] && outcome):
    #  outcome = 2**63
    #  median = 2**63
  	#	p = self.getProportionCorrect(event, rejected)
  	#	oldRep = MAKEREPORTS.getBeforeRep(branch, period)
  	#	# wrong
  	#	if(reportValue > outcome+.01 or reportValue < outcome-.01):
  	#		if(scalar or categorical or .5):
  	#		  # scalar/cat are 0 - 1, binary .5 are 1-2 and 1.5
    #     # should be outcome since median is the same
  	#			p = -(abs(reportValue - median)/2) + 1
  	#		newRep = oldRep*(2*p -1)
  	#	# right
  	#	else:
  	#		if(scalar or categorical or .5):
  	#			p = -(abs(reportValue - median)/2) + 1
  	#		newRep = oldRep*(2*(1-p)**2 / p + 1)
  	#	smoothedRep = oldRep*.8 + newRep*.2
  	#	MAKEREPORTS.setAfterRep(branch, period, oldRep + (smoothedRep - oldRep))
    # repChange = smoothedRep - oldRep
    # if(repChange < 0):
    #   sendToRedistribPool
    # # need to except round two events from this when added
    # if(MAKEREPORTS.getNumReportsActual(branch, lastPeriod)==self.penalized[lastPeriod][tx.origin].num):
    #   self.totalRepPenalized[period] += oldRep
    #   self.denominator[branch][period] = self.totalRepPenalized[period] + (smoothedRep - oldRep)
    # self.penalized[lastPeriod][tx.origin].event[event] = 1
    # self.penalized[lastPeriod][tx.origin].num += 1
  	#	return(1)
# test .99 resolve push forward