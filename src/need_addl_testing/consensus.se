import expiringEvents as EXPIRING
import reporting as REPORTING
import events as EVENTS
import fxpFunctions as FXP
import events as EVENTS
import makeReports as REPORTS
import branches as BRANCHES
import markets as MARKETS
import sendReputation as SENDREP

data proportionCorrect[]
# takes branch, votePeriod
data denominator[][]

data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, final)

data bondPaid[]

data repDelta[][]

data totalRepPenalized[]

#1. Record rep at start of report period
#2. Penalize for each event
#	- subtract from 1 and store in another variable if a loss
#	- add to 1 and store in another variable if win rep
#3. Always keep updated the current denominator, so totalRep + delta from 2
	#3a. Make it so a user has to do this for all events they reported on _before_ updating the denominator
#4. Do 2 and 3 for each reporter (note: each reporter needs to do this for all events they reported on, if not get docked)
#5. At the end of some period make so users have to claim rep (win/loss var for a user / (current denominator) * totalRepInPeriod)
#6. If you don't do it for all events, autolose 20% rep (b/c you're trying to cheat)
#7. what if don't claim rep, nothing, it just doesn't formally exist until you claim it or try to send it somewhere (upon which it claims your old rep)
# make sure user has always done this up to current period before doing current period
# Errors:
  # -1: pushed back event already resolved, so can't redistribute rep based off of its original expected expiration period
def penalizeWrong(branch, period, event):
  # if appealed don't allow rbcr until after the appeal process is over
  if(self.roundTwo[event].roundTwo && !self.roundTwo[event].final):
    return(0)
  if(BRANCHES.getVotePeriod(branch) > period +1):
    return(0)
  # reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, then beyond that the people who originally reported whatever the actual truth was would get the rest. then regular rbcr for the round 2 reporting
  # Don't want to allow people to do rbcr for a round 2 event until the round 2 period is over
	# So we want to do the rbcr for both period 1 and period 2 at this time
	# ○ Do the first rbcr, payback bond and subtract diff in rep from total rep reported b/c it goes to bonded challenger and not reporters who reported that round
	#	○ Do the second (for each user), payback bond and subtract diff in rep from total rep reported b/c it goes to bonded challenger and not reporters who reported that round
	#	○ Denominator is as normal, but totalRepReported is lower
  # if round 2 outcome is different
  # does this work properly for scalars and binary and categorical re p and scalar 0-1 reports in fxp and binary 1 or 2 or 1.5 in fxp
  if(self.roundTwo[event].originalOutcome != EVENTS.getOutcome(event) && self.roundTwo[event].originalOutcome != EVENTS.getMedian(event) && notDoneForEvent && periodOver && reported && eventInPeriod):
    # submit later period, do rbcr on both
    if(period == (EVENTS.getExpiration(event)/BRANCHES.getPeriodLength(branch))):
      p = self.getProportionCorrect(event)
      outcome = EVENTS.getOutcome(event)
      reportValue = REPORTS.getReport(branch,period,event)
      secondReportValue
      oldRep = REPORTS.getBeforeRep(branch, period)
      # wrong
      if(reportValue > outcome+.01 or reportValue < outcome-.01):
        if(scalar or categorical):
          # should be outcome since median is the same
          p = -(abs(reportValue - EVENTS.getMedian(event))/2) + 1
        newRep = oldRep*(2*p -1)
      # right
      else:
        if(scalar or categorical):
          p = -(abs(reportValue - EVENTS.getMedian(event))/2) + 1
        newRep = oldRep*(2*(1-p)**2 / p + 1)
      smoothedRep = oldRep*.8 + newRep*.2
      REPORTS.setAfterRep(branch, period, oldRep + (smoothedRep - oldRep))

      repChange = smoothedRep - oldRep

      if(repChange < 0):
        self.repDelta[period][tx.origin] += -1*repChange
        # give rep to bonded challenger
        # only give rep to bonded challenger _if_ it hasn't been paid back 2x yet
        if(self.bondPaid[event] < 200):
          # done instead of sending to redistrib. pool
          addRepToBondedChallenger(-1*repChange)
          removeRepFromReporter(-1*repChange)
        else:
          sendToRedistribPoolForThisPeriod

      if(doneForAllEventsUserReportedOnExceptAnyRoundTwoEventsInThisRoundButNotExemptingOldPeriodRoundTwoEvents):
        self.totalRepPenalized[period] += oldRep
        self.denominator[branch][period] = self.totalRepPenalized[period] + (smoothedRep - oldRep)


  if(EVENTS.getOriginalExpiration(event)!=EVENTS.getExpiration(event) && MARKETS.getPushedForward(market)):
    if(period==EVENTS.getOriginalExpiration(event)/BRANCHES.getPeriodLength(branch)):
      return(-1)

	if(notDoneForEvent && periodOver && reported && eventResolvedInCloseMarket && eventInPeriod):
		p = self.getProportionCorrect(event)
		outcome = EVENTS.getOutcome(event)
		reportValue = REPORTS.getReport(branch,period,event)
		oldRep = REPORTS.getBeforeRep(branch, period)
		# wrong
		if(reportValue > outcome+.01 or reportValue < outcome-.01):
			if(scalar or categorical):
        # should be outcome since median is the same
				p = -(abs(reportValue - EVENTS.getMedian(event))/2) + 1
			newRep = oldRep*(2*p -1)
		# right
		else:
			if(scalar or categorical):
				p = -(abs(reportValue - EVENTS.getMedian(event))/2) + 1
			newRep = oldRep*(2*(1-p)**2 / p + 1)
		smoothedRep = oldRep*.8 + newRep*.2
		REPORTS.setAfterRep(branch, period, oldRep + (smoothedRep - oldRep))
    repChange = smoothedRep - oldRep
    if(repChange < 0):
      sendToRedistribPool

		if(doneForAllEventsUserReportedOnExceptAnyRoundTwoEvent):
        self.totalRepPenalized[period] += oldRep
        self.denominator[branch][period] = self.totalRepPenalized[period] + (smoothedRep - oldRep)
		return(1)

  if(rejected && rejectedPeriod periodOver && reported && eventResolvedInCloseMarket && notDoneForRejectedEvent):
    outcome = 2**63
    median = 2**63
		p = self.getProportionCorrect(event, rejected)
		reportValue = REPORTS.getReport(branch,period,event)
		oldRep = REPORTS.getBeforeRep(branch, period)
		# wrong
		if(reportValue > outcome+.01 or reportValue < outcome-.01):
			if(scalar or categorical):
        # should be outcome since median is the same
				p = -(abs(reportValue - median)/2) + 1
			newRep = oldRep*(2*p -1)
		# right
		else:
			if(scalar or categorical):
				p = -(abs(reportValue - median)/2) + 1
			newRep = oldRep*(2*(1-p)**2 / p + 1)
		smoothedRep = oldRep*.8 + newRep*.2
		REPORTS.setAfterRep(branch, period, oldRep + (smoothedRep - oldRep))
    repChange = smoothedRep - oldRep
    if(repChange < 0):
      sendToRedistribPool
    if(doneForAllEventsUserReportedOnExceptAnyRoundTwoEvent):
      self.totalRepPenalized[period] += oldRep
      self.denominator[branch][period] = self.totalRepPenalized[period] + (smoothedRep - oldRep)
		return(1)

  else:
    return(0)

def proportionCorrect(event, rejected):
  if(rejected && eventActuallyRejected && rejectedPeriod && periodOver && reported && eventResolvedInCloseMarket):
		# real answer is outcome
    outcome = 2**63
    # p is proportion of correct responses
		p = 0
		if(outcome!=0):
			# binary
			if(EVENTS.getNumOutcomes(event)==2 and 2**64*EVENTS.getMaxValue(event)==2**65 and 2**64*EVENTS.getMinValue(event)==2**64):
        # need to fetch uncaught outcome for rejectedperiod separately
        avgOutcome = EVENTS.getRejectedPeriodUncaught(event)
				# say we have outcome of 0, avg is .4, what is p?
        # p is .6 or 60%
				if(outcome == 2**64):
					p = 1 - avgOutcome
				# say we have outcome of 1, avg is .8, what is p (proportion correct)?
					# p is .8 or 80%
				if(outcome == 2 * 2**64):
					p = avgOutcome
				# say we have outcome of .5, avg is .55, what is p?
				if(outcome == 3 * 2**63):
		return(p)

	if(notDoneForEvent && periodOver && reported && eventResolvedInCloseMarket):
		# p is proportion of correct responses
		p = 0
		# real answer is outcome
		outcome = EVENTS.getOutcome(event)
		if(outcome!=0):
			# binary
			if(EVENTS.getNumOutcomes(event)==2 and 2**64*EVENTS.getMaxValue(event)==2**65 and 2**64*EVENTS.getMaxValue(event)==2**64):
				avgOutcome = EVENTS.getUncaughtOutcome(event)
				# say we have outcome of 0, avg is .4, what is p?
        # p is .6 or 60%
				if(outcome == 2**64):
					p = 1 - avgOutcome
				# say we have outcome of 1, avg is .8, what is p (proportion correct)?
					# p is .8 or 80%
				if(outcome == 2 * 2**64):
					p = avgOutcome
				# say we have outcome of .5, avg is .55, what is p?
				if(outcome == 3 * 2**63):
		return(p)
	else:
		return(0)



# At the end of some period make so users have to claim rep (win/loss var for a user / (current denominator) * totalRepInPeriod)
# what is window to do this?
  # after this window, any unclaimed rep is pushed to the next period's redistrib. pool
def collectRegularRep(branch, votePeriod):
	if(periodOver && reportedEnough && claimedProportionCorrectEnough && hasDoneRRForLazyEventsAndWrongAnsForPastOrGottenPenaltyBelow && hasntDoneThisAlready):
		totalRepReported = EXPIRING.getTotalRepReported(branch, votePeriod)
		# denominator (so it is normalized rep)
		denominator = self.denominator[branch][period]
		# new rep pre normalization
		newRep = REPORTS.getAfterRep(branch, period)
		# after normalization
		#newRep =  newRep * 2**64 / denominator * totalRepReported / 2**64
    # rep in redistrib. pool for that period
    gainedRep = newRep * 2**64 / denominator * self.repInRedistribPool(period) / 2**64
    if(lostRep):
      newRep = REPORTS.getAfterRep(branch, period) + gainedRep
    if(gainedRep):
      newRep = REPORTS.getBeforeRep(branch, period) + gainedRep
		REPORTING.setRep(branch, REPORTING.repIDToIndex(branch, tx.origin), newRep)
		return(1)
	else:
		return(0)


# rep claiming similar to fee claiming
# person didn't report enough
def collectPenaltyRep(branch, votePeriod):
	# if reported not enough for this period, don't allow collection
	numEvents = REPORTS.getNumEventsToReport(branch, votePeriod)
	if(numEvents < 30*2**64):
        numEvents = 30*2**64
    if(numEvents/(2*2**64) > REPORTS.getNumReportsActual(branch, votePeriod)):
    	return(-1)
    if(hasntDoneRRForLazyEventsAndWrongAnsForPast+CurrentPeriods):
        doIt()
        self.RRDone = true
    if(oldPeriodsTooLateToPenalize && userDidntPenalizeForAllInOldPeriods):
      # dock 20% for each period they didn't penalize on
    	smoothedRep = oldRep*.8
    	# and send it to branch for penalty rep collection
    lastPeriod = BRANCHES.getVotePeriod(branch)-1
    repReported = EXPEVENTS.getTotalRepReported(branch, lastPeriod)
    if(penaltyNotAlreadyCollected && periodOver && hasReported && collectedRepForPeriod)
    	rep = fixed_multiply(REPORTING.getInitialRep(branch, lastPeriod), REPORTING.getReputation(msg.sender)*2**64/repReported)
    	REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, tx.origin), rep)
		REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, branch), rep)
	return(1)

#Q: Can we do lazy eval claiming of trading fees?
#A: Yes:
#      if(addrWasInThisConsensusPeriod):
#          send them cash of amount equal to fees from that period * rep owned by addr in that period / total #rep in that period
# payout function (lazily evaluate it)
def collectFees(branch):
	# if reported not enough for this period, don't allow collection
	numEvents = REPORTS.getNumEventsToReport(branch, votePeriod)
	if(numEvents < 30*2**64):
        numEvents = 30*2**64
    if(numEvents/(2*2**64) > REPORTS.getNumReportsActual(branch, votePeriod)):
    	return(-1)
	# - need to loop through rep holders and distribute 50% of branch fees to
	# except instead, do it on a per report basis
    # reporters' cashcoin addresses
    if(hasntDoneRRForLazyEventsAndWrongAnsForPast+CurrentPeriods):
        doIt()
        self.RRDone = true
    lastPeriod = BRANCHES.getVotePeriod(branch)-1
    repReported = EXPEVENTS.getTotalRepReported(branch, lastPeriod)
    if(feesNotAlreadyCollected && periodOver && hasReported)
		cash = fixed_multiply(BRANCHES.getInitialBalance(branch, lastPeriod), REPORTING.getReputation(msg.sender)*2^64/repReported)
		CASH.addCash(msg.sender, cash)
		CASH.subtractCash(branch, cash)
	return(1)

# test penalize not enough reports
# test bonded pushed forward event though not ready to be resolved
# test .99 resolve push forward

# anti cheat provide ballot and randomNum mechanism steal deposit
# Returns:
  # 0: not a valid claim
  # -2: reporter doesn't exist
def slashRep(branch, votePeriod, salt, report, reporter, eventID):
  realHash = EXPEVENTS.getReportHash(branch, votePeriod, reporter, eventID)
  hashInfo = array(4)
  hashInfo[0] = reporter
  hashInfo[1] = salt
  hashInfo[2] = report
  hashInfo[3] = eventID
  reportHash = sha256(hashInfo, chars=32*len(hashInfo))
  if(reportHash!=realHash):
      return(0)
  else:
    reporterIndex = REPORTING.repIDToIndex(branch, reporter)
    trutherIndex = REPORTING.repIDToIndex(branch, tx.origin)
    trutherBalance = REPORTING.getRepBalance(branch, tx.origin)
    # if the truther's rep. account doesn't exist, make one
    if(REPORTING.getReporterID(branch, trutherIndex)!=tx.origin):
        trutherIndex = REPORTING.getNumberReporters(branch)
        REPORTING.addReporter(branch, tx.origin)
    if(REPORTING.getReporterID(branch, reporterIndex)!=reporter):
        return(-2)
    reporterBalance = REPORTING.getRepBalance(branch, reporter)
    REPORTING.setRep(branch, reporterIndex, 0)
    REPORTING.setRep(branch, trutherIndex, (trutherBalance + reporterBalance*2**63 / 2**64))
  return(reporterBalance)

def incrementPeriodAfterReporting():
	# do this after reporting is finished
	if(reportingPeriodOver/finished):
		BRANCHES.incrementPeriod(branch)
		return(1)
	else:
		return(0)
		
macro abs($a):
	if($a<0):
		$a = -$a
	$a
	
def getProportionCorrect(event):
  return(self.proportionCorrect[event])