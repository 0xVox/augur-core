#    todo so if user hasn't claimed rep on the branch yet and it's a fork scenario, don't allow sending rep on the parent branch until they [receiver] claim 
#    should also perhaps make sender claim too
#    check overflows and underflows


# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import expiringEvents as EXPEVENTS
import reporting as REPORTING
import makeReports as REPORTS
import penalizationCatchup as CATCHUP
import consensusData as CONSENSUS
import consensus as INCREMENTPERIOD
import repContract as REPCONTRACT
inset('refund.se')

# sender/owner, then spender
data amountCanSpend[][](branch[])

event Transfer(_from:indexed, _to:indexed, _value)
event Approval(_owner:indexed, _spender:indexed, value)

def any():
    refund()

# send active reputation
# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: not enough rep / value too small or not authorized
    # -3: "Receiving address doesn't exist"
def sendRepFrom(branch, from, recver, value):
    checkInvariants(from)
    senderIndex = REPORTING.repIDToIndex(branch, from)
    receiverIndex = REPORTING.repIDToIndex(branch, recver)
    # if the sender's rep. account doesn't exist, make one, only if in first half of period and not a fork scenario
    if(REPORTING.getReporterID(branch, senderIndex)!=from && from==msg.sender):
        CONSENSUS.setPenalizedUpTo(branch, from, (votePeriod-1))
        REPORTING.addReporter(branch, from)
        return(-1)
    if(REPORTING.getReporterID(branch, receiverIndex)!=recver):
        return(-3)

    senderBalance = REPORTING.getRepBalance(branch, from)
    if(senderBalance < value || value <= 0 || !(self.amountCanSpend[from][msg.sender].branch[branch] >= value or from==msg.sender)):
        return(-2)
    if(from!=msg.sender)
        self.amountCanSpend[from][msg.sender].branch[branch] -= value
    if(!REPORTING.subtractRep(branch, senderIndex, value) || !REPORTING.addRep(branch, receiverIndex, value)):
        throw()
    log(type=Transfer, from, recver, value)
    return(1)

# Transfer dormant rep
# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: not enough rep / value too small or not authorized
    # -3: "Receiving address doesn't exist"
# fails unless from has authorized sender [either contract which was approved or the from address is the msg.sender]
def transferFrom(branch, from, recver, value):
    refund()
    votePeriod = BRANCHES.getVotePeriod(branch)
    senderIndex = REPORTING.repIDToIndex(branch, from)
    receiverIndex = REPORTING.repIDToIndex(branch, recver)
    # if the sender's rep. account doesn't exist, make one
    if(REPORTING.getReporterID(branch, senderIndex)!=from && from==msg.sender):
        CONSENSUS.setPenalizedUpTo(branch, from, (votePeriod-1))
        REPORTING.addReporter(branch, from)
        return(-1)
    if(REPORTING.getReporterID(branch, receiverIndex)!=recver):
        return(-3)

    senderBalance = REPORTING.balanceOf(branch, from)
    if(senderBalance < value || value <= 0 || !(self.amountCanSpend[from][msg.sender].branch[branch] >= value or from==msg.sender)):
        return(-2)
    if(from!=msg.sender)
        self.amountCanSpend[from][msg.sender].branch[branch] -= value
    if(!REPORTING.subtractDormantRep(branch, senderIndex, value) || !REPORTING.addDormantRep(branch, receiverIndex, value)):
       throw()
    log(type=Transfer, from, recver, value)
    return(1)
    
# Convert active rep to dormant rep
# error messages
    # -1: sender's rep account didn't exist, just made one
    # -2: not enough rep / value too small
# if a person reported on a round 2 event, they cannot convert their rep to dormant or send rep until they've finished the resolution process for that round 2 event todo
# unless this just happened to them last period and they reported correctly then
def convertToDormantRep(branch, value):
    checkInvariants(msg.sender)
    senderIndex = REPORTING.repIDToIndex(branch, msg.sender)
    # if the sender's rep. account doesn't exist, make one, only if in first half of period and not a fork scenario
    if(REPORTING.getReporterID(branch, senderIndex)!=msg.sender):
        REPORTING.addReporter(branch, msg.sender)
        CONSENSUS.setPenalizedUpTo(branch, msg.sender, (votePeriod-1))
        return(-1)

    senderBalance = REPORTING.getRepBalance(branch, msg.sender)
    if(senderBalance < value or value <= 0):
        return(-2)
    if(!REPORTING.subtractRep(branch, senderIndex, value) || !REPORTING.addDormantRep(branch, senderIndex, value)):
        throw()
    REPORTING.adjustActiveRep(branch, -value)
    return(1)
    
# Convert dormant rep to active rep
# error messages
    # -1: sender's rep account didn't exist, just made one
    # -2: 
def convertToActiveRep(branch, value):
    checkInvariants(msg.sender)
    senderIndex = REPORTING.repIDToIndex(branch, msg.sender)
    # if the sender's rep. account doesn't exist, make one
    if(REPORTING.getReporterID(branch, senderIndex)!=msg.sender):
        REPORTING.addReporter(branch, msg.sender)
        CONSENSUS.setPenalizedUpTo(branch, msg.sender, (votePeriod-1))
        return(-1)

    senderBalance = REPORTING.balanceOf(branch, msg.sender)
    if(senderBalance < value or value <= 0):
        return(-2)
    if(!REPORTING.subtractDormantRep(branch, senderIndex, value) || !REPORTING.addRep(branch, senderIndex, value) || !safeToAdd(value, REPORTING.getRepBalance(msg.sender))):
        throw()
    REPORTING.adjustActiveRep(branch, value)
    return(1)  
            
def claimRep():
    balance = REPCONTRACT.balanceOf(msg.sender)
    if(!REPCONTRACT.transferFrom(msg.sender, 0, balance) || !REPORTING.addReporter(1010101, msg.sender, 0, balance, 0)):
        throw()
    return(1)

# Allows spender to withdraw from your dormant rep account
# fix to be branch specific todo
def approve(branch, spender, value):
    self.amountCanSpend[msg.sender][spender].branch[branch] = value
    log(type=Approval, msg.sender, spender, value)
    return(1)

# Returns amount spender can withdraw from owner
def allowance(branch, owner, spender):
    return(self.amountCanSpend[owner][spender].branch[branch])
    
#  0: only one period behind, need to do penalizations for it
# -3: not in right part of period
# -4: couldn't catchup automatically
macro checkInvariants($account):
    refund()
    # need to check all this for the person it's being sent to as well
    periodLength = BRANCHES.getPeriodLength(branch)
    votePeriod = BRANCHES.getVotePeriod(branch)
    lastPeriod = votePeriod - 1
    lastPeriodPenalized = CONSENSUS.getPenalizedUpTo(branch, $account)
    delta = lastPeriod - lastPeriodPenalized
    residual = block.timestamp % periodLength
    # Rep cannot be simultaneously spent (transferred) and used to vote
    if(residual > periodLength/2):
        return(-3)
    # auto increment vote period if needed
    INCREMENTPERIOD.incrementPeriodAfterReporting(branch)
    if(delta > 1):
        if(CATCHUP.penalizationCatchup(branch, $account)!=1):
            return(-4)
    if(!CONSENSUS.getRepRedistributionDone(branch, $account)):
        return(0)
        

# safe adders idea pulled from piper merriam's btcrelay audit
macro safeToAdd($a, $b):
    (($a + $b) >= $a)

macro safeToSubtract($a, $b):
    ($b <= $a)







































