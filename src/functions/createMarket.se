# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import info as INFO
import cash as CASH
import reporting as REPORTING
import makeReports as MAKEREPORTS
import fxpFunctions as FXP
import markets as MARKETS
import events as EVENTS
import expiringEvents as EXPEVENTS
import trades as TRADES
inset(refund.se)

event creationBlock(market:indexed)

data shareLiquidityLeft[]
data cashLiquidityLeft[]
data orderSet[][](bids[], asks[], numOrders)
data orderDepth[]

event log_add_tx(market:indexed, sender, type, price, amount, outcome, tradeid)
event log_update_tx(market:indexed, sender, type, price, tradeid)

# Trade types
macro BID: 1
macro ASK: 2

# alpha is a fixedpoint number / calc. it in UI
# z is the optimal initial vector for each outcome
# z = liquidity / (1+(alpha*n*ln(n)))
    # n is num outcomes
# initialLiquidity is initial number of cash in each outcome you want to buy/initialize/set
# tradingFee is a percent in fixedPoint
# same for these values
# @return marketID if success or 1 if on an oracle only branch creation we have success
# error messages otherwise
    # -1: bad input or parent doesn't exist
    # -2: too many events
    # -3: too many outcomes
    # -4: not enough money
    # -5: fee too low
    # -6: duplicate events
    # -7: event already expired
    # -8: market already exists
# .05 eth to create
# need to check that it's an actual subcurrency upon market creation (maybe check send/balance funs)
def createMarket(branch, description:str, tradingFee, initialLiquidity, events:arr, forkSelection):
    refund()
    periodLength = BRANCHES.getPeriodLength(branch)
    # send this to branch
    creationFee = 1106804644422573056 * BRANCHES.getBaseReporters(branch) * 2**64 / tradingFee
    # min initial liquidity
    if(initialLiquidity < 2213609288845146112 * BRANCHES.getBaseReporters(branch) * 2**64 / tradingFee):
        return(-4)
    # will need to get equivalent value in usd or eth or w/e via etherex exchange for subcurrency markets
    if(periodLength==0 or len(description)==0 || tradingFee < BRANCHES.getMinTradingFee(branch)):
        return(-1)
    if(tradingFee > 2^61):
        return(-1)
        
    event = events[0]
    # check that events have same exp. dates && branch
    i = 0
    eventNum = len(events)
    # only supports upto 3 dimensional markets
    if(eventNum > 3):
        return(-2)
    numOutcomes = 0
    eventsConcat = 0
    cumulativeScale = 0
    tradingPeriod = 0
    while i < eventNum:
        event = events[i]
        if(i!=0):
            if(event==events[i-1]):
                return(-6)
        expirationDate = EVENTS.getExpiration(event)
        futurePeriod = expirationDate / periodLength
        if(expirationDate < block.number):
            return(-7)
        if(EVENTS.getEventBranch(event) != branch || !INFO.getCreator(event)):
            return(-1)
        EXPEVENTS.addEvent(branch, futurePeriod, event)
        if(expirationDate > tradingPeriod):
            tradingPeriod = expirationDate
        eventsConcat += event
        if(!EVENTS.getBond(event)):
            # pay validity bond
            24period = block.number / 7200
            validity_bond =  6 * creationFee * 2 * (1 + EVENTS.getPast24(24period-1)) / (1 + EXPEVENTS.getNumberEvents(branch, BRANCHES.getVotePeriod(branch)))
            if(!CASH.send(eventID, validity_bond)):
                return(-4)
            EVENTS.setBond(event, validity_bond)
            EVENTS.addPast24(24period)
        #scalars
        maxValue = EVENTS.getMaxValue(event)
        minValue = EVENTS.getMinValue(event)
        if((maxValue!=2**65 || minValue !=2**64) && EVENTS.getNumOutcomes(event)==2):
            # is a valid scalar
            cumulativeScale += maxValue - minValue
        eventNumOutcomes = EVENTS.getNumOutcomes(event)
        if(i==0):
            numOutcomes += eventNumOutcomes
        else:
            numOutcomes *= eventNumOutcomes
        i += 1
    if(numOutcomes > 8):
        return(-3)
    if(cumulativeScale==0):
        cumulativeScale = 1
    tradingPeriod = (tradingPeriod / periodLength)

    # formation of marketID (hash)
    marketinfo = string(11*32 + len(description))
    marketinfo[0] = MARKET
    marketinfo[1] = tx.origin
    marketinfo[2] = initialLiquidity
    marketinfo[3] = branch
    marketinfo[4] = eventsConcat
    marketinfo[5] = len(events)
    marketinfo[6] = cumulativeScale
    marketinfo[7] = alpha
    marketinfo[8] = numOutcomes
    marketinfo[9] = tradingPeriod
    marketinfo[10] = tradingFee
    mcopy(marketinfo + 11*32, description, chars=len(description))
    marketID = sha256(marketinfo, chars=len(marketinfo))
    log(type=creationBlock, marketID)
    CASH.initiateOwner(marketID)
    # pay numOutcomes fee
    # if it's already been created return 0
    if(INFO.getCreator(marketID) || MARKETS.getMarketNumOutcomes(marketID)):
        return(-8)
    if(!BRANCHES.getOracleOnly(branch) && CASH.balance(msg.sender) < (initialLiquidity + creationFee)):
        return(-4)

    if(INFO.setInfo(marketID, description, tx.origin, creationFee) && BRANCHES.addMarketToBranch(branch, marketID) && MARKETS.initializeMarket(marketID, events, tradingPeriod, tradingFee, branch, forkSelection) && CASH.send(branch, creationFee)):
        i = 0
        while i < len(events):
            EVENTS.addMarket(events[i], marketID)
            i += 1
            
    if(!BRANCHES.getOracleOnly(branch) && CASH.send(marketID, initialLiquidity/2))
        # buy some of all outcomes
        MARKETS.initialLiquiditySetup(marketID, cumulativeScale, numOutcomes)
        # buy complete sets
        MARKETS.setInitialLiquidityAmount(marketID, initialLiquidity/2)
        participantNumber = MARKETS.addParticipant(marketID, tx.origin)

        i = 0
        # send shares of the event to user address
        while i <= numOutcomes:
            MARKETS.modifyShares(marketID, i, initialLiquidity/(2*cumulativeScale))
            MARKETS.modifyParticipantShares(branch, market, participantNumber, i, initialLiquidity/(2*cumulativeScale))
            i += 1
        self.cashLiquidityLeft[market] = initialLiquidity/2
        # amount of shares held of each outcome
        self.shareLiquidityLeft[market] = initialLiquidity/(2*cumulativeScale)
        return(marketID)
    else:
        return(1)


# bids have amount, price for each outcome
# asks have amount, price for each outcome
# do this for each set as we go down the book to form a whole schedule of orders
# need to add the sets of orders
# if schedule of orders not set, no one can trade in the market
# returns 1 if done, 2 if not done yet but order was added successfully
def addSetOfOrders(bids: arr, asks: arr, market):
    refund()
    if(msg.sender != INFO.getCreator(market) || tx.origin != INFO.getCreator(market)):
        return(-4)
    cumScale = MARKETS.getCumScale(market)
    branch = MARKETS.getBranch(market)
    numOutcomes = MARKETS.getMarketNumOutcomes(market)
    if(len(bids)!=len(asks) or len(bids)!=numOutcomes*2):
        return(0)
    i = 0
    amount = bids[0]
    if(amount <= 0):
        return(0)
    sum = 0
    bidsum = 0
    asksum = 0
    cash = 0
    while i < len(bids):
        # force num shares on each outcome offered to be equal
        if(bids[i]!=amount || asks[i]!=amount):
            return(-1)
        if(bids[i+1] <= 0 or asks[i+1] <= 0 or asks[i+1]*amount < 2**64 or bids[i+1]*amount < 2**64):
            return(0)
        sum += bids[i+1] + asks[i+1]
        bidsum += bids[i+1]
        asksum += asks[i+1]
        cash += amount*bids[i+1]/2**64
        if(abs(bids[i+1] - asks[i+1]) > 1844674407370955264):
            return(-3)
        i += 2
    # ensure that bids and asks for each side's outcome add up to (range[1 if binary] + spread[.1]) and no more
    if(bidsum > (cumScale + 1844674407370955264)):
        return(-2)
    if(asksum > (cumScale + 1844674407370955264)):
        return(-2)

    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)
    if(CASH.balance(msg.sender) < cash):
        return(-5)
    if((self.cashLiquidityLeft[market]-cash) < 0 || (self.shareLiquidityLeft[market]-amount) < 0):
        return(-1)
    # remove liquidity from amount needed still remaining for the bid aspect
    self.cashLiquidityLeft[market] -= cash
    # remove liquidity added here in shares amount from amount needed still remaining for the ask aspect
    self.shareLiquidityLeft[market] -= amount

    i = 0
    # put up ask orders, don't allow mm to cancel them but only adj. them
    # put up and pay for bid orders, don't allow mm to cancel them but only adj. them
    while i < len(bids):
        ask = save_trade(ASK, amount, asks[i+1], market, (i/2 + 1), branch, participantNumber)
        bid = save_trade(BID, amount, bids[i+1], market, (i/2 + 1), branch, participantNumber)
        self.orderSet[market][self.orderDepth[market]].bids[i/2] = bid
        self.orderSet[market][self.orderDepth[market]].asks[i/2] = ask
        i += 2
    self.orderSet[market][self.orderDepth[market]].numOrders = len(bids)
    self.orderDepth[market] += 1
    # liquidity is put on the book, market is ready to roll
    if(self.shareLiquidityLeft[market] == 0 && self.cashLiquidityLeft[market] == 0):
        MARKETS.setScheduleSet(market)
        return(1)
    else:
        return(2)

macro save_trade($type, $amount, $price, $market, $outcome, $branch, $participantNumber):
    trade = [$type, $market, $amount, $price, msg.sender, block.number, $outcome]
    trade_id = sha256(trade, items=7)
    # Save trade
    if !TRADES.getID(trade_id):
        TRADES.saveTrade(trade_id, $type, $market, $amount, $price, msg.sender, $outcome)
        # Update market
        last_id = MARKETS.getLastTrade($market)
        MARKETS.addTrade($market, trade_id, last_id)
        # Update available amount for asks
        if $type == ASK:
            MARKETS.modifyParticipantShares($branch, $market, $participantNumber, $outcome, -$amount)
        # Send / escrow cash for bids
        if $type == BID:
            if(!CASH.send($market, $amount * $price / 2**64)):
                return(-2)
    else:
        return(-1)
    TRADES.setInitialTrade(trade_id)
    log(type=log_add_tx, $market, msg.sender, $type, $price, $amount, $outcome, trade_id)
    trade_id

# call for each set in a schedule to adjust a whole schedule of orders
# bids and asks only have prices here
def adjustSetOfOrders(bids: arr, asks: arr, market, setToReplace):
    refund()
    if(msg.sender != INFO.getCreator(market) || tx.origin != INFO.getCreator(market)):
        return(-4)
    # an ask order can have its price changed to sell at a new price
    # bid orders can have their prices changed as long as the sums equal the same total escrowed value as the original bids
    oldCash = 0
    oldBids = array(self.orderSet[market][setToReplace].numOrders)
    oldAsks = array(self.orderSet[market][setToReplace].numOrders)
    i = 0
    while i < self.orderSet[market][setToReplace].numOrders:
        oldBids[i] = self.orderSet[market][setToReplace].bids[i]
        oldAsks[i] = self.orderSet[market][setToReplace].asks[i]
        oldCash += TRADES.get_amount(oldBids[i])*TRADES.get_price(oldBids[i])/2**64
        i += 1

    cumScale = MARKETS.getCumScale(market)
    branch = MARKETS.getBranch(market)
    numOutcomes = MARKETS.getMarketNumOutcomes(market)
    if(len(bids)!=len(asks) or len(bids)!=numOutcomes or len(bids)!=len(oldBids)):
        return(0)
    i = 0
    sum = 0
    cash = 0
    while i < len(bids):
        if(bids[i] <= 0 or asks[i] <= 0):
            return(0)
        sum += bids[i] + asks[i]
        cash += TRADES.get_amount(oldBids[i])*bids[i]/2**64
        if(abs(bids[i] - asks[i]) > 1844674407370955264):
            return(-3)
        i += 1
    # ensure that bids and asks for each side's outcome add up to 2*(range[1 if binary] + spread[.1]) and no more
    if(sum > 2*(1844674407370955264 + cumScale)):
        return(-2)

    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)
    if(cash!=oldCash):
        return(-5)
    i = 0
    while i < len(bids):
        TRADES.update_trade(oldBids[i], bids[i])
        TRADES.update_trade(oldAsks[i], asks[i])
        log(type=log_update_tx, market, msg.sender, BID, bids[i], trade_id)
        log(type=log_update_tx, market, msg.sender, ASK, asks[i], trade_id)
        i += 1
    return(1)

def updateTradingFee(branch, market, tradingFee):
    refund()
    if(msg.sender != INFO.getCreator(market) || tx.origin != INFO.getCreator(market)):
        return(-4)
    oldFee = MARKETS.getTradingFee(market)
    oldCreationFee = 1106804644422573056 * BRANCHES.getBaseReporters(branch) * 2**64 / oldFee
    newCreationFee = 1106804644422573056 * BRANCHES.getBaseReporters(branch) * 2**64 / tradingFee
    if(tradingFee < BRANCHES.getMinTradingFee(branch) or tradingFee > oldFee):
        return(-1)
    CASH.send(branch, newCreationFee-oldCreationFee)
    return(MARKETS.setTradingFee(market, tradingFee))

#Add def moveMarket(market, newBranch, marketAuthor) in case of a fork or some other issue
#In event of fork:
#1) Market Maker chooses the fork
#2) Market is closed at current prices
#3) The market is unable to go to adjudication upon close date and closes at final prices.
#4) All traders currently involved in this market are asked which fork to participate in. At market close, this vote is used to determine the fork this market moves to before adjudication.
#5) market is moved to the fork with a higher rep market cap at the end of time period x as defined by etherex
#6) market is moved to the fork with a higher market cap as defined by centralized exchange y
def moveMarketAndAssocEvents(market, fork):
    refund()
    #if(self.stuffForked()):
    if(1):
        forkChoice = MARKETS.getForkSelection(market)

        # set market branch
        # move event
        # move market as well to whichever fork

        #1) Market Maker chooses the fork
        if(forkChoice==1):
            if(INFO.getCreator(market)==msg.sender):
                return(0)
        #2) Market is closed at current prices
        elif(forkChoice==2):
            return(0)
        #3) The market is unable to go to adjudication upon close date and closes at final prices.
        elif(forkChoice==3):
            return(0)
        #4) All traders currently involved in this market are asked which fork to participate in. At market close, this vote is used to determine the fork this market moves to before adjudication.
        # should this be weighted by capital in the market? hmm
        elif(forkChoice==4):
            return(0)
        #5) market is moved to the fork with a higher rep market cap at the end of time period x as defined by etherex
        elif(forkChoice==5):
            return(0)
        #6) market is moved to the fork with a higher market cap as defined by centralized exchange y
        elif(forkChoice==6):
            return(0)
        #7) autonocoin style bet which fork it should go on and that's the one (like futarchy, except you don't get a refund)
        elif(forkChoice==7):
            return(0)
    else:
        return(0)


# Anyone can post an "Early Resolution Bond"
# This bond is equal to 0.5 * Market_Fee * Market_Value
# This amount is the amount needed to pay the reporters in case this was frivolous.
# The market goes up for early resolution and reporters place claim to what is truth, however for early resolution, they have an additional option: 'Market is not ready to resolve'
    # this addl option is just the normal indeterminate (except here it's a bit of a special case, see below)
# In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and market remains with old expiration dateevent
# In the event any other option is found to be the consensus the early resolution bond is returned to the poster and then resolution is handled just like any other case.
def pushMarketForward(branch, market):
    refund()
    # prevent for backstop 1 markets and vice versa
    # todo: if has been pushed forward in the past (see close market) don't allow it again
    numEvents = MARKETS.getNumEvents(market)
    if(marketClosed):
        return(0)
    if(CASH.send(market, numEvents*MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))==0):
        return(0)
    i = 0
    # for each event in market
    while i < numEvents:
        if(eventNotResolved && eventNotInRound2Adj):
            event = MARKETS.getMarketEvent(market, i)
            # push into next vote period
            period = BRANCHES.getVotePeriod(branch)
            EXPEVENTS.addEvent(branch, period+1, event)
            # set event expiration date to be after the current reporting period ends
            EVENTS.setExpiration(event, block.number)
            MARKETS.setTradingPeriod(market, period+1)
            MARKETS.setPushedForward(market, 1)
            #MAKEREPORTS.setReportable(period+1, event)
        i += 1
    return(1)

# Absolute value
macro abs($n):
    if($n<0, -$n, $n)