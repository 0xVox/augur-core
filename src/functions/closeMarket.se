# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import info as INFO
import cash as CASH
import markets as MARKETS
import events as EVENTS
import closeMarketOne as CLOSEONE
import closeMarketTwo as CLOSETWO
import closeMarketFour as CLOSEFOUR
import closeMarketEight as CLOSEEIGHT
import expiringEvents as EXPEVENTS
import makeReports as MAKEREPORTS

# first param is the market, second param is the subcurrency contract
data cash[][]

macro YES: 2^65
macro NO: 2^64
macro BAD: 3 * 2^63

macro CATCH_TOLERANCE: 2^64 / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE), NO, if($x > BAD + CATCH_TOLERANCE, YES, BAD))

# lazy eval this or reward closer
# loop through events in the market, get their outcomes && use those to determine the winning events!
# distribute coins among winning events
# when multidimen fancy payouts we report on the events separately per usual, but combine them to determine winning state of a fancy market && then payout that state
#Whoever “closes” the market should get a small portion of fees to simply cover the gas cost to close the market and do payouts. (or lazily eval this)
# @return 0 if fail, if success 1
# Error messages otherwise
    # -1: Market has no cash anyway / already closed
    # -2: 0 outcome
    # -3: Outcome indeterminable
    # -4: Outcome .5 once, pushback and retry
        # if mult events call this fun again to make sure no more to push back
    # -5: event not expired
    # -6: bonded pushed forward market not ready to be resolved
    # -7: event not reportable >.99
# Make sure there are no "while loop out of gas" issues
#Need to make sure we close out markets where one doesn’t happen (i.e. Hillary or Bush? and GDP>3% growth 2017?) properly.
#Use consistent 1 and 2 fixed point numbers as min and max for close market, make market, make event, buy/sell shares, and consensus on binary events - really, just use base 64 fixed point everywhere
# call mult. times if a multidimensional market
def closeMarket(branch, market):
    if(CASH.balance(market)<=0):
        return(-1)
    numberEvents = MARKETS.getNumEvents(market)
    tradingPeriod = MARKETS.getTradingPeriod(market)
    events = array(3)
    events = MARKETS.getMarketEvents(market, outitems=3)
    i = 0
    reportingDone = 1
    while i < numberEvents:
        if(MAKEREPORTS.getNumReportsEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i]) != MAKEREPORTS.getNumReportsExpectedEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])):
            reportingDone = 0
        i += 1
    # check if any events in the market were pushed back and that market has expired
    # (as long as the latest expiring event wasn't pushed back, we know they all got reported on)
    # if it *was* pushed back, we'll just get an outcome of 0, return 0 until the event is actually reported on, then we can resolve the market
    if((BRANCHES.getVotePeriod(branch) > tradingPeriod || reportingDone)):
        # loop through events in the market, get their outcomes && use those to determine the winning events!
        n = 0
        # (max poss. winning outcomes is 8 outcomes total all scalar multidimensional)
        winningOutcomes = array(8)

        periodLength = BRANCHES.getPeriodLength(branch)
        residual = block.number % periodLength
        period = BRANCHES.getVotePeriod(branch)
        while n < numberEvents:
            votingPeriodEvent = EVENTS.getExpiration(events[n])/BRANCHES.getPeriodLength(branch)
            if(MAKEREPORTS.getReportable(votingPeriodEvent, events[n])==-1):
                return(-7)
            fxpOutcome = EVENTS.getOutcome(events[n])
            pushedBack = EVENTS.getPushedBack(events[n])
            ethical = catch(EVENTS.getEthical(events[n]))
            # TODO: if round 2 event && notFinal return 0
            # if binary, catch the outcome
            if(EVENTS.getNumOutcomes(events[n])==2 and 2**64*EVENTS.getMaxValue(events[n])==2**65 and EVENTS.getMinValue(events[n])==1):
                # if outcome not set
                if(fxpOutcome==0 && period > votingPeriodEvent):
                    fxpOutcome = catch(EVENTS.getUncaughtOutcome(events[n]))
                    EVENTS.setOutcome(events[n], fxpOutcome)
                    #•In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
                    # and market remains with old expiration date
                    if(fxpOutcome == 2**63 && MARKETS.getPushedForward(market)):
                        #set event expiration to be the old date prior to this bond process
                        EVENTS.setExpiration(events[n], EVENTS.getOriginalExpiration(events[n]))
                        MARKETS.setTradingPeriod(market, MARKETS.getOriginalTradingPeriod(market))
                        CASH.addCash(branch, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                        CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                        MARKETS.setPushedForward(market, 0)
                        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, events[n], 0)
                        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, events[n], 0)
                        #set outcome to 0
                        EVENTS.setOutcome(events[n], 0)
                        EVENTS.setMedian(events[n], 0)
                        EVENTS.setEthics(events[n], 0)
                        #set uncaughtoutcome to 0
                        EVENTS.setUncaughtOutcome(events[n], 0)
                        # need to store uncaught outcome for rejectedperiod separately as well as which period it was "rejected" in
                        EVENTS.setRejected(events[n], EVENTS.getExpiration(events[n])/periodLength, fxpOutcome)
                        return(-6)
                    # if .5 due to catch param push back once (as .5 outcome), if same on next consensus no more push backs, that's the outcome
                    if(fxpOutcome==2**63 && !pushedBack && residual < periodLength/2):
                        #push back event
                        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, events[n], 0)
                        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, events[n], 0)
                        EVENTS.setEthics(events[n], 0)
                        EXPEVENTS.addEvent(branch, period+1, events[n])
                        #set outcome to 0
                        EVENTS.setOutcome(events[n], 0)
                        #set uncaughtoutcome to 0
                        EVENTS.setUncaughtOutcome(events[n], 0)
                        #set pushedback to true
                        EVENTS.setPushedBack(events[n])
                        #set event expiration date to be after the current reporting period ends
                        EVENTS.setExpiration(events[n], block.number)
                        MARKETS.setTradingPeriod(market, period+1)
                        return(-4)
                    if((fxpOutcome==2**63 && pushedBack) || !ethical):
                        # give event bond money to reporters
                        CASH.subtractCash(events[n], 42*2**64)
                        CASH.addCash(branch, 42*2**64)
                        # not ethical is same as .5 outcome
                        fxpOutcome = 2**63
                        EVENTS.setOutcome(events[n], fxpOutcome)
                    else:
                        # return bond
                        CASH.subtractCash(events[n], 42*2**64)
                        CASH.addCash(INFO.getCreator(events[n]), 42*2**64)
                        if(MARKETS.getPushedForward(market)):
                            CASH.addCash(MARKETS.getBondsMan(market), MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                            CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                            # delete old event from future events exp
                            EXPEVENTS.removeEvent(branch, EVENTS.getOriginalExpiration(events[n])/periodLength)
                else:
                    return(-5)

            # scalar
            elif((2^64*EVENTS.getMaxValue(events[n]) != YES || 2**64*EVENTS.getMinValue(events[n]) != NO) and EVENTS.getNumOutcomes(events[n]) == 2):
                # if outcome/median aren't set
                if(EVENTS.getMedian(events[n])==0 && period > votingPeriodEvent):
                    median = MEDIAN.calculateMedian(events[n])
                    EVENTS.setMedian(events[n], median)
                    EVENTS.setOutcome(events[n], fxpOutcome)
                    scaled_min = 2^64*EVENTS.getMinValue(events[n])
                    scaled_max = 2^64*EVENTS.getMaxValue(events[n])
                    fxpOutcome = median * (scaled_max - scaled_min) + scaled_min
                    EVENTS.setOutcome(events[n], fxpOutcome)
                    #•In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
                    # and market remains with old expiration date
                    if(fxpOutcome == 2**63 && MARKETS.getPushedForward(market)):
                        #set event expiration to be the old date prior to this bond process
                        EVENTS.setExpiration(events[n], EVENTS.getOriginalExpiration(events[n]))
                        MARKETS.setTradingPeriod(market, MARKETS.getOriginalTradingPeriod(market))
                        CASH.addCash(branch, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                        CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                        MARKETS.setPushedForward(market, 0)
                        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, events[n], 0)
                        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, events[n], 0)
                        # need to store uncaught outcome for rejectedperiod separately as well as which period it was "rejected" in
                        EVENTS.setRejected(events[n], EVENTS.getExpiration(events[n])/periodLength, fxpOutcome)
                        #set outcome to 0
                        EVENTS.setOutcome(events[n], 0)
                        EVENTS.setMedian(events[n], 0)
                        EVENTS.setEthics(events[n], 0)
                        #set uncaughtoutcome to 0
                        EVENTS.setUncaughtOutcome(events[n], 0)

                        return(-6)
                    # if .5 due to catch param push back once (as .5 outcome), if same on next consensus no more push backs, that's the outcome
                    if(fxpOutcome==2**63 && !pushedBack && residual < periodLength/2):
                        #push back event
                        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, events[n], 0)
                        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, events[n], 0)
                        EVENTS.setEthics(events[n], 0)
                        EXPEVENTS.addEvent(branch, period+1, events[n])
                        #set outcome to 0
                        EVENTS.setOutcome(events[n], 0)
                        #set pushedback to true
                        EVENTS.setPushedBack(events[n])
                        # set median to 0
                        EVENTS.setMedian(events[n], 0)
                        #set event expiration date to be after the current reporting period ends
                        EVENTS.setExpiration(events[n], block.number)
                        MARKETS.setTradingPeriod(market, period+1)
                        return(-4)
                    if((fxpOutcome==2**63 && pushedBack) || !ethical):
                        # give event bond money to reporters
                        CASH.subtractCash(events[n], 42*2**64)
                        CASH.addCash(branch, 42*2**64)
                        # not ethical is same as .5 outcome
                        fxpOutcome = 2**63
                        EVENTS.setOutcome(events[n], fxpOutcome)
                        EVENTS.setMedian(events[n], fxpOutcome)
                    else:
                        # return bond
                        CASH.subtractCash(events[n], 42*2**64)
                        CASH.addCash(INFO.getCreator(events[n]), 42*2**64)
                        if(MARKETS.getPushedForward(market)):
                            CASH.addCash(MARKETS.getBondsMan(market), MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                            CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                            # delete old event from future events exp
                            EXPEVENTS.removeEvent(branch, EVENTS.getOriginalExpiration(events[n])/periodLength)
                else:
                    return(-5)

            # categorical, but we can make it behave as a scalar for all intents and purposes here
            elif(EVENTS.getNumOutcomes(events[n])>2):
                # if outcome/median aren't set
                if(EVENTS.getMedian(events[n])==0 && period > votingPeriodEvent):
                    median = MEDIAN.calculateMedian(events[n])
                    EVENTS.setMedian(events[n], median)
                    scaled_min[j] = 2^64
                    scaled_max[j] = 2^64*EVENTS.getNumOutcomes(event)
                    fxpOutcome = median * (scaled_max - scaled_min) + scaled_min
                    EVENTS.setOutcome(events[n], fxpOutcome)
                    #•In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
                    # and market remains with old expiration date
                    if(fxpOutcome == 2**63 && MARKETS.getPushedForward(market)):
                        #set event expiration to be the old date prior to this bond process
                        EVENTS.setExpiration(events[n], EVENTS.getOriginalExpiration(events[n]))
                        MARKETS.setTradingPeriod(market, MARKETS.getOriginalTradingPeriod(market))
                        CASH.addCash(branch, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                        CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                        MARKETS.setPushedForward(market, 0)
                        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, events[n], 0)
                        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, events[n], 0)
                        #set outcome to 0
                        EVENTS.setOutcome(events[n], 0)
                        EVENTS.setMedian(events[n], 0)
                        EVENTS.setEthics(events[n], 0)
                        #set uncaughtoutcome to 0
                        EVENTS.setUncaughtOutcome(events[n], 0)
                        # need to store uncaught outcome for rejectedperiod separately as well as which period it was "rejected" in
                        EVENTS.setRejected(events[n], EVENTS.getExpiration(events[n])/periodLength, fxpOutcome)
                        return(-6)

                    # if .5 due to catch param push back once (as .5 outcome), if same on next consensus no more push backs, that's the outcome
                    if(fxpOutcome==2**63 && !pushedBack && residual < periodLength/2):
                        #push back event
                        MAKEREPORTS.setNumReportsExpectedEvent(branch, votingPeriodEvent, events[n], 0)
                        MAKEREPORTS.setNumReportsEvent(branch, votingPeriodEvent, events[n], 0)
                        EXPEVENTS.addEvent(branch, period+1, events[n])
                        #set outcome to 0
                        EVENTS.setOutcome(events[n], 0)
                        #set pushedback to true
                        EVENTS.setPushedBack(events[n])
                        # set median to 0
                        EVENTS.setMedian(events[n], 0)
                        EVENTS.setEthics(events[n], 0)
                        EVENTS.setExpiration(events[n], block.number)
                        MARKETS.setTradingPeriod(market, period+1)
                        return(-4)
                    if((fxpOutcome==2**63 && pushedBack) || !ethical):
                        # give event bond money to reporters
                        CASH.subtractCash(events[n], 42*2**64)
                        CASH.addCash(branch, 42*2**64)
                        # not ethical is same as .5 outcome
                        fxpOutcome = 2**63
                        EVENTS.setOutcome(events[n], fxpOutcome)
                        EVENTS.setMedian(events[n], fxpOutcome)
                    else:
                        # return bond
                        CASH.subtractCash(events[n], 42*2**64)
                        CASH.addCash(INFO.getCreator(events[n]), 42*2**64)
                        if(MARKETS.getPushedForward(market)):
                            CASH.addCash(MARKETS.getBondsMan(market), MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                            CASH.subtractCash(market, MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*2^64))
                            # delete old event from future events exp
                            EXPEVENTS.removeEvent(branch, EVENTS.getOriginalExpiration(events[n])/periodLength)
                else:
                    return(-5)
            # events not expired yet
            if(fxpOutcome==0):
                return(-2)

            outcome = fxpOutcome/2^64
            # makes sure it's not a scalar
            if(fxpOutcome==3*2^63 && numberEvents==1 && !((EVENTS.getMaxValue(events[n])!=2 || EVENTS.getMinValue(events[n])!=1) && EVENTS.getNumOutcomes(events[n])==2)):
                # return all the $$$ - (@ 50 cents a share)
                i = 0
                currentParticipant = MARKETS.getCurrentParticipantNumber(market)
                while i < currentParticipant:
                    sharesOwnedOne = MARKETS.getParticipantSharesPurchased(market, i, 1)
                    sharesOwnedTwo = MARKETS.getParticipantSharesPurchased(market, i, 2)
                    participant = MARKETS.getParticipantID(market, i)
                    CASH.subtractCash(market, sharesOwnedOne*2^63 / 2^64)
                    CASH.addCash(participant, sharesOwnedOne*2^63 / 2^64)
                    CASH.subtractCash(market, sharesOwnedTwo*2^63 / 2^64)
                    CASH.addCash(participant, sharesOwnedTwo*2^63 / 2^64)
                    i += 1

                # give back initial liquidity and ls-lmsr alpha fees (or as much of it/profits are left)
                # refund left over initial liquidity in market - half to market creator, other half to voters
                # rest of money available in market + the additional trading fees divy up amongst reporters and market creator
                initialLiquidity = INFO.getCreationFee(market)
                # split up excess profits & liquidity
                marketCash = CASH.balance(market)
                CASH.addCash(branch, marketCash/2)
                CASH.addCash(INFO.getCreator(market), marketCash / 2)
                CASH.subtractCash(market, marketCash)

                winningOutcomes[0] = 1
                winningOutcomes[1] = 2
                MARKETS.setWinningOutcomes(market, winningOutcomes)
                return(-3)
            elif(fxpOutcome==0):
                return(-2)
            if(n==0):
                #scalar or .5
                if(((EVENTS.getMaxValue(events[n])!=2 || EVENTS.getMinValue(events[n])!=1) && EVENTS.getNumOutcomes(events[n])==2) || fxpOutcome==3*2^63):
                    winningOutcomes[0] = 1
                    winningOutcomes[1] = 2
                # anything besides scalar or .5
                else:
                    winningOutcomes[0] += outcome
            elif(n==1):
                if(((EVENTS.getMaxValue(events[n])!=2 || EVENTS.getMinValue(events[n])!=1) && EVENTS.getNumOutcomes(events[n])==2) || fxpOutcome==3*2^63):
                    # scalar, scalar
                    if(winningOutcomes[1]):
                        winningOutcomes[2] = 3
                        winningOutcomes[3] = 4
                    # nonscalar, scalar
                    else:
                      # winningOutcomes[0] = winningOutcomes[0]
                        winningOutcomes[1] = winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-1])
                # scalar, nonscalar
                elif(winningOutcomes[1]):
                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)
                    winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)
                # nonscalar, nonscalar
                else:
                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)
            elif(n==2):
                if(((EVENTS.getMaxValue(events[n])!=2 || EVENTS.getMinValue(events[n])!=1) && EVENTS.getNumOutcomes(events[n])==2) || fxpOutcome==3*2^63):
                    #scalar, scalar, scalar
                    if(winningOutcomes[3]):
                        winningOutcomes[4] = 5
                        winningOutcomes[5] = 6
                        winningOutcomes[6] = 7
                        winningOutcomes[7] = 8
                    #scalar, nonscalar, scalar
                    #nonscalar, scalar, scalar
                    elif(winningOutcomes[1]):
                      # winningOutcomes[0] = winningOutcomes[0]
                      # winningOutcomes[1] = winningOutcomes[1]
                        winningOutcomes[2] += winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])
                        winningOutcomes[3] += winningOutcomes[1] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])
                    #nonscalar, nonscalar, scalar
                    elif(winningOutcomes[1]==0):
                      # winningOutcomes[0] = winningOutcomes[0]
                        winningOutcomes[1] += winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])
                else:
                    #scalar, scalar, nonscalar
                    if(winningOutcomes[3]):
                        winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)
                        winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)
                        winningOutcomes[2] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)
                        winningOutcomes[3] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)
                    #scalar, nonscalar, nonscalar
                    #nonscalar, scalar, nonscalar
                    elif(winningOutcomes[1]):
                        winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)
                        winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)
                    #nonscalar, nonscalar, nonscalar
                    else:
                        winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)
            n+=1

        pricePerShare1 = 0
        pricePerShare2 = 0
        pricePerShare3 = 0
        pricePerShare4 = 0
        pricePerShare5 = 0
        pricePerShare6 = 0
        pricePerShare7 = 0
        pricePerShare8 = 0

        if(winningOutcomes[1]==0):
            CLOSEONE.oneOutcome(market, winningOutcomes[0])

        elif(winningOutcomes[7]):
            CLOSEEIGHT.eightOutcomes(market, winningOutcomes, events)

        elif(winningOutcomes[3]):
            CLOSEFOUR.fourOutcomes(market, winningOutcomes, events)

        elif(winningOutcomes[1]):
            CLOSETWO.twoOutcomes(market, winningOutcomes, events)

        # give back initial liquidity and ls-lmsr alpha fees (or as much of it/profits are left)
        # refund left over initial liquidity in market - half to market creator, other half to voters
        # *unless* it's a scaled decision, refund all initial liquidity left over to market creator
        # rest of money available in market + the additional trading fees divy up amongst reporters and market creator
        initialLiquidity = INFO.getCreationFee(market)
        creator = INFO.getCreator(market)
        marketCash = CASH.balance(market)
        # some scalar involved
        if(winningOutcomes[1]):
            if(CASH.balance(market) > initialLiquidity):
                # pay back liquidity, split up excess profits
                CASH.addCash(creator, initialLiquidity)
                CASH.subtractCash(market, initialLiquidity)
                marketCash -= initialLiquidity
                CASH.addCash(branch, marketCash/2)
                CASH.addCash(creator, marketCash/2)
                CASH.subtractCash(market, marketCash)
            # send whatever's left of the initial liquidity to the creator
            else:
                CASH.addCash(creator, marketCash)
                CASH.subtractCash(market, marketCash)

        # no scalars
        else:
            # split up excess profits & liquidity
            CASH.addCash(branch, marketCash/2)
            CASH.addCash(creator, marketCash/2)
            CASH.subtractCash(market, marketCash)

        MARKETS.setWinningOutcomes(market, winningOutcomes)
        return(1)
    else:
        return(0)
