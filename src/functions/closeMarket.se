# This software (Augur) allows buying and selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
# 
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
# 
#    This program is distributed in the hope that it will be useful, #    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
# 
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

### This allows users to close markets

import branches as BRANCHES
import markets as MARKETS
import events as EVENTS
import backstops as BACKSTOPS
import eventResolution as RESOLVE
import info as INFO
import mutex as MUTEX
extern subcurrency: [allowance:[uint256,uint256]:uint256, approve:[uint256,uint256]:uint256, balance:[]:uint256, balanceOf:[uint256]:uint256, transfer:[uint256,uint256]:uint256, transferFrom:[uint256,uint256,uint256]:uint256]
inset('../data_api/refund.se')
inset('eventHelpers.se')
inset('logReturn.se')

event closeMarketLogReturn(returnValue)

# Loop through events in the market, get their outcomes and use those to determine the winning outcomes and resolve a market!
# @return 0 if fail/trading not over yet/event not expired or closed already, if success 1
# Error messages otherwise
    # 0: hasn't been reported on yet or already resolved
    # -1: Market already closed
    # -2: 0 outcome / not reported on yet
    # -3: not final round 2 event
    # -4: Event forked and not final yet
    # -5: bonded pushed forward market not ready to be resolved
def closeMarket(market, sender):
    refund()
    if(MUTEX.getMutex() && !mutexWhitelisted()):
        throw()
    if(!mutexWhitelisted()):
        MUTEX.setMutex()
    event = MARKETS.getMarketEvent(market, 0)
    branch = EVENTS.getEventBranch(event)
    expirationPeriod = EVENTS.getExpiration(event)
    period = BRANCHES.getVotePeriod(branch)
    fxpOutcome = EVENTS.getOutcome(event)
    resolution = 1
    forkPeriod = BRANCHES.getForkPeriod(branch)
    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)
    checkCloseMarketPreconditions()
    
    resolveEventsInMarket()    
    winningOutcomes = array(8)
    winningOutcomes = RESOLVE.determineWinningOutcomes(event, outitems = 8)
    MARKETS.setWinningOutcomes(market, winningOutcomes)
    # refunds closing cost
    MARKETS.refundClosing(market, sender)
    if(!mutexWhitelisted()):
        MUTEX.unsetMutex()
    logReturn(closeMarketLogReturn, 1)

macro checkCloseMarketPreconditions():
    if((period <= expirationPeriod)):
        if(!mutexWhitelisted()):
            MUTEX.unsetMutex()
        logReturn(closeMarketLogReturn, 0)
    if(MARKETS.getOneWinningOutcome(market, 0)):
        if(!mutexWhitelisted()):
            MUTEX.unsetMutex()
        logReturn(closeMarketLogReturn, -1)
    if(!EVENTS.getUncaughtOutcome(event) && !EVENTS.getFirstPreliminaryOutcome(event)):
        if(!mutexWhitelisted()):
            MUTEX.unsetMutex()
        logReturn(closeMarketLogReturn, -2)
    # as long as resolved and not challenged we can then resolve, i.e. if not challenged and > 6 days then can take prelim outcome and make it final outcome
    if(BACKSTOPS.getRoundTwo(event) and !BACKSTOPS.getFinal(event)):
        if(!mutexWhitelisted()):
            MUTEX.unsetMutex()
        logReturn(closeMarketLogReturn, -3)
    # if an event is one from before a fork and hasn't been moved yet don't resolve it
    if((EVENTS.getForked(event) and !EVENTS.getForkedDone(event)) or eventCreatedPriorToFork(eventID)):
        if(!mutexWhitelisted()):
            MUTEX.unsetMutex()
        logReturn(closeMarketLogReturn, -4)

macro resolveEventsInMarket():
    resolution = 0
    # look at event in the market, get its outcomes, resolve it and use those to determine the winning outcomes for a given market!
    if(binary(event) and !fxpOutcome):
        resolution = RESOLVE.resolveBinary(event, market, branch, votingPeriodEvent)
    elif(scalar(event) and !EVENTS.getMode(event)):
        resolution = RESOLVE.resolveCategoricalOrScalar(EVENTS.getMinValue(event), EVENTS.getMaxValue(event), event, market, branch, votingPeriodEvent)
    elif(categorical(event) and !EVENTS.getMode(event)):
        resolution = RESOLVE.resolveCategoricalOrScalar(ONE, ONE * EVENTS.getNumOutcomes(event), event, market, branch, votingPeriodEvent)
    else:
        throw()
    if(resolution == -6):
        if(!mutexWhitelisted()):
            MUTEX.unsetMutex()
        logReturn(closeMarketLogReturn, -5)

def closeChallengeBond(event):
    extraBond = EVENTS.getExtraBond(event)
    branch = EVENTS.getEventBranch(event)
    if(!EVENTS.getChallenged(event)):
        throw()
    periodLength = BRANCHES.getPeriodLength(branch)
    votePeriod = EVENTS.getExpiration(event) / periodLength
    if(BRANCHES.getVotePeriod(branch) <= votePeriod):
        throw()
    forkPeriod = BRANCHES.getForkPeriod(branch)
    forking = forkPeriod == votePeriod or votePeriod == (forkPeriod + 1)
    if(BACKSTOPS.getRoundTwo(event) or forking):
        returnBond() from event wallet
    if(!EVENTS.getOutcome(event)):
        throw()
    if(EVENTS.getFirstPreliminaryOutcome(event) == EVENTS.getOutcome(event)):
        loseBond

    # outcome is different
    else:
        returnBond + pay half of validity bond to challenger [but it's already been paid back to event creator by now, todo fixes and also check if bond already returned]
    return(1)
