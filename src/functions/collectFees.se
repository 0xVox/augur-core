import cash as CASH
import branches as BRANCHES
import expiringEvents as EXPEVENTS
import consensusData as CONSENSUS
import reporting as REPORTING
extern subcurrency: [allowance:[int256,int256]:int256, approve:[int256,int256]:int256, balance:[]:int256, balanceOf:[int256]:int256, transfer:[int256,int256]:int256, transferFrom:[int256,int256,int256]:int256]
inset('../data_api/refund.se')

macro prepareInfoForConsensus():
    CONSENSUS.setFeesCollected(branch, sender, lastPeriod)
    # return not reported enough bond if not enough penalized is 0 or BRANCHES.getForkPeriod(branch)+1 == lastPeriod during collect fees
    if(!CONSENSUS.getNotEnoughPenalized(branch, sender, lastPeriod) or BRANCHES.getForkPeriod(branch) + 1 == lastPeriod):
        CONSENSUS.doRefund(sender, sender)
    # need to pay not reporting bond
    if(msg.value <= 500000 * tx.gasprice):
        throw()
    balance = REPORTING.getRepBalance(branch, sender)
    dormantRep = REPORTING.balanceOf(branch, sender)
    # Record rep for next report period before any redistributions
    EXPEVENTS.setBeforeRep(branch, votePeriod, balance, sender)
    EXPEVENTS.setAfterRep(branch, votePeriod, balance, sender)
    EXPEVENTS.setPeriodDormantRep(branch, votePeriod, dormantRep, sender)
    CONSENSUS.setRefund(sender, msg.value)
    if(!send(CONSENSUS, msg.value)):
        throw()

# Allows a user to collect both redistributed rep and trading fees earned at the end of a period
# Errors:
    #  0: fees already collected
    # -1: rep redistribution/rewards/penalizations in consensus not done yet
    # -2: needs to be second half of reporting period to claim rep [1st half is when redistribution is done]
        # after this window, any unclaimed rep is pushed to the next period's redistrib. pool via the first make report submission
# 2 means no errors but didnt report last period
# distribute any eth here too
def collectFees(branch, sender):
    refund()
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual <= periodLength / 2):
        return(-2)
    if(!CONSENSUS.getRepRedistributionDone(branch, sender)):
        # need to call penalize for all events and penalize for too lazy to report or catchup if necessary
        return(-1)
    votePeriod = BRANCHES.getVotePeriod(branch)
    lastPeriod = votePeriod - 1
    newRep = EXPEVENTS.getAfterRep(branch, lastPeriod, sender)
    feesCollected = CONSENSUS.getFeesCollected(branch, sender, lastPeriod)
    # need 1 rep to claim fees
    if(!feesCollected and newRep > ONE):
        denominator = CONSENSUS.getDenominator(branch, lastPeriod)
        # sets the amount of rep available for redistribution in the next period
        if(!CONSENSUS.getFeeFirst(branch, lastPeriod)):
            CONSENSUS.setFeeFirst(branch, lastPeriod, 1)
            CONSENSUS.setPeriodBalance(branch, lastPeriod, REPORTING.getRepBalance(branch, branch))
        gainedRep = newRep * CONSENSUS.getPeriodBalance(branch, lastPeriod) / denominator
        # if a user lost rep their newRep should be == EXPEVENTS.getAfterRep(branch, period, sender) + gainedRep
        # if gained rep overall their newRep should be == EXPEVENTS.getBeforeRep(branch, period, sender) + gainedRep
        # give a reporter their portion of redistributed rep
        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, branch), gainedRep)
        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, sender), gainedRep)
        cash = BRANCHES.getInitialBalance(branch, lastPeriod) * newRep / denominator
        # give a reporter their portion of the trading fees
        CASH.subtractCash(branch, cash)
        CASH.addCash(sender, cash)
        prepareInfoForConsensus()
        return(1)
    elif(!feesCollected):
        prepareInfoForConsensus()
        return(2)
    else:
        return(0)
