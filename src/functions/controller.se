### Controller - A contract for updating Augur via a REP weighted vote and storing a whitelist of contract addresses

inset('../macros/refund.sem')

# TODO:
    # updating controller
    # emergency stops?
    # Some of the contracts have internal state that shouldn't be modified by code or users, besides the official Augur contracts. The method joey and I designed uses three primitives to alter the contracts' whitelists; replace, add and delete. A rep-weighted voting system is used to choose among proposed changes, proposals that recieve a majority of rep during the current voting period are executed at the start of the next voting period. If a rep holder has voted, they must not be allowed to send their rep to other accounts, so methods are provided for checking whether of not a voter has voted. Other method are provided to get various metadata including details about how an address voted at a certain period.
    # 	Min of 100 REP to vote/propose changes
    # 	prospoals and votes happen in 60 day cycle, first 30 days for proposals and next 30 days for votes.
    # 	Dev mode: a developer address which can do an update without a vote - done
    #	Vote to switch to hybrid mode: Dev address can propose changes and voters may veto within time limit
    # 	Vote to switch to full decentralized mode: every proposal must be made by address with min rep, must have a majority of rep voted for it to pass
    # 	Proposal structure: an array of arguments which change can replace a contract with a new one, delete a contract, or add a contract
    #   Proposal hash stored onchain along with short description.
    # 	vote to suicide and transfer control of whitelist and reg to new updater

data owner

# Registry keys have a 32 char limit and the contract address is the value, index is the contract name
data registry[](value)

# takes contract address as index, value is whether it's in the whitelist or not
data whitelist[]

def init():
    self.owner = msg.sender

def transferOwnership(key, newOwner):
    if(self.owner == msg.sender):
        self.owner = newOwner
    return(1)

def setValue(key, newValue, inWhitelist, removeOldFromWhitelist):
    if(self.owner == msg.sender):
        self.whitelist[newValue] = inWhitelist
        if(removeOldFromWhitelist):
            self.whitelist[self.registry[key].value] = 0
        self.registry[key].value = newValue
        return(1)
    else:
        return(0)

def lookup(key):
    return(self.registry[key].value)

def getOwner(key):
    return(self.owner)

def addToWhitelist(address):
    if(self.owner == msg.sender):
        self.whitelist[address] = 1
        return(1)
    else:
        return(0)

def removeFromWhitelist(address):
    if(self.owner == msg.sender):
        self.whitelist[address] = 0
        return(1)
    else:
        return(0)
        
def replaceOnWhitelist(original, new):
    if(self.removeFromWhitelist(original) && self.addToWhitelist(new)):
        return(1)
    else:
        throw()

def checkWhitelist(address):
    return(self.whitelist[address])
