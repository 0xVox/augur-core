### Deals with forking over events

import info as INFO
import branches as BRANCHES
import reporting as REPORTING
import events as EVENTS
import markets as MARKETS
import backstops as BACKSTOPS
import sendReputation as SENDREP
import roundTwo as ROUNDTWO
import expiringEvents as EXPEVENTS
import createBranch as CREATEBRANCH
import consensusData as CONSENSUSDATA
import mutex as MUTEX
extern subcurrency: [allowance:[int256,int256]:int256, approve:[int256,int256]:int256, balance:[]:int256, balanceOf:[int256]:int256, transfer:[int256,int256]:int256, transferFrom:[int256,int256,int256]:int256]
extern forkResolveContract: [resolveFork:[]:int256]
inset('../data_api/refund.se')
inset('eventHelpers.se')
inset('../data_api/float.se')

macro FORK_TEXT: text("fork")
macro POINT_ZERO_ONE: 10000000000000000
macro COST_FOR_EVENT_REPORT_CALCULATION: 500000

# UI has to handle function calls for these

# Notes:
    # Anyone can pay some amount significantly greater than the backstop 1 bond amount to force a branching event, splitting rep into two classes.
    # In one class the reported outcome for whatever event was the cause of dispute is said to be right, and rep is redistributed accordingly.
    # In the other class/branch, the event is readjudicated and remove the outcome on the pre fork branch and rep is redistributed as normal, except people who said the original outcome in the original fork lose rep.
    # Note: Whichever outcome was truly the correct one would determine which branch had rep that actually held value.  This would be akin to a Bitcoin hard fork scenario.  The winning fork, of course, would be the one with the most voluminous markets, which would be determined by the fork that represented reality, which would have a higher market cap.  Markets go to the most popular fork by default after 2 months.

# Events created after fork are allowed to go through the process as normal


# Parent
    # Vote period when forked [events can also be created post fork in the last 48 hours that expire in this period and are thus reported on the next one]
        # Events created prior to fork
            # Don't penalize on or resolve events expiring in this period, these events should be moved to the period after the fork has resolved 
            # Event forked over on parent should be voted on

    # First vote period after fork [events can also be created that expire in this period, waiting for fork to resolve here]
        # Events created prior to fork
            # Don't penalize, report on, or resolve for these events in this period, these events should be moved to the period after the fork has resolved 

    # Vote period after fork resolved
        # All markets have early exp disabled until this point
        # Events created prior to fork
            # Don't penalize, report on, or resolve for these events in this period, these events should be moved to the period after the fork has resolved 
            # Each event which would've expired in the past 2 periods and this vote period is moved to the winning branch and pushed up into the current period and voted on in the period after this
            # Each event resolving further in the future is pushed into the respective period on whichever fork wins

# Fork
    # Vote Period where forked
        # Don't allow events to be created that expire in the last 48 hr of this period [and thus being reported on next period] if a fork was made [this'll allow people to have time to claim rep on the fork, not result in weird issues with calculating events to report on changing due to active rep changing as people claim rep on the new fork, and only make people have to worry about reporting on the forked event next period]
    # First vote period after fork [events can also be created that expire in this period and thus are reported on in the next one, we're waiting for fork to resolve here]
        # Events created prior to fork [only 1 since this branch is a new one]
            # Only event that there is here is the forked event and we report on that again here
    # Vote period after fork resolved
        # Things proceed as normal
def moveEvent(event):
    refund()
    if(MUTEX.getMutex()):
        throw()
    MUTEX.setMutex()

    forkPeriod = BRANCHES.getForkPeriod(EVENTS.getEventBranch(event))
    branch = EVENTS.getEventBranch(event)
    eventForkedOver = BRANCHES.getEventForkedOver(branch)
    expPeriod = EVENTS.getExpiration(event) / BRANCHES.getPeriodLength(branch)
    eventIndex = EXPEVENTS.getEventIndex(expPeriod, event)
    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)
    currentVotePeriod = BRANCHES.getVotePeriod(branch)
    checkMoveEventPreconditions()
    if(event == eventForkedOver):
        MUTEX.unsetMutex()
        return(1)
    # leave event here in same branch
    elif(winner == EVENTS.getEventBranch(event)):
        keepEventInOriginalBranch()
    # event's branch is changed to winning branch
    else:
        moveEventToWinningBranch()
    BACKSTOPS.setMoved(event)
    MUTEX.unsetMutex()
    return(1)

# parent branch is branch here
# If there's only 1 event and that's the one we forked over [rare edge case] we can call resolve fork manually if it hasn't been done yet within the time parameters which allows a fork to be resolved [2 periods after the start of the fork]
def resolveFork(branch):
    if(MUTEX.getMutex() && !mutexWhitelisted()):
        throw()
    if(!mutexWhitelisted()):
        MUTEX.setMutex()
    forkPeriod = BRANCHES.getForkPeriod(branch)
    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)
    if(BACKSTOPS.getResolved(branch, forkPeriod)):
        throw()
    if(currentPeriod < (forkPeriod + 2)):
        if(!mutexWhitelisted()):
            MUTEX.unsetMutex()
        return(0)

    forkPeriod = BRANCHES.getForkPeriod(EVENTS.getEventBranch(event))
    origCap = self.exchangeRate(branch)
    fork = REPORTING.getFork(branch)
    forkCap = self.exchangeRate(fork)
    winner = 0
    if(origCap >= forkCap):
        winner = branch
    else:
        winner = fork
    BACKSTOPS.setResolved(branch, forkPeriod, winner)
    if(!mutexWhitelisted()):
        MUTEX.unsetMutex()
    return(winner)

# Resolve fork method that gets exchange rate
# add contract for choosing this to create market
def exchangeRate(branch):
    # get rep exchange rate from etherex for (branch)
    # return(exchangeRate)
    # for testing we'll just rng the exchange rate :)
    return(sha3(branch))

# Forks a contested event
# In the last 48 hours during period where a round 2 was pushed back to, can be made to fork instead of just round 2, so round 2 bond poster gets bond back and a fork commences
# bond for a fork is 1% of rep
# Errors:
    #  0: not in last 48 hr of period
    # -1: ineligible for forking over, already resolved, forked, or hasn't seen 1st backstop yet
    # -3: no fork allowed for 1 period after a forking event
    # -4: event was pushed forward, not allowed yet
    # -5: invalid branch
def fork(event, branch, forkedOverEthicality):
    if(MUTEX.getMutex()):
        throw()
    MUTEX.setMutex()

    forkPeriod = BRANCHES.getForkPeriod(branch)
    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)
    currentVotePeriod = BRANCHES.getVotePeriod(branch)
    checkForkPreconditions()

    if(!send(CONSENSUSDATA, msg.value)):
        throw()
    bond = safeFxpDiv(POINT_ZERO_ONE, REPORTING.getTotalRep(branch))
    BACKSTOPS.setBondAmount(event, bond)
    # lose fork bond in branch 1
    # results same as roundtwobond, let it resolve as that on original network
    if(!SENDREP.sendRepFrom(branch, msg.sender, event, bond)):
        throw()
    # on branch 2 fork bond isn't lost
    # on fork bond isn't lost, gets paid up to 2x from "liars"
    # make the fork
    makeFork()
    # return round 2 bond on orig. branch
    returnRoundTwoBond()
    MUTEX.unsetMutex()
    return(1)

# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
# branch is orig. branch
# Returns 1
# Errors:
    # 0 fork not done yet
    # -1 event not fork event
    # -2 wrong branch
def resolveForkedEvent(branch, event):
    refund()
    if(MUTEX.getMutex()):
        throw()
    MUTEX.setMutex()
    # checks for orig. branch
    if(EVENTS.getEventBranch(event) != branch or BRANCHES.getEventForkedOver(branch) != event or !branch or !event):
        MUTEX.unsetMutex()
        return(0)
    if(!EVENTS.getForked(event)):
        MUTEX.unsetMutex()
        return(-1)
    if(self.resolveForkEvent(branch, event)):
        EVENTS.setForkDone(event)
        EVENTS.setCreationTime(event)
        CONSENSUSDATA.doRefund(msg.sender, event)
        MUTEX.unsetMutex()
        return(1)
    # fork not done yet
    else:
        MUTEX.unsetMutex()
        return(0)

# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
    # helper function for resolveForkedEvent
# needs whitelist
macro resolveForkEvent(branch, event):
    refund()
    # whitelist
    bond = EVENTS.getBond(event)
    winner = BACKSTOPS.getResolved(branch, BRANCHES.getForkPeriod(branch))
    if(!winner):
        return(-5)
    nonDefaultForkResolution = EVENTS.getForkResolveAddress(event)
    if(nonDefaultForkResolution):
        resolveCustomForkResolution()
    # binary
    if(binary(event)):
        binaryForkResolve()
    # scalar or categorical
    elif(scalar(event) or categorical(event)):
        scalarOrCategoricalForkResolve()
    # (should never be reached)
    else:
        return(0)

macro binaryForkResolve():
    fxpOutcome = 0
    ethical = 0
    # original parent won
    if(winner == branch):
        fxpOutcome = catch(EVENTS.getUncaughtOutcome(event))
        ethical = ethicCatch(EVENTS.getEthics(event))
    # fork won
    else:
        fxpOutcome = catch(EVENTS.getForkOutcome(event))
        ethical = ethicCatch(EVENTS.getForkEthicality(event))
    EVENTS.setOutcome(event, fxpOutcome)
    EVENTS.setEthics(event, ethical)
    if(fxpOutcome == 3 * ONE_HALF or !ethical):
        # give event bond money to reporters
        branchWallet = BRANCHES.getWallet(branch, INFO.getCurrency(event))
        if(!INFO.getWallet(event).transfer(branchWallet, bond)):
            throw()

        # not ethical is same as .5 outcome
        fxpOutcome = 3 * ONE_HALF
        EVENTS.setOutcome(event, fxpOutcome)
    else:
        # return 
        if(!INFO.getWallet(event).transfer(INFO.getCreator(event), bond)):
            throw()
    EVENTS.setBranch(event, winner)
    BACKSTOPS.setMoved(event)
    return(1)

macro scalarOrCategoricalForkResolve():
    mode = 0
    ethical = 0
    # original parent won
    if(winner == branch):
        mode = EVENTS.getUncaughtOutcome(event)
        ethical = ethicCatch(EVENTS.getEthics(event))
    # fork won
    else:
        mode = EVENTS.getForkOutcome(event)
        ethical = ethicCatch(EVENTS.getForkEthicality(event))
    EVENTS.setMode(event, mode)
    EVENTS.setEthics(event, ethical)
    scaledMax = EVENTS.getMaxValue(event)
    scaledMin = EVENTS.getMinValue(event)
    if(categorical(event)):
        scaledMin = ONE
        scaledMax = ONE * EVENTS.getNumOutcomes(event)
    fxpOutcome = safeFxpMul(mode, (scaledMax - scaledMin)) + scaledMin
    if(categorical(event)):
        fxpOutcome = round(fxpOutcome)
    ethicOutcome = safeFxpMul(ONE_HALF, (scaledMax - scaledMin)) + scaledMin
    # outcome of 1 is 1/10**18 or basically 0, but allows us to still check if outcome is 0 or not to see if an outcome has been set
    if(ethicOutcome == 0):
        ethicOutcome = 1
    if(fxpOutcome == 0):
        fxpOutcome = 1
    EVENTS.setOutcome(event, fxpOutcome)
    if(mode == ONE_HALF or !ethical):
        # give event bond money to reporters
        branchWallet = BRANCHES.getWallet(branch, INFO.getCurrency(event))
        if(!INFO.getWallet(event).transfer(branchWallet, bond)):
            throw()
        # not ethical is same as .5 outcome
        EVENTS.setOutcome(event, ethicOutcome)
    else:
        # return bond
        if(!INFO.getWallet(event).transfer(INFO.getCreator(event), bond)):
            throw()
    EVENTS.setBranch(event, winner)
    BACKSTOPS.setMoved(event)
    return(1)

macro checkForkPreconditions():
    if(!EVENTS.getRoundTwo(event) or BACKSTOPS.getFinal(event) or EVENTS.getForked(event)):
        MUTEX.unsetMutex()
        return(-1)
    if(forkPeriod == currentVotePeriod or currentVotePeriod == (forkPeriod + 1) or currentVotePeriod == (forkPeriod + 2)):
        MUTEX.unsetMutex()
        return(-3)
    if(EVENTS.getOriginalExpiration(event) != EVENTS.getExpiration(event)):
        MUTEX.unsetMutex()
        return(-4)
    if(EVENTS.getEventBranch(event) != branch or !branch or !event):
        MUTEX.unsetMutex()
        return(-5)
    if(msg.value < 350000 * tx.gasprice):
        MUTEX.unsetMutex()
        return(0)
    CONSENSUSDATA.setRefund(event, msg.value)
    last48HoursOfPeriod = (block.timestamp / BRANCHES.getPeriodLength(branch) != ((block.timestamp + 2 * TWENTY_FOUR_HR) / BRANCHES.getPeriodLength(branch)))
    reportedOnInRoundTwo = EVENTS.getUncaughtOutcome(event)
    if(!last48HoursOfPeriod or !reportedOnInRoundTwo):
        MUTEX.unsetMutex()
        return(0)

macro makeFork():
    newBranch = CREATEBRANCH.createSubbranch(FORK_TEXT, BRANCHES.getPeriodLength(branch), branch, BRANCHES.getMinTradingFee(branch), BRANCHES.getOracleOnly(branch), 0)
    BRANCHES.setMostRecentChild(branch, newBranch)
    REPORTING.setFork(newBranch)
    period = BRANCHES.getVotePeriod(newBranch)
    EXPEVENTS.setEventRequired(newBranch, period + 1, event)
    forkPeriod = BRANCHES.getForkPeriod(branch)
    afterFork = 0
    if(period == (forkPeriod + 1) or period == (forkPeriod + 2)):
	    afterFork = 1
    currency = INFO.getCurrency(event)
    wallet = INFO.getWallet(event)
    # add to next expiration period
    EXPEVENTS.addEvent(newBranch, period + 1, event, COST_FOR_EVENT_REPORT_CALCULATION * tx.gasprice, currency, wallet, afterFork)
    EVENTS.setExpiration(event, block.timestamp)
    BACKSTOPS.setOriginalBranch(event, branch)
    BACKSTOPS.setForkBondPoster(event, msg.sender)
    EVENTS.setForked(event)
    BACKSTOPS.setFinal(event)
    BRANCHES.setForkPeriod(branch)
    BRANCHES.setEventForkedOver(branch, event)
    if(forkedOverEthicality):
        BACKSTOPS.setForkedOverEthicality(event)

macro returnRoundTwoBond():
    market = EVENTS.getMarket(event, 0)
    averageAdjudicationCost = BRANCHES.getInitialBalance(branch, period - 1) / EXPEVENTS.getNumberEvents(branch, period - 1)
    bond = safeAdd(averageAdjudicationCost, safeFxpMul(MARKETS.getSharesValue(market), (POINT_ZERO_ONE + MARKETS.getTradingFee(market) / 2)))
    minBond = 200 * ONE
    bond = min(bond, minBond)
    REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, event), bond)
    REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getBondPoster(event)), bond)
    BACKSTOPS.setBondReturned(event)

macro checkMoveEventPreconditions():
    if(!branch or !event or currentVotePeriod < (forkPeriod + 2) or EVENTS.getOutcome(event) or BACKSTOPS.getMoved(event) or !eventCreatedPriorToFork(event)):
        MUTEX.unsetMutex()
        return(0)
    winner = BACKSTOPS.getResolved(branch, forkPeriod)
    if(!winner):
        winner = self.resolveFork(branch)
    nonDefaultForkResolution = EVENTS.getForkResolveAddress(event)
    if(nonDefaultForkResolution):
        resolveCustomForkResolution()

macro keepEventInOriginalBranch():
    # set outcomes to 0
    EVENTS.setOutcome(event, 0)
    EVENTS.setMode(event, 0)
    EVENTS.setEthics(event, 0)
    EVENTS.setUncaughtOutcome(event, 0)
    EVENTS.setCreationTime(event)

    # return bond if it's a round 2 event and make it not one anymore
    if(BACKSTOPS.getRoundTwo(event) && !ROUNDTWO.roundTwoResolve(branch, event, eventIndex, msg.sender)):
        throw()
    # if should've resolved in past periods
    if(expPeriod <= currentVotePeriod):
        # should only be put into vote period if it's not in early resolve / first wave portion anymore
        if(EVENTS.getChallenged(event)):
            # push it into next [this] period
            forkPeriod = BRANCHES.getForkPeriod(branch)
            afterFork = 0
            if(currentPeriod == (forkPeriod + 1) or currentPeriod == (forkPeriod + 2)):
        	    afterFork = 1
            currency = INFO.getCurrency(event)
            wallet = INFO.getWallet(event)
            # add to next expiration period
            EXPEVENTS.addEvent(branch, currentPeriod, event, COST_FOR_EVENT_REPORT_CALCULATION * tx.gasprice, currency, wallet, afterFork)
        EVENTS.setExpiration(event, block.timestamp)
    # otherwise it's set to expire in the period it would've expired in as normal, no changes needed

macro moveEventToWinningBranch():
    EVENTS.setBranch(event, winner)
    # set outcomes to 0
    EVENTS.setOutcome(event, 0)
    EVENTS.setMode(event, 0)
    EVENTS.setEthics(event, 0)
    EVENTS.setUncaughtOutcome(event, 0)
    EVENTS.setCreationTime(event)
    originalPeriod = EVENTS.getOriginalExpiration(event)
    # return bond if it's a round 2 event and make it not one anymore
    if(BACKSTOPS.getRoundTwo(event) && !ROUNDTWO.roundTwoResolve(branch, event, eventIndex, msg.sender)):
        throw()
    # move event to fork
    # and place it into the next reporting period w/ outcomes to 0
    if(expPeriod <= currentVotePeriod):
        EVENTS.setExpiration(event, block.timestamp)
        # should only be put into vote period if it's not in early resolve / first wave portion anymore
        if(EVENTS.getChallenged(event)):
            # push it into next [this] period
            forkPeriod = BRANCHES.getForkPeriod(winner)
            afterFork = 0
            if(currentPeriod == (forkPeriod + 1) or currentPeriod == (forkPeriod + 2)):
        	    afterFork = 1
            currency = INFO.getCurrency(event)
            wallet = INFO.getWallet(event)
            # add to next expiration period
            EXPEVENTS.addEvent(winner, currentPeriod, event, COST_FOR_EVENT_REPORT_CALCULATION * tx.gasprice, currency, wallet, afterFork)

            # add event to original exp period per event early push forward res on new branch
            if(EVENTS.getEventPushedUp(event)):
                forkPeriod = BRANCHES.getForkPeriod(winner)
                afterFork = 0
                if(originalPeriod == (forkPeriod + 1) or originalPeriod == (forkPeriod + 2)):
        	        afterFork = 1
                currency = INFO.getCurrency(event)
                wallet = INFO.getWallet(event)
                # add to next expiration period
                EXPEVENTS.addEvent(winner, originalPeriod, event, COST_FOR_EVENT_REPORT_CALCULATION * tx.gasprice, currency, wallet, afterFork)

    else:
        # should only be put into vote period if it's not in early resolve / first wave portion anymore
        if(EVENTS.getChallenged(event)):
            # push into period it wouldve expired in
            # expiration time doesnt need to change
            forkPeriod = BRANCHES.getForkPeriod(winner)
            afterFork = 0
            if(expPeriod == (forkPeriod + 1) or  == (forkPeriod + 2)):
        	    afterFork = 1
            currency = INFO.getCurrency(event)
            wallet = INFO.getWallet(event)
            # add to next expiration period
            EXPEVENTS.addEvent(winner, expPeriod, event, COST_FOR_EVENT_REPORT_CALCULATION * tx.gasprice, currency, wallet, afterFork)
    
            # add event to original exp period per event early push forward res on new branch
            if(EVENTS.getEventPushedUp(event)):
                forkPeriod = BRANCHES.getForkPeriod(winner)
                afterFork = 0
                if(originalPeriod == (forkPeriod + 1) or originalPeriod == (forkPeriod + 2)):
        	        afterFork = 1
                currency = INFO.getCurrency(event)
                wallet = INFO.getWallet(event)
                # add to next expiration period
                EXPEVENTS.addEvent(winner, originalPeriod, event, COST_FOR_EVENT_REPORT_CALCULATION * tx.gasprice, currency, wallet, afterFork)

# use address picked in event creation to resolve it instead of the default fork resolve option
macro resolveCustomForkResolution():
    winner = nonDefaultForkResolution.resolveFork()
