### Deals with forking over events

import info as INFO
import branches as BRANCHES
import reporting as REPORTING
import events as EVENTS
import markets as MARKETS
import backstops as BACKSTOPS
import sendReputation as SENDREP
import roundTwo as ROUNDTWO
import expiringEvents as EXPEVENTS
import createBranch as CREATEBRANCH
import consensusData as CONSENSUSDATA
extern subcurrency: [allowance:[int256,int256]:int256, approve:[int256,int256]:int256, balance:[]:int256, balanceOf:[int256]:int256, transfer:[int256,int256]:int256, transferFrom:[int256,int256,int256]:int256]
inset('../data_api/refund.se')
inset('eventHelpers.se')

macro POINT_ZERO_ONE: 184467440737095520
macro FORK_TEXT: text("fork")

# UI has to handle function calls for these

# Notes:
    # Anyone can pay some amount significantly greater than the backstop 1 bond amount to force a branching event, splitting rep into two classes.
    # In one class the reported outcome for whatever event was the cause of dispute is said to be right, and rep is redistributed accordingly.
    # In the other class/branch, the event is readjudicated and remove the outcome on the pre fork branch and rep is redistributed as normal, except people who said the original outcome in the original fork lose rep.
    # Note: Whichever outcome was truly the correct one would determine which branch had rep that actually held value.  This would be akin to a Bitcoin hard fork scenario.  The winning fork, of course, would be the one with the most voluminous markets, which would be determined by the fork that represented reality, which would have a higher market cap.  Markets go to the most popular fork by default after 2 months.

# Period where we forked, at the end of it
    # don't penalize for this period / anything that happened here should be considered to not have happened - done
    # let period be incremented as normal - done
    # no rep redistribution on this period besides for event forked over on original. parent but don't actually resolve the event until later per below - done
    # fork users get a free pass for not reporting on this period - done
# Period after fork where we need to do nothing while waiting for fork to resolve
    # free pass for not reporting during this period in og branch - done, UI needs to call penalizeWrong with a 0 as event param or todo do this contract side after doing penalize wrong
    # no reporting or rep redistribution in this period except for on fork branch we re-report on the forked market and that's it, so no free pass on fork for that one event - done
# Period after fork is resolved
    # markets can't be moved until now - done
    # all markets have early exp disabled until this point - done
    # each event which should've resolved in the past 2 periods and this one is pushed up into this period and voted on in period after this - done
        # stays in parent if it wins, otherwise goes to new fork - done
    # each event resolving further in the future is pushed into the respective period on whichever fork wins - done
# todo if already moved once don't allow again after another fork
def moveEvent(event):
    refund()
    forkPeriod = BRANCHES.getForkPeriod(EVENTS.getEventBranch(event))
    branch = EVENTS.getEventBranch(event)
    if(!branch or !event):
        return(0)
    eventForkedOver = BRANCHES.getEventForkedOver(branch)
    expPeriod = EVENTS.getExpiration(event) / BRANCHES.getPeriodLength(branch)
    eventIndex = EXPEVENTS.getEventIndex(expPeriod, event)
    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)
    # todo getoutcome may not work
    if(!forkPeriod or currentPeriod != (forkPeriod + 2) or EVENTS.getOutcome(event) or BACKSTOPS.getMoved(event)):
        return(0)
    winner = BACKSTOPS.getResolved(branch, forkPeriod)
    if(!winner):
        winner = self.resolveFork(branch)
    BACKSTOPS.setMoved(event)
    if(event == eventForkedOver):
        return(1)
    # leave event here in same branch
    elif(winner == EVENTS.getEventBranch(event)):
        # set outcomes to 0
        EVENTS.setOutcome(event, 0)
        EVENTS.setMode(event, 0)
        EVENTS.setEthics(event, 0)
        EVENTS.setUncaughtOutcome(event, 0)
        # return bond if it's a round 2 event and make it not one anymore
        if(!ROUNDTWO.roundTwoResolve(branch, event, eventIndex, msg.sender)):
            throw()
        # if should've resolved in past periods
        if(expPeriod == forkPeriod or expPeriod == (forkPeriod + 1)):
            # push it into next [this] period
            EXPEVENTS.addEvent(branch, currentPeriod, event)
            EVENTS.setExpiration(event, block.timestamp)
        # otherwise it's set to expire in the period it would've expired in as normal, no changes needed
    # event's branch is changed to winning branch
    else:
        EVENTS.setBranch(event, winner)
        # set outcomes to 0
        EVENTS.setOutcome(event, 0)
        EVENTS.setMode(event, 0)
        EVENTS.setEthics(event, 0)
        EVENTS.setUncaughtOutcome(event, 0)
        # return bond if it's a round 2 event and make it not one anymore
        if(!ROUNDTWO.roundTwoResolve(branch, event, eventIndex, msg.sender)):
            throw()
        # move event to fork
        # and place it into the next reporting period w/ outcomes to 0
        if(expPeriod == forkPeriod or expPeriod == (forkPeriod + 1)):
            # push it into next [this] period
            EXPEVENTS.addEvent(winner, currentPeriod, event)
            EVENTS.setExpiration(event, block.timestamp)
        else:
            # push into period it wouldve expired in
            EXPEVENTS.addEvent(winner, expPeriod, event)
            # expiration time doesnt need to change
    return(1)

# parent branch is branch here
# todo fork use address picked in market creation to resolve it and have a default fork resolve option
def resolveFork(branch):
    callstackCheck()
    # do whitelist
    forkPeriod = BRANCHES.getForkPeriod(EVENTS.getEventBranch(event))
    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)
    origCap = self.exchangeRate(branch)
    fork = REPORTING.getFork(branch)
    forkCap = self.exchangeRate(fork)
    if(origCap >= forkCap):
        winner = branch
        BACKSTOPS.setResolved(branch, forkPeriod, winner)
        return(winner)
    else:
        winner = fork
    BACKSTOPS.setResolved(branch, forkPeriod, winner)
    return(winner)

# Resolve fork method that gets exchange rate
def exchangeRate(branch):
    callstackCheck()
    # get rep exchange rate from etherex for (branch)
    # return(exchangeRate)
    # for testing we'll just rng the exchange rate :)
    return(sha3(branch))

# Forks a contested event
# In the last 48 hours during period where a round 2 was pushed back to, can be made to fork instead of just round 2, so round 2 bond poster gets bond back and a fork commences
# bond for a fork is 1% of rep
# Errors:
    #  0: not in last 48 hr of period
    # -1: ineligible for forking over, already resolved, forked, or hasn't seen 1st backstop yet
    # -3: no fork allowed for 1 period after a forking event
    # -4: event was pushed forward, not allowed yet
    # -5: invalid branch
def fork(event, branch, forkedOverEthicality):
    callstackCheck()
    forkPeriod = BRANCHES.getForkPeriod(branch)
    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)
    if(!EVENTS.getRoundTwo(event) or BACKSTOPS.getFinal(event) or EVENTS.getForked(event)):
        return(-1)
    if(forkPeriod == currentPeriod or currentPeriod == (forkPeriod + 1) or currentPeriod == (forkPeriod + 2)):
        return(-3)
    if(EVENTS.getOriginalExpiration(event) != EVENTS.getExpiration(event)):
        return(-4)
    if(EVENTS.getEventBranch(event) != branch or !branch or !event):
        return(-5)
    # todo find actual gas cost for resolution here and charge that
    if(msg.value < 200000 * tx.gasprice):
        return(0)
    CONSENSUSDATA.setRefund(event, msg.value)
    # if in last 48 hr of period and is round 2 event with reports attempted
    if(block.timestamp / BRANCHES.getPeriodLength(branch) != ((block.timestamp + 2 * TWENTY_FOUR_HR) / BRANCHES.getPeriodLength(branch)) and EVENTS.getUncaughtOutcome(event) != 0):
        if(!send(CONSENSUSDATA, msg.value)):
            throw()
        bond = POINT_ZERO_ONE * REPORTING.getTotalRep(branch) / ONE
        BACKSTOPS.setBondAmount(event, bond)
        # lose fork bond in branch 1
        # results same as roundtwobond, let it resolve as that on original network
        if(!SENDREP.sendRepFrom(branch, msg.sender, event, bond)):
            throw()
        # on branch 2 fork bond isn't lost
        # on fork bond isn't lost, gets paid up to 2x from "liars"
        # make the fork
        newBranch = CREATEBRANCH.createSubbranch(FORK_TEXT, BRANCHES.getPeriodLength(branch), branch, BRANCHES.getMinTradingFee(branch), BRANCHES.getOracleOnly(branch))
        REPORTING.setFork(newBranch)
        period = BRANCHES.getVotePeriod(newBranch)
        EXPEVENTS.setEventRequired(newBranch, period + 1, event)
        EXPEVENTS.addEvent(newBranch, period + 1, event)
        EVENTS.setExpiration(event, block.timestamp)
        BACKSTOPS.setOriginalBranch(event, branch)
        BACKSTOPS.setForkBondPoster(event, msg.sender)
        EVENTS.setForked(event)
        BACKSTOPS.setFinal(event)
        BRANCHES.setForkPeriod(branch)
        BRANCHES.setForkPeriod(newBranch)
        BRANCHES.setEventForkedOver(newBranch, event)
        BRANCHES.setEventForkedOver(branch, event)
        if(forkedOverEthicality):
            BACKSTOPS.setForkedOverEthicality(event)
        # return round 2 bond on orig. branch
        market = EVENTS.getMarket(event, 0)
        averageAdjudicationCost = BRANCHES.getInitialBalance(branch, period - 1)/EXPEVENTS.getNumberEvents(branch, period - 1)
        bond = averageAdjudicationCost + MARKETS.getSharesValue(market) * (POINT_ZERO_ONE + MARKETS.getTradingFee(market) / 2) / 2 ** 64
        bond = min(bond, 200 * ONE)
        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, event), bond)
        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getBondPoster(event)), bond)
        BACKSTOPS.setBondReturned(event)
        return(1)
    else:
        return(0)

# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
# branch is orig. branch
# Returns 1
# Errors:
    # 0 fork not done yet
    # -1 event not fork event
    # -2 wrong branch
def resolveForkedEvent(branch, event):
    refund()
    votedOnAgain = 0
    # checks for orig. branch
    if(EVENTS.getEventBranch(event) != branch or BRANCHES.getEventForkedOver(branch) != event or !branch or !event):
        return(0)
    if(BRANCHES.getVotePeriod(branch) > (EVENTS.getExpiration(event) / BRANCHES.getPeriodLength(branch))):
        votedOnAgain = 1
    if(!EVENTS.getForked(event)):
        return(-1)
    if(self.resolveForkEvent(branch, event)):
        EVENTS.setForkDone(event)
        CONSENSUSDATA.doRefund(msg.sender, event)
        return(1)
    # fork not done yet
    else:
        return(0)

# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
    # helper function for resolveForkedEvent
# needs whitelist
def resolveForkEvent(branch, event):
    refund()
    # whitelist
    bond = EVENTS.getBond(event)
    winner = BACKSTOPS.getResolved(branch, BRANCHES.getForkPeriod(branch))
    if(!winner):
        return(-5)
    # binary
    if(binary(event)):
        fxpOutcome = 0
        ethical = 0
        # original parent won
        if(winner == branch):
            fxpOutcome = catch(EVENTS.getUncaughtOutcome(event))
            ethical = ethicCatch(EVENTS.getEthics(event))
        # fork won
        else:
            fxpOutcome = catch(EVENTS.getForkOutcome(event))
            ethical = ethicCatch(EVENTS.getForkEthicality(event))
        EVENTS.setOutcome(event, fxpOutcome)
        EVENTS.setEthics(event, ethical)
        if(fxpOutcome == 3 * ONE_HALF or !ethical):
            # give event bond money to reporters
            branchWallet = BRANCHES.getWallet(branch, INFO.getCurrency(event))
            if(!INFO.getWallet(event).transfer(branchWallet, bond)):
                throw()

            # not ethical is same as .5 outcome
            fxpOutcome = 3 * ONE_HALF
            EVENTS.setOutcome(event, fxpOutcome)
        else:
            # return 
            if(!INFO.getWallet(event).transfer(INFO.getCreator(event), bond)):
                throw()
        return(1)
    # scalar
    elif(scalar(event) or categorical(event)):
        mode = 0
        ethical = 0
        # original parent won
        if(winner == branch):
            mode = EVENTS.getUncaughtOutcome(event)
            ethical = ethicCatch(EVENTS.getEthics(event))
        # fork won
        else:
            mode = EVENTS.getForkOutcome(event)
            ethical = ethicCatch(EVENTS.getForkEthicality(event))
        EVENTS.setMode(event, mode)
        EVENTS.setEthics(event, ethical)
        scaledMax = EVENTS.getMaxValue(event)
        scaledMin = EVENTS.getMinValue(event)
        if(categorical(event)):
            scaledMin = ONE
            scaledMax = ONE * EVENTS.getNumOutcomes(event)
        fxpOutcome = mode * (scaledMax - scaledMin) / ONE + scaledMin
        ethicOutcome = 2 ** 63 * (scaledMax - scaledMin) / ONE + scaledMin
        EVENTS.setOutcome(event, fxpOutcome)
        if(mode == ONE_HALF or !ethical):
            # give event bond money to reporters
            branchWallet = BRANCHES.getWallet(branch, INFO.getCurrency(event))
            if(!INFO.getWallet(event).transfer(branchWallet, bond)):
                throw()
            # not ethical is same as .5 outcome
            EVENTS.setOutcome(event, ethicOutcome)
        else:
            # return bond
            if(!INFO.getWallet(event).transfer(INFO.getCreator(event), bond)):
                throw()
        return(1)
    # (should never be reached)
    else:
        return(0)
