import reporting as REPORTING
import branches as BRANCHES
import expiringEvents as EXPEVENTS
import events as EVENTS
import markets as MARKETS
import backstops as BACKSTOPS
import consensusData as CONSENSUS
import roundTwo as ROUNDTWO

inset('refund.se')
inset('eventHelpers.se')
inset('redistributeRep.se')
inset('proportionCorrect.se')
inset('repChange.se')

#event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)

macro POINTZEROONE: 184467440737095520
macro POINTONE: 1844674407370955264
macro POINTTWO: 3689348814741910528
macro POINTEIGHT: 14757395258967642112
macro MINBOND: 200*ONE

# Penalizes a reporter for reporting wrongly on a round 2 reporting / backstop 1 event
# So we want to do the rep redistribution for both period 1 and period 2 at this time
# essentially penalizeWrong for backstop 1 [where everyone reports on a given event]
# in a fork this is called on the original branch and event is reported on again on new branch
# Errors:
    #  0: event isn't eligible/up for round two penalization
    # -1: already past first half of new period and needed to penalize before then
    # -2: round two resolve wasn't successful
    # -3: in fork period only thing that rep redistribution is done on is the round 2 event in the original branch via round 2 penalize
    # -4: already done for all events in this period
    # -5: needed to collect fees last period which sets the before/after rep
# force event to be resolved first if it can be
# roundTwoResolve needs to be called for any event here before can be penalized if it's a backstop 1 event, a la close market for other events before being penalized
def penalizeRoundTwoWrong(branch, event):
    refund()
    lastPeriod = BRANCHES.getVotePeriod(branch)-1
    lastPenalizationPeriod = lastPeriod - 1
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    newRep = 0
    newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender)
    repBalance = REPORTING.getRepBalance(branch, msg.sender)
    oldRep = EXPEVENTS.getBeforeRep(branch, lastPeriod, msg.sender)
    forkEvent = BRANCHES.getEventForkedOver(branch)
    uncaught = EVENTS.getUncaughtOutcome(event)
    outcome = catch(uncaught)
    if(scalar(event) or categorical(event)):
        outcome = uncaught
    reportValue = EXPEVENTS.getReport(branch, lastPeriod, event, msg.sender)
    oldReport = EXPEVENTS.getReport(branch,lastPenalizationPeriod,event,msg.sender)
    ethics = EXPEVENTS.getEthicReport(branch, lastPeriod, event, msg.sender)
    oldEthics = EXPEVENTS.getEthicReport(branch, lastPenalizationPeriod, event, msg.sender)
    averageAdjudicationCost = BRANCHES.getInitialBalance(branch, lastPeriod)/EXPIRING.getNumberEvents(branch, lastPeriod)
    bond = averageAdjudicationCost + MARKETS.getSharesValue(market)*(POINTZEROONE + MARKETS.getTradingFee(market)/2) / 2**64
    bond = min(bond, MINBOND)
    ethical = EVENTS.getEthics(event)
    p = proportionCorrect(event, 0)
    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period
    if(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
        return(-1)
    # if no outcome / event not resolved yet, resolve it [as long as it wasn't an event that was pushed fwd and got rejected and thus hasn't actually resolved yet]
    elif(!EVENTS.getOutcome(event)):
        if(ROUNDTWO.roundTwoResolve(branch, event, EXPEVENTS.getEventIndex(branch, lastPeriod, event), msg.sender)==0):
            return(-2)
    elif(BRANCHES.getForkPeriod(branch) == lastPeriod && event!=forkEvent):
        return(-3)
    elif(CONSENSUS.getPenalizedUpTo(branch, msg.sender)==lastPeriod):
        return(-4)
    elif(!CONSENSUS.getFeesCollected(branch, msg.sender, lastPeriod)):
        return(-5)
    # if overruled / different outcome after reporting on again
    overruled = 0
    if(scalar(event) or categorical(event)):
        if((BACKSTOPS.getOriginalOutcome(event) != EVENTS.getUncaughtOutcome(event) or BACKSTOPS.getOriginalEthicality(event)!=ethic_catch(ethical))):
            overruled = 1
    elif((BACKSTOPS.getOriginalOutcome(event) != catch(uncaught) or BACKSTOPS.getOriginalEthicality(event)!=ethic_catch(ethical))):
        overruled = 1
        
    numReportedOn = EXPEVENTS.getNumReportsSubmitted(branch, lastPeriod, msg.sender)
    repChange = 0
    # penalization on a round 2 event if not already penalized, it has outcome, and user reported on it
    # if it's penalizing in the period it was pushed back to we can do the penalization, should do it for both the first and second period
    if(BACKSTOPS.getRoundTwo(event) && (BACKSTOPS.getFinal(event) or event==forkEvent) && !CONSENSUS.getPenalized(branch, lastPeriod, msg.sender, event) && (reportValue or oldReport)):
        # Do the first rep redistribution based on first report and final outcome if reported first time
        if(oldReport && outcome!=0):
            calculateRepChange(oldReport, POINTTWO)
            handleEthicsAndBondRepRedistribution(POINTTWO, oldEthics, numReportedOn)
        # Do the second (for each user) based on second report and final outcome
        if(reportValue && outcome!=0):
            calculateRepChange(reportValue, POINTONE)
            handleEthicsAndBondRepRedistribution(POINTONE, ethics, numReportedOn)
        CONSENSUS.setPenalized(branch, lastPeriod, msg.sender, event)
        CONSENSUS.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    else:
        return(0)
    # if a fork event in original branch, only event needed to report on in this period is that one [b/c the original branch resolves it as a regular round 2 event, fork reports again]
    if(event==forkEvent):
        CONSENSUS.increasePenalizedNum(branch, lastPeriod, msg.sender, (numReportedOn - 1))
    # penalization on a regular event if not already penalized, it has outcome, and user reported on it
    # once penalized for all events actually get rid of net rep lost
    if(numReportedOn==CONSENSUS.getPenalizedNum(branch, lastPeriod, msg.sender)):
        sendRedistributedRepToBranch()
    return(1)


macro handleEthicsAndBondRepRedistribution($maxPenalty, $ethics, $numReportedOn):
    # for ethicality if diff. appeal then pay back the appeal bond from people who reported the wrong ethicality, but don't take rep beyond that and max maxPenalty% of their rep respectively
    if($ethics != ethic_catch(ethical) && repChange >=0 && BACKSTOPS.getDisputedOverEthics(event)):
        if($numReportedOn<10):
            repChange = -$maxPenalty/10*repBalance / ONE
        else:
            repChange = -$maxPenalty/$numReportedOn*repBalance / ONE
    if(repBalance + repChange <= 0):
        repChange = -1*repBalance
    # if overruled: reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, rest goes to branch as usulater in the process
    if(overruled && BACKSTOPS.getBondPaid(event) < 2*bond && repChange < 0 && event!=forkEvent):
        # done instead of sending to redistrib. pool
        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), repChange)
        # sends that rep to the bonded challenger
        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getBondPoster(event)), -repChange)
        BACKSTOPS.increaseBondPaid(event, (-1*repChange))
    # if rep isn't redistributed immediately to bond poster [if they're already paid back] then we adjust the after rep as normal and do it all at the end
    else:
        newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender) + repChange
        EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
