# This software (Augur) allows buying and selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
# 
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
# 
#    This program is distributed in the hope that it will be useful, #    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
# 
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

### This allows you to place orders on the book and cancel them

import branches as BRANCHES
import markets as MARKETS
import trades as TRADES
import info as INFO
extern subcurrency: [allowance:[int256,int256]:int256, approve:[int256,int256]:int256, balance:[]:int256, balanceOf:[int256]:int256, transfer:[int256,int256]:int256, transferFrom:[int256,int256,int256]:int256]
inset('../data_api/refund.se')

event logAddTx(market:indexed, sender:indexed, type, fxpPrice, fxpAmount, outcome, tradeid)
event logCancel(market:indexed, sender:indexed, fxpPrice, fxpAmount, tradeid, outcome, type)

# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 8
# Boolean success/failure
macro SUCCESS: 1
macro FAILURE: 0
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_ALREADY_EXISTS: 21
macro TRADE_SAME_BLOCK_PROHIBITED: 22

macro feePercent($marketFee, $fxpPrice, $cumScale):
    4 * $marketFee * $fxpPrice * (ONE - $fxpPrice * 2 ** 64 / $cumScale) / ($cumScale * ONE)

macro saveTrade($type, $fxpAmount, $fxpPrice, $market, $outcome, $branch, $fee, $sender):
    trade = [$type, $market, $fxpAmount, $fxpPrice, $sender, block.number, $outcome]
    tradeID = sha3(trade, items = 7)
    cumScale = MARKETS.getCumScale($market)

    # Save trade
    if(!TRADES.getID(tradeID)):
        TRADES.saveTrade(tradeID, $type, $market, $fxpAmount, $fxpPrice, $sender, $outcome)
        # Update market
        lastID = MARKETS.getLastTrade($market)
        MARKETS.addTrade($market, tradeID, lastID)
        # Update available and trading fxpAmounts for asks
        if($type == ASK):
            MARKETS.modifyParticipantShares($market, msg.sender, $outcome, -$fxpAmount, 0)
            if($fee):
                if(!INFO.getCurrency($market).transferFrom($sender, INFO.getWallet($market), ($fxpAmount * $fxpPrice * $fee / ONE ** 2))):
                    throw()
        # Send / escrow cash for bids
        if($type == BID):
            if(!INFO.getCurrency($market).transferFrom($sender, INFO.getWallet($market), $fxpAmount * $fxpPrice / ONE)):
                throw()
            if($fee and !INFO.getCurrency($market).transferFrom($sender, INFO.getWallet($market), ($fxpAmount * $fxpPrice * $fee / ONE ** 2))):
                throw()
    else:
        return(TRADE_ALREADY_EXISTS)
    log(type = logAddTx, $market, $sender, $type, $fxpPrice, $fxpAmount, $outcome, tradeID)
    return(tradeID)
    
macro removeTrade($tradeID, $market):
    TRADES.removeTrade($tradeID)
    MARKETS.removeTradeFromMarket($market, $tradeID)

# 
# Cancellation: cancels a trade, if a bid refunds money, if an ask returns shares
# @returns 1 if success, 0 if failure
# 
# 200k gas
def cancel(tradeID):
    refund()
    # user can cancel anytime
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = TRADES.getTrade(tradeID, outitems = TRADE_FIELDS)
    if(!trade):
        return(0)
    type = trade[1]
    market = trade[2]
    fxpAmount = trade[3]
    fxpPrice = trade[4]
    owner = trade[5]
    outcome = trade[7]
    tradingFee = MARKETS.getTradingFee(market)
    cumScale = MARKETS.getCumScale(market)
    fee = feePercent(tradingFee, fxpPrice, cumScale) * MARKETS.getMakerFees(market) / ONE
    # Check the owner
    if(msg.sender == owner):
        # Clear the trade first
        removeTrade(tradeID, market)
        # Issue refunds
        if(type == BID):
            # cash refund
            amt = fxpAmount * fxpPrice * (fee + ONE) / ONE ** 2
            if(!INFO.getWallet(market).transfer(msg.sender, amt)):
                throw()
        elif(type == ASK):
            # shares refund
            MARKETS.modifyParticipantShares(market, msg.sender, outcome, fxpAmount, 0)
            if(!INFO.getWallet(market).transfer(msg.sender, (fxpAmount * fxpPrice * fee / ONE ** 2))):
                throw()
        else:
            throw()
        # Log cancellation
        log(type = logCancel, market, msg.sender, fxpPrice, fxpAmount, tradeID, outcome, type)
        return(SUCCESS)
    return(FAILURE)

# 
# Buy / Sell actions: puts orders on the book
# Errors:
    #  0: market doesn't exist
    # -1: fxpAmount/fxpPrice bad
    # -2: oracle only branch
    # -3: not enough shares
# 
# costs 532k gas
# smallest trade value is 0.00000001
def buy(fxpAmount, fxpPrice, market, outcome):
    refund()
    tradingFee = MARKETS.getTradingFee(market)
    cumScale = MARKETS.getCumScale(market)
    fee = feePercent(tradingFee, fxpPrice, cumScale) * MARKETS.getMakerFees(market) / ONE
    branch = MARKETS.getBranch(market)
    if(!MARKETS.getCreationTime(market)):
        return(0)
    # fxpPrice cannot be greater than max share value, value traded can't be <.00000001, and value can't be > 2**126 in unfixed point so we don't get overflow issues
    if(fxpPrice > cumScale or fxpAmount * fxpPrice < 3402823669209384705829531287552 or fxpAmount * fxpPrice >= 2 ** 190):
        return(-1)
    if(BRANCHES.getOracleOnly(branch)):
        return(-2)
    saveTrade(BID, fxpAmount, fxpPrice, market, outcome, branch, fee, msg.sender)
    return(FAILURE)

# costs 532k gas
# smallest trade value is 0.00000001
def sell(fxpAmount, fxpPrice, market, outcome):
    refund()
    branch = MARKETS.getBranch(market)
    tradingFee = MARKETS.getTradingFee(market)
    cumScale = MARKETS.getCumScale(market)
    fee = feePercent(tradingFee, fxpPrice, cumScale) * MARKETS.getMakerFees(market) / ONE
    # fxpPrice cannot be greater than max share value, value traded can't be <.00000001, and value can't be > 2**126 in unfixed point so we don't get overflow issues
    if(fxpPrice > cumScale or fxpAmount * fxpPrice < 3402823669209384705829531287552L or fxpAmount * fxpPrice >= 2 ** 190):
        return(-1)
    if(BRANCHES.getOracleOnly(branch)):
        return(-2)
    if(MARKETS.getParticipantSharesPurchased(market, msg.sender, outcome) < fxpAmount):
        return(-3)
    saveTrade(ASK, fxpAmount, fxpPrice, market, outcome, branch, fee, msg.sender)
    return(FAILURE)
