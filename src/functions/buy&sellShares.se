# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

# Note: must spend at least 1 in ONE

import branches as BRANCHES
import expiringEvents as EXPEVENTS
import info as INFO
import cash as CASH
import reporting as REPORTING
import fxpFunctions as FXP
import markets as MARKETS
import events as EVENTS
import trades as TRADES
inset('refund.se')

event log_price(market:indexed, type, price, amount, timestamp, outcome, trader:indexed)
event log_add_tx(market:indexed, sender, type, price, amount, outcome, tradeid)
event log_fill_tx(market:indexed, sender:indexed, owner:indexed, type, price, amount, tradeid, outcome)
event log_cancel(market:indexed, sender, price, amount, tradeid, outcome, type)

# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 9
# Boolean success/failure
macro SUCCESS: 1
macro FAILURE: 0
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_ALREADY_EXISTS: 21

macro save_trade($type, $amount, $price, $market, $outcome, $branch, $participantNumber):
    trade = [$type, $market, $amount, $price, msg.sender, block.number, $outcome]
    trade_id = sha256(trade, items=7)
    trading_fee = MARKETS.getTradingFee($market)
    cumScale = MARKETS.getCumScale($market)
    fee = fee_percent(trading_fee, $price, $amount, cumScale) * MARKETS.getMakerFees($market) / ONE

    # Save trade
    if !TRADES.getID(trade_id):
        TRADES.saveTrade(trade_id, $type, $market, $amount, $price, msg.sender, $outcome)
        # Update market
        last_id = MARKETS.getLastTrade($market)
        MARKETS.addTrade($market, trade_id, last_id)
        # Update available and trading amounts for asks
        if $type == ASK:
            MARKETS.modifyParticipantShares($market, $participantNumber, $outcome, -$amount)
            if(fee):
                CASH.send($market, ($amount * $price / ONE * fee / ONE))
        # Send / escrow cash for bids
        if $type == BID:
            CASH.send($market, $amount * $price / ONE)
            if(fee):
                CASH.send($market, ($amount * $price / ONE * fee / ONE))
    else:
        return(TRADE_ALREADY_EXISTS)
    log(type=log_add_tx, $market, msg.sender, $type, $price, $amount, $outcome, trade_id)
    return(trade_id)

#
# Cancellation
#
# 200k gas
def cancel(trade_id):
    refund()
    # user can cancel anytime
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = TRADES.get_trade(trade_id, outitems=TRADE_FIELDS)
    if !trade:
        return(0)
    type = trade[1]
    market = trade[2]
    amount = trade[3]
    price = trade[4]
    owner = trade[5]
    outcome = trade[8]
    branch = MARKETS.getBranchID(market)
    trading_fee = MARKETS.getTradingFee(market)
    cumScale = MARKETS.getCumScale(market)
    fee = fee_percent(trading_fee, price, amount, cumScale) * MARKETS.getMakerFees($market) / ONE
    # Check the owner
    if msg.sender == owner:
        # Clear the trade first
        remove_trade(trade_id, market)
        # Issue refunds
        if type == BID:
            # cash refund
            amt = amount * price / ONE * (fee + ONE) / ONE
            CASH.subtractCash(market, amt)
            CASH.addCash(msg.sender, amt)
        elif type == ASK:
            # shares refund
            participantNumber = MARKETS.getParticipantNumber(market, msg.sender)
            MARKETS.modifyParticipantShares(market, participantNumber, outcome, amount)
            CASH.subtractCash(market, (amount * price / ONE * fee / ONE))
            CASH.addCash(msg.sender, (amount * price / ONE * fee / ONE))
        # Log cancellation
        log(type=log_cancel, market, msg.sender, price, amount, trade_id, outcome, type)
        return(SUCCESS)
    return(FAILURE)

macro remove_trade($trade_id, $market_id):
    TRADES.remove_trade(trade_id)
    MARKETS.remove_trade_from_market(market_id, trade_id)

#
# Buy / Sell actions
# Errors:
    # -1: amount/price bad or no market
    # -2: oracle only branch
    # -3: bad outcome to trade [not needed anymore, can't buy shares that don't exist]
    # -4: not enough money or shares
#
# costs 532k
def buy(amount, price, market, outcome):
    refund()
    if(amount <= 0 or price <= 0):
        return(-1)
    branch = MARKETS.getBranchID(market)
    if(BRANCHES.getOracleOnly(branch)):
        return(-2)
    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)
    # if participant doesn't exist in market, add them
    if(tx.origin != MARKETS.getParticipantID(market, participantNumber)):
        participantNumber = MARKETS.addParticipant(market, tx.origin)
    trading_fee = MARKETS.getTradingFee(market)
    cumScale = MARKETS.getCumScale(market)
    fee = fee_percent(trading_fee, price, amount, cumScale) * MARKETS.getMakerFees($market) / ONE
    if(amount*price < ONE or price>cumScale):
        return(0)
    if(CASH.balance(tx.origin) < (amount * price / ONE * (fee + ONE) /ONE)):
        return(-4)
    save_trade(BID, amount, price, market, outcome, branch, participantNumber)
    return(FAILURE)

# cost 532k
def sell(amount, price, market_id, outcome):
    refund()
    if(amount <= 0 or price <= 0):
        return(-1)
    branch = MARKETS.getBranchID(market)
    if(BRANCHES.getOracleOnly(branch)):
        return(-2)
    participantNumber = MARKETS.getParticipantNumber(market_id, tx.origin)
    if(MARKETS.getParticipantID(market_id, participantNumber) != tx.origin):
        return(-3)
    if(MARKETS.getParticipantSharesPurchased(market_id, participantNumber, outcome) < amount):
        return(-4)
    trading_fee = MARKETS.getTradingFee(market_id)
    cumScale = MARKETS.getCumScale(market_id)
    fee = fee_percent(trading_fee, price, amount, cumScale) * MARKETS.getMakerFees($market) / ONE
    if(amount*price < ONE or price>cumScale):
        return(0)
    if(CASH.balance(tx.origin) < (amount * price / ONE * fee / ONE)):
        return(-4)
    save_trade(ASK, amount, price, market_id, outcome, branch, participantNumber)
    return(FAILURE)

# Example:
    #buyer gives up say 20
    #complete set cost is say 100
    #fee is say 2
    #market should lose 20 from buyer's escrowed money
    #market should gain 100 from complete set
    #person short selling should give the market 80 [complete set cost less shares sold]
    #plus fees
        #1 should go to branch
        #1 should go to creator
def short_sell(buyer_trade_id, max_amount):
    refund()
    # check trade hash
    tradeInfo = array(3)
    tradeInfo[0] = buyer_trade_id
    tradeInfo[1] = max_amount
    tradeInfo[2] = 0
    tradeHash = sha256(tradeInfo, items=3)
    if(TRADES.checkHash(tradeHash)==-1):
        return(-2)
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = TRADES.get_trade(buyer_trade_id, outitems=TRADE_FIELDS)
    if !trade:
        return(0)
    # Get market
    type = trade[1]
    if(type!=BID):
        return(0)
    market_id = trade[2]
    if(MARKETS.getOneWinningOutcome(market_id, 0)):
        return(-4)
    orig_amount = trade[3]
    price = trade[4]
    owner = trade[5]
    outcome = trade[8]
    if(owner == msg.sender or owner == tx.origin):
        return(0)
    # Make sure the trade has been mined, obvious HFT prevention
    if block.number <= self.trades[trade_id].block:
        return(TRADE_SAME_BLOCK_PROHIBITED)
    branch = MARKETS.getBranchID(market_id)
    if(BRANCHES.getOracleOnly(branch)):
        return(-1)
    creator = INFO.getCreator(market_id)
    trading_fee = MARKETS.getTradingFee(market_id)
    cumScale = MARKETS.getCumScale(market_id)
    amount = min(orig_amount, max_amount)
    fee = amount * price / ONE * fee_percent(trading_fee, price, amount, cumScale) / ONE
    branchFees = (THREEFOURTHS+(ONEHALF - MARKETS.getMakerFees(market))/2)*fee / ONE
    creatorFees = (ONEFOURTH+(ONEHALF - MARKETS.getMakerFees(market))/2)*fee / ONE
    takerFeesTotal = branchFees + creatorFees
    cost = amount*cumScale/ONE - (amount*price/ONE - takerFeesTotal)
    if(CASH.balance(tx.origin) < cost):
        return(INSUFFICIENT_BALANCE)
    numOutcomes = MARKETS.getMarketNumOutcomes(market)
    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)
    # if participant doesn't exist in market, add them
    if(tx.origin != MARKETS.getParticipantID(market, participantNumber)):
        participantNumber = MARKETS.addParticipant(market, tx.origin)

    i = 0
    # send shares of the event to user address
    while i <= numOutcomes:
        MARKETS.modifyShares(market, i, amount)
        MARKETS.modifyParticipantShares(market, participantNumber, i, amount)
        i += 1
    if(BRANCHES.getVotePeriod(branch)<MARKETS.getTradingPeriod(market)):
        MARKETS.modifySharesValue(market, amount*cumScale/ONE)
        EXPEVENTS.adjustPeriodShareValueOutstanding(branch, MARKETS.getTradingPeriod(market), amount*cumScale/ONE)

    # send money from user acc. to market address/account
    # cost for shares
    CASH.send(market, cost-takerFeesTotal)

    # Fill buy order
    # Determine fill amount
    fill = amount
    # Calculate value
    value = (fill * price)/ONE
    # Update trade amount or remove
    if fill < orig_amount:
        TRADES.fill_trade(trade_id, fill)
    else:
        remove_trade(trade_id, market_id)
    # Update balances
    MARKETS.modifyParticipantShares(market_id, msg.sender, outcome, -fill)
    MARKETS.modifyParticipantShares(market_id, owner, outcome, fill)
    # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
    # 75% to branch + .5% more to branch per maker fee 1% decrease 
    CASH.send(branch, branchFees)
    # 25% to creator + .5% more to creator per 1% decrease in maker fees
    CASH.send(creator, creatorFees)

    # other party [maker] pay their part of the fee here too
    fee = fee * MARKETS.getMakerFees(market) / ONE
    CASH.subtractCash(market_id, fee)
    CASH.addCash(creator, fee/2)
    CASH.addCash(branch, fee/2)
    
    MARKETS.addFees(market, fee+takerFeesTotal)

    # Log transaction
    log(type=log_fill_tx, market_id, msg.sender, owner, ASK, price, fill, trade_id, outcome)
    # Log price, fill amount, type and timestamp
    log(type=log_price, market_id, type, price, fill, block.timestamp, outcome, msg.sender)
    return([SUCCESS, max_value, max_amount]: arr)

#
# Trade
#
# Errors:
    # -1: oracle only branch
    # -2: bad trade hash
    # -3: trader doesn't exist / own shares in this market
    # 10: insufficient balance
#Exchange(Market, outcome, sender, amount, receiver, payment) – transfers amount shares from sender to receiver for payment amount
#max value is max amount to spend to buy [including fees]
#max amount is max shares to sell
# 500k gas
def trade(max_value, max_amount, trade_ids:arr):
    refund()
    if(BRANCHES.getOracleOnly(branch)):
        return(-1)
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeInfo[2] = max_value
    tradeHash = sha256(tradeInfo, items=3)
    if(TRADES.checkHash(tradeHash)==-1):
        return(-2)
    max_value = max_value
    max_amount = max_amount
    # Try to fulfill each trade passed
    t = 0
    while t < len(trade_ids):
        trade_id = trade_ids[t]
        # Get trade
        trade = array(TRADE_FIELDS)
        trade = TRADES.get_trade(trade_id, outitems=TRADE_FIELDS)
        if !trade:
            return(0)
        # Get market
        type = trade[1]
        market_id = trade[2]
        creator = INFO.getCreator(market_id)
        amount = trade[3]
        price = trade[4]
        owner = trade[5]
        outcome = trade[8]
        if(owner == msg.sender or owner == tx.origin):
            return(0)
        # Make sure the trade has been mined, obvious HFT prevention
        if block.number <= self.trades[trade_id].block:
            return(TRADE_SAME_BLOCK_PROHIBITED)
        branch = MARKETS.getBranchID(market_id)
        trading_fee = MARKETS.getTradingFee(market_id)
        cumScale = MARKETS.getCumScale(market_id)
        fee = fee_percent(trading_fee, price, amount, cumScale)

        # Fill buy order
        if type == BID:
            # Get available balance of shares
            participantNumber = MARKETS.getParticipantNumber(market_id, tx.origin)
            balance = MARKETS.getParticipantSharesPurchased(market_id, participantNumber, outcome)
            if balance > 0:
                if(MARKETS.getParticipantID(market_id, participantNumber) != tx.origin):
                    return(-3)
                # Determine fill amount
                fill = min(amount, min(balance, max_amount))
                # Calculate value
                value = (fill * price)/ONE
                # Update trade amount or remove
                if fill < amount:
                    TRADES.fill_trade(trade_id, fill)
                else:
                    remove_trade(trade_id, market_id)
                # Update balances
                MARKETS.modifyParticipantShares(market_id, msg.sender, outcome, -fill)
                MARKETS.modifyParticipantShares(market_id, owner, outcome, fill)
                # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
                fee = value * fee / ONE
                # THREEFOURTHS is 3/4
                branchFees = (THREEFOURTHS+(ONEHALF - MARKETS.getMakerFees(market))/2)*fee / ONE
                creatorFees = (ONEFOURTH+(ONEHALF - MARKETS.getMakerFees(market))/2)*fee / ONE
                takerFeesTotal = branchFees + creatorFees
                CASH.addCash(msg.sender, value-takerFeesTotal)
                # 75% to branch + .5% more to branch per maker fee 1% decrease 
                CASH.addCash(branch, branchFees)
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                CASH.addCash(creator, creatorFees)
                CASH.subtractCash(market_id, value)

                # other party [maker] pay their part of the fee here too
                fee = fee * MARKETS.getMakerFees(market) / ONE
                CASH.subtractCash(market_id, fee)
                CASH.addCash(creator, fee/2)
                CASH.addCash(branch, fee/2)
                
                # needed to keep track of how many fees a market has raised
                MARKETS.addFees(market, fee+takerFeesTotal)
                # Update max_amount
                max_amount -= fill
                # Log transaction
                log(type=log_fill_tx, market_id, msg.sender, owner, ASK, price, fill, trade_id, outcome)
            else:
                return(INSUFFICIENT_BALANCE)
        elif type == ASK:
            max_value = min(CASH.balance(msg.sender), max_value)
            if max_value > 0:
                # Calculate value of trade
                trade_value = amount * price / ONE
                # Determine fill value
                value = min(max_value, trade_value)
                fee = trade_value * fee / ONE
                branchFees = (THREEFOURTHS+(ONEHALF - MARKETS.getMakerFees(market))/2)*fee / ONE
                creatorFees = (ONEFOURTH+(ONEHALF - MARKETS.getMakerFees(market))/2)*fee / ONE
                takerFeesTotal = branchFees + creatorFees
                # fix todo for what if maxvalue is say 10 but adding fees to it makes it 11, max value should _include_, not exclude fees and account for it w/ cash balance including fees
                if(CASH.balance(tx.origin) < (value + takerFeesTotal)):
                    return(INSUFFICIENT_BALANCE)
                fill = 0
                # Calculate fill amount, update trade amount or remove filled trade
                if value < trade_value:
                    fill = value*ONE / price
                    TRADES.fill_trade(trade_id, fill)
                else:
                    fill = amount
                    remove_trade(trade_id, market_id)
                participantNumber = MARKETS.getParticipantNumber(market_id, tx.origin)
                # if participant doesn't exist in market, add them
                if(tx.origin != MARKETS.getParticipantID(market_id, participantNumber)):
                    participantNumber = MARKETS.addParticipant(market_id, tx.origin)
                # Update balances [user asking has already gotten rid of shares in escrow, just need to add them to the buyer]
                MARKETS.modifyParticipantShares(market_id, msg.sender, outcome, fill)
                # Transfer cash from user to person who has ask order and pay fee to branch and market creator
                # 75% to branch + .5% more to branch per maker fee 1% decrease 
                CASH.addCash(branch, branchFees)
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                CASH.addCash(creator, creatorFees)
                cost = value + takerFeesTotal
                CASH.addCash(owner, value)
                CASH.subtractCash(msg.sender, cost)

                # other party [maker] pay their part of the fee here too
                fee = fee * MARKETS.getMakerFees(market) / ONE
                CASH.subtractCash(market_id, fee)
                CASH.addCash(creator, fee/2)
                CASH.addCash(branch, fee/2)
                
                MARKETS.addFees(market, fee+takerFeesTotal)
                # Update max_value
                max_value -= value
                # Log transaction
                log(type=log_fill_tx, market_id, msg.sender, owner, BID, price, fill, trade_id, outcome)
            else:
                return(INSUFFICIENT_BALANCE)

        # Log price, fill amount, type and timestamp
        log(type=log_price, market_id, type, price, fill, block.timestamp, outcome, msg.sender)
        # Next trade
        t += 1
    return([SUCCESS, max_value, max_amount]: arr)

# buys amount of every outcome
# cost 850k gas
def buyCompleteSets(branch, market, amount):
    refund()
    if(BRANCHES.getOracleOnly(branch)):
        return(-1)
    numOutcomes = MARKETS.getMarketNumOutcomes(market)
    cumScale = MARKETS.getCumScale(market)
    branch = MARKETS.getBranchID(market)
    cost = amount*cumScale/ONE
    if(CASH.balance(tx.origin) < price):
        return(-3)
    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)
    # if participant doesn't exist in market, add them
    if(tx.origin != MARKETS.getParticipantID(market, participantNumber)):
        participantNumber = MARKETS.addParticipant(market, tx.origin)
    i = 0
    # send shares of the event to user address
    while i <= numOutcomes:
        MARKETS.modifyShares(market, i, amount)
        MARKETS.modifyParticipantShares(market, participantNumber, i, amount)
        i += 1
    if(BRANCHES.getVotePeriod(branch)<MARKETS.getTradingPeriod(market)):
        MARKETS.modifySharesValue(market, amount*cumScale/ONE)
        EXPEVENTS.adjustPeriodShareValueOutstanding(branch, MARKETS.getTradingPeriod(market), amount*cumScale/ONE)
    # send money from user acc. to market address/account
    CASH.send(market, cost)
    return(1)

    
# sells amount of every outcome [if user owns it]
def sellCompleteSets(market, amount):
    refund()
    if(BRANCHES.getOracleOnly(branch)):
        return(-1)
    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)
    numOutcomes = MARKETS.getMarketNumOutcomes(market)
    cumScale = MARKETS.getCumScale(market)
    branch = MARKETS.getBranchID(market)
    if(MARKETS.getParticipantID(market, participantNumber) != tx.origin):
        return(-2)
    # these prices are in fixed point
    cost = amount*cumScale/ONE
    i = 0
    while i <= numOutcomes:
        if(MARKETS.getParticipantSharesPurchased(market, participantNumber, i) < amount):
            return(-3)
        i += 1
    i = 0
    while i <= numOutcomes:
        MARKETS.modifyShares(market, i, -amount)
        MARKETS.modifyParticipantShares(market, participantNumber, i, -amount)
        i += 1
    if(BRANCHES.getVotePeriod(branch)<MARKETS.getTradingPeriod(market)):
        MARKETS.modifySharesValue(market, -amount*cumScale/ONE)
        EXPEVENTS.adjustPeriodShareValueOutstanding(branch, MARKETS.getTradingPeriod(market), -amount*cumScale/ONE)
    # send funds from the market to the user acc.
    CASH.subtractCash(market, cost)
    CASH.addCash(tx.origin, cost)
    return(1)
    
macro fee_percent($market_fee, $price, $amount, $cumScale):
    4 * $market_fee * $price / ($cumScale) * (ONE-$price/$cumScale)