import markets as MARKETS
import events as EVENTS'
import info as INFO
extern subcurrency: [allowance:[int256,int256]:int256, approve:[int256,int256]:int256, balance:[]:int256, balanceOf:[int256]:int256, transfer:[int256,int256]:int256, transferFrom:[int256,int256,int256]:int256]
inset('refund.se')

# Payout traders in markets with number of winningOutcomes of 2 [one scalar with any combination of binary + categorical for the other 2 dimensions, or just 1D with a scalar]
# Error:
    # -1: sender doesn't exist / match up with the participant given participant number [this is used as a check to make sure participant # 0 is really # 0]
def twoOutcomes(market, winningOutcome: arr, event, sender):
    callstackCheck()
    # fetch outcome and min/max values for the scalar
    outcome = EVENTS.getOutcome(event)
    minValue = EVENTS.getMinValue(event)
    maxValue = EVENTS.getMaxValue(event)
    # price is in fixed point
    # share two goes with the high/long side
    pricePerShare2 = ONE * (outcome - minValue) / (maxValue - minValue)
    # share one goes with the low/short side of the calc
    pricePerShare1 = ONE - pricePerShare2
    # for each winning outcome get rid of shares and send money to the trader
    n = 0
    cumScale = MARKETS.getCumScale(market)
    while(winningOutcome[n] != 0):
        sharesOwned = MARKETS.getParticipantSharesPurchased(market, sender, winningOutcome[n])
        MARKETS.modifyParticipantShares(market, sender, winningOutcome[n], -sharesOwned, 0)
        # low side
        if(n == 0):
            if(!INFO.getWallet(market).transfer(sender, sharesOwned * cumScale / ONE * pricePerShare1 / ONE)):
                throw()
        # high side (of the scalar part)
        elif(n == 1):
            if(!INFO.getWallet(market).transfer(sender, sharesOwned * cumScale / ONE * pricePerShare2 / ONE)):
                throw()
        else:
            throw()
        n += 1
    return(1)
