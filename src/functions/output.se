def init():
    description = text("Root branch")
    save(self.Info[1010101].description[0], description, chars=len(description))
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Info[1010101].descriptionLength = len(description)
    self.Reporting[1010101].repIDtoIndex[msg.sender] = 0
    self.Reporting[1010101].reputation[0].repValue = 0
    self.Reporting[1010101].reputation[0].reporterID = msg.sender
    self.Reporting[1010101].numberReporters = 2
    self.Reporting[1010101].repIDtoIndex[1010101] = 1
    self.Reporting[1010101].reputation[1].repValue = 0
    self.Reporting[1010101].reputation[1].reporterID = 1010101
    self.branch[1010101].baseReportersLastPeriod = 2*3
    self.Branches[1010101].currentVotePeriod = (block.timestamp / 15) - 1
    self.Branches[1010101].periodLength = 15 # 2 hours
    # .5%
    self.Branches[1010101].minTradingFee = 92233720368547760 
    self.branchListCount = 1
    self.branchList[0] = 1010101
    # since only have to report on half this targets 3
    self.Branches[1010101].baseReporters = 2*3
    # test initial funds
    self.cashcoinBalances[msg.sender] = 100000*ONE

inset('refund.se')

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](description[2048], descriptionLength, creator, creationFee)


def getDescription(ID):
    refund()
    length=self.Info[ID].descriptionLength
    return(load(self.Info[ID].description[0], chars=length): str)

def getDescriptionLength(ID):
    refund()
    return(self.Info[ID].descriptionLength)

def getCreator(ID):
    refund()
    return(self.Info[ID].creator)

def getCreationFee(ID):
    refund()
    return(self.Info[ID].creationFee)

# @return 1 if success, 0 if creator already exists
def setInfo(ID, description: str, creator, fee):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    # check that msg.sender is one of our function contracts
    if(self.Info[ID].creator == 0):
        save(self.Info[ID].description[0], description, chars=len(description))
        self.Info[ID].descriptionLength = len(description)
        self.Info[ID].creationFee = fee
        self.Info[ID].creator = creator
        return(1)
    else:
        return(0)
inset('refund.se')

# Storage of all data associated with reporters
    # Reporting index is the branchID
    # Reporters index is the rep. address
    # We 0 index reputation so can walk thru for consensus - todo / wrong don't need 0 indexing anymore
    # RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
    # total rep is all the rep in augur
    # active rep is the amount which is actually active
    # fork is the child branch of a parent which forked
    # dormant rep stores dormant rep values
data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep, dormantRep[](repValue, reporterID), activeRep, fork)

data whitelists[](addresses[], taken)


def checkWhitelist(address):
    refund()
    return(self.whitelists[msg.sender].addresses[address])

def getActiveRep(branch):
    return(self.Reporting[branch].activeRep)
    
def adjustActiveRep(branch, amount):
    self.Reporting[branch].activeRep += amount
    return(1)

def setFork(branch):
    self.Reporting[branch].fork = branch
    return(1)
    
def getFork(branch):
    return(self.Reporting[branch].fork)

def checkContractWhitelist(contract, address):
    refund()
    return(self.whitelists[contract].addresses[address])

def setWhitelist(contract, addresses:arr):
    refund()
    if self.whitelists[contract].taken:
        return(text("ERROR: you have to vote to change a whitelist"):str)
    else:
        self.whitelists[contract].taken = 1
        i = 0
        l = len(addresses)
        while i <l:
            address = addresses[i]
            self.whitelists[contract].addresses[addresses] = 1
            i += 1
        return(text("SUCCESS"):str)

# @return reputation value
def getRepByIndex(branch, repIndex):
    refund()
    return(self.Reporting[branch].reputation[repIndex].repValue)

# @return reputation value
def getRepBalance(branch, address):
    refund()
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].reputation[repIndex].repValue)

def getDormantRepByIndex(branch, repIndex):
    refund()
    return(self.Reporting[branch].dormantRep[repIndex].repValue)

# @return reputation value
# getDormantRepBalance
def balanceOf(branch, address):
    refund()
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].dormantRep[repIndex].repValue)
    
# return total supply of dormant rep
def totalSupply(branch):
    return((self.Reporting[branch].totalRep - self.Reporting[branch].activeRep))

def getReporterID(branch, index):
    refund()
    return(self.Reporting[branch].reputation[index].reporterID)

def getTotalRep(branch):
    refund()
    return(self.Reporting[branch].totalRep)

# will return 0s for array values after it's looped through all the ones you
# have an actual balance in
def getReputation(address):
    refund()
    branchListCount = self.getNumBranches()
    if(address):
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    else:
        address = msg.sender
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    return(branches: arr)

def getNumberReporters(branch):
    refund()
    return(self.Reporting[branch].numberReporters)

def repIDToIndex(branch, repID):
    refund()
    return(self.Reporting[branch].repIDtoIndex[repID])

# check that msg.sender is one of our function contracts
def setInitialReporters(parent, branchID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # add branch as a "reporter"
    self.Reporting[branchID].numberReporters = 1
    self.Reporting[branchID].repIDtoIndex[branchID] = 0
    self.Reporting[branchID].reputation[0].repValue = 0
    self.Reporting[branchID].reputation[0].reporterID = branchID
    return(1)

def addReporter(branch, sender, amount, dormant, repToBonderOrBranch):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    refund()
    reporterIndex = self.Reporting[branch].numberReporters
    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex
    self.Reporting[branch].reputation[reporterIndex].repValue = amount
    self.Reporting[branch].reputation[reporterIndex].reporterID = sender
    self.Reporting[branch].dormantRep[reporterIndex].reporterID = sender
    self.Reporting[branch].dormantRep[reporterIndex].repValue = dormant
    self.Reporting[branch].activeRep += amount + repToBonderOrBranch
    self.Reporting[branch].totalRep += amount + dormant + repToBonderOrBranch
    self.Reporting[branch].numberReporters += 1
    return(1)

def addRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue += value
    return(1)

def subtractRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue -= value
    return(1)

def setRep(branch, index, newRep):
    refund()
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    oldRep = self.Reporting[branch].reputation[index].repValue
    self.Reporting[branch].reputation[index].repValue = newRep
    self.Reporting[branch].activeRep += newRep - oldRep
    self.Reporting[branch].totalRep += newRep - oldRep
    return(1)

def addDormantRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue += value
    return(1)

def subtractDormantRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue -= value
    return(1)

# check that msg.sender is one of our function contracts
# Sets the initial distribution of rep
def setSaleDistribution(addresses: arr, balances: arr, branchID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    i = 0
    while i < len(addresses):
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].repValue = balances[i]
        self.Reporting[branchID].dormantRep[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].repIDtoIndex[addresses[i]] = self.Reporting[branchID].numberReporters
        self.Reporting[branchID].numberReporters += 1
        i+=1
    return(1)

inset('refund.se')

macro fx_floor_log2($x):
    with $y = $x / 0x10000000000000000:
        with $lo = 0:
            with $hi = 191:
                with $mid = ($hi + $lo)/2:
                    while (($lo + 1) != $hi):
                        if $y < 2**$mid:
                            $hi = $mid
                        else:
                            $lo = $mid
                        $mid = ($hi + $lo)/2
                    $lo

macro fx_log2_small($x):
    with $result = -0x48A49EAD9B2CD16BE:
        with $temp = $x:
            $result += 0x124DC64B2741E5F083*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x36A569D528A96FF419*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x880785B1DE09970584*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x10AF33C52EB996E92A6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x19FD6E8AC1305DD6D3F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x2086485A91622AE7378*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x210382DF5A3175686B4*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1B58D71F02D9DA4F7B6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1288E14C2FB8C4C1595*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0xA44C5BBEB599D5AB38*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A0E619C630B69BC17*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1AE8CAEA63CF2593A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x7C3EF5A5BFC21BA1F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1BD202FA82B683802*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A90858A0731AD74*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x8CB3CD4376E76EF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA6B8F8E68CD877*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result - 0x5D5316875D9E3*$temp / 0x10000000000000000

macro fx_log2($x):
    with $y = fx_floor_log2($x):
        with $z = $x / 2**$y:
            $y * 0x10000000000000000 + fx_log2_small($z)

macro fx_log($x):
    fx_log2($x) * 0x10000000000000000 / 0x171547652B82FE177

macro fx_exp2_small($x):
    with $result = 0x10000000000000000:
        with $temp = $x:
            $result += 0xB17217F7D1CF79AC*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x3D7F7BFF058B1D56*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xE35846B82505F32*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x276556DF749D7C6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x5761FF9E294A6F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA184897C5558D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xFFE5FE24386C*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x162C023B2A1D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1B5250C02BF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E4D3F1A83*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E87B8E21*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1C768AA3*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x164F0A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result + 0x1B08D3*$temp / 0x10000000000000000

macro fx_exp2($x):
    with $y = $x / 0x10000000000000000:
        with $z = $x % 0x10000000000000000:
            fx_exp2_small($z) * 2**$y

macro fx_exp($x):
    fx_exp2($x * 0x10000000000000000 / 0xB17217F7D1CF79AC)

# Calculates the exponential function given a fixed point [base 2^64] number, so e^x
def fx_exp(x):
    refund()
    return(fx_exp(x))

# Calculates the natural log function given a fixed point [base 2^64] number, so ln(x)
def fx_log(x):
    refund()
    return(fx_log(x))

# Takes the square root of a fixed point number
def sqrt(n):
    refund()
    val = n
    i = 0
    while i < 11:
        val = (val + n*ONE/val)/2
        i += 1
    return val
inset('refund.se')

# Keeps track of data for round two backstop [where everyone reports on something] using event as the index
    # final is whether an event is final
    # bondReturned is whether the bond principle has been returned
    # bondPaid is how much on top of the bond principle has been paid to the bond poster
    # refund is subsidy to pay for round 2 event resolution function call
    # bondPoster is the account which posted the bond
    # original ethicality, outcome, and voteperiod specify the first round of consensus values for ethicality, outcome, and voteperiod, respectively
    # roundTwo states whether an event is a round two event
data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, originalEthicality, final, bondPoster, bondReturned, bondPaid, refund)

# Keeps track of data for the forking backstop [wherein the network is forked into two sets of rep] using event as the index
    # moved is used for stating whether an event has been moved to the winning fork
    # bondPaid is how much on top of the bond principle has been paid to the bond poster
    # bondAmount is the amount of the bond
    # bondPoster is the account which posted the bond
    # forkedOverEthicality states whether the event was forked due to controversy of ethicality
    # originalBranch is the branch the event was originally on
data forking[](bondPoster, bondAmount, forkedOverEthicality, bondPaid, originalBranch, moved)

# Given a branch and a forkPeriod it states which fork the winner was
data resolved[][]

def setRoundTwoRefund(event, amt):
    self.roundTwo[event].refund = amt
    return(1)
    
def doRoundTwoRefund(sender, event):
    send(sender, self.roundTwo[event].refund)
    return(1)

def setForkBondPoster(event, poster):
    self.forking[event].bondPoster = poster
    return(1)

def getForkBondPoster(event):
    return(self.forking[event].bondPoster)

def setForkedOverEthicality(event):
    self.forking[event].forkedOverEthicality = 1
    return(1)

def getForkedOverEthicality(event):
    return(self.forking[event].forkedOverEthicality)
    
def adjForkBondPaid(event, amount):
    self.forking[event].bondPaid += amount
    return(1)

def getForkBondPaid(event):
    return(self.forking[event].bondPaid)

# sets bond amount for a fork bond
def setBondAmount(event, amount):
    self.forking[event].bondAmount = amount
    return(1)

# gets bond amount for a fork bond
def getBondAmount(event):
    return(self.forking[event].bondAmount)

def setOriginalBranch(event, branch):
    self.forking[event].originalBranch = branch
    return(1)

def getOriginalBranch(event):
    return(self.forking[event].originalBranch)
    
def setMoved(event):
    self.forking[event].moved = 1
    return(1)

def getMoved(event):
    return(self.forking[event].moved)
    
def setResolved(branch, forkPeriod, winner):
    self.resolved[branch][forkPeriod] = winner
    return(1)

def getResolved(branch, forkPeriod):
    return(self.resolved[branch][forkPeriod])

# gets how much of round 2 bond has been paid back
def getBondPaid(event):
    return(self.roundTwo[event].bondPaid)

# increases how much of round 2 bond has been paid back
def increaseBondPaid(event, amount):
    self.roundTwo[event].bondPaid += amount
    return(1)

# whether a round 2 bond's principle has been returned
def getBondReturned(event):
    return(self.roundTwo[event].bondReturned)
    
def setBondReturned(event):
    self.roundTwo[event].bondReturned = 1
    return(1)

def getRoundTwo(event):
    refund()
    return(self.roundTwo[event].roundTwo)
    
def setRoundTwo(event, roundTwo):
    self.roundTwo[event].roundTwo = roundTwo
    return(1)
    
def getBondPoster(event):
    refund()
    return(self.roundTwo[event].bondPoster)

def setBondPoster(event, bondPoster):
    self.roundTwo[event].bondPoster = bondPoster
    return(1)

# whether a round 2 event is final
def getFinal(event):
    refund()
    return(self.roundTwo[event].final)

def setFinal(event):
    self.roundTwo[event].final = 1
    return(1)
    
def getOriginalOutcome(event):
    refund()
    return(self.roundTwo[event].originalOutcome)

def setOriginalOutcome(event, originalOutcome):
    self.roundTwo[event].originalOutcome = originalOutcome
    return(1)

def getOriginalEthicality(event):
    refund()
    return(self.roundTwo[event].originalEthicality)
    
def setOriginalEthicality(event, ethicality):
    self.roundTwo[event].originalEthicality = ethicality
    return(1)

def getOriginalVotePeriod(event):
    refund()
    return(self.roundTwo[event].originalVotePeriod)

def setOriginalVotePeriod(event, period):
    self.roundTwo[event].originalVotePeriod = period
    return(1)
inset('refund.se')

### This contract keeps track of data associated with reporting periods and the events + reports in them

# This keeps track of info in a period for the events in that period, it takes a branch and votePeriod as params, respectively
    # Events is 0 indexed and stores the events in a period [this allows the client to loop through and detect which events a given user should report on]
    # eventIDToIndex returns an event id for a given index in events
    # requiredEvents states whether a given event is required to be reported on or not [a round2 backstop or a fork event are both required]
    # subsidy is money for paying back a user for calculating the targeted num of reports for an event
    # eventWeight is number of reports on an event in a round 1 event, total rep repord on it in a backstop 1 or fork event
    # repEvent is the amount of rep that has reported on an event
    # lesserReportNum is the number of reports an event should have [the lesser of how many it can afford from fees and how many it should have due to outstanding share value]
    # numberEvents is the total number of events in a given reporting period
    # roundTwoNumEvents is the number of round 2 events in a given reporting period
    # numReqEvents is the number of events that are required to be reported on in a given reporting period
    # numberRemoved is the number of events that no longer have to be reported on in this period [a good example is an event that was resolved early successfully]
    # numEventsToReportOn is the number of events available for reporting on [not including required events] * base number of reporters per event [this is multiplied by a user's periodRepWeight to figure out how many events they should be reporting on in a given period]
    # shareValue is the value of all the outstanding shares from markets that have events expiring in this period 
data periodEventInfo[][](events[], eventIDToIndex[], requiredEvents[], subsidy[], eventWeight[], lesserReportNum[], numberEvents, roundTwoNumEvents, numReqEvents, numberRemoved, numEventsToReportOn, shareValue)

# This keeps track of info in a period for the reporters, it takes a branch and votePeriod as params, respectively
    # Before rep is the amount of active rep a user has before any penalizations for reporting incorrectly
    # After rep is the amount of active rep a user has after all the modifications to their rep at the end of a period [it's initially equal to the before rep]
    # Period dormant rep is how much rep a user has dormant at the start of a period
    # Report hash stores the hash of a report&salt a user submitted for a given report [takes reporter, event as params]
    # Salty encrypted hash stores an encrypted concatenation of the salt and a report: it allows users to easily migrate across devices [takes reporter, event as params]
    # Report is the report a reporter submitted for a given event [takes reporter, event as params]
    # Ethics is the ethicality a reporter submitted for a given event [takes reporter, event as params]
    # numReportsSubmitted is the number of a reports a reporter has submitted for this period
    # periodRepWeight is a weighting used to calculate how many events a reporter should report on in a given period
data reporterPeriodInfo[][](beforeRep[], afterRep[], periodDormantRep[], reportHash[][], saltyEncryptedHash[][], report[][], ethics[][], numReportsSubmitted[], periodRepWeight[])

# This takes a period and event as params (e.g self.modeItems[period][event]) and stores mode data for categorical & scalar event reports
    # reportValue takes a possible reported value [say .72 in fixed point] as a key and the value is how many reports that event has, or in the case of a backstop, how much rep has reported on that event
    # currentMode keeps track of the current mode report for an event or which reportValue key has the highest value of reports/rep reported on it
    # currentModeItems is how many reports or rep reported the current mode has, which is used in determining whether there's a new mode
data modeItems[][](reportValue[], currentMode, currentModeItems)

def getSaltyEncryptedHash(branch, period, reporter, event):
    refund()
    return(self.reporterPeriodInfo[branch][period].saltyEncryptedHash[reporter][event])

def setSaltyEncryptedHash(branch, period, reporter, saltyEncryptedHash, event):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.reporterPeriodInfo[branch][period].saltyEncryptedHash[reporter][event] = saltyEncryptedHash
    return(1)
    
# todo fix sec.
def refundCost(to, value):
    send(to, value)
    return(1)

def getSubsidy(branch, period, event):
    return(self.periodEventInfo[branch][period].subsidy[event])

def getPeriodRepWeight(branch, votePeriod, sender):
    return(self.reporterPeriodInfo[branch][votePeriod].periodRepWeight[sender])

def setPeriodRepWeight(branch, votePeriod, sender, value):
    self.reporterPeriodInfo[branch][votePeriod].periodRepWeight[sender] = value
    return(1)

def getReportHash(branch, period, reporter, event):
    refund()
    return(self.reporterPeriodInfo[branch][period].reportHash[reporter][event])

def setEthicReport(branch, period, event, ethics, sender):
    self.reporterPeriodInfo[branch][period].ethics[sender][event] = ethics
    return(1)

def setReport(branch, period, event, report, sender):
    self.reporterPeriodInfo[branch][period].report[sender][event] = report
    return(1)

def setBeforeRep(branch, period, rep, sender):
    self.reporterPeriodInfo[branch][period].beforeRep[sender] = rep
    return(rep)

def setAfterRep(branch, period, rep, sender):
    self.reporterPeriodInfo[branch][period].afterRep[sender] = rep
    return(rep)

def setPeriodDormantRep(branch, period, rep, sender):
    self.reporterPeriodInfo[branch][period].periodDormantRep[sender] = rep
    return(rep)

def getLesserReportNum(branch, period, event):
    return(self.periodEventInfo[branch][period].lesserReportNum[event])

def getCurrentModeItems(period, event):
    return(self.modeItems[period][event].currentModeItems)

def getCurrentMode(period, event):
    return(self.modeItems[period][event].currentMode)
    
# returns weight of a report value for the mode
def getWeightOfReport(period, event, report):
    return(self.modeItems[period][event].reportValue[report])

def getEthicReport(branch, period, event, sender):
    return(self.reporterPeriodInfo[branch][period].ethics[sender][event])

def getReport(branch, period, event, sender):
    #if(whitelist):
    return(self.reporterPeriodInfo[branch][period].report[sender][event])

def getBeforeRep(branch, period, sender):
    return(self.reporterPeriodInfo[branch][period].beforeRep[sender])

def getAfterRep(branch, period, sender):
    return(self.reporterPeriodInfo[branch][period].afterRep[sender])
    
def getPeriodDormantRep(branch, period, sender):
    return(self.reporterPeriodInfo[branch][period].periodDormantRep[sender])

def getNumReportsSubmitted(branch, votePeriod, sender):
    return(self.reporterPeriodInfo[branch][votePeriod].numReportsSubmitted[sender])

def getEventWeight(branch, votePeriod, eventID):
    return(self.periodEventInfo[branch][votePeriod].eventWeight[eventID])

def getNumRoundTwo(branch, period):
    refund()
    return(self.periodEventInfo[branch][period].roundTwoNumEvents)

def addRoundTwo(branch, period):
    refund()
    self.periodEventInfo[branch][period].roundTwoNumEvents += 1
    return(1)

def getRequired(event, period, branch):
    return(self.periodEventInfo[branch][period].requiredEvents[event])
    
def getNumRequired(branch, period):
    return(self.periodEventInfo[branch][period].numReqEvents)
    
# Return 0 means already required
def setEventRequired(branch, period, event):
    if(self.periodEventInfo[branch][period].requiredEvents[event]==0):
        self.periodEventInfo[branch][period].requiredEvents[event] = 1
        self.periodEventInfo[branch][period].numReqEvents += 1
        return(1)
    else:
        return(0)

# With this function you can get the eventIDs and report on outcomes
# @return all events in a branch and expiration period
def getEvents(branch, period):
    refund()
    numEvents = self.periodEventInfo[branch][period].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.periodEventInfo[branch][period].events[i]
        i += 1
    return(events: arr)
    
def getEventsRange(branch, period, start, end):
    refund()
    numEvents = end-start
    events = array(numEvents)
    i = start
    index = 0
    while i < end:
        events[index] = self.periodEventInfo[branch][period].events[i]
        index += 1
        i += 1
    return(events: arr)
    
def getEventIndex(branch, period, eventID):
    refund()
    return(self.periodEventInfo[branch][period].eventIDToIndex[eventID])

# we should probably make this bonded too
# -1: voting not started
def setNumEventsToReportOn(branch):
    refund()
    # after voting has started
    period = self.getVotePeriod(branch)
    self.periodEventInfo[branch][period].numEventsToReportOn = (self.periodEventInfo[branch][period].numberEvents - self.periodEventInfo[branch][period].numReqEvents - self.periodEventInfo[branch][period].numberRemoved)*self.getBaseReporters(branch)
    return(1)

def getNumEventsToReportOn(branch, period):
    refund()
    return(self.periodEventInfo[branch][period].numEventsToReportOn)

def getShareValue(branch, expIndex):
    refund()
    return(self.periodEventInfo[branch][expIndex].shareValue)

def getNumberEvents(branch, period):
    refund()
    return(self.periodEventInfo[branch][period].numberEvents)

def getEvent(branch, period, eventIndex):
    refund()
    return(self.periodEventInfo[branch][period].events[eventIndex])

# check that msg.sender is one of our function contracts
def addEvent(branch, futurePeriod, eventID, subsidy):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.periodEventInfo[branch][futurePeriod].events[self.periodEventInfo[branch][futurePeriod].numberEvents] = eventID
    self.periodEventInfo[branch][futurePeriod].eventIDToIndex[eventID] = self.periodEventInfo[branch][futurePeriod].numberEvents
    self.periodEventInfo[branch][futurePeriod].numberEvents += 1
    self.periodEventInfo[branch][futurePeriod].subsidy[eventID] += subsidy
    return(1)

def deleteEvent(branch, period, event):
    i = self.periodEventInfo[branch][period].eventIDToIndex[event]
    self.periodEventInfo[branch][period].events[i] = 0
    self.periodEventInfo[branch][period].eventIDToIndex[event] = 0
    return(1)

def removeEvent(branch, period):
    refund()
    self.periodEventInfo[branch][period].numberRemoved += 1
    return(1)

def getNumRemoved(branch, period):
    refund()
    return(self.periodEventInfo[branch][period].numberRemoved)

def adjustPeriodShareValueOutstanding(branch, expIndex, amount):
    refund()
    self.periodEventInfo[branch][expIndex].shareValue += amount
    return(1)

def setReportHash(branch, period, reporter, reportHash, event):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.reporterPeriodInfo[branch][period].reportHash[reporter][event] = reportHash
    return(1)

# called in case an event doesn't get reported on at all in a period
def moveEvent(branch, event):
    if(self.getVotePeriod(branch) > self.getExpiration(event)/self.getPeriodLength(branch) && !self.getUncaughtOutcome(event)):
        # add to next expiration period
        self.addEvent(branch, block.timestamp/self.getPeriodLength(branch), event)
        self.setExpiration(event, block.timestamp)
        return(1)
    else:
        return(0)

def addToWeightOfReport(period, event, report, amount):
    self.modeItems[period][event].reportValue[report] += amount
    return(1)

def setCurrentMode(period, event, mode):
    self.modeItems[period][event].currentMode = mode
    return(1)

# basically setting current mode's weight
def setCurrentModeItems(period, event, modeReport):
    self.modeItems[period][event].currentModeItems = self.modeItems[period][event].reportValue[modeReport]
    return(1)

def setEventWeight(branch, votePeriod, eventID, num):
    self.periodEventInfo[branch][votePeriod].eventWeight[eventID] = num
    return(1)

def countReportAsSubmitted(branch, votePeriod, eventID, sender, weight):
    self.periodEventInfo[branch][votePeriod].eventWeight[eventID] += weight
    self.reporterPeriodInfo[branch][votePeriod].numReportsSubmitted[sender] += 1
    return(1)

def setLesserReportNum(branch, period, event, num):
    self.periodEventInfo[branch][period].lesserReportNum[event] = num
    return(1)
inset('refund.se')

# Storage for branch data
# branch takes a branchID
    # penalized takes for a given period a user / address reported for a certain event and num of events they reported on in that period in total
    # penalizedUpTo is the latest period a user has done the penalization for
    # fees collected states whether for a given period a user collected fees
    # rep collected states whether for a given period a user collected rep
    # base reporters last period is the minimum number of reporters for the last period
data branch[](period[](denominator, penalized[](event[], num, notEnoughReportsPenalized), feesCollected[], feeFirst, periodBalance), penalizedUpTo[], baseReportersLastPeriod)

# refunds keeps track of subsidies for various consensus function calls paid for by the market creator or bonders
data refunds[]

# Keeps track of whether a reporter has been penalized for collusion while reporting
data slashed[][](reporter[])


def getSlashed(branch, votePeriod, reporter):
    return(self.slashed[branch][votePeriod].reporter[reporter])
    
def setSlashed(branch, votePeriod, reporter):
    self.slashed[branch][votePeriod].reporter[reporter] = 1
    return(1)

def setRefund(refunder, amt):
    self.refunds[refunder] = amt
    return(1)
    
def doRefund(sender, refunder):
    send(sender, self.refunds[refunder])
    return(1)

def getBaseReportersLastPeriod(branch):
    return(self.branch[branch].baseReportersLastPeriod)

def setBaseReportersLastPeriod(branch, amount):
    self.branch[branch].baseReportersLastPeriod = amount
    return(1)

# get whether the first fee has been claimed by a reporter yet
def getFeeFirst(branch, period):
    return(self.branch[branch].period[period].feeFirst)

def setFeeFirst(branch, period, val):
    self.branch[branch].period[period].feeFirst = val
    return(1)

def getPeriodBalance(branch, period):
    return(self.branch[branch].period[period].periodBalance)

def setPeriodBalance(branch, period, balance):
    self.branch[branch].period[period].periodBalance = balance

def getPenalizedUpTo(branch, sender):
    return(self.branch[branch].penalizedUpTo[sender])

def setPenalizedUpTo(branch, sender, period):
    self.branch[branch].penalizedUpTo[sender] = period
    return(1)

def getDenominator(branch, period):
    return(self.branch[branch].period[period].denominator)

def increaseDenominator(branch, period, amount):
    self.branch[branch].period[period].denominator += amount
    return(1)

def getFeesCollected(branch, address, period):
    return(self.branch[branch].period[period].feesCollected[address])

def setFeesCollected(branch, address, period):
    self.branch[branch].period[period].feesCollected[address] = 1
    return(1)
    
def getPenalized(branch, period, sender, event):
    return(self.branch[branch].period[period].penalized[sender].event[event])

def setPenalized(branch, period, sender, event):
    self.branch[branch].period[period].penalized[sender].event[event] = 1
    return(1)

def getPenalizedNum(branch, period, sender):
    return(self.branch[branch].period[period].penalized[sender].num)    

def increasePenalizedNum(branch, period, sender, amount):
    self.branch[branch].period[period].penalized[sender].num += amount
    return(1)

def setNotEnoughPenalized(branch, address, period):
    self.branch[branch].period[period].penalized[address].notEnoughReportsPenalized = 1
    return(1)
    
def getNotEnoughPenalized(branch, address, period):
    return(self.branch[branch].period[period].penalized[address].notEnoughReportsPenalized)
    
def getRepRedistributionDone(branch, reporter):
    refund()
    return(repRedistributionDone(branch, reporter))

macro repRedistributionDone($branch, $reporter):
    lastPeriodPenalized = self.branch[$branch].penalizedUpTo[$reporter]
    lastPeriod = self.getVotePeriod($branch)-1
    if(lastPeriod==lastPeriodPenalized):
        1
    else:
        0
inset('refund.se')

# Branches keeps track of data associated with branches in augur
# Branches' index is the hash of the branch (aka branchID)
# currentVotePeriod is the current index in eventsExpDates and tells us which bucket of events are up to be
# voted on in the current vote period (should always be 1 behind block.timestamp/periodlength or current EventsExpDates index)
# currentExpPeriod = (block.timestamp / self.Branches[branch].periodLength)
# currentExpPeriod - 1 is what's up for reporting at any given time
# periodLength is the length in seconds of the branch's reporting period
# parentPeriod is the period the parent was in when the branch was created [useful for claiming rep after a fork]
# baseReporters the number of reporters which report on a market at a minimum
# forkPeriod is the period a branch was last forked over
# eventForkedOver is the event a branch was last forked over
# parent is the parent branch of the given branch
# How to set minimum reporting fee guidelines for reporters, abs. minimum should be calc. as follows:
    #Volume per period * .5 * fee * ev/ebit * 6 >= rep market cap
    #Say ev/ebit or valuation is 15, so:
    #45 * fee * volume per period = rep market cap
    #Want:
        #Rep market cap >> outstanding shares value at all times
# min can be no lower than ~0.0000001 or so otherwise can run into underflow isues
data Branches[](currentVotePeriod, periodLength, markets[], numMarkets, minTradingFee, balance[], creationDate, oracleOnly, parentPeriod, baseReporters, forkPeriod, eventForkedOver, parent)

# first param is the branch, second param is the subcurrency contract
data cash[][]

# keeps track of a list of all branches
data branchList[]
data branchListCount


# call once after uploading (externed method not allowed in init)
def initDefaultBranch():
    refund()
    return(self.initiateOwner(1010101))

# event a branch was most recently forked over
def getEventForkedOver(branch):
    return(self.Branches[branch].eventForkedOver)

def setEventForkedOver(branch, event):
    self.Branches[branch].eventForkedOver = event
    return(1)

def getBaseReporters(branch):
    refund()
    return(self.Branches[branch].baseReporters)
    
def setBaseReporters(branch, num):
    refund()
    self.Branches[branch].baseReporters = num
    return(1)

def getOracleOnly(branch):
    refund()
    return(self.Branches[branch].oracleOnly)

def getVotePeriod(branch):
    refund()
    return(self.Branches[branch].currentVotePeriod)

def getPeriodLength(branch):
    refund()
    return(self.Branches[branch].periodLength)

# branch cash balance at start of period
def setInitialBalance(branch, period, balance):
    refund()
    self.Branches[branch].balance[period] = balance
    return(balance)

def getInitialBalance(branch, period):
    refund()
    return(self.Branches[branch].balance[period])

# @return all markets in a branch
def getMarketsInBranch(branch):
    refund()
    numMarkets = self.Branches[branch].numMarkets
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[i]
        i += 1
    return(markets: arr)
   
   
def getParent(branch):
    return(self.Branches[branch].parent)

# @return all markets in a branch
def getSomeMarketsInBranch(branch, initial, last):
    refund()
    numMarkets = last - initial
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[initial+i]
        i += 1
    return(markets: arr)

def getNumMarketsBranch(branch):
    refund()
    return(self.Branches[branch].numMarkets)

def getMinTradingFee(branch):
    refund()
    return(self.Branches[branch].minTradingFee)

# @return all branches
def getBranches():
    refund()
    b = 0
    numBranches = self.branchListCount
    branches = array(numBranches)
    while b < numBranches:
        branches[b] = self.branchList[b]
        b += 1
    return(branches: arr)

def getNumBranches():
    refund()
    return(self.branchListCount)

def getBranchByNum(branchNumber):
    refund()
    return(self.branchList[branchNumber])

def getCreationDate(ID):
    refund()
    return(self.Branches[ID].creationDate)

# check that msg.sender is one of our function contracts
def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod, parent):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    if(self.Branches[ID].periodLength==0):
        self.Branches[ID].currentVotePeriod = currentVotePeriod
        self.Branches[ID].periodLength = periodLength
        self.Branches[ID].minTradingFee = minTradingFee
        self.branchList[self.branchListCount] = ID
        self.branchListCount += 1
        self.Branches[ID].creationDate = block.timestamp
        self.Branches[ID].parentPeriod = parentPeriod
        self.Branches[ID].oracleOnly = oracleOnly
        self.Branches[ID].parent = parent
        self.Branches[ID].baseReporters = self.Branches[parent].baseReporters
        self.initiateOwner(ID)
        return(1)
    else:
        return(0)

def getParentPeriod(branch):
    refund()
    return(self.Branches[branch].parentPeriod)

def incrementPeriod(branch):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    self.Branches[branch].currentVotePeriod += 1
    return(1)

# check that msg.sender is one of our function contracts
def addMarketToBranch(branch, market):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    numMarkets = self.Branches[branch].numMarkets
    self.Branches[branch].markets[numMarkets] = market
    self.Branches[branch].numMarkets += 1
    return(1)
    
def setForkPeriod(branch):
    self.Branches[branch].forkPeriod = self.Branches[branch].currentVotePeriod
    return(1)
    
# gets the period in which a branch was most recently forked
def getForkPeriod(branch):
    return(self.Branches[branch].forkPeriod)
macro refund():
    if self.test_callstack() != 1: return(-1)
    if(msg.value > 0):
        send(msg.sender, msg.value)

def test_callstack(): return(1)

macro ONE: 2^64

macro WEITOETH: 10^18

macro THREEFOURTHS: 13835058055282163712

macro ONEFOURTH: 2**62

macro ONEHALF: 2**63

macro TWO: 2**65

macro TWENTYFOURHR: 86400

macro throw():
    i = 0
    while(1):
        i += 1
    i
inset('refund.se')

# Markets' index is the marketID, markets stores data about markets [which are able to be traded on] in augur
    # Events is a 0 indexed array of events in the market in the format of
        # [1, event, event, 2, event, 3, event, event, event]
        # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
    # Sharespurchased keeps track of the number of shares purchased for each outcome
        # sharesPurchased states starts at 1 - (same for participants[].shares[] array)
    # Participants is an array of participants, their addresses as keys and the shares in each outcome they've purchased of an event as the values
        # e.g. participants[addr].shares[1]
    # currentParticipant is the number of participants [traders] in the market
    # cumulativeScale == range of the market for scalars
    # numOutcomes is the number of outcomes in a market [up to 8 for now]
    # a binary outcome state 1 is no, 2 is true, 0 if not done, 1.5 if indeterminate
    # tradingFee is a percent in fixedPoint and the base trading fee for a market: takers pay 100%-150% of this, makers pay 0-50% of this
    # tradingPeriod is which eventExpPeriod market expires in
    # pushing forward is whether a market has been pushed forward to attempt early resolution
    # bondsman is the person/address who/that posted the early resolution bond
    # originalPeriod is the original period the market's event would resolve in
    # trade_ids stores trades for a given market
    # last_trade is the last trade that happened in a given market
    # total_trades is the total number of trades in a give market
    # tags are the subject tags / categories / keywords for a given market
    # makerFees - from 0-50% - amount of fee that the maker orders pay
    # extraInfo is any extra info that didn't fit well in the regular description
    # sharesValue is the value of the shares traded in a given market
    # gasSubsidy is paid by the creator to pay for closing the market [closing is just setting the winning outcomes and allowing people to withdraw funds if they own winning shares]
    # fees is total amount of fees a market has paid to a branch [the reporters]
    # lastExpDate is when the market's last event expires
    # prices keeps track of the latest traded price for a given outcome in a market
data Markets[](events[], lenEvents, sharesPurchased[], participants[](shares[]), winningOutcomes[], cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch, volume, pushingForward, bondsMan, originalPeriod, trade_ids[](id, next_id, prev_id), last_trade, total_trades, tag1, tag2, tag3, makerFees, extraInfo[], extraInfoLen, sharesValue, gasSubsidy, fees, creationTime, lastExpDate, prices[])

# takes branch as param, composite hash of all markets in the system
data marketsHash[]

def getMarketsHash(branch):
    return(self.marketsHash[branch])

def addToMarketsHash(branch, newHash):
    x = array(2)
    x[0] = self.marketsHash[branch]
    x[1] = newHash
    self.marketsHash[branch] = sha3(x, items=2)
    return(1)

def addFees(market, amount):
    self.Markets[market].fees += amount
    return(1)

def setPrice(market, outcome, price):
    self.Markets[market].prices[outcome] = price
    return(1)

# refund closing cost for a market
def refundClosing(market, to):
    subsidy = self.Markets[market].gasSubsidy
    self.Markets[market].gasSubsidy -= subsidy
    send(subsidy, to)
    return(1)

def getLastExpDate(market):
    return(self.Markets[market].lastExpDate)

def getLastOutcomePrice(market, outcome):
    return(self.Markets[market].prices[outcome])

def getFees(market):
    return(self.Markets[market].fees)

def getMakerFees(market):
    return(self.Markets[market].makerFees)

def getgasSubsidy(market):
    return(self.Markets[market].gasSubsidy)

def getSharesValue(market):
    return(self.Markets[market].sharesValue)

def returnTags(market):
    tags = array(3)
    tags[0] = self.Markets[market].tag1
    tags[1] = self.Markets[market].tag2
    tags[2] = self.Markets[market].tag3
    return(tags: arr)

def getTotalSharesPurchased(market):
    refund()
    total = 0
    n = self.Markets[market].numOutcomes
    i = 1
    while i <= n:
      total += self.Markets[market].sharesPurchased[i]
      i += 1
    return(total)

def getMarketEvent(market, index):
    refund()
    return(self.Markets[market].events[index])

def getCreationTime(market):
    return(self.Markets[market].creationTime)

def getMarketEvents(market):
    refund()
    return(load(self.Markets[market].events[0], items=self.Markets[market].lenEvents): arr)

def getSharesPurchased(market, outcome):
    refund()
    return(self.Markets[market].sharesPurchased[outcome])

def getExtraInfo(market):
    refund()
    length=self.Markets[market].extraInfoLen
    return(load(self.Markets[market].extraInfo[0], chars=length): str)

def getVolume(market):
    refund()
    return(self.Markets[market].volume)

def getParticipantSharesPurchased(market, trader, outcome):
    refund()
    return(self.Markets[market].participants[trader].shares[outcome])

def getNumEvents(market):
    refund()
    return(self.Markets[market].lenEvents)

def getCumScale(market):
    refund()
    return(self.Markets[market].cumulativeScale)

def getMarketNumOutcomes(market):
    refund()
    return(self.Markets[market].numOutcomes)

def getTradingPeriod(market):
    refund()
    return(self.Markets[market].tradingPeriod)

def getOriginalTradingPeriod(market):
    refund()
    return(self.Markets[market].originalPeriod)

def setTradingPeriod(market, period):
    refund()
    self.Markets[market].tradingPeriod = period
    return(1)

def getTradingFee(market):
    refund()
    return(self.Markets[market].tradingFee)

def getBranchID(market):
    refund()
    return(self.Markets[market].branch)

macro market($marketID):
    self.Markets[$marketID]

macro cumScale($marketID):
    market($marketID).cumulativeScale

macro numOutcomes($marketID):
    market($marketID).numOutcomes

macro sharesPurchased($marketID):
    market($marketID).sharesPurchased

# check that msg.sender is one of our function contracts
def initializeMarket(marketID, events: arr, tradingPeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumScale, numOutcomes, extraInfo: str, gasSubsidy, creationFee, lastExpDate):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # add event list to the market
    save(self.Markets[marketID].events[0], events, items=len(events))
    self.Markets[marketID].lenEvents = len(events)
    save(self.Markets[marketID].extraInfo[0], extraInfo, chars=len(extraInfo))
    self.Markets[marketID].extraInfoLen = len(extraInfo)
    self.Markets[marketID].tradingPeriod = tradingPeriod
    self.Markets[marketID].originalPeriod = tradingPeriod
    self.Markets[marketID].tradingFee = tradingFee
    self.Markets[marketID].branch = branch
    self.Markets[marketID].cumulativeScale = cumScale
    self.Markets[marketID].numOutcomes = numOutcomes
    self.Markets[marketID].tag1 = tag1
    self.Markets[marketID].tag2 = tag2
    self.Markets[marketID].gasSubsidy = gasSubsidy
    self.Markets[marketID].tag3 = tag3
    self.Markets[marketID].makerFees = makerFees
    self.Markets[marketID].fees = creationFee
    self.Markets[marketID].creationTime = block.timestamp
    self.Markets[marketID].lastExpDate = lastExpDate
    return(1)

def modifyShares(marketID, outcome, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    sharesPurchased(marketID)[outcome] += amount
    return(1)
    
def modifySharesValue(marketID, amount):
    self.Markets[marketID].sharesValue += amount
    return(1)

def modifyParticipantShares(marketID, trader, outcome, amount, cancel):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Markets[marketID].participants[trader].shares[outcome] += amount
    if(amount<0):
        amount = amount*-1
    if(cancel):
        amount = -1*amount
    self.Markets[marketID].volume += amount
    return(1)   

def setWinningOutcomes(market, outcomes: arr):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # largest # of winning outcomes is 8
    save(self.Markets[market].winningOutcomes[0], outcomes, items=len(outcomes))
    return(1)

def getWinningOutcomes(market):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good, if not, log
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # largest # of winning outcomes is 8
    return(load(self.Markets[market].winningOutcomes[0], items=8): arr)
    
def getOneWinningOutcome(market, num):
    refund()
    # whitelist
    return(self.Markets[market].winningOutcomes[num])

def setTradingFee(market, fee):
    refund()
    self.Markets[market].tradingFee = fee
    return(fee)

def setPushedForward(market, bool, sender):
    refund()
    self.Markets[market].pushingForward = bool
    self.Markets[market].bondsMan = sender
    return(1)

def getPushedForward(market):
    refund()
    return(self.Markets[market].pushingForward)

def getBondsMan(market):
    refund()
    return(self.Markets[market].bondsMan)

def getLastTrade(market):
    refund()
    return(self.Markets[market].last_trade)
    
def addTrade(market, trade_id, last_id):
    refund()
    self.Markets[market].trade_ids[last_id].next_id = trade_id
    self.Markets[market].trade_ids[trade_id].prev_id = last_id
    self.Markets[market].trade_ids[trade_id].id = trade_id
    self.Markets[market].last_trade = trade_id
    self.Markets[market].total_trades += 1
    return(1)
    
def remove_trade_from_market(market_id, trade_id):
    refund()
    prev_id = self.Markets[market_id].trade_ids[trade_id].prev_id
    next_id = self.Markets[market_id].trade_ids[trade_id].next_id
    if prev_id and next_id:
        self.Markets[market_id].trade_ids[prev_id].next_id = next_id
        self.Markets[market_id].trade_ids[next_id].prev_id = prev_id
    elif prev_id:
        self.Markets[market_id].last_trade = prev_id
        self.Markets[market_id].trade_ids[prev_id].next_id = 0

    if next_id:
        self.Markets[market_id].trade_ids[trade_id].next_id = 0
    if prev_id:
        self.Markets[market_id].trade_ids[trade_id].prev_id = 0
    self.Markets[market_id].trade_ids[trade_id].id = 0
    self.Markets[market_id].total_trades -= 1
    return(1)

def get_trade_ids(market_id):
    refund()
    trades_count = self.Markets[market_id].total_trades
    trade_id = self.Markets[market_id].last_trade
    trade_ids = array(trades_count)

    i = 0
    while i < trades_count:
        trade_ids[i] = self.Markets[market_id].trade_ids[trade_id].id
        trade_id = self.Markets[market_id].trade_ids[trade_id].prev_id
        i += 1

    if trade_ids:
        return(trade_ids:arr)
    return([FAILURE]:arr)
    
def get_total_trades(market_id):
    refund()
    return(self.Markets[market_id].total_trades)

def getSender():
    return(msg.sender)

inset('refund.se')

macro TRADE_FIELDS: 8
macro EVENTS_FIELDS: 6
macro OUTCOMES_FIELDS: 2
macro WINNING_OUTCOMES_FIELDS: 8
macro BASE_FIELDS: 17

def getOrderBook(marketID):
    refund()
    numTrades = self.get_total_trades(marketID)
    trades = self.get_trade_ids(marketID, outitems=numTrades)
    orderBook = array(TRADE_FIELDS*numTrades)
    i = 0
    while i < numTrades:
        tradeInfo = self.get_trade(trades[i], outitems=TRADE_FIELDS)
        j = 0
        while j < 8:
            orderBook[8*i + j] = tradeInfo[j]
            j += 1
        i += 1
    return(orderBook:arr)

def getMarketInfo(marketID):
    refund()
    index = BASE_FIELDS
    descriptionLength = self.getDescriptionLength(marketID)
    numEvents = self.getNumEvents(marketID)
    numOutcomes = self.getMarketNumOutcomes(marketID)
    marketInfo = array(BASE_FIELDS + numEvents*EVENTS_FIELDS + numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1)
    marketInfo[0] = marketID
    # marketInfo[1] = self.getCurrentParticipantNumber(marketID)
    marketInfo[2] = self.getMakerFees(marketID)
    # marketInfo[3] = self.getParticipantNumber(marketID, msg.sender)
    marketInfo[4] = numOutcomes
    marketInfo[5] = self.getTradingPeriod(marketID)
    marketInfo[6] = self.getTradingFee(marketID)
    marketInfo[7] = self.getBranchID(marketID)
    marketInfo[8] = numEvents
    marketInfo[9] = self.getCumScale(marketID)
    marketInfo[10] = self.getCreationTime(marketID)
    marketInfo[11] = self.getVolume(marketID)
    marketInfo[12] = self.getCreationFee(marketID)
    marketInfo[13] = self.getCreator(marketID)
    tags = slice(self.returnTags(marketID, outitems=3), items=0, items=3)
    marketInfo[14] = tags[0]
    marketInfo[15] = tags[1]
    marketInfo[16] = tags[2]

    # gather event(s) info:
    # [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]
    events = slice(self.getMarketEvents(marketID, outitems=numEvents), items=0, items=numEvents)
    i = 0
    while i < numEvents:
        eventInfo = self.getEventInfo(events[i], outitems=EVENTS_FIELDS)
        marketInfo[index + i*EVENTS_FIELDS] = events[i]
        j = 1
        while j < EVENTS_FIELDS:
            marketInfo[index + i*EVENTS_FIELDS + j] = eventInfo[j]
            j += 1
        i += 1
    index += numEvents*EVENTS_FIELDS

    # gather outcomes info: [sharesPurchased, price], winningOutcomes
    # (price of outcome = last trade)
    numTrades = self.get_total_trades(marketID)
    trades = self.get_trade_ids(marketID, outitems=numTrades)
    k = 0
    while k < numOutcomes:
        marketInfo[index + k*OUTCOMES_FIELDS] = self.getSharesPurchased(marketID, k + 1)
        i = 0
        marketInfo[index + k*OUTCOMES_FIELDS + 1] = self.getLastOutcomePrice(market, k + 1)
        k += 1
    index += numOutcomes*OUTCOMES_FIELDS
    winningOutcomes = slice(self.getWinningOutcomes(marketID, outitems=8), items=0, items=8)
    k = 0
    while k < WINNING_OUTCOMES_FIELDS:
        marketInfo[index + k] = winningOutcomes[k]
        k += 1
    index += WINNING_OUTCOMES_FIELDS

    # append description character codes
    marketInfo[index] = descriptionLength
    index += 1
    description = self.getDescription(marketID, outchars=descriptionLength)
    c = 0
    while c < descriptionLength:
        marketInfo[index + c] = getch(description, c)
        c += 1
    return(marketInfo: arr)

def batchGetMarketInfo(marketIDs: arr):
    refund()
    numMarkets = len(marketIDs)
    totalLength = 0
    marketInfoLength = array(numMarkets)
    i = 0
    while i < numMarkets:
        marketID = marketIDs[i]
        descriptionLength = self.getDescriptionLength(marketID)
        numEvents = self.getNumEvents(marketID)
        numOutcomes = self.getMarketNumOutcomes(marketID)
        marketInfoLength[i] = BASE_FIELDS + numEvents*EVENTS_FIELDS + numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 2
        totalLength += marketInfoLength[i]
        i += 1
    marketsInfo = array(totalLength)
    index = 0
    i = 0
    while i < numMarkets:
        marketInfo = self.getMarketInfo(marketIDs[i], outitems=marketInfoLength[i] - 1)
        marketsInfo[index] = marketInfoLength[i]
        j = 0
        while j < marketInfoLength[i] - 1:
            marketsInfo[index + j + 1] = marketInfo[j]
            j += 1
        index += marketInfoLength[i]
        i += 1
    return(marketsInfo: arr)

def getMarketsInfo(branch, offset, numMarketsToLoad):
    refund()
    numMarkets = self.getNumMarketsBranch(branch)
    if numMarketsToLoad == 0:
        numMarketsToLoad = numMarkets
    marketIDs = slice(self.getMarketsInBranch(branch, outitems=numMarkets), items=0, items=numMarkets)
    totalLen = numMarketsToLoad*11
    m = 0
    while m < numMarketsToLoad:
        totalLen += self.getDescriptionLength(marketIDs[m + offset])
        m += 1
    marketsInfo = array(totalLen + 1)
    m = 0
    c = 1
    totalMarkets = min(numMarketsToLoad, numMarkets)
    marketsInfo[0] = totalMarkets
    while m < totalMarkets:
        marketID = marketIDs[m + offset]
        descriptionLength = self.getDescriptionLength(marketID)
        marketsInfo[c] = 11 + descriptionLength
        marketsInfo[c + 1] = marketID
        marketsInfo[c + 2] = self.getTradingPeriod(marketID)
        marketsInfo[c + 3] = self.getTradingFee(marketID)
        marketsInfo[c + 4] = self.getCreationTime(marketID)
        marketsInfo[c + 5] = self.getVolume(marketID)
        tags = slice(self.returnTags(marketID, outitems=3), items=0, items=3)
        marketsInfo[c + 6] = tags[0]
        marketsInfo[c + 7] = tags[1]
        marketsInfo[c + 8] = tags[2]
        marketsInfo[c + 9] = self.getLastExpDate(marketID)
        marketsInfo[c + 10] = self.getMakerFees(marketID)
        description = self.getDescription(marketIDs[m + offset], outchars=descriptionLength)
        c += 11
        d = 0
        while d < descriptionLength:
            marketsInfo[c] = getch(description, d)
            c += 1
            d += 1
        m += 1
    return(marketsInfo: arr)

inset('refund.se')

# Keeps track of data about events in augur
# Events' index is the eventID
# so max-min/numOutcomes is interval between outcomes (useful for ui for categoricals, e.g. 1 is >50, 2 is >100, etc.)
# markets keeps track of the markets associated with an event
# threshold is the min "random" sha threshold for reporting on an event used in the scenario where no one reports on an event
# mode is the mode reported value for a given event [only on categorical / scalar events]
# uncaughtOutcome is the average reported value for a binary event
# ethical is the ethicality for a given event
# originalExp is original expiry date in the case an event was pushed back and the expiration date gets changed - both are in epoch time
# pushedUp states that an event was pushed forward to attempt early resolution
# rejected states that a pushed forward market's event [so one that attempted to resolve before it was expired] got rejected and shouldn't have actually been pushed forward
    # rejectedPeriod is the period such an event was pushed forward to and failed to be resolved in
# bond is the indeterminate bond that's taken away if an event is reported on as indeterminate
# forked is whether an event was the event a branch was forked over
# forkOver is whether the event that was forked over is resolved
# forkOutcome is the outcome of an event that was forked over
# forkEthicality is the ethicality of an event that was forked over
# resolutionSource is a string with the recommended source for resolving a market
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes, markets[], numMarkets, threshold, mode, uncaughtOutcome, ethical, originalExp, rejected, rejectedPeriod, bond, forked, forkOver, forkOutcome, forkEthicality, resolutionSource[], resolutionSourceLength, pushedUp, reportersPaidSoFarForEvent)

# Keeps track of number of events created in the past 24 hours
data past24Hours[]

def getReportersPaidSoFar(event):
    return(self.Events[event].reportersPaidSoFarForEvent)

def addReportersPaidSoFar(event):
    self.Events[event].reportersPaidSoFarForEvent += 1
    return(1)

def getEventPushedUp(event):
    return(self.Events[event].pushedUp)
    
def setEventPushedUp(event, val):
    self.Events[event].pushedUp = val
    return(1)

def getForkOutcome(event):
    return(self.Events[event].forkOutcome)

def setForkOutcome(event, value):
    self.Events[event].forkOutcome = value
    return(1)
    
def getForkEthicality(event):
    return(self.Events[event].forkEthicality)

def setForkEthicality(event, value):
    self.Events[event].forkEthicality = value
    return(1)

def getForked(event):
    return(self.Events[event].forked)

def setForked(event):
    self.Events[event].forked = 1
    return(1)
    
def setForkDone(event):
    self.Events[event].forkOver = 1
    return(1)
    
def getForkedDone(event):
    return(self.Events[event].forkOver)

def getEventResolution(event):
    resLen = self.Events[event].resolutionSourceLength
    return(load(self.Events[event].resolutionSource[0], chars=resLen): str)

def getEventInfo(event):
    refund()
    eventinfo = array(7)
    eventinfo[0] = self.Events[event].branch
    eventinfo[1] = self.Events[event].expirationDate 
    eventinfo[2] = self.Events[event].outcome
    eventinfo[3] = self.Events[event].minValue
    eventinfo[4] = self.Events[event].maxValue
    eventinfo[5] = self.Events[event].numOutcomes
    eventinfo[6] = self.Events[event].bond
    return(eventinfo: arr)
    
def getResolution(event):
    refund()
    length=self.Events[event].resolutionSourceLength
    return(load(self.Events[event].resolutionSource[0], chars=length): str)

def getPast24(period):
    refund()
    return(self.past24Hours[period])

def addPast24(period):
    refund()
    self.past24Hours[period] += 1
    return(1)

def getEventBranch(event):
    refund()
    return(self.Events[event].branch)

def getExpiration(event):
    refund()
    return(self.Events[event].expirationDate)

def getOriginalExpiration(event):
    refund()
    return(self.Events[event].originalExp)
    
def setOriginalExpiration(event, date):
    self.Events[event].originalExp = date
    return(1)

def setExpiration(event, date):
    refund()
    self.Events[event].expirationDate = date
    return(1)

def setBranch(event, branch):
    self.Events[event].branch = branch
    return(1)

def getOutcome(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].outcome)

def getEthics(event):
    refund()
    return(self.Events[event].ethical)

def setEthics(event, ethicality):
    refund()
    self.Events[event].ethical = ethicality
    return(ethicality)

def getEthical(event):
    refund()
    return(self.Events[event].ethical)

def getMinValue(event):
    refund()
    return(self.Events[event].minValue)

def getMaxValue(event):
    refund()
    return(self.Events[event].maxValue)

def getNumOutcomes(event):
    refund()
    return(self.Events[event].numOutcomes)

def setUncaughtOutcome(event, outcome):
    refund()
    self.Events[event].uncaughtOutcome = outcome
    return(1)

def getUncaughtOutcome(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].uncaughtOutcome)

def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes, resolution: str):
    refund()
    # check that msg.sender is one of our function contracts
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    if(self.Events[ID].expirationDate==0):
        self.Events[ID].branch = branch
        self.Events[ID].expirationDate = expirationDate
        self.Events[ID].originalExp = expirationDate
        self.Events[ID].minValue = minValue
        self.Events[ID].maxValue = maxValue
        self.Events[ID].numOutcomes = numOutcomes
        save(self.Events[ID].resolutionSource[0], resolution, chars=len(resolution))
        return(1)
    else:
        return(0)

def setBond(event, bond):
    refund()
    self.Events[event].bond = bond
    return(1)

def addMarket(event, marketID):
    refund()
    self.Events[event].markets[self.Events[event].numMarkets] = marketID
    self.Events[event].numMarkets += 1
    return(1)

def getBranch(event):
    return(self.Events[event].branch)

def getBond(event):
    refund()
    return(self.Events[event].bond)

def getMarkets(event):
    refund()
    i = 0
    markets = array(self.Events[event].numMarkets)
    while i < self.Events[event].numMarkets:
        markets[i] = self.Events[event].markets[i]
        i += 1
    return(markets: arr)
    
def getMarket(event, marketIndex):
    refund()
    return(self.Events[event].markets[marketIndex])

def getNumMarkets(event):
    refund()
    return(self.Events[event].numMarkets)

def setOutcome(ID, outcome):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.Events[ID].outcome = outcome
    return(1)

def getReportingThreshold(event):
    refund()
    return(self.Events[event].threshold)
    
def setThreshold(event, threshold):
    # do whitelist
    self.Events[event].threshold = threshold
    return(1)

def getMode(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].mode)

def setMode(event, mode):
    refund()
    self.Events[event].mode = mode
    return(1)

def setRejected(event, period):
    refund()
    self.Events[event].rejected = 1
    self.Events[event].rejectedPeriod = period
    return(1)

def getRejected(event):
    refund()
    return(self.Events[event].rejected)

def getRejectedPeriod(event):
    refund()
    return(self.Events[event].rejectedPeriod)
inset('refund.se')

### Storage of all data associated with trades

# reporterID is index
data tradeCommits[](hash, block)
# tradeID is index
data trades[](id, type, market, amount, price, owner, block, outcome)

def makeTradeHash(max_value, max_amount, trade_ids: arr):
    refund()
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeInfo[2] = max_value
    tradeHash = sha3(tradeInfo, items=3)
    return(tradeHash)

def commitTrade(hash):
    refund()
    self.tradeCommits[msg.sender].hash = hash
    self.tradeCommits[msg.sender].block = block.number
    return(1)

def zeroHash():
    refund()
    self.tradeCommits[msg.sender].hash = 0
    return(1)

def checkHash(tradeHash, sender):
    refund()
    if(self.tradeCommits[sender].hash != tradeHash || block.number <= self.tradeCommits[sender].block):
        return(-1)
    else:
        return(1)
        
def getID(tradeID):
    refund()
    return(self.trades[tradeID].id)
    
def saveTrade(trade_id, type, market, amount, price, sender, outcome):
    refund()
    self.trades[trade_id].id = trade_id
    self.trades[trade_id].type = type
    self.trades[trade_id].market = market
    self.trades[trade_id].amount = amount
    self.trades[trade_id].price = price
    self.trades[trade_id].owner = sender
    self.trades[trade_id].block = block.number
    self.trades[trade_id].outcome = outcome
    return(1)

def get_trade(id):
    refund()
    trade = array(8)
    trade[0] = self.trades[id].id
    trade[1] = self.trades[id].type
    trade[2] = self.trades[id].market
    trade[3] = self.trades[id].amount
    trade[4] = self.trades[id].price
    trade[5] = self.trades[id].owner
    trade[6] = self.trades[id].block
    trade[7] = self.trades[id].outcome
    if trade:
        return(trade:arr)
    return([0]:arr)    

def get_amount(id):
    refund()
    return(self.trades[id].amount)
    
def get_price(id):
    refund()
    return(self.trades[id].price)

def update_trade(id, price):
    refund()
    self.trades[id].price = price
    self.trades[id].block = block.number

def remove_trade(id):
    refund()
    self.trades[id].id = 0
    self.trades[id].type = 0
    self.trades[id].market = 0
    self.trades[id].amount = 0
    self.trades[id].price = 0
    self.trades[id].owner = 0
    self.trades[id].block = 0
    self.trades[id].outcome = 0
    return(1)
    
def fill_trade(trade_id, fill):
    refund()
    self.trades[trade_id].amount -= fill
    return(1)
inset('refund.se')

# address -> value map of "cash [a made up subcurrency/token for testing"
data cashcoinBalances[]

# address -> address mapping of a cash address to the address that owns it
data owners[]


# @return: cash balance of address
def balance(address):
    refund()
    return(self.cashcoinBalances[address])

# A random market could have a balance, and when that account was created/first used in the subcurrency, it'd have whatever contract that created it be the owner, so for example...
# needs to be called when making a market, branch, etc. or a new cash user acc.
def initiateOwner(account):
    refund()
    if(self.owners[account]==0 and self.cashcoinBalances[account]==0):
        self.owners[account] = msg.sender
        return(1)
    else:
        return(0)

# Send cash to a receiver from msg.sender
# should send values as fixed point in UI (1 is ONE, 4 is 4*ONE, .5 is ONEHALF, etc.)
# @return: value sent, 0 if fails
def send(recver, value):
    refund()
    if(self.owners[msg.sender]==0):
        self.owners[msg.sender] = msg.sender
    #if(self.owners[recver]==0):
    #    return(0)
    sender = msg.sender
    senderBalance = self.cashcoinBalances[sender]
    if(senderBalance >= value && value > 0):
        self.cashcoinBalances[sender] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# Sends cash from a user to a receiver
# @return value of cash sent; fail is 0
def sendFrom(recver, value, from):
    refund()
    # sendFrom would check if the sender had an owner, if it did, then it'd check and see if the msg.sender was the owner.
    # it's not owned by a regular account nor a contract owned account (i.e. a market's hash from markets.)
    if(from!=tx.origin and msg.sender!=self.owners[from] and msg.sender!=from):
        return(0)
    #if(self.owners[recver]==0):
    #    return(0)
    senderBalance = self.cashcoinBalances[from]
    if(senderBalance >= value && value > 0):
        self.cashcoinBalances[from] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# make sure only coming from specific contracts
def subtractCash(ID, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    #if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):
    #    return(0)
    self.cashcoinBalances[ID] -= amount
    return(1)

def addCash(ID, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.cashcoinBalances[ID] += amount
    return(1)

def setCash(address, balance):
    refund()
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    self.cashcoinBalances[address] = balance
    return(1)

def depositEther():
    self.cashcoinBalances[msg.sender] += msg.value * ONE / WEITOETH
    return msg.value

def withdrawEther(to, value):
    if(value < 0):
        return(-1)
    if self.cashcoinBalances[msg.sender] >= value * ONE / WEITOETH:
        self.cashcoinBalances[msg.sender] -= value * ONE / WEITOETH
        send(to, value)
        return 1
    else:
        return 0
inset('refund.se')
inset('eventHelpers.se')

macro POINTSEVEN: 12912720851596685312
macro POINTZEROONE: 184467440737095520

# Error -1: Hey, you're not broke!
def cashFaucet():
    refund()
    if self.balance(msg.sender) > 5*ONE:
        return(-1)
    self.setCash(msg.sender, 10000*ONE)
    return(1)

def reputationFaucet(branch):
    refund()
    if self.repIDToIndex(branch, tx.origin) != 0 or self.getReporterID(branch, 0) == tx.origin:
        index = self.repIDToIndex(branch, tx.origin)
    else:
        index = self.getNumberReporters(branch)
        self.addReporter(branch, tx.origin, 0, 0, 0)
    self.setRep(branch, index, 47*ONE)
    self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
    return(1)

def fundNewAccount(branch):
    self.send(self, 0)
    self.reputationFaucet(branch)
    self.setCash(msg.sender, 10000*2^64)
    return(1)

# Used to claim rep on a fork or on a new branch
# Returns 1 if successful, 0 if already claimed
# Error:
    # -1: parent isn't the actual parent
def claimInitialRep(parent, branch):
    refund()
    if(self.getParent(branch)!=parent):
        return(-1)
    # have 1 month to claim
    if(self.repIDToIndex(branch, msg.sender)==0 && block.timestamp < (self.getCreationDate(branch) + TWENTYFOURHR*30)):
        parentPeriod = self.getParentPeriod(branch)
        forkPeriod = self.getForkPeriod(parent)
        fork = self.getFork(parent)
        forkEvent = self.getEventForkedOver(parent)
        report = self.getReport(parent, forkPeriod, forkEvent, msg.sender)
        outcome = self.getUncaughtOutcome(forkEvent)
        if(binary(forkEvent)):
            outcome = catch(outcome)
        ethical = ethic_catch(self.getEthical(forkEvent))
        ethicReport = self.getEthicReport(parent, forkPeriod, forkEvent, msg.sender)
        # todo what if this wasn't set
        rep = self.getBeforeRep(parent, parentPeriod, msg.sender)
        repDecrease = 0
        # if forked and (reported with original consensus or didn't report or (reported with original ethicality and forked over ethicality))
        if(fork && ((report >= (outcome-POINTZEROONE) && report <= (outcome+POINTZEROONE)) || report==0 || (self.getForkedOverEthicality(forkEvent) && ethical==ethicReport))):
            # take away 30% of rep from liars and those who didn't report
            repDecrease = rep - rep*POINTSEVEN/ONE
            rep = rep - repDecrease
            amountLeftToPayBonder = self.getBondAmount(forkEvent) - self.getForkBondPaid(forkEvent)
            if(repDecrease < amountLeftToPayBonder):
                # send all the rep to the fork bond poster
                self.addRep(branch, self.repIDToIndex(branch, self.getForkBondPoster(forkEvent)), repDecrease)
            else:
                # send amountLeftToPayBonder [if positive] to the fork bond poster
                if(amountLeftToPayBonder > 0):
                    self.addRep(branch, self.repIDToIndex(branch, self.getForkBondPoster(forkEvent)), amountLeftToPayBonder)    
                    # send the rest to the new branch's redistribution pool
                    self.addRep(branch, self.repIDToIndex(branch, branch), (repDecrease - amountLeftToPayBonder))
                else:
                    # send to new branch's redistribution pool
                    self.subtractRep(branch, self.repIDToIndex(branch, branch), repDecrease)
        if(fork):
            self.setPenalizedUpTo(branch, msg.sender, forkPeriod)
        else:
            self.setPenalizedUpTo(branch, msg.sender, (self.getVotePeriod(branch)-1))
        # todo this doesn't work if hasn't reported last period
        dormantRep = self.getPeriodDormantRep(parent, self.getParentPeriod(branch), msg.sender)
        self.addReporter(branch, msg.sender, rep, dormantRep, repDecrease)
        return(1)
    else:
        # already claimed or too late
        return(0)
inset('refund.se')

event log_add_tx(market:indexed, sender:indexed, type, price, amount, outcome, tradeid)
event log_cancel(market:indexed, sender:indexed, price, amount, tradeid, outcome, type)

# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 8
# Boolean success/failure
macro SUCCESS: 1
macro FAILURE: 0
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_ALREADY_EXISTS: 21
macro TRADE_SAME_BLOCK_PROHIBITED: 22

macro fee_percent($market_fee, $price, $cumScale):
    4 * $market_fee * $price * (ONE-$price*2**64/$cumScale) / ($cumScale*ONE)

macro save_trade($type, $amount, $price, $market, $outcome, $branch, $fee, $sender):
    trade = [$type, $market, $amount, $price, $sender, block.number, $outcome]
    trade_id = sha3(trade, items=7)
    cumScale = self.getCumScale($market)

    # Save trade
    if !self.getID(trade_id):
        self.saveTrade(trade_id, $type, $market, $amount, $price, $sender, $outcome)
        # Update market
        last_id = self.getLastTrade($market)
        self.addTrade($market, trade_id, last_id)
        # Update available and trading amounts for asks
        if $type == ASK:
            self.modifyParticipantShares($market, msg.sender, $outcome, -$amount, 0)
            if($fee):
                self.sendFrom($market, ($amount * $price * $fee / ONE^2), $sender)
        # Send / escrow cash for bids
        if $type == BID:
            self.sendFrom($market, $amount * $price / ONE, $sender)
            if($fee):
                self.sendFrom($market, ($amount * $price * $fee / ONE^2), $sender)
    else:
        return(TRADE_ALREADY_EXISTS)
    log(type=log_add_tx, $market, $sender, $type, $price, $amount, $outcome, trade_id)
    return(trade_id)

#
# Cancellation: cancels a trade, if a bid refunds money, if an ask returns shares
# @returns 1 if success, 0 if failure
#
# 200k gas
def cancel(trade_id):
    refund()
    # user can cancel anytime
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = self.get_trade(trade_id, outitems=TRADE_FIELDS)
    if !trade:
        return(0)
    type = trade[1]
    market = trade[2]
    amount = trade[3]
    price = trade[4]
    owner = trade[5]
    outcome = trade[7]
    branch = self.getBranchID(market)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    # Check the owner
    if msg.sender == owner:
        # Clear the trade first
        remove_trade(trade_id, market)
        # Issue refunds
        if type == BID:
            # cash refund
            amt = amount * price * (fee + ONE) / ONE^2
            self.subtractCash(market, amt)
            self.addCash(msg.sender, amt)
        elif type == ASK:
            # shares refund
            self.modifyParticipantShares(market, msg.sender, outcome, amount, 1)
            self.subtractCash(market, (amount * price * fee / ONE^2))
            self.addCash(msg.sender, (amount * price * fee / ONE^2))
        # Log cancellation
        log(type=log_cancel, market, msg.sender, price, amount, trade_id, outcome, type)
        return(SUCCESS)
    return(FAILURE)

macro remove_trade($trade_id, $market):
    self.remove_trade($trade_id)
    self.remove_trade_from_market($market, $trade_id)

#
# Buy / Sell actions: puts orders on the book
# Errors:
    #  0: market doesn't exist
    # -1: amount/price bad
    # -2: oracle only branch
    # -3: not enough money or shares
#
# costs 532k gas
# smallest trade value is 0.00000001
def buy(amount, price, market, outcome):
    refund()
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    branch = self.getBranchID(market)
    if(!self.getCreationTime(market)):
        return(0)
    # price cannot be greater than max share value, value traded can't be <.00000001, and value can't be > 2**126 in unfixed point so we don't get overflow issues
    if(price>cumScale or amount*price < 3402823669209384705829531287552 or amount*price >= 2**190):
        return(-1)
    if(self.getOracleOnly(branch)):
        return(-2)
    if(self.balance(msg.sender) < (amount * price * (fee + ONE) / ONE^2)):
        return(-3)
    save_trade(BID, amount, price, market, outcome, branch, fee, msg.sender)
    return(FAILURE)

# costs 532k gas
# smallest trade value is 0.00000001
def sell(amount, price, market, outcome):
    refund()
    branch = self.getBranchID(market)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    # price cannot be greater than max share value, value traded can't be <.00000001, and value can't be > 2**126 in unfixed point so we don't get overflow issues
    if(price>cumScale or amount*price < 3402823669209384705829531287552L or amount*price >= 2**190):
        return(-1)
    if(self.getOracleOnly(branch)):
        return(-2)
    if(self.getParticipantSharesPurchased(market, msg.sender, outcome) < amount):
        return(-3)
    # check for enough money for fees
    if(self.balance(msg.sender) < (amount * price * fee / ONE^2)):
        return(-3)
    save_trade(ASK, amount, price, market, outcome, branch, fee, msg.sender)
    return(FAILURE)
inset('refund.se')

macro ONEPOINTTWO: 22136092888451461120

macro POINTZEROONE: 184467440737095520

macro POINTONE: 1844674407370955264

macro POINTNINE: 16602069666338596864

# Prove both that a reporter voted on less than he/she actually could have and it was <.5 of what they should have reported on using an example event
# The rep lost here is then sent to the branch's rep account and distributed like other redistributed rep.
# Note:
    # Reporters pay an eth bond for this on their first report --- if never called then during collect fees they get it back else it goes back to pay someone who correctly calls this function, so the bond is returned to the poster if not enough penalized is 0 or self.getForkPeriod(branch)+1 == lastPeriod during collect fees [which means it's the first period after a fork is initiated]
# Returns 1 if successful penalization
# Returns 2 if didn't need to be penalized and thus wasn't
# Errors:
    # -1: already done
    # -2: not in right part of period
def proveReporterDidntReportEnough(branch, reporter, eventExample):
    refund()
    lastPeriod = self.getVotePeriod(branch)-1
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(self.getNotEnoughPenalized(branch, reporter, lastPeriod)):
        return(-1)
    if(residual > periodLength/2):
        return(-2)
    # in period just after fork period no reports required
    if(self.getForkPeriod(branch)+1 == lastPeriod):
        self.setNotEnoughPenalized(branch, reporter, lastPeriod)
        return(2)
    # events a user should be reporting on
    # eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2))
    # a^b=exp(b*ln(a))=e^(b*ln(a)).
    prelim = self.getNumEventsToReportOn(branch, lastPeriod)
    # need to do active rep on a period by period basis.. todo
    # switch to period rep weight for expe
    exp = self.fx_exp(ONEPOINTTWO*self.fx_log(self.getBeforeRep(branch, lastPeriod, sender))/ONE)*2**64/self.fx_exp(ONEPOINTTWO*self.fx_log(self.getActiveRep(branch))/ONE)
    baseReporters = self.getBaseReportersLastPeriod(branch)
    # if total [which is mult by num events to report on via the prelim amount] is too high [>1] then numevents will estimate a higher number than reality, so need to correct for this below
    total = exp*baseReporters
    numEvents = exp*prelim + self.getNumRequired(branch, lastPeriod)*ONE
    eventsInPeriod = self.getNumberEvents(branch, lastPeriod)-self.getNumRemoved(branch, lastPeriod)
    if(repConstant >= POINTZEROONE):
        minimum = min(30+self.getNumRequired(branch, lastPeriod), eventsInPeriod)
        if(numEvents/ONE < minimum):
            numEvents = minimum*ONE
    # correction for if people have more than x [4.6% of at 40 min reporters] rep in one account - they report on everything (hence incentive to divy rep into mult. accounts and not pool) i.e. if((exp(ln(rep%)*1.2)+0.001)*40 > 1)
    if(total > ONE):
        numEvents = (self.getNumEventsToReportOn(branch, lastPeriod)/baseReporters)*ONE + self.getNumRequired(branch, lastPeriod)*ONE
    numReportsSubmitted = self.getNumReportsSubmitted(branch, lastPeriod, reporter)
    # reporter couldve reported on event example but didnt
    couldveReported = self.getEventCanReportOn(branch, lastPeriod, reporter, eventExample)
    if(numEvents/2 > numReportsSubmitted*ONE && couldveReported):
        # typically meant for people who did report but not enough [those who didnt at all use pen. catchup] so using before rep is fine, but if not use rep balance
        originalRep = self.getBeforeRep(branch, lastPeriod, reporter)
        if(originalRep==0):
            originalRep = self.getRepBalance(branch, reporter)
        # penalize people
        newRep = POINTONE*numReportsSubmitted*originalRep / numEvents
        oldRep = originalRep*POINTNINE / ONE
        repChange = (oldRep+newRep) - originalRep
        if(repChange > 0):
            return(1)
        # removes rep from reporter who lost it
        self.addRep(branch, self.repIDToIndex(branch, reporter), repChange)
        # sends that rep to the branch rep pool
        self.addRep(branch, self.repIDToIndex(branch, branch), -repChange)
        self.setBeforeRep(branch, lastPeriod, oldRep+newRep, reporter)
        afterRep = self.getAfterRep(branch, lastPeriod, reporter)
        newAfterRep = afterRep + repChange
        if(afterRep==0):
            newAfterRep = oldRep+newRep
        # todo decrease denominator by rep person lost here
        self.setAfterRep(branch, lastPeriod, newAfterRep, reporter)
        self.setNotEnoughPenalized(branch, reporter, lastPeriod)
        self.doRefund(msg.sender, reporter)
        return(1)
    else:
        return(2)
inset('refund.se')

# first param is the market, second param is the subcurrency contract
data cash[][]

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF

macro CATCH_TOLERANCE: ONE / 10


# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

# If ethicality value <.5 it's 0, otherwise it's ethical
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

# Loop through events in the market, get their outcomes && use those to determine the winning outcomes and resolve a market!
# @return 0 if fail/trading not over yet/event not expired or closed already, if success 1
# Error messages otherwise
    # -1: Market has no cash anyway / already closed
    # -2: 0 outcome / not reported on yet
    # -3: not final round 2 event
    # -4: market isn't in branch
    # -5: Event forked and not final yet
    # -6: bonded pushed forward market not ready to be resolved
    # -7: already resolved
# if market's events have moved due to a fork branch param passed should be the new fork [todo check to make sure it handles the wrong branch param properly here]
def closeMarket(branch, market, sender):
    refund()
    tradingPeriod = self.getTradingPeriod(market)
    period = self.getVotePeriod(branch)
    event = self.getMarketEvent(market, 0)
    if(self.balance(market)<=0):
        return(-1)
    if(self.getUncaughtOutcome(event)==0):
        return(-2)
    if(self.getRoundTwo(event) && !self.getFinal(event)):
        return(-3)
    if(self.getBranchID(market)!=branch):
        return(-4)
    # checks whether any events not already resolved
    resolved = 1
    # what if we forked or round 2 won't it be resolved and thus market never gets resolved todo
    if(self.getOutcome(event)==0 && self.getMode(event)==0):
        resolved = 0
    if((period > tradingPeriod) && !resolved):
        # look at through event in the market, get its outcomes, resolve it && use those to determine the winning outcomes for a given market!
        votingPeriodEvent = self.getExpiration(event)/self.getPeriodLength(branch)
        fxpOutcome = self.getOutcome(event)
        resolution = 1
        forkPeriod = self.getForkPeriod(self.getEventBranch(event))
        currentPeriod = block.timestamp / self.getPeriodLength(branch)
        if((self.getForked(event) && !self.getForkedDone(event)) or (currentPeriod <= (forkPeriod+1))):
            return(-5)
        if(binary(event) && fxpOutcome==0):
                resolution = self.resolveBinary(event, market, branch, votingPeriodEvent)
        elif(scalar(event) && self.getMode(event)==0):
                resolution = self.resolveCategoricalOrScalar(self.getMinValue(event), self.getMaxValue(event), event, market, branch, votingPeriodEvent)
        elif(categorical(event) && self.getMode(event)==0):
                resolution = self.resolveCategoricalOrScalar(ONE, ONE*self.getNumOutcomes(event), event, market, branch, votingPeriodEvent)
        if(resolution==-6):
            return(-6)
        winningOutcomes = array(8)
        winningOutcomes = self.determineWinningOutcomes(event, outitems=8)
        self.setWinningOutcomes(market, winningOutcomes)
        # refunds closing cost
        self.refundClosing(market, sender)
        return(1)
    else:
        return(0)

# Claim trading profits/value per share after a market is resolved
# @returns 1 if successful
# Errors:
    # 0: market not resolved
    # -1: trader doesn't exist
    # -8: invalid branch
def claimProceeds(branch, market):
    refund()
    if(self.getBranchID(market)!=branch):
        return(-8)
    tradingPeriod = self.getTradingPeriod(market)
    period = self.getVotePeriod(branch)
    event = self.getMarketEvent(market, 0)
    resolved = 1
    if(self.getOutcome(event)==0 && self.getMode(event)==0):
        resolved = 0
    # as long as it's resolved money can be collected
    if((period > tradingPeriod) && resolved):
        winningOutcomes = array(8)
        winningOutcomes = self.getWinningOutcomes(market, outitems=8)
        outcome = 0
        # market not resolved
        if(winningOutcomes[0]==0):
            return(0)
        if(winningOutcomes[1]==0):
            ethical = ethic_catch(self.getEthical(event))
            # unethical or .5 categorical 1d market is resolved with all outcomes having equal values
            if(categorical(event) && (self.getMode(event)==ONEHALF or !ethical)):
                outcome = self.oneOutcome(market, winningOutcomes[0], msg.sender, 1, self.getNumOutcomes(event))
            # resolves a regular binary market
            else:
                outcome = self.oneOutcome(market, winningOutcomes[0], msg.sender, 0, 0)
        # resolves a scalar market
        elif(winningOutcomes[1]):
            outcome = self.twoOutcomes(market, winningOutcomes, event, msg.sender)
        return(outcome)
    else:
        return(0)

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro binary($event):
    (self.getNumOutcomes($event)==2 and ONE*self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)

macro categorical($event):
    (self.getNumOutcomes($event)>2)
inset('refund.se')

# Create a new branch given a parent branch - a branch is essentially a fork of rep where new markets can be created
# period length is given in seconds
# @return branchID if success
# error messages otherwise
    # -1: bad input or parent doesn't exist
    # -2: no money for creation fee
    # -3: branch already exists
def createSubbranch(description:str, periodLength, parent, minTradingFee, oracleOnly):
    refund()
    if(periodLength<=0 || !self.getPeriodLength(parent) || description==0):
        return(-1)
    if(minTradingFee < 0 or minTradingFee > 2**62):
        return(-1)
    parentPeriod = self.getVotePeriod(parent)
    branchInfo = string(7*32+len(description))
    branchInfo[0] = msg.sender
    #creation fee
    branchInfo[1] = 47*ONE
    #length of voting cycle
    branchInfo[2] = periodLength
    branchInfo[3] = block.timestamp
    branchInfo[4] = parent
    branchInfo[5] = minTradingFee
    branchInfo[6] = oracleOnly
    mcopy(branchInfo + 7*32, description, len(description))
    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash && characteristics && say, "don't trust me? check"
    branchID = sha3(branchInfo, chars=len(branchInfo))
    currentVotePeriod = (block.timestamp / periodLength) - 1
    if(self.balance(msg.sender)<47*ONE):
        return(-2)
    # provided event doesn't already exist, create it
    if(self.getCreator(branchID)==0):
        self.initializeBranch(branchID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod, parent)
    else:
        return(-3)
    # pay creation fee, initialize branch info
    if(self.sendFrom(parent, 47*ONE, msg.sender) && self.setInfo(branchID, description, tx.origin, 47*ONE) && self.setInitialReporters(parent, branchID)):
        return(branchID)
    else:
        return(-2)
inset('refund.se')
inset('eventHelpers.se')
inset('redistributeRep.se')
inset('proportionCorrect.se')
inset('repChange.se')

#event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)

macro POINTZEROONE: 184467440737095520
macro POINTEIGHT: 14757395258967642112
macro POINTTWO: 3689348814741910528
macro POINTFOUR: 7378697629483821056
macro MINBOND: 200*ONE

# Penalizes a reporter for reporting wrongly on a round 2 reporting / backstop 1 event
# So we want to do the rep redistribution for both period 1 and period 2 at this time
# essentially penalizeWrong for backstop 1 [where everyone reports on a given event]
# in a fork this is called on the original branch and event is reported on again on new branch
# Errors:
    #  0: event isn't eligible/up for round two penalization
    # -1: already past first half of new period and needed to penalize before then
    # -2: round two resolve wasn't successful
    # -3: in fork period only thing that rep redistribution is done on is the round 2 event in the original branch via round 2 penalize
    # -4: already done for all events in this period
    # -5: needed to collect fees last period which sets the before/after rep
# force event to be resolved first if it can be
# roundTwoResolve needs to be called for any event here before can be penalized if it's a backstop 1 event, a la close market for other events before being penalized
# todo go over penalty amounts like .2 for ethicality seems too high
def penalizeRoundTwoWrong(branch, event):
    refund()
    lastPeriod = self.getVotePeriod(branch)-1
    lastPenalizationPeriod = lastPeriod - 1
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    newRep = 0
    newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
    repBalance = self.getRepBalance(branch, msg.sender)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)
    forkEvent = self.getEventForkedOver(branch)
    uncaught = self.getUncaughtOutcome(event)
    outcome = catch(uncaught)
    if(scalar(event) or categorical(event)):
        outcome = uncaught
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    oldReport = self.getReport(branch,lastPenalizationPeriod,event,msg.sender)
    ethics = self.getEthicReport(branch, lastPeriod, event, msg.sender)
    oldEthics = self.getEthicReport(branch, lastPenalizationPeriod, event, msg.sender)
    averageAdjudicationCost = self.getInitialBalance(branch, lastPeriod)/self.getNumberEvents(branch, lastPeriod)
    bond = averageAdjudicationCost + self.getSharesValue(market)*(POINTZEROONE + self.getTradingFee(market)/2) / 2**64
    bond = min(bond, MINBOND)
    ethical = self.getEthical(event)
    p = proportionCorrect(event, 0)
    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period
    if(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
        return(-1)
    # if no outcome / event not resolved yet, resolve it [as long as it wasn't an event that was pushed fwd and got rejected and thus hasn't actually resolved yet]
    elif(!self.getOutcome(event)):
        if(self.roundTwoResolve(branch, event, self.getEventIndex(branch, lastPeriod, event), msg.sender)==0):
            return(-2)
    elif(self.getForkPeriod(branch) == lastPeriod && event!=forkEvent):
        return(-3)
    elif(self.getPenalizedUpTo(branch, msg.sender)==lastPeriod):
        return(-4)
    elif(!self.getFeesCollected(branch, msg.sender, lastPeriod)):
        return(-5)
    # if overruled / different outcome after reporting on again
    overruled = 0
    if(scalar(event) or categorical(event)):
        if((self.getOriginalOutcome(event) != self.getUncaughtOutcome(event) or self.getOriginalEthicality(event)!=ethic_catch(ethical))):
            overruled = 1
    elif((self.getOriginalOutcome(event) != catch(uncaught) or self.getOriginalEthicality(event)!=ethic_catch(ethical))):
        overruled = 1
        
    numReportedOn = self.getNumReportsSubmitted(branch, lastPeriod, msg.sender)
    repChange = 0
    # penalization on a round 2 event if not already penalized, it has outcome, and user reported on it
    # if it's penalizing in the period it was pushed back to we can do the penalization, should do it for both the first and second period
    if(self.getRoundTwo(event) && (self.getFinal(event) or event==forkEvent) && !self.getPenalized(branch, lastPeriod, msg.sender, event) && (reportValue or oldReport)):
        # Do the first rep redistribution based on first report and final outcome if reported first time
        if(oldReport && outcome!=0):
            calculateRepChange(oldReport, POINTFOUR)
            handleEthicsAndBondRepRedistribution(POINTFOUR, oldEthics, numReportedOn)
        # Do the second (for each user) based on second report and final outcome
        if(reportValue && outcome!=0):
            calculateRepChange(reportValue, POINTTWO)
            handleEthicsAndBondRepRedistribution(POINTTWO, ethics, numReportedOn)
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    else:
        return(0)
    # if a fork event in original branch, only event needed to report on in this period is that one [b/c the original branch resolves it as a regular round 2 event, fork reports again]
    if(event==forkEvent):
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, (numReportedOn - 1))
    # penalization on a regular event if not already penalized, it has outcome, and user reported on it
    # once penalized for all events actually get rid of net rep lost
    if(numReportedOn==self.getPenalizedNum(branch, lastPeriod, msg.sender)):
        sendRedistributedRepToBranch()
    return(1)


macro handleEthicsAndBondRepRedistribution($maxPenalty, $ethics, $numReportedOn):
    # for ethicality if diff. appeal then pay back the appeal bond from people who reported the wrong ethicality, but don't take rep beyond that and max maxPenalty% of their rep respectively
    if($ethics != ethic_catch(ethical) && repChange >=0):
        if($numReportedOn<10):
            repChange = -$maxPenalty/10*repBalance / ONE
        else:
            repChange = -$maxPenalty/$numReportedOn*repBalance / ONE
    if(repBalance + repChange <= 0):
        repChange = -1*repBalance
    # if overruled: reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, rest goes to branch as usulater in the process
    if(overruled && self.getBondPaid(event) < 2*bond && repChange < 0 && event!=forkEvent):
        # done instead of sending to redistrib. pool
        self.addRep(branch, self.repIDToIndex(branch, msg.sender), repChange)
        # sends that rep to the bonded challenger
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), -repChange)
        self.increaseBondPaid(event, (-1*repChange))
    # if rep isn't redistributed immediately to bond poster [if they're already paid back] then we adjust the after rep as normal and do it all at the end
    else:
        newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
        self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
inset('refund.se')

# Payout traders in markets with number of winningOutcomes of 2 [one scalar with any combination of binary + categorical for the other 2 dimensions, or just 1D with a scalar]
# Error:
    # -1: sender doesn't exist / match up with the participant given participant number [this is used as a check to make sure participant #0 is really #0]
def twoOutcomes(market, winningOutcome: arr, event, sender):
    refund()
    # fetch outcome and min/max values for the scalar
    outcome = self.getOutcome(event)
    minValue = self.getMinValue(event)
    maxValue = self.getMaxValue(event)
    # price is in fixed point
    # share two goes with the high/long side
    pricePerShare2 = ONE*(outcome - minValue) / (maxValue - minValue)
    # share one goes with the low/short side of the calc
    pricePerShare1 = ONE - pricePerShare2
    # for each winning outcome get rid of shares and send money to the trader
    n = 0
    cumScale = self.getCumScale(market)
    while(winningOutcome[n]!=0):
        sharesOwned = self.getParticipantSharesPurchased(market, sender, winningOutcome[n])
        self.modifyParticipantShares(market, sender, winningOutcome[n], -sharesOwned)
        # low side
        if(n==0):
            self.subtractCash(market, sharesOwned*cumScale/ONE*pricePerShare1/ONE)
            self.addCash(sender, sharesOwned*cumScale/ONE*pricePerShare1/ONE)
        # high side (of the scalar part)
        elif(n==1):
            self.subtractCash(market, sharesOwned*cumScale/ONE*pricePerShare2/ONE)
            self.addCash(sender, sharesOwned*cumScale/ONE*pricePerShare2/ONE)
        n+=1
    return(1)
inset('refund.se')
inset('eventHelpers.se')

def makeHash(salt, report, eventID, sender):
    hashInfo = array(4)
    hashInfo[0] = sender
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha3(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# Allows a user to submit the hash of their report / commit
# Error: 0: not caught up on rep redistributions/penalizations so should be done first
# Error -1: invalid event
# Error -2: not in first half of period [commit part]
# Error -3: not able to report on this event
def submitReportHash(event, reportHash, encryptedSaltyHash):
    branch = self.getBranch(event)
    votePeriod = self.getVotePeriod(branch)
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    delta = lastPeriod - lastPeriodPenalized
    eventIndex = self.getEventIndex(branch, votePeriod, event)
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    if(eventIndex==0 && (eventID==0 || event!=eventID)):
        return(-1)
    if(residual > periodLength/2):
        return(-2)
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)
    if(!self.getRepRedistributionDone(branch, msg.sender)):
        return(0)

    # if first report of period, num events not set
    if(!self.getNumEventsToReportOn(branch, votePeriod)):
        self.setNumEventsToReportOn(branch)
        # set amount of fees to be distributed in this period from the branch
        self.setInitialBalance(branch, votePeriod, self.balance(branch))
    reportingThreshold = 0
    # if required or threshold has been set b/c wasn't  yet
    if(self.getRequired(event, votePeriod, branch) || self.getReportingThreshold(event)):
        reportingThreshold = 2**192
    # if number of reports event should have hasn't been calculated yet do it
    elif(!self.getLesserReportNum(branch, votePeriod, event)):
        self.calculateReportTargetForEvent(branch, event, votePeriod, msg.sender)
        reportingThreshold = self.calculateReportingThreshold(branch, event, votePeriod, msg.sender)
    else:
        reportingThreshold = self.calculateReportingThreshold(branch, event, votePeriod, msg.sender)
    x = array(1)
    x[0] = msg.sender + event
    # do abs then mult by 2 to ensure pos. and between 0 and 1
    shaHash = sha3(x, items=1)
    shaHash = (abs(shaHash)/ONE) * 2
    # shaHash must be <= to the threshold for that user to be able to report on the given event
    if(shaHash <= reportingThreshold):
        self.setReportHash(branch, votePeriod, msg.sender, reportHash, event)
        self.setSaltyEncryptedHash(branch, votePeriod, msg.sender, encryptedSaltyHash, event)
        return(1)
    else:
        return(-3)

# Submits / reveals a report for a period
# @return 1 if success
# Error messages
    # 0: reporter doesn't exist or has <1 rep
    # -1: has already reported
    # -2: not in second half of period [reveal part]
    # -3: hash doesn't match
    # -4: bad report
    # -5: invalid ethics
    # -6: already resolved
    # -7: <48 hr left in period, too late to report, able to put up readj. bonds though
    # -8: fees couldn't be collected
def submitReport(event, salt, report, ethics):
    branch = self.getBranch(event)
    balance = self.getRepBalance(branch, msg.sender)
    votePeriod = self.getVotePeriod(branch)
    periodLength = self.getPeriodLength(branch)
    forkedOverThisEvent = 0
    roundTwo = self.getRoundTwo(event)
    weight = 1
    residual = block.timestamp % periodLength
    forkedOverEthicality = self.getForkedOverEthicality(event)
    if(self.getEventForkedOver(branch) == event):
        forkedOverThisEvent = 1
    if(roundTwo or forkedOverThisEvent):
        weight = balance
    if(balance < ONE):
        return(0)
    if(self.getReport(branch, votePeriod, event, msg.sender)):
        return(-1)
    if(residual <= periodLength/2):
        return(-2)
    realHash = self.getReportHash(branch, votePeriod, msg.sender, event)
    if(self.makeHash(salt, report, event, msg.sender)!=realHash || realHash==0):
        return(-3)
    if(ethics!=ONE and ethics!=0):
        return(-5)
    # todo get outcome may not work / be valid
    elif(self.getOutcome(event)!=0):
        return(-6)
    # commented out for easy testing
    #if(block.timestamp/periodLength!=((block.timestamp + 2*TWENTYFOURHR)/periodLength)):
    #    return(-7)
    # ensures user has collected fees for last reporting period
    if(!self.getFeesCollected(branch, msg.sender, votePeriod-1)):
        if(self.collectFees(branch, msg.sender, value=msg.value)<0):
            return(-8)
   
    # actual submitting of report and ethicality
    report = self.validateReport(event, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, weight)
    if(report == -4):
        return(-4)
    self.setReport(branch, votePeriod, event, report, msg.sender)
    # set ethicality for forked event
    if(forkedOverThisEvent):
        # fork remove ethicality option if was forked over ethicality, other ethicality choice is the ethicality
        if(forkedOverEthicality):
            oldEthical = ethic_catch(self.getEthical(event))
            if(oldEthical == ONE):
                ethics = 0
            else:
                ethics = ONE
        self.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
        ethics = (self.getForkEthicality(event)*self.getEventWeight(branch, votePeriod, event) + ethics*weight) / (self.getEventWeight(branch, votePeriod, event) + weight)
        self.setForkEthicality(event, ethics)
    # set ethicality for a regular event
    else:
        self.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
        ethics = (self.getEthics(event)*self.getEventWeight(branch, votePeriod, event) + ethics*weight) / (self.getEventWeight(branch, votePeriod, event) + weight)
        self.setEthics(event, ethics)
    # round 2 and fork events are weighted by rep, otherwise 1
    self.countReportAsSubmitted(branch, votePeriod, event, msg.sender, weight)
    
    # pay reporters after reporting for their gas costs
    reportsNum = self.getLesserReportNum(branch, votePeriod, event)
    paidBack = self.getReportersPaidSoFar(event)
    diff = reportsNum - paidBack
    if(diff >= 1):
        self.addReportersPaidSoFar(event)
        self.subtractCash(branch, 3500000*tx.gasprice*ONE / WEITOETH)
        self.addCash(msg.sender, 3500000*tx.gasprice*ONE / WEITOETH)
    return(1)

# validates and submits report
# weights reports by rep if round 2 and fork
# Returns -4 if report is invalid
    # isn't between 1 and 2 if binary
    # if same report as original outcome / ethicality if a forked event not forked over ethicality it's also invalid b/c this option was removed as a poss. answer
def validateReport(eventID, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, weight):
    outcome = 0
    # binary
    if(self.getNumOutcomes(eventID)==2 and self.getMaxValue(eventID)==TWO and self.getMinValue(eventID)==ONE):
        if(report>2*ONE or report<ONE or report==0):
            return(-4)
        # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        elif(forkedOverThisEvent):
            # in case of fork remove the original outcome as a possible response if forked over outcome [i.e. didn't fork over ethics]
            if(!forkedOverEthicality && report == catch(self.getUncaughtOutcome(eventID))):
                return(-4)
            outcome = (self.getForkOutcome(eventID)*self.getEventWeight(branch, votePeriod, eventID) + report*weight) / (self.getEventWeight(branch, votePeriod, eventID) + weight)
            self.setForkOutcome(eventID, outcome)
        else:
            outcome = (self.getUncaughtOutcome(eventID)*self.getEventWeight(branch, votePeriod, eventID) + report*weight) / (self.getEventWeight(branch, votePeriod, eventID) + weight)
            self.setUncaughtOutcome(eventID, outcome)
    # scalar or categorical
    else:
        if(report > ONE):
            report = ONE
        elif(report <= 0):
            # 1 is the new 0 [1/2**64 is basically 0 but able to be differentiated from no report of 0]
            report = 1
        # in case of fork remove the original outcome as a possible response if didn't fork over ethics
        if(forkedOverThisEvent && (!forkedOverEthicality && report == self.getUncaughtOutcome(eventID))):
            return(-4)
        # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        # adding weight to a given poss. mode report
        self.addToWeightOfReport(votePeriod, eventID, report, weight)
        if(self.getWeightOfReport(votePeriod, eventID, report) > self.getCurrentModeItems(votePeriod, eventID)):
            self.setCurrentMode(votePeriod, eventID, report)
            self.setCurrentModeItems(votePeriod, eventID, report)
        outcome = self.getCurrentMode(votePeriod, eventID)
        if(forkedOverThisEvent):
            self.setForkOutcome(eventID, outcome)
        else:
            self.setUncaughtOutcome(eventID, outcome)
    return(report)whwe

### Helper functions:
# calculates how many reports should be on a given event
# todo make sure max cost is actually 500k gas here
def calculateReportTargetForEvent(branch, eventID, votePeriod, sender):
    numMarkets = self.getNumMarkets(eventID)
    if(numMarkets>20):
        numMarkets = 20
    markets = array(numMarkets)
    markets = self.getMarkets(eventID, outitems=numMarkets)
    totalFees = 0
    shareValue = 0
    i = 0
    while i < numMarkets:
        shareValue += self.getSharesValue(markets[i])
        totalFees += self.getFees(markets[i])
        i += 1
    totalVal = self.getShareValue(branch, votePeriod)
    shareFraction = shareValue*ONE/totalVal
    numReportersOnMarket = self.getBaseReporters(branch)*((-(267*shareFraction**2)/(2*ONE) + (533*shareFraction)/2 + 1*ONE))
    totalFeesInWei = totalFees * WEITOETH / ONE
    canPayForThisManyReporters = totalFeesInWei/(3500000*tx.gasprice)
    lesser = min(canPayForThisManyReporters*ONE, numReportersOnMarket)
    if(self.getLesserReportNum(branch, votePeriod, eventID)==0):
        self.refundCost(sender, self.getSubsidy(branch, votePeriod, eventID))
        self.setLesserReportNum(branch, votePeriod, eventID, lesser)
    return(lesser)
inset('refund.se')

macro POINTZEROSIX: 1106804644422573056
macro COSTPERREPORTER: 3500000

event marketCreated(marketID)
event tradingFeeUpdated(marketID, tradingFee)

# def createSingleEventMarket(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution:str, tradingFee, tag1, tag2, tag3, makerFees, extraInfo:str):
#     eventID = self.createEvent(branch, description, expDate, minValue, maxValue, numOutcomes, resolution, call=delegate)
#     marketID = self.createMarket(branch, description, tradingFee, [eventID], tag1, tag2, tag3, makerFees, extraInfo, call=delegate)
#     return(marketID)

# Create an event. Events are the basic units / questions that are reported on in Augur by reporters
# @param numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0 to 11.0 would be 11 outcomes (if incremented by 0.1)
# @param minValue should be 2**64 for a binary event, maxValue should be 2**65 for a binary event
# @param minValue for a scalar from 0 to 100 should be 0 and max should be 100*2**64, for -100 to 200, it should be -100*2**64 and 200*2**64 respectively
# @param description is a description of the event / the question itself
# @param resolution is the string source/link to resolve the event
# @param branch is the branch the event is created in
# @param expDate is the epoch time in which the event expires
# @return eventID if success
# error messages otherwise
    #  0: not enough money to pay fees or event already exists
    # -1: we're either already past that date, branch doesn't exist, or description is bad
    # -2: max value < min value or range < 1
    # -3: invalid number of outcomes
    # -4: would expire during non-reporting fork period
# .025 eth to create
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution: str):
    refund()
    periodLength = self.getPeriodLength(branch)
    forkPeriod = self.getForkPeriod(branch)
    if(!periodLength or description == 0 or expDate < block.timestamp):
        return(-1)
    if(maxValue < minValue or (maxValue-minValue) < ONE):
        return(-2)
    if(numOutcomes < 2 || numOutcomes > 8):
        return(-3)
    if(forkPeriod && ((expDate / periodLength)==forkPeriod or (expDate / periodLength)==(forkPeriod+1))):
        return(-4)
    eventinfo = string(7*32 + len(description))
    eventinfo[0] = branch                                       #branchID
    eventinfo[1] = expDate                                      #expiration date
    eventinfo[2] = msg.sender                                   #creator address
    eventinfo[3] = periodLength
    eventinfo[4] = minValue                                     #minimum outcome value
    eventinfo[5] = maxValue                                     #maximum outcome value
    eventinfo[6] = numOutcomes                                  #number of outcomes
    mcopy(eventinfo + 7*32, description, len(description))
    eventID = sha3(eventinfo, chars=len(eventinfo))
    self.initiateOwner(eventID)
    if(self.getCreator(eventID)):
        return(0)
    if(self.setInfo(eventID, description, msg.sender, 0) && self.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes, resolution)):
        return(eventID)
    else:
        return(0)

# Create a market. Markets are the basic _tradable_ units / questions that are traded on in Augur
# @param branch is the branch of the market
# @param description is the description for a market
# @param tradingFee is percent in fixedPoint
# @param events array is the list of events in a market [up to 3]
# @params tag1, tag2, and tag3 are the tags describing a market
# @param makerFees are the percent of the trading fee a maker pays [0-50% in fixed point]
# @param extraInfo is a string of any extra info associated with a market
# @return marketID if success or 1 if on an oracle only branch creation we have success
# error messages otherwise
    # -1: bad input or event doesn't exist
    # -2: event already expired
    # -3: would expire during non-reporting fork period
    # -4: market already exists
    # throw()s if not enough money to create the market and place event in the appropriate reporting period
# .05 eth to create
# need at least 1.2M gas @ gas price to cover resolution 500k per event to calc. num reports for it - this is passed as value to this function
# need to check that it's an actual subcurrency upon market creation (maybe check send/balance funs)
def createMarket(branch, description:str, tradingFee, event, tag1, tag2, tag3, makerFees, extraInfo:str):
    periodLength = self.getPeriodLength(branch)
    creationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / (2*tradingFee)
    # gives ether/cash amount in fixed point
    minFee = COSTPERREPORTER*self.getBaseReporters(branch)*tx.gasprice*ONE/WEITOETH
    creationFee = max(minFee, creationFee)
    validity_bond = (creationFee * (1 + self.getPast24(period)) / (1 + self.getNumberEvents(branch, self.getVotePeriod(branch))))/2
    numOutcomes = self.getNumOutcomes(event)
    cumulativeScale = 0
    # market's trading period is the same as the last expiring event in the market
    expirationDate = self.getExpiration(event)
    futurePeriod = expirationDate / periodLength
    forkPeriod = self.getForkPeriod(branch)
    # will need to get equivalent value in usd or eth or w/e via etherex exchange for subcurrency markets
    if(periodLength==0 or len(description)==0 || tradingFee < self.getMinTradingFee(branch) or tradingFee > 2^61 or self.getEventBranch(event) != branch or !self.getCreator(event) or makerFees < 0 or makerFees > ONEHALF):
        return(-1)
    if(expirationDate < block.timestamp):
        return(-2)
    if(forkPeriod && (futurePeriod == forkPeriod or futurePeriod == (forkPeriod+1))):
        return(-3)
    #scalars
    maxValue = self.getMaxValue(event)
    minValue = self.getMinValue(event)
    # is a valid scalar
    if((maxValue!=TWO || minValue !=ONE) && numOutcomes==2):
        # cumulativeScale is the range of a scalar
        cumulativeScale += maxValue - minValue
    if(cumulativeScale==0):
        cumulativeScale = ONE

    # formation of marketID (hash)
    marketinfo = string(8*32 + len(description))
    marketinfo[0] = futurePeriod
    marketinfo[1] = tradingFee
    marketinfo[2] = block.timestamp
    marketinfo[3] = tag1
    marketinfo[4] = tag2
    marketinfo[5] = tag3
    marketinfo[6] = expirationDate
    marketinfo[7] = len(description)
    mcopy(marketinfo + 8*32, description, chars=len(description))
    marketID = sha3(marketinfo, chars=len(marketinfo))
    # if it's already been created return 0
    if(self.getCreator(marketID) || self.getMarketNumOutcomes(marketID)):
        return(-4)
    events = array(1)
    events[0] = event
    # initialize market and send money to pay for resolution
    if(self.sendFrom(branch, creationFee, msg.sender) && send(MARKETS, (msg.value-500000*tx.gasprice)) && self.setInfo(marketID, description, msg.sender, creationFee) && self.addMarketToBranch(branch, marketID) && self.initializeMarket(marketID, events, futurePeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumulativeScale, numOutcomes, extraInfo, msg.value-500000*tx.gasprice, creationFee, expirationDate)):
        self.addToMarketsHash(branch, marketID)
        self.initiateOwner(marketID)
        self.addMarket(event, marketID)
    else:
        throw()
    # add events to the appropriate reporting period
    if(self.getEvent(branch, futurePeriod, self.getEventIndex(branch, futurePeriod, event))!=event):
        self.addEvent(branch, futurePeriod, event, 500000*tx.gasprice)
        # cost for calculating num. of reports for an event
        if(!send(EXPEVENTS, 500000*tx.gasprice)):
            throw()
        if(!self.getBond(event)):
            # pay validity / indeterminate protection bond
            period = block.timestamp / TWENTYFOURHR
            if(!self.sendFrom(event, validity_bond, msg.sender)):
                throw()
            self.setBond(event, validity_bond)
            self.addPast24(period)
    log(type=marketCreated, marketID)
    return(marketID)

# Updates a trading fee to be lower in a market
# Errors
    # -1: not the market creator
    # -2: invalid new trading fee
def updateTradingFee(branch, market, tradingFee):
    refund()
    if(msg.sender != self.getCreator(market) || tx.origin != self.getCreator(market)):
        return(-1)
    oldFee = self.getTradingFee(market)
    oldCreationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / oldFee
    newCreationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / tradingFee
    if(tradingFee < self.getMinTradingFee(branch) or tradingFee > oldFee):
        return(-2)
    if(!self.sendFrom(branch, newCreationFee-oldCreationFee, msg.sender) && self.setTradingFee(market, tradingFee)):
        throw()
    log(type=tradingFeeUpdated, market, tradingFee)
    return(1)

# Anyone can post an "Early Resolution Bond"
# This bond is equal to 0.5 * Market_Fee * Market_Value
# This amount is the amount needed to pay the reporters in case this was frivolous.
# The market goes up for early resolution and reporters place claim to what is truth, however for early resolution, they have an additional option: 'Market is not ready to resolve'
    # this addl option is just the normal indeterminate (except here it's a bit of a special case, see below)
# In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and market remains with old expiration dateevent
# In the event any other option is found to be the consensus the early resolution bond is returned to the poster and then resolution is handled just like any other case.
def pushMarketForward(branch, market):
    refund()
    # can't do while forking
    forkPeriod = self.getForkPeriod(branch)
    periodLength = self.getPeriodLength(branch)
    currentPeriod = block.timestamp / periodLength
    if(forkPeriod == currentPeriod or currentPeriod == (forkPeriod+1)):
        return(-1)
    # if market closed or already pushed forward, return 0
    if(self.getOneWinningOutcome(market, 0) or self.getPushedForward(market)):
        return(-2)
    if(self.sendFrom(market, self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*ONE), msg.sender)==0):
        return(-3)
    event = self.getMarketEvent(market, 0)
    expiration = self.getExpiration(event)
    if(self.getRejectedPeriod(event) || expiration!=self.getOriginalExpiration(event) || self.getOutcome(event) || self.getRoundTwo(event) || expiration/periodLength==block.timestamp/periodLength):
            return(-4)
    # push into next vote period
    period = block.timestamp/periodLength
    # figure out what's going on with subsidy system here todo
    self.addEvent(branch, period, event, 0)
    # set event expiration date to be after the current reporting period ends
    self.setExpiration(event, block.timestamp)
    self.setTradingPeriod(market, period)
    self.setPushedForward(market, 1, msg.sender)
    self.setEventPushedUp(event, 1)
    return(1)
inset('refund.se')

# Buys amount of every outcome
# cost 850k gas
# Errors:
    # 0: invalid market/doesn't exist
    # -1: oracle only branch [no trading allowed]
    # -2: not enough money
def buyCompleteSets(market, amount):
    refund()
    branch = self.getBranchID(market)
    numOutcomes = self.getMarketNumOutcomes(market)
    cumScale = self.getCumScale(market)
    cost = amount*cumScale/ONE
    if(!self.getCreationTime(market)):
        return(0)
    if(self.getOracleOnly(branch)):
        return(-1)
    if(self.balance(msg.sender) < cost):
        return(-2)
    n = 1
    # send shares of the event to user address and increment the number issued in the market for each outcome
    while n <= numOutcomes:
        self.modifyShares(market, n, amount)
        self.modifyParticipantShares(market, msg.sender, n, amount, 0)
        n += 1
    # if still before voting period has started count it in the share value for the period and market to target # of reporters to be higher in markets w/ more outstanding value
    if(self.getVotePeriod(branch) < self.getTradingPeriod(market)):
        self.modifySharesValue(market, amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), amount*cumScale/ONE)
    # send money from user acc. to market address/account
    self.sendFrom(market, cost, msg.sender)
    return(1)

# Sells amount of every outcome [if user owns it]
# cost 850k gas
# Errors:
    # -2: trader doesn't exist
    # -3: user doesn't own enough shares 
def sellCompleteSets(market, amount):
    refund()
    branch = self.getBranchID(market)
    numOutcomes = self.getMarketNumOutcomes(market)
    cumScale = self.getCumScale(market)
    cost = amount*cumScale/ONE
    n = 1
    while n <= numOutcomes:
        if(self.getParticipantSharesPurchased(market, msg.sender, n) < amount):
            return(-3)
        n += 1
    n = 1
    # Takes shares away from participant and decreases the amount issued in the market since we're exchanging complete sets
    while n <= numOutcomes:
        self.modifyShares(market, n, -amount)
        self.modifyParticipantShares(market, msg.sender, n, -amount, 0)
        n += 1
    # if still before voting period has started count it in the share value for the period and market to target # of reporters to be higher in markets w/ more outstanding value
    if(self.getVotePeriod(branch)<self.getTradingPeriod(market)):
        self.modifySharesValue(market, -amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), -amount*cumScale/ONE)
    # send funds from the market to the user acc.
    self.subtractCash(market, cost)
    self.addCash(msg.sender, cost)
    return(1)
macro sendRedistributedRepToBranch():
    if(newAfterRep <= 0):
        newAfterRep = 0
        self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
    self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
    self.increaseDenominator(branch, lastPeriod, newAfterRep)
    totalRepDifference = newAfterRep - oldRep
    if(repBalance + totalRepDifference <= 0):
        totalRepDifference = -1*repBalance
    if(totalRepDifference<0):
        # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
        self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
        # sends that rep to the branch
        self.addRep(branch, self.repIDToIndex(branch, branch), -totalRepDifference)
macro proportionCorrect(event, forkEvent):
    refund()
    p = 0
    if(forkEvent):
        uncaught = self.getForkOutcome(event)
        outcome = catch(uncaught)
        # subtract 1 to get it from 0 to 1
        avgOutcome = uncaught - ONE
    else:
        uncaught = self.getUncaughtOutcome(event)        
        outcome = catch(uncaught)
        # subtract 1 to get it from 0 to 1
        avgOutcome = uncaught - ONE
        return(0)
    # binary
    if(self.getNumOutcomes(event)==2 and self.getMaxValue(event)==TWO and self.getMinValue(event)==ONE):
        # say we have outcome of 0, avg is .4, what is p?
            # p is .6 or 60%
        if(outcome == ONE):
            p = ONE - avgOutcome
        # say we have outcome of 1, avg is .8, what is p (proportion correct)?
            # p is .8 or 80%
        elif(outcome == 2 * ONE):
            p = avgOutcome
        # unneeded but nice to know that in indeterminate case it'll return 0
        #elif(outcome == 3 * ONEHALF):
        #    return(0)
    p
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)

macro categorical($event):
    (self.getNumOutcomes($event)>2)

macro abs($a):
    if($a<0):
        $a = -$a
    $a

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE
inset('refund.se')

# sender/owner, then spender
data amountCanSpend[][]

event Transfer(_from:indexed, _to:indexed, _value)
event Approval(_owner:indexed, _spender:indexed, value)

# fix sender, tx.origin stuff here
# todo should we check collect fees done or no

# send active reputation
# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
def sendReputation(branch, recver, value):
    refund()
    # Rep cannot be simultaneously spent (transferred) and used to vote
    currentVotePeriod = self.getVotePeriod(branch)
    # you can't trade if you or the person you're sending to have submitted a report, or at all in the second half of the period [b/c you can messup / cheat w/ reporting by gettin extra claims on fees] and you can't trade in the first half of a period until you've been penalized for reporting wrongly/not reporting
    # use a diff. fun. than getReport here
    #if(value<=0 || self.getReport(branch, currentVotePeriod, tx.origin, 0) != 0 || self.getReport(branch, currentVotePeriod, msg.sender, 0) != 0 || self.getReport(branch, currentVotePeriod, recver, 0) != 0):
    # self.getNumReportsSubmitted(branch, currentVotePeriod, msg.sender)
    #    return(0)
    
    lastPeriodPenalized = self.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)

    # need to check all this for the person it's being sent to as well
    if(!self.getRepRedistributionDone(branch, msg.sender)):
        return(0)
    #if(self.getRRUpToDate()!=1):
    #    doIt()
    #    self.RRDone = true
    #if(hasReported(lastPeriod) && periodOver && hasntcollectedfees && residual > periodLength/2):
    #    self.collectFees(lastPeriod)
    # before rep, after rep, balance
    # person you're sending to needs rr up to date / done as well
    # auto increment vote period if needed
    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one, only if in first half of period
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.getRepBalance(branch, sender)
    if(senderBalance >= value && value > 0):
        if(self.subtractRep(branch, senderIndex, value) && self.addRep(branch, receiverIndex, value)):
            return(value)
        else:
            return(0)
    else:
        return(0)

# Transfer dormant rep
# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
# sendDormantRep
def transfer(branch, recver, value):
    refund()
    currentVotePeriod = self.getVotePeriod(branch)
    if(value<=0):
        return(0)
    sender = msg.sender
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=msg.sender):
        self.setPenalizedUpTo(branch, msg.sender, (self.getVotePeriod(branch)-1))
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, msg.sender, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value && value > 0):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addDormantRep(branch, receiverIndex, value)):
            log(type=Transfer, msg.sender, recver, value)
            return(value)
        else:
            return(0)
    else:
        return(0)

# TransferFrom per token api for dormant rep
# fails unless from has authorized sender
def transferFrom(branch, from, recver, value):
    refund()
    currentVotePeriod = self.getVotePeriod(branch)
    if(value<=0):
        return(0)
    sender = from
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=from):
        self.setPenalizedUpTo(branch, from, (self.getVotePeriod(branch)-1))
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, from, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value && value > 0 && self.amountCanSpend[from][msg.sender]>=value):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addDormantRep(branch, receiverIndex, value)):
            self.amountCanSpend[from][msg.sender] -= value
            log(type=Transfer, from, recver, value)
            return(value)
        else:
            return(0)
    else:
        return(0)
    
# Allows spender to withdraw from your dormant rep account
# fix to be branch specific todo
def approve(branch, spender, value):
    self.amountCanSpend[msg.sender][spender] = value
    log(type=Approval, msg.sender, spender, value)
    return(1)

# Returns amount spender can withdraw from owner
def allowance(owner, spender):
    return(self.amountCanSpend[owner][spender])

# Convert active rep to dormant rep
# error messages
    # -1: not in first half of reporting period
# shouldn't be penalized for dormant rep when converting back to active due to not reporting beyond the dormant penalization
# todo when handling dormant rep stuff:
# if a person reported on a round 2 event, they cannot convert their rep to dormant or send rep until they've finished the resolution process for that round 2 event
# unless this just happened to them last period and they reported correctly then
def convertToDormantRep(branch, value):
    refund()
    # if not in first half of reporting period
    periodLength = self.getPeriodLength(branch)
    if(!self.getRepRedistributionDone(branch, msg.sender)):
        return(0)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
      return(-1)
        # benny comment:
            #```Maybe still have this sort-of variable "power" to it, but REP initially doesn't have "full-power", or REP that hasn't been used to report over the past week has now let it's "power-meter" drop to only 20% earning power (it's kind-of dormant), that then ramps back up to 100% power once it gets used a bit. Could there be an element of this type of time-decay programmed into the REP that's helps incentive? Something like this would make the system more automatic, rather than relying on the user to manually switch "on" or switch "off" the self. If a user knows, "I better report this week or my REP's power meter goes down to 20% again, and it's gonna take extra effort to get it back to full-power", well that's pretty good incentive to keep the user active, without actually taking it from them.```

    if(value<=0):
        return(0)
    
    lastPeriodPenalized = self.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)

    #if(self.getRRUpToDate()!=1):
    #    doIt()

    #if(hasReported(lastPeriod) && periodOver):
        #self.collectFees(lastPeriod)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    senderBalance = self.getRepBalance(branch, sender)
    if(senderBalance >= value):
        if(self.subtractRep(branch, senderIndex, value) && self.addDormantRep(branch, senderIndex, value)):
            self.adjustActiveRep(branch, -value)
            return(value)
        else:
            return(0)
    else:
        return(0)

# Convert dormant rep to active rep
# error messages
    # -1: not in first half of reporting period
def convertToActiveRep(branch, value):
    refund()
    # if not in first half of reporting period
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
      return(-1)
      
    lastPeriodPenalized = self.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)
    if(!self.getRepRedistributionDone(branch, msg.sender)):
        return(0)
    if(value<=0):
        return(0)

    #if(self.getRRUpToDate()):
        #doIt()
    #if(hasReported(lastPeriod) && periodOver):
        #self.collectFees(lastPeriod)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addRep(branch, senderIndex, value)):
            self.adjustActiveRep(branch, value)
            return(value)
        else:
            return(0)
    else:
        return(0)
        
    
macro hasReported($branch, $period):
    self.getNumReportsSubmitted($branch, $period, msg.sender)
inset('refund.se')

macro POINTNINE: 16602069666338596864

# Call when a user who hasn't reported for a while [and had their rep active] and wants to start again and needs to catch up on penalizations
# Errors:
    # -1: not in first half of reporting period
    # -2: doesn't need to be penalized/caught up
    # -3: user isn't behind or reported in the last period [and should thus use the penalization functions in consensus.se]
def penalizationCatchup(branch, sender):
    refund()
    # find delta between this last period and the last one a reporter was penalized up to
    lastPeriodPenalized = self.getPenalizedUpTo(branch, sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    oldRep = self.getRepBalance(branch, sender)
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    # should only be allowed in 1st half of any period b/c rep removal / sending to branch should only be done then
    if(residual > periodLength/2):
        return(-1)
    if(delta <= 0):
        return(-2)
    # provided user is at least one period behind and they didn't report in the last period
    if(lastPeriodPenalized==lastPeriod or self.getNumReportsSubmitted(branch, lastPeriod, sender)):
        return(-3)
    # dock 10% for each period they didn't penalize on
    smoothedRep = oldRep*POINTNINE/ONE
    i = 1
    # if delta >22, max is 23 [1 above, 1 below, and 21 in while loop] penalizations simply so we don't run into out of gas issues
    if(delta>22):
        smoothedRep = smoothedRep*POINTNINE/ONE
        delta = 22
    while i < delta:
        smoothedRep = smoothedRep*POINTNINE/ONE
        i += 1
    # and send it to branch for penalty rep collection
    repChange = oldRep - smoothedRep
    # removes rep from reporter who lost it
    self.subtractRep(branch, self.repIDToIndex(branch, sender), repChange)
    # sends that rep to the branch rep pool
    self.addRep(branch, self.repIDToIndex(branch, branch), repChange)
    self.setPenalizedUpTo(branch, sender, lastPeriod)
    return(1)

inset('refund.se')
inset('eventHelpers.se')

## helper function to close an event for resolution
macro closeOut($event, $market, $branch, $votingPeriodEvent, $fxpOutcome, $periodLength, $ethical, $scalarorcat, $mode, $ethicOutcome):
    # In the $event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and $market remains with old expiration date
    # UI needs to call penalizeWrong for ones that are pushed back in both pushed back period and regular period with actual reporting
    $indeterminate = ONEHALF*3
    if(($fxpOutcome == $indeterminate or $mode==ONEHALF) && self.getEventPushedUp($event)):
        if(self.getPushedForward($market)):
            self.addCash($branch, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
            self.subtractCash($market, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
        self.setTradingPeriod($market, self.getOriginalTradingPeriod($market))
        self.setPushedForward($market, 0, msg.sender)
        self.setEventWeight($branch, $votingPeriodEvent, $event, 0)
        #set outcome to 0
        self.setOutcome($event, 0)
        self.setMode($event, 0)
        self.setEthics($event, 0)
        #set uncaughtoutcome to 0
        self.setUncaughtOutcome($event, 0)
        self.setEventPushedUp($event, 0)
        # need to store which period it was "rejected" in
        self.setRejected($event, self.getExpiration($event)/$periodLength)
        #set $event expiration to be the old date
        self.setExpiration($event, self.getOriginalExpiration($event))
        -6
    elif(($fxpOutcome==$indeterminate or $mode==ONEHALF) || !$ethical):
        # give $event bond money to reporters
        self.subtractCash($event, self.getBond($event))
        self.addCash($branch, self.getBond($event))
        # not $ethical is same as .5 outcome
        if($scalarorcat):
            # the mode is used to compare for reporting accuracy. so still the same as the reported uncaught outcome/mode, but resolving the market as .5 right in the middle of the range so payouts are done right for an unethical [or indeterminate] market
            self.setOutcome($event, $ethicOutcome)
        else:
            self.setOutcome($event, $indeterminate)
        1
    else:
        # return bond as a normal event resolution
        self.subtractCash($event, self.getBond($event))
        self.addCash(self.getCreator($event), self.getBond($event))
        if(self.getPushedForward($market)):
            self.addCash(self.getBondsMan($market), self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
            self.subtractCash($market, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
        if(self.getEventPushedUp($event)):
            # delete old $event from future events exp
            $period = self.getOriginalExpiration($event)/$periodLength
            self.removeEvent($branch, $period)
            self.deleteEvent($branch, $period, $event)
            self.setOriginalExpiration($event, self.getExpiration($event))
        1

# Resolves a binary market
def resolveBinary(event, market, branch, votingPeriodEvent):
    refund()
    fxpOutcome = catch(self.getUncaughtOutcome(event))
    periodLength = self.getPeriodLength(branch)
    ethical = ethic_catch(self.getEthical(event))
    # outcome is set to the binned version of the raw reported outcome
    self.setOutcome(event, fxpOutcome)
    # ethics is set to the binned version of the raw ethicality outcome
    self.setEthics(event, ethical)
    val = closeOut(event, market, branch, votingPeriodEvent, fxpOutcome, periodLength, ethical, 0, 0, 0)
    return(val)

# Resolves a categorical market
def resolveCategoricalOrScalar(scaled_min, scaled_max, event, market, branch, votingPeriodEvent):
    refund()
    mode = self.getUncaughtOutcome(event)
    self.setMode(event, mode)
    fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
    # outcome is set to the mode of the reported outcomes
    self.setOutcome(event, fxpOutcome)
    periodLength = self.getPeriodLength(branch)
    # ethics is set to the binned version of the raw ethicality outcome
    ethical = ethic_catch(self.getEthical(event))
    ethicOutcome = 2**63 * (scaled_max - scaled_min)/ONE + scaled_min
    self.setEthics(event, ethical)
    val = closeOut(event, market, branch, votingPeriodEvent, fxpOutcome, periodLength, ethical, 1, mode, ethicOutcome)
    return(val)

# Determines the "winning outcomes" for a given market
# Easiest to give examples:
    # 1D Markets:
        # Binary or Categorical will have 1 winning outcome [1 or 2 for binary, 1 thru numOutcomes for categorical is the poss. value for the winning outcome]
def determineWinningOutcomes(event):
    refund()
    winningOutcomes = array(8)
    fxpOutcome = self.getOutcome(event)
    outcome = fxpOutcome/ONE
    #scalar or .5
    if(scalar(event) || fxpOutcome==3*ONEHALF):
        winningOutcomes[0] = 1
        winningOutcomes[1] = 2
    # anything besides scalar or .5
    else:
        winningOutcomes[0] += outcome
    return(winningOutcomes: arr)
inset('refund.se')
inset('eventHelpers.se')
inset('redistributeRep.se')
inset('proportionCorrect.se')
inset('repChange.se')

# Penalizes a reporter for reporting wrongly on a forked event / backstop 2
# Notes:
    # essentially penalizeWrong for backstop 2 [where everyone reports on a forked event on the new branch]
    # only called on the fork not the parent, normal penalization except the outcome values are forkOutcome and forkEthicality as opposed to anything else
    # some rep from this goes to bond poster
    # branch is the fork, not the parent
    # fork event needs to be resolved first before this can be called
# Errors:
    #  0: not enough rep to report/penalize
    # -1: already past first half of new period and needed to penalize before then
    # -2: fork event isn't resolved yet
    # -3: already done for all events in this period
    # -4: needed to collect fees last period which sets the before/after rep
def penalizeOnForkedEvent(branch, event):
    refund()
    repBalance = self.getRepBalance(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    newRep = 0
    newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)
    if(repBalance < ONE):
        return(0)
    forkOutcome = self.getForkOutcome(event)
    outcome = catch(forkOutcome)
    if(scalar(event) or categorical(event)):
        outcome = forkOutcome
    p = proportionCorrect(event, 1)
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    ethics = self.getEthicReport(branch, lastPeriod, event, msg.sender)
    bond = self.getBondAmount(event)
    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period
    if(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
        return(-1)
    # means event / fork isn't resolved
    if(self.getForkedDone(event)==0):
        return(-2)
    if(self.getPenalizedUpTo(branch, msg.sender)==lastPeriod):
        return(-3)
    if(!self.getFeesCollected(branch, msg.sender, lastPeriod)):
        return(-4)
    numReportedOn = self.getNumReportsSubmitted(branch, lastPeriod, msg.sender)
    # penalization on a forked event
    # if didn't report [reportValue of 0] then it's a bad report here
    # Do (for each user) based on forking report and final outcome
    if(!self.getPenalized(branch, lastPeriod, msg.sender, event)):
        if(outcome!=0):
            calculateRepChange(reportValue, ONE)
            handleEthicsAndBondRepRedistribution(numReportedOn)
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    # once penalized for all events actually get rid of net rep lost
    if(numReportedOn==self.getPenalizedNum(branch, lastPeriod, msg.sender)):
        sendRedistributedRepToBranch()
    return(1)
    
macro handleEthicsAndBondRepRedistribution($numReportedOn):
    # for ethicality if diff. appeal then pay back the fork bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively
    if(ethics != ethic_catch(self.getEthical(event)) && repChange >=0):
        if($numReportedOn<10):
            repChange = -ONE/10*repBalance / ONE
        else:
            repChange = -ONE/$numReportedOn*repBalance / ONE
    if(repBalance + repChange <= 0):
        repChange = -1*repBalance
    if(self.getForkBondPaid(event) < self.getBondAmount(event)*2 && repChange < 0):
        # done instead of sending to redistrib. pool
        self.addRep(branch, self.repIDToIndex(branch, msg.sender), repChange)
        # sends that rep to the bonded challenger
        self.addRep(branch, self.repIDToIndex(branch, self.getForkBondPoster(event)), -repChange)
        self.adjForkBondPaid(event, -1*repChange)
    else:
        newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
        self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
inset('refund.se')
inset('eventHelpers.se')

macro POINTZEROONE: 184467440737095520

macro MINBOND: 200*2**64

# Allows a user to post a bond to enter round two of consensus
# Appeal_Bond = Market_Value * (0.01 + Market_Fee / 2) + Average_Adjudication_Cost
    # Average_Adjudication_Cost = Total fees paid to reporters for all markets in this reporting round / number of markets in this reporting round.
        # needs an abs min of ~200 rep.
# Reporting period is 2 months minus 48 hours.  This 48 hours allows for the appeals to take place before the next reporting round begins.
# Returns 1 upon success
# Errors:
    #  0: invalid votePeriod/branch
    # -1: Pushed forward event, bonding not allowed during this
    # -2: branch is in the middle of a fork
    # throw()s if not enough msg.value to cover resolution cost or not a large enough bond
def roundTwoPostBond(branch, event, eventIndex, votePeriod):
    if(self.getVotePeriod(branch)!=votePeriod):
        return(0)
    # if pushed forward don't allow until no longer pushed fwd
    if(self.getOriginalExpiration(event)!=self.getExpiration(event)):
        return(-1)
    market = self.getMarket(event, 0)
    forkPeriod = self.getForkPeriod(branch)
    if(forkPeriod == votePeriod or (forkPeriod+1) == votePeriod):
        return(-2)
    # todo find actual cost
    if(msg.value < 500000*tx.gasprice):
        return(0)
    # pays money to cover resolution cost
    if(!send(BACKSTOPS, msg.value)):
        throw()
    self.setRoundTwoRefund(event, msg.value)
    averageAdjudicationCost = self.getInitialBalance(branch, votePeriod)/self.getNumberEvents(branch, votePeriod)
    bond = averageAdjudicationCost + self.getSharesValue(market)*(POINTZEROONE + self.getTradingFee(market)/2) / ONE
    bond = min(bond, MINBOND)
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    # if so, we're in the final 48 hours and event is in this branch + votePeriod
    if(block.timestamp/self.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/self.getPeriodLength(branch)) && eventID!=0 && event==eventID && !self.getRoundTwo(event) && !self.getForked(event)):
        # send the bond to the branch
        # todo fix this will fail b/c event doesn't have rep acc
        if(!self.sendReputation(branch, event, bond)):
            throw()
        period = self.getVotePeriod(branch)
        # remove from events in # to report on calc for last period
        self.removeEvent(branch, period)
        # makes event required reporting in round 2 (the next period) as well
        self.setEventRequired(branch, period+1, event)
        # push event into next period
        self.addEvent(branch, period+1, event)
        # set event expiration date to be after the current reporting period ends
        self.setExpiration(event, block.timestamp)
        # set round two to true so can't be done again
        self.setRoundTwo(event, 1)
        self.setOriginalVotePeriod(event, votePeriod)
        if(scalar(event) or categorical(event)):
            self.setOriginalOutcome(event, self.getUncaughtOutcome(event))
        else:
            self.setOriginalOutcome(event, catch(self.getUncaughtOutcome(event)))
        self.setOriginalEthicality(event, ethic_catch(self.getEthical(event)))
        self.addRoundTwo(branch, period)
        self.setBondPoster(event, msg.sender)
        self.setUncaughtOutcome(event, 0)
        self.setMode(event, 0)
        self.setEthics(event, 0)
        return(1)

# Resolves a round 2 event scenario
# Errors:
    # 0: returned if not reported on again yet
def roundTwoResolve(branch, event, eventIndex, sender):
    refund()
    votePeriod = self.getVotePeriod(branch)
    market = self.getMarket(event, 0)
    averageAdjudicationCost = self.getInitialBalance(branch, votePeriod-1)/self.getNumberEvents(branch, votePeriod-1)
    bond = averageAdjudicationCost + self.getSharesValue(market)*(POINTZEROONE + self.getTradingFee(market)/2) / ONE
    bond = min(bond, MINBOND)
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    votedOnAgain = 0
    overruled = 1
    forked = self.getForked(event)
    # checks if the event's outcome was overruled or the same as the original reporting cycle
    if(scalar(event) or categorical(event)):
        if(self.getOriginalOutcome(event) == self.getUncaughtOutcome(event) && self.getOriginalEthicality(event)==ethic_catch(self.getEthical(event))):
            overruled = 0
    elif(self.getOriginalOutcome(event) == catch(self.getUncaughtOutcome(event)) && self.getOriginalEthicality(event)==ethic_catch(self.getEthical(event))):
        overruled = 0
    if(votePeriod > (self.getExpiration(event) / self.getPeriodLength(branch))):
        votedOnAgain = 1
    forkPeriod = self.getForkPeriod(branch)
    # if forking and this isn't the fork event
    if(forkPeriod==votePeriod or votePeriod==(forkPeriod+1) && (self.getEventForkedOver(branch)!=event && self.getBondReturned(event)==0 && self.getRoundTwo(event)) && eventID!=0 && event==eventID):
        # return the bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), bond)
        self.setBondReturned(event)
        self.setRoundTwo(event, 0)
        self.doRoundTwoRefund(sender, event)
        return(1)
    # overruled and bond poster was right
    elif(overruled && votedOnAgain && self.getRoundTwo(event) && votePeriod!=self.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked && !self.getBondReturned(event)):
        # return the bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), bond)
        # and set final outcome / event bond, etc
        if(!self.resolve(branch, event)):
            throw()
        # reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, then beyond that the people who originally reported whatever the actual truth was would get the rest. then regular rep redistribution for the round 2 reporting
        self.setFinal(event)
        self.setBondReturned(event)
        self.doRoundTwoRefund(sender, event)
        return(2*bond)
    # same as original consensus and bond poster was wrong [or malicious]
    elif(votedOnAgain && self.getRoundTwo(event) && votePeriod!=self.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked && !self.getBondReturned(event)):
        # lose bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, branch), bond)
        # and set final outcome / event bond, etc
        if(!self.resolve(branch, event)): 
            throw()
        # rep redistribution from original period/orig. outcome stands, rep redistribution from round 2 happens as usual as well
        self.setFinal(event)
        self.setBondReturned(event)
        self.doRoundTwoRefund(sender, event)
        return(1)
    # not voted on again yet
    else:
        return(0)

# Actually sets the outcome for a round 2 event
# Errors:
    # 0: event isn't binary, categorical, or scalar [hell has frozen over or quantum events have been invented]
def resolve(branch, event):
    refund()
    bond = self.getBond(event)
    # set ethicality to the binned version of the ethics
    ethical = ethic_catch(self.getEthical(event))
    self.setEthics(event, ethical)
    # binary
    if(binary(event)):
        # set outcome to the binned version of the outcome
        fxpOutcome = catch(self.getUncaughtOutcome(event))
        self.setOutcome(event, fxpOutcome)
        if(fxpOutcome==3*ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as 1.5 outcome w/ binary
            fxpOutcome = 3*ONEHALF
            self.setOutcome(event, fxpOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # scalar
    elif(scalar(event) or categorical(event)):
        mode = self.getUncaughtOutcome(event)
        # sets mode which is used to penalize/reward reporters
        self.setMode(event, mode)
        scaled_max = self.getMaxValue(event)
        scaled_min = self.getMinValue(event)
        if(categorical(event)):
            scaled_min = ONE
            scaled_max = ONE*self.getNumOutcomes(event)
        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
        # sets outcome which is used in calculating payouts 
        self.setOutcome(event, fxpOutcome)
        ethicOutcome = 2**63 * (scaled_max - scaled_min)/ONE + scaled_min
        if(mode==ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as .5 outcome w/ scalar
            # mode is used to compare for reporting acc. so still the same as reported outcome, but resolving the market as .5
            self.setOutcome(event, ethicOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # (should never be reached)
    else:
        return(0)
inset('refund.se')
inset('eventHelpers.se')
inset('redistributeRep.se')
inset('proportionCorrect.se')
inset('repChange.se')

event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)

macro POINTZEROONE: 184467440737095520
macro POINTEIGHT: 14757395258967642112
macro POINTTWO: 3689348814741910528

# Penalizes a reporter for reporting wrongly on an event
    # examples from the start of a new branch:
        # ex:
            #period 0 voteperiod -1 - last period penalized should be -1 or starting vote period
            #add some events to period 0
            #increment
            #period 1 voteperiod 0 - shouldn't be penalizing anything yet b/c still reporting on period 0
            #increment
            #period 2 voteperiod 1 - penalize on events in voteperiod 0
        # ex 2:
            #currently in period 100, voteperiod 99 - last period penalized up to should be 99 or starting vote period
            #add some events to period 100
            #increment to period 101
            #period 101, voteperiod 100 - shouldn't be penalizing anything yet
            #increment
            #period 102, voteperiod 101 - penalize on events in voteperiod 100
#1. Record rep at start of report period [before rep in make reports]
#2. Penalize for each event
#3. Each reporter needs to do this for all events they reported on, if not get docked
#4. For first half of the new period, people can do penalization for the last period, for the second half users have to claim rep then trading fees
#5. If a reporter doesn't do it for all events, they autolose 10% rep each period one doesn't do it (b/c they're trying to cheat)
# Errors:
    #  0: user has <1 rep
    # -1: need to penalize in round 2 penalize function
    # -2: already past first half of new period and needed to penalize before then
    # -3: in fork period only thing that rep redistribution is done on is the round 2 event in the original branch via round 2 penalize
    # -4: already done for all events in this period
    # -5: forked events should be penalized using the fork penalization function
    # -6: no outcome
    # -7: needed to collect fees last period [but didn't] which sets the before/after rep so now have to call penalizationCatchup
# force event to be resolved first if it can be
# call with branch, 0 if no events
def penalizeWrong(branch, event):
    refund()
    repBalance = self.getRepBalance(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    newRep = 0
    rejected = self.getRejected(event)
    newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)
    roundTwo = self.getRoundTwo(event)
    uncaught = self.getUncaughtOutcome(event)
    outcome = catch(uncaught)
    if(repBalance < ONE):
        return(0)
    if(scalar(event) or categorical(event)):
        outcome = uncaught
    p = proportionCorrect(event, 0)
    if(roundTwo && outcome!=0):
        return(-1)
    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period
    elif(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
        return(-2)
    elif(self.getForkPeriod(branch) == lastPeriod):
        return(-3)
    elif(self.getPenalizedUpTo(branch, msg.sender)==lastPeriod):
        return(-4)
    elif(self.getForked(event)):
        return(-5)
    # if no outcome / event not resolved yet, resolve it [as long as it wasn't an event that was pushed fwd and got rejected and thus hasn't actually resolved yet]
    # todo fix getoutcome
    elif(!self.getOutcome(event) && !(rejected && self.getRejectedPeriod(event)==lastPeriod)):
        if(self.closeMarket(branch, self.getMarket(event, 0), msg.sender)!=1):
            return(-6)
    elif(!self.getFeesCollected(branch, msg.sender, lastPeriod)):
        return(-7)

    repChange = 0
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    numReportedOn = self.getNumReportsSubmitted(branch, lastPeriod, msg.sender)
    penalizedOnEvent = self.getPenalized(branch, lastPeriod, msg.sender, event)
    # lastperiod is where people who originally voted on a round 2 event voted the first time - want num events penalized to go up but not to actually be penalized for it yet
        # shouldn't be penalized until the next period resolution is over [since it's a round 2 event]
    if(roundTwo && !penalizedOnEvent && reportValue):
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    # if this event was a pushed forward event that got rejected, don't penalize on it, only penalize on the final reporting, i.e. don't allow rep redistribution until the original period it was supposed to resolve in
    elif(!penalizedOnEvent && reportValue && rejected && self.getRejectedPeriod(event)==lastPeriod):
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    # penalization on a regular event if not already penalized, it has outcome, and user reported on it
    elif(!penalizedOnEvent && reportValue && outcome!=0):
        calculateRepChange(reportValue, POINTTWO)
        newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
        log(type=penalize, msg.sender, outcome, oldRep, repChange, newAfterRep, p, reportValue)
        self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    # once penalized for all events actually get rid of net rep lost and send it to the branch for redistribution
    if(numReportedOn==self.getPenalizedNum(branch, lastPeriod, msg.sender)):
        sendRedistributedRepToBranch()
    return(1)

# Increments the period after reporting
# ui has to call this to stay cheap / not check it elsewhere
def incrementPeriodAfterReporting(branch):
    refund()
    # do this after reporting is finished
    if(periodOver(branch)):
        period = block.timestamp / self.getPeriodLength($branch) - 1
        lastPeriod = period - 1
        percentAppealed = (self.getNumRoundTwo(branch, period)*ONE/self.getNumberEvents(branch, period) + self.getNumRoundTwo(branch, lastPeriod)*ONE/self.getNumberEvents(branch, lastPeriod)) / 2
        self.incrementPeriod(branch)
        # mult. by 2 b/c reporters only have to report on half the things they're selected to report on
        base_reporter_quantity = 2*(3*ONE + ((333*ONE * percentAppealed/ONE)**3 / 2**128))/ONE
        self.setBaseReportersLastPeriod(branch, self.getBaseReporters(branch))
        self.setBaseReporters(branch, base_reporter_quantity)
        return(1)
    else:
        return(0)

macro periodOver($branch):
    # what the current vote period should be
    currentVotePeriod = block.timestamp / self.getPeriodLength($branch) - 1
    # if actual vote period is less than what the current one should be, return 1, it can be incremented
    if(self.getVotePeriod($branch) < currentVotePeriod):
        1
    else:
        0
inset('refund.se')

# Anti cheat/collusion mechanism: provide ballot and random salt to steal rep from a colluder
# Returns:
    # 1: on success
    # -1: invalid vote period
    # -2: past reveal date
    # -3: reporter being slashed doesn't exist
    # -4: invalid claim / report hash -     # make sure that the colluding reporter's commit is the same as the info provided in the params
def slashRep(branch, salt, report, reporter, eventID):
    refund()
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    votePeriod = self.getVotePeriod(branch)
    alreadySlashed = self.getSlashed(branch, votePeriod, reporter)
    votePeriodShouldBe = block.timestamp / periodLength - 1
    realHash = self.getReportHash(branch, votePeriod, reporter, eventID)
    hashInfo = array(4)
    hashInfo[0] = reporter
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha3(hashInfo, chars=32*len(hashInfo))
    if(residual > periodLength/2):
        return(-2)
    if(votePeriodShouldBe!=votePeriod):
        return(-1)
    reporterIndex = self.repIDToIndex(branch, reporter)
    if(self.getReporterID(branch, reporterIndex)!=reporter):
        return(-3)
    if(alreadySlashed):
        return(-5)
    if(reportHash!=realHash):
        return(-4)
    self.setSlashed(branch, votePeriod, reporter)
    trutherIndex = self.repIDToIndex(branch, msg.sender)
    # if the truther's rep. account doesn't exist, make one
    if(self.getReporterID(branch, trutherIndex)!=msg.sender):
        trutherIndex = self.getNumberReporters(branch)
        self.addReporter(branch, msg.sender, 0, 0, 0)
    reporterBalance = self.getRepBalance(branch, reporter)
    # removes rep from colluder
    self.subtractRep(branch, reporterIndex, reporterBalance)
    # gives truther half 
    self.addRep(branch, trutherIndex, (reporterBalance*ONEHALF / ONE))
    # other half sent to branch
    self.addRep(branch, self.repIDToIndex(branch, branch), reporterBalance*ONEHALF/ONE)
    return(1)
inset('refund.se')
inset('eventHelpers.se')

macro POINTZEROONE: 184467440737095520

# UI has to handle function calls for these

#Notes:
    #Anyone can pay some amount significantly greater than the bond amount to force a branching event, splitting rep into two classes.  
    #In one class the reported outcome for whatever event was the cause of dispute is said to be right, and rep is redistributed accordingly.  
    #In the other class/branch, the event is readjudicated and remove the outcome on the pre fork branch and rep is redistributed as normal, except people who said the original outcome in the original fork lose rep.  
    # Note: Whichever outcome was truly the correct one would determine which branch had rep that actually held value.  This would be akin to a Bitcoin hard fork scenario.  The winning fork, of course, would be the one with the most voluminous markets, which would be determined by the fork that represented reality, which would have a higher market cap.  Markets go to the most popular fork by default after 2 months.

# Period where we forked, at the end of it
    # don't penalize for this period / anything that happened here should be considered to not have happened - done
    # let period be incremented as normal - done
    # no rep redistribution on this period besides for event forked over on original. parent but don't actually resolve the event until later per below - done
    # fork users get a free pass for not reporting on this period - done
# Period after fork where we need to do nothing while waiting for fork to resolve
    # free pass for not reporting during this period in og branch - done, UI needs to call penalizeWrong with a 0 as event param or todo do this contract side after doing penalize wrong
    # no reporting or rep redistribution in this period except for on fork branch we re-report on the forked market and that's it, so no free pass on fork for that one event - done
# Period after fork is resolved
    # markets can't be moved until now - done
    # all markets have early exp disabled until this point - done
    # each event which should've resolved in the past 2 periods and this one is pushed up into this period and voted on in period after this - done
        # stays in parent if it wins, otherwise goes to new fork - done
    # each event resolving further in the future is pushed into the respective period on whichever fork wins - done
# todo if already moved once don't allow again after another fork
def move_event(event):
    forkPeriod = self.getForkPeriod(self.getEventBranch(event))
    branch = self.getEventBranch(event)
    eventForkedOver = self.getEventForkedOver(branch)
    expPeriod = self.getExpiration(event)/self.getPeriodLength(branch)
    eventIndex = self.getEventIndex(expPeriod, event)
    currentPeriod = block.timestamp / self.getPeriodLength(branch)
    # todo getoutcome may not work
    if(forkPeriod && currentPeriod == (forkPeriod+2) && !self.getOutcome(event) && !self.getMoved(event)):
        winner = self.getResolved(branch, forkPeriod)
        if(winner==0):
            winner = self.resolve_fork(branch)
        self.setMoved(event)
        if(event == eventForkedOver):
            return(1)
        # leave event here in same branch
        elif(winner == self.getEventBranch(event)):
            # set outcomes to 0
            self.setOutcome(event, 0)
            self.setMode(event, 0)
            self.setEthics(event, 0)
            self.setUncaughtOutcome(event, 0)
            # return bond if it's a round 2 event and make it not one anymore
            self.roundTwoResolve(branch, event, eventIndex)    
            # if should've resolved in past periods
            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1)):
                # push it into next [this] period
                self.addEvent(branch, currentPeriod, event)
                self.setExpiration(event, block.timestamp)
            # otherwise it's set to expire in the period it would've expired in as normal, no changes needed
        # event's branch is changed to winning branch
        else:
            self.setBranch(event, winner)
            # set outcomes to 0
            self.setOutcome(event, 0)
            self.setMode(event, 0)
            self.setEthics(event, 0)
            self.setUncaughtOutcome(event, 0)
            # return bond if it's a round 2 event and make it not one anymore
            self.roundTwoResolve(branch, event, eventIndex)
            # move event to fork
            # and place it into the next reporting period w/ outcomes to 0
            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1)):
                # push it into next [this] period
                self.addEvent(winner, currentPeriod, event)
                self.setExpiration(event, block.timestamp)
            else:
                # push into period it wouldve expired in
                self.addEvent(winner, expPeriod, event)
                # expiration time doesnt need to change
    else:
        return(0)

# parent branch is branch here
# todo fork use address picked in market creation to resolve it and have a default fork resolve option
def resolve_fork(branch):
    # do whitelist
    forkPeriod = self.getForkPeriod(self.getEventBranch(event))
    currentPeriod = block.timestamp / self.getPeriodLength(branch)
    origCap = self.exchangeRate(branch)
    fork = self.getFork(branch)
    forkCap = self.exchangeRate(fork)
    if(origCap >= forkCap):
        winner = branch
        self.setResolved(branch, forkPeriod, winner)
        return(winner)
    else:
        winner = fork
    self.setResolved(branch, forkPeriod, winner)
    return(winner)

# Resolve fork method that gets exchange rate
def exchangeRate(branch):
    # get rep exchange rate from etherex for (branch)
    #return(exchangeRate)
    # for testing we'll just rng the exchange rate :)
    return(sha3(branch))

# Forks a contested event
# In the last 48 hours during period where a round 2 was pushed back to, can be made to fork instead of just round 2, so round 2 bond poster gets bond back
# bond is 1% of rep
# Errors:
    #  0: not in last 48 hr of period
    # -1: ineligible for forking over, already resolved, forked, or hasn't seen 1st backstop yet
    # -2: wasn't able to pay for bond
    # -3: no fork allowed for 1 period after a forking event
    # -4: event was pushed forward, not allowed yet
    # -5: invalid branch
def fork(event, branch, forkedOverEthicality):
    forkPeriod = self.getForkPeriod(branch)
    currentPeriod = block.timestamp / self.getPeriodLength(branch)
    if(!self.getRoundTwo(event) || self.getFinal(event) || self.getForked(event)):
        return(-1)
    if(forkPeriod == currentPeriod or currentPeriod == (forkPeriod+1) or currentPeriod == (forkPeriod+2)):
        return(-3)
    if(self.getOriginalExpiration(event)!=self.getExpiration(event)):
        return(-4)
    if(self.getBranch(event)!=branch):
        return(-5)
    # todo find actual gas cost for resolution here and charge that
    if(msg.value < 200000*tx.gasprice):
        return(0)
    if(!send(CONSENSUSDATA, msg.value)):
        throw()
    self.setRefund(event, msg.value)
    # if in last 48 hr of period and is round 2 event with reports attempted
    if(block.timestamp/self.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/self.getPeriodLength(branch)) && self.getUncaughtOutcome(event)!=0):
        bond = POINTZEROONE*self.getTotalRep(branch)/ONE
        self.setBondAmount(event, bond)
        # lose fork bond in branch 1
        # results same as roundtwobond, let it resolve as that on original network
        if(self.sendReputation(branch, event, bond)==0):
            return(-2)
        # on branch 2 fork bond isn't lost
        # on fork bond isn't lost, gets paid up to 2x from "liars"
        # make the fork
        newBranch = self.createSubbranch(text("fork"), self.getPeriodLength(branch), branch, self.getMinTradingFee(branch), 0)
        self.setFork(newBranch)
        period = self.getVotePeriod(newBranch)
        self.setEventRequired(newBranch, period+1, event)
        self.addEvent(newBranch, period+1, event)
        self.setExpiration(event, block.timestamp)
        self.setOriginalBranch(event, branch)
        self.setForkBondPoster(event, msg.sender)
        self.setForked(event)
        self.setFinal(event)
        self.setForkPeriod(branch)
        self.setForkPeriod(newBranch)
        self.setEventForkedOver(newBranch, event)
        self.setEventForkedOver(branch, event)
        if(forkedOverEthicality):
            self.setForkedOverEthicality(event)
        # return round 2 bond on orig. branch
        market = self.getMarket(event, 0)
        averageAdjudicationCost = self.getInitialBalance(branch, period-1)/self.getNumberEvents(branch, period-1)
        bond = averageAdjudicationCost + self.getSharesValue(market)*(184467440737095520 + self.getTradingFee(market)/2) / 2**64
        bond = min(bond, 200*ONE)
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), bond)
        self.setBondReturned(event)
    else:
        return(0)


# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
# branch is orig. branch
# Returns 1
# Errors:
    # 0 fork not done yet
    # -1 event not fork event
    # -2 wrong branch
def resolveForkedEvent(branch, event):
    refund()
    votedOnAgain = 0
    # checks for orig. branch
    if(self.getBranch(event)!=branch or self.getEventForkedOver(branch)!=event):
        return(0)
    if(self.getVotePeriod(branch) > (self.getExpiration(event) / self.getPeriodLength(branch))):
        votedOnAgain = 1
    if(!self.getForked(event)):
        return(-1)
    if(self.resolveForkEvent(branch, event)):
        self.setForkDone(event)
        self.doRefund(msg.sender, event)
        return(1)
    # fork not done yet
    else:
        return(0)

# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
def resolveForkEvent(branch, event):
    refund()
    # whitelist
    bond = self.getBond(event)
    winner = self.getResolved(branch, self.getForkPeriod(branch))
    if(!winner):
        return(-5)
    # binary
    if(binary(event)):
        fxpOutcome = 0
        ethical = 0
        # original parent won
        if(winner==branch):
            fxpOutcome = catch(self.getUncaughtOutcome(event))
            ethical = ethic_catch(self.getEthical(event))
        # fork won
        else:
            fxpOutcome = catch(self.getForkOutcome(event))
            ethical = ethic_catch(self.getForkEthicality(event))
        self.setOutcome(event, fxpOutcome)
        self.setEthics(event, ethical)
        if(fxpOutcome==3*ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as .5 outcome
            fxpOutcome = 3*ONEHALF
            self.setOutcome(event, fxpOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # scalar
    elif(scalar(event) or categorical(event)):
        mode = 0
        ethical = 0
        # original parent won
        if(winner==branch):
            mode = self.getUncaughtOutcome(event)
            ethical = ethic_catch(self.getEthical(event))
        # fork won
        else:
            mode = self.getForkOutcome(event)
            ethical = ethic_catch(self.getForkEthicality(event))
        self.setMode(event, mode)
        self.setEthics(event, ethical)
        scaled_max = self.getMaxValue(event)
        scaled_min = self.getMinValue(event)
        if(categorical(event)):
            scaled_min = ONE
            scaled_max = ONE*self.getNumOutcomes(event)
        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
        ethicOutcome = 2**63 * (scaled_max - scaled_min)/ONE + scaled_min
        self.setOutcome(event, fxpOutcome)
        if(mode==ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as .5 outcome
            self.setOutcome(event, ethicOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # (should never be reached)
    else:
        return(0)
inset('refund.se')

event log_price(market:indexed, type, price, amount, timestamp, outcome, trader:indexed)
event log_fill_tx(market:indexed, sender:indexed, owner:indexed, type, price, amount, tradeid, outcome)

macro ONEPOINTFIVE: 27670116110564327424

# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 8
# Boolean success/failure
macro SUCCESS: 1
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_SAME_BLOCK_PROHIBITED: 22

# calculates trading fee percentage
# 4*fee*price*(1-price/range)/range keeps fees lower at the edges
macro fee_percent($market_fee, $price, $cumScale):
    4 * $market_fee * $price * (ONE-$price*2**64/$cumScale) / ($cumScale*ONE)

# removes a trade from the book
macro remove_trade($trade_id, $market):
    self.remove_trade($trade_id)
    self.remove_trade_from_market($market, $trade_id)

#
# Trade [allows a user to pick up/fill orders off the book]
#
# Errors:
    # -1: trade doesn't exist
    # -2: bad trade hash
    # -4: must buy at least .00000001 in 
    # -5: can't pick up your own trade
    # 10: insufficient balance
    # 22: trade in same block prohibited
# max value is max money to spend to buy [including fees] filling ask orders
# max amount is max shares to sell filling bid orders
# 500k gas cost
# picks orders off the book
def trade(max_value, max_amount, trade_ids:arr):
    if(msg.value > 0):
        send(msg.sender, msg.value)
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeInfo[2] = max_value
    tradeHash = sha3(tradeInfo, items=3)
    if(self.checkHash(tradeHash, msg.sender)==-1):
        return([-2]: arr)
    # Try to fulfill each trade passed
    t = 0
    while t < len(trade_ids):
        # Get trade
        trade = array(TRADE_FIELDS)
        trade = self.get_trade(trade_ids[t], outitems=TRADE_FIELDS)
        if !trade:
            return([0]: arr)
        # Get market
        type = trade[1]
        market = trade[2]
        creator = self.getCreator(market)
        amount = trade[3]
        price = trade[4]
        owner = trade[5]
        outcome = trade[7]
        fill = 0
        if(owner == msg.sender or owner == tx.origin):
            return([-5]: arr)
        # Make sure the trade has been mined, obvious HFT prevention
        if block.number <= trade[6]:
            return([TRADE_SAME_BLOCK_PROHIBITED]: arr)
        branch = self.getBranchID(market)
        fee = fee_percent(self.getTradingFee(market), price, self.getCumScale(market))

        # Fill buy order
        if type == BID:
            # Get available balance of shares
            balance = self.getParticipantSharesPurchased(market, msg.sender, outcome)
            if(balance > 0 and max_amount > 0):
                makerFeeRate = self.getMakerFees(market)
                # Determine fill amount
                fill = min(amount, min(balance, max_amount))
                # Calculate value
                value = (fill * price)/ONE
                # must trade at least 0.00000001 in value
                if(value < 184467440738):
                    return([-4]: arr)
                # Update trade amount or remove
                if fill < amount:
                    self.fill_trade(trade_ids[t], fill)
                else:
                    remove_trade(trade_ids[t], market)
                # Update balances
                self.modifyParticipantShares(market, msg.sender, outcome, -fill, 0)
                self.modifyParticipantShares(market, owner, outcome, fill, 0)
                # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
                fee = value * fee / ONE
                branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE
                creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE
                self.addCash(msg.sender, value-(branchFees + creatorFees))
                # 75% to branch + .5% more to branch per maker fee 1% decrease
                self.addCash(branch, branchFees)
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                self.addCash(creator, creatorFees)
                self.subtractCash(market, value)

                # other party [maker] pays their part of the fee here too [they previously escrowed it in the market]
                fee = fee * makerFeeRate / ONE
                self.subtractCash(market, fee)
                self.addCash(creator, fee/2)
                self.addCash(branch, fee/2)
                
                # needed to keep track of how many fees a market has raised
                # only count branch fees here
                self.addFees(market, fee/2+branchFees)
                # Update max_amount
                max_amount -= fill
                # Log transaction
                log(type=log_fill_tx, market, msg.sender, owner, ASK, price, fill, trade_ids[t], outcome)
            else:
                return([INSUFFICIENT_BALANCE]: arr)
        elif type == ASK:
            balance = self.balance(msg.sender)
            makerFeeRate = self.getMakerFees(market)
            takerFee = (ONEPOINTFIVE - makerFeeRate)*fee / ONE
            total_trade_cost = amount * price * (takerFee+ONE) / ONE**2
            # trade value to spend is equal to min(moneyUserOwns, moneyUserWantsToSpend, valueOfTradeThatIsUnfilledIncludingFees)
            value_to_spend = min(total_trade_cost, min(max_value, balance))
            # Determine fill amount
            fill = value_to_spend*ONE / price * ONE / (takerFee+ONE)
            trade_value_excluding_fees = fill*price/ONE
            if(trade_value_excluding_fees >= 184467440738):
                # Update trade amount or remove filled trade
                if fill < amount:
                    self.fill_trade(trade_ids[t], fill)
                else:
                    remove_trade(trade_ids[t], market)
                # Update balances [user asking has already gotten rid of shares in escrow, just need to add them to the buyer]
                self.modifyParticipantShares(market, msg.sender, outcome, fill, 0)

                branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*trade_value_excluding_fees/ONE * fee / ONE
                creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*trade_value_excluding_fees/ONE * fee / ONE
                # Transfer cash from user to person who has ask order and pay fee to branch and market creator
                # 75% to branch + .5% more to branch per maker fee 1% decrease 
                self.addCash(branch, branchFees)
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                self.addCash(creator, creatorFees)
                self.addCash(owner, value_to_spend-(branchFees+creatorFees))
                self.subtractCash(msg.sender, value_to_spend)

                # other party [maker] pay their part of the fee here too
                makerFee = trade_value_excluding_fees * makerFeeRate / ONE * fee / ONE
                self.subtractCash(market, makerFee)
                self.addCash(creator, makerFee/2)
                self.addCash(branch, makerFee/2)
                
                # only count branch fees here
                self.addFees(market, makerFee/2+branchFees)
                # Update max_value
                max_value -= value_to_spend
                # Log transaction
                log(type=log_fill_tx, market, msg.sender, owner, BID, price, fill, trade_ids[t], outcome)
            else:
                return([INSUFFICIENT_BALANCE]: arr)

        # Log price, fill amount, type and timestamp
        self.setPrice(market, outcome, price)
        log(type=log_price, market, type, price, fill, block.timestamp, outcome, msg.sender)
        # Next trade
        t += 1
    return([SUCCESS, max_value, max_amount]: arr)

# Allows a user to "short" by buying n complete sets and selling n shares of the unwanted outcome to a bid on the book
# Example:
    #buyer gives up say 20
    #complete set cost is say 100
    #fee is say 2
    #market should lose 20 from buyer's escrowed money
    #market should gain 100 from complete set
    #person short selling should give the market 80 [complete set cost less shares sold]
    #plus fees
        #1 should go to branch
        #1 should go to creator
# Errors:
    # -1: trade doesn't exist
    # -2: invalid trade hash/commitment
    # -3: must be a bid, not an ask
    # -4: market is already resolved
    # -5: can't pickup your own trade
    # -7: not a large enough trade
def short_sell(buyer_trade_id, max_amount):
    if(msg.value > 0):
        send(msg.sender, msg.value)
    # check trade hash
    tradeInfo = array(3)
    tradeInfo[0] = buyer_trade_id
    tradeInfo[1] = max_amount
    tradeInfo[2] = 0
    tradeHash = sha3(tradeInfo, items=3)
    if(self.checkHash(tradeHash, msg.sender)==-1):
        return([-2]: arr)
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = self.get_trade(buyer_trade_id, outitems=TRADE_FIELDS)
    if !trade:
        return([-1]: arr)
    # Get market
    type = trade[1]
    if(type!=BID):
        return([-3]: arr)
    market = trade[2]
    branch = self.getBranchID(market)
    if(self.getOneWinningOutcome(market, 0)):
        return([-4]: arr)
    orig_amount = trade[3]
    price = trade[4]
    owner = trade[5]
    outcome = trade[7]
    if(owner == msg.sender or owner == tx.origin):
        return([-5]: arr)
    # Make sure the trade has been mined, obvious HFT prevention
    if block.number <= trade[6]:
        return([TRADE_SAME_BLOCK_PROHIBITED]: arr)
    
    # calculate cost
    creator = self.getCreator(market)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    amount = min(orig_amount, max_amount)
    if(amount < 0):
        return([INSUFFICIENT_BALANCE]: arr)
    fee = amount * price * fee_percent(trading_fee, price, cumScale) / ONE^2
    makerFeeRate = self.getMakerFees(market)
    branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE
    creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE
    takerFeesTotal = branchFees + creatorFees
    cost = amount*cumScale/ONE - (amount*price/ONE - takerFeesTotal)
    if(self.balance(msg.sender) < cost):
        return([INSUFFICIENT_BALANCE]: arr)
    if(amount*price/ONE < 184467440738):
        return([-7]: arr)

    numOutcomes = self.getMarketNumOutcomes(market)

    i = 1
    # send shares of the event to user address, buying complete sets
    while i <= numOutcomes:
        self.modifyShares(market, i, amount)
        self.modifyParticipantShares(market, msg.sender, i, amount, 0)
        i += 1
    if(self.getVotePeriod(branch)<self.getTradingPeriod(market)):
        self.modifySharesValue(market, amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), amount*cumScale/ONE)
    # send money from user acc. to market address/account
    # cost for shares
    if(!self.sendFrom(market, cost-takerFeesTotal, msg.sender)):
        throw()

    # Fill buy order [short selling the outcome user doesn't want]
    # Determine fill amount
    fill = amount
    # Update trade amount or remove
    if fill < orig_amount:
        self.fill_trade(trade_id, fill)
    else:
        remove_trade(trade_id, market)
    # Update balances
    self.modifyParticipantShares(market, msg.sender, outcome, -fill, 0)
    self.modifyParticipantShares(market, owner, outcome, fill, 0)
    # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
    # 75% to branch + .5% more to branch per maker fee 1% decrease 
    if(!self.sendFrom(branch, branchFees, msg.sender)):
        throw()
    # 25% to creator + .5% more to creator per 1% decrease in maker fees
    if(!self.sendFrom(creator, creatorFees, msg.sender)):
        throw()

    # other party [maker] pay their part of the fee here too
    fee = fee * makerFeeRate / ONE
    self.subtractCash(market, fee)
    self.addCash(creator, fee/2)
    self.addCash(branch, fee/2)
    
    # only count branch fees here
    self.addFees(market, fee/2+branchFees)

    max_amount -= fill
    # Log transaction
    log(type=log_fill_tx, market, msg.sender, owner, ASK, price, fill, trade_id, outcome)
    # Log price, fill amount, type and timestamp
    log(type=log_price, market, type, price, fill, block.timestamp, outcome, msg.sender)
    self.setPrice(market, outcome, price)
    return([SUCCESS, max_amount, fill, price]: arr)

macro refund():
    if self.test_callstack() != 1: return(-1)
    if(msg.value > 0):
        send(msg.sender, msg.value)

macro ONE: 2^64

macro WEITOETH: 10^18

macro THREEFOURTHS: 13835058055282163712

macro ONEFOURTH: 2**62

macro ONEHALF: 2**63

macro TWO: 2**65

macro TWENTYFOURHR: 86400
macro calculateRepChange($report, $maxPenalty):
    # wrong
    #184467440737095520 == 0.01 in fxp
    if($report > outcome+POINTZEROONE or $report < outcome-POINTZEROONE):
        if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
            diff = $report - outcome
            p = -(abs(diff)/2) + ONE
        newRep = oldRep*(2*p - ONE)/ONE
    # right
    else:
        if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
            diff = $report - outcome
            p = -(abs(diff)/2) + ONE
        newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
    # (1-k) * old rep + k * new rep where k = maxPenalty [max of 1] / (number of events you reported on last period) for penalization and pen. rate for backstop 1
    if(numReportedOn<10):
        repChange = oldRep * (ONE - $maxPenalty/10)/ONE + newRep*($maxPenalty/10)/ONE - oldRep
    else:
        repChange = oldRep * (ONE - $maxPenalty/numReportedOn)/ONE + newRep*($maxPenalty/numReportedOn)/ONE - oldRep
inset('refund.se')

# Payout a trader in a market with one winning outcome [so not scalar]
# Error:
    # -1: sender doesn't exist / match up with the participant given participant number [this is used as a check to make sure participant #0 is really #0]
def oneOutcome(market, winningOutcome, sender, categoricalPointFive, numOutcomes):
    cumScale = self.getCumScale(market)
    # if it's an indeterminate categorical market resolve with all outcomes having an equal value
    if(categoricalPointFive):
        i = 0
        while(i < numOutcomes):
            sharesOwned = self.getParticipantSharesPurchased(market, sender, i+1)
            self.modifyParticipantShares(market, sender, i+1, -sharesOwned)
            self.subtractCash(market, sharesOwned*self.getCumScale(market)/(numOutcomes*ONE))
            self.addCash(sender, sharesOwned*self.getCumScale(market)/(numOutcomes*ONE))
            i+=1
    else:
        # distribute profit to the people who won money by holding winning shares
        sharesOwned = self.getParticipantSharesPurchased(market, sender, winningOutcome)
        self.modifyParticipantShares(market, sender, winningOutcome, -sharesOwned)
        self.subtractCash(market, sharesOwned*cumScale/ONE)
        self.addCash(sender, sharesOwned*cumScale/ONE)
    return(1)
inset('refund.se')

# Allows a user to collect both redistributed rep and trading fees earned at the end of a period
# Errors:
    #  0: fees already collected
    # -1: rep redistribution/rewards/penalizations in consensus not done yet
    # -2: needs to be second half of reporting period to claim rep [1st half is when redistribution is done]
        # after this window, any unclaimed rep is pushed to the next period's redistrib. pool via the first make report submission
# 2 means no errors but didnt report last period
def collectFees(branch, sender):
    refund()
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual <= periodLength/2):
        return(-2)
    if(!self.getRepRedistributionDone(branch, sender)):
        # need to call penalize for all events and penalize for too lazy to report or catchup if necessary
        return(-1)
    votePeriod = self.getVotePeriod(branch)
    lastPeriod = votePeriod - 1
    newRep = self.getAfterRep(branch, lastPeriod, sender)
    feesCollected = self.getFeesCollected(branch, sender, lastPeriod)
    # need 1 rep to claim fees
    if(!feesCollected && newRep>ONE):
        denominator = self.getDenominator(branch, lastPeriod)
        # sets the amount of rep available for redistribution in the next period
        if(!self.getFeeFirst(branch, lastPeriod)):
            self.setFeeFirst(branch, lastPeriod, 1)
            self.setPeriodBalance(branch, lastPeriod, self.getRepBalance(branch, branch))
        gainedRep = newRep * self.getPeriodBalance(branch, lastPeriod) / denominator
        # if a user lost rep their newRep should be == self.getAfterRep(branch, period, sender) + gainedRep
        # if gained rep overall their newRep should be == self.getBeforeRep(branch, period, sender) + gainedRep
        # give a reporter their portion of redistributed rep
        self.addRep(branch, self.repIDToIndex(branch, sender), gainedRep)
        self.subtractRep(branch, self.repIDToIndex(branch, branch), gainedRep)
        cash = self.getInitialBalance(branch, lastPeriod) * newRep / denominator
        # give a reporter their portion of the trading fees
        self.addCash(sender, cash)
        self.subtractCash(branch, cash)
        prepareInfoForConsensus()
        return(1)
    elif(!feesCollected):
        prepareInfoForConsensus()
        return(2)
    else:
        return(0)

macro prepareInfoForConsensus():
    self.setFeesCollected(branch, sender, lastPeriod)
    # return not reported enough bond if not enough penalized is 0 or self.getForkPeriod(branch)+1 == lastPeriod during collect fees
    if(self.getNotEnoughPenalized(branch, msg.sender, lastPeriod)==0 or self.getForkPeriod(branch)+1 == lastPeriod):
        self.doRefund(msg.sender, msg.sender)
    # need to pay not reporting bond
    if(msg.value <= 500000*tx.gasprice):
        throw()
    balance = self.getRepBalance(branch, msg.sender)
    dormantRep = self.balanceOf(branch, msg.sender)
    # Record rep for next report period before any redistributions
    self.setBeforeRep(branch, votePeriod, balance, msg.sender)
    self.setAfterRep(branch, votePeriod, balance, msg.sender)
    self.setPeriodDormantRep(branch, votePeriod, dormantRep, msg.sender)
    self.setRefund(msg.sender, msg.value)
    send(CONSENSUS, msg.value)
inset('refund.se')

macro ONEPOINTTWO: 22136092888451461120
macro POINTZEROONE: 184467440737095520

# eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2))
    # exp(1.2*ln(repbal)) / exp(1.2*ln(totalrep)) is == (reporterList[n]/totalRep)**1.2
    # a^b=exp(b*ln(a))=e^(b*ln(a)).
def calculateReportingThreshold(branch, eventID, votePeriod, sender):
    repConstant = self.getPeriodRepWeight(branch, votePeriod, sender)
    if(!repConstant):
        repConstant = self.fx_exp(ONEPOINTTWO*self.fx_log(self.getRepBalance(branch, sender))/ONE)*2**64/self.fx_exp(ONEPOINTTWO*self.fx_log(self.getActiveRep(branch))/ONE)
        numEventsToReportOn = self.getNumEventsToReportOn(branch, votePeriod)
        expectedEventsForReporter = repConstant * numEventsToReportOn
        total = expectedEventsForReporter
        eventsInPeriod = self.getNumberEvents(branch, period)-self.getNumRemoved(branch, votePeriod)
        numRequiredEvents = self.getNumRequired(branch, votePeriod)
        if(repFraction >= POINTZEROONE):
            minimum = min(30-numRequiredEvents, eventsInPeriod-numRequiredEvents)
            if(total/ONE < minimum):
                total = minimum*ONE
                repConstant = total / numEventsToReportOn
        self.setPeriodRepWeight(branch, votePeriod, sender, repConstant)
    # 1 is 2**192 here, lesserreportnum, repconstant, and one are all base 2**64
    reportingThreshold = self.getLesserReportNum(branch, votePeriod, eventID)*repConstant*ONE
    return(reportingThreshold)

def getEventsToReportOn(branch, period, sender, start):
    numEvents = self.getNumberEvents(branch, period)
    events = array(numEvents*2)
    i = 0
    n = start
    while i < numEvents*2:
        events[i] = self.getEvent(branch, period, n)
        # calculate report target for event here if not done for purposes of computing this
        if(self.getLesserReportNum(branch, period, events[i])==0):
            self.calculateReportTargetForEvent(branch, events[i], period, msg.sender)
        reportingThreshold = self.calculateReportingThreshold(branch, events[i], period, sender)
        x = array(1)
        x[0] = sender + events[i]
        # do abs then mult by 2 to ensure pos. and between 0 and 1
        shaHash = sha3(x, items=1)
        shaHash = (abs(shaHash)/ONE) * 2
        if((shaHash < reportingThreshold || self.getRequired(events[i], period, branch)) && !self.getOutcome(events[i])):
            events[i+1] = 1
        else:
            events[i+1] = 0
        i += 2
        n += 1
    return(events: arr)

def getEventCanReportOn(branch, period, reporter, event):
    refund()
    reportingThreshold = self.calculateReportingThreshold(branch, event, period, reporter)
    x = array(1)
    x[0] = reporter + event
    # do abs then mult by 2 to ensure pos. and between 0 and 1
    shaHash = sha3(x, items=1)
    shaHash = (abs(shaHash)/ONE) * 2    
    if(shaHash < reportingThreshold || self.getRequired(event, period, branch)):
        return(1)
    else:
        return(0)

#In the rare possibility that no one gets randomly selected to report on a market in a given period, on the last day, we can change the sha3 threshold.
def setReportingThreshold(event):
    refund()
    # first check is if event expDate is in the current vote period and second is if blockNum is near expiration of commit period (within 24 hr.)
    # final check is if no reports on event
    # so if in 24 hr we'd be in the next half of the vote period, we're within 24 hr of the end of this one
    branch = self.getBranch(event)
    periodLength = self.getPeriodLength(branch)
    votePeriod = self.getVotePeriod(branch)
    if(votePeriod==self.getExpiration(event)/periodLength and (((block.timestamp + TWENTYFOURHR) % periodLength) > periodLength/2) and !self.getUncaughtOutcome(event)):
        self.setThreshold(event, 2**192)
        return(1)
    else:
        return(0)

macro abs($a):
    if($a<0):
        $a = -$a
    $a
