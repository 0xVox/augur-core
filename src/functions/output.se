def init():
    description = text("Root branch")
    save(self.Info[1010101].description[0], description, chars=len(description))
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Info[1010101].descriptionLength = len(description)
    self.Reporting[1010101].repIDtoIndex[msg.sender] = 0
    self.Reporting[1010101].reputation[0].repValue = 0
    self.Reporting[1010101].reputation[0].reporterID = msg.sender
    self.Reporting[1010101].numberReporters = 2
    self.Reporting[1010101].repIDtoIndex[1010101] = 1
    self.Reporting[1010101].reputation[1].repValue = 0
    self.Reporting[1010101].reputation[1].reporterID = 1010101
    self.branch[1010101].baseReportersLastPeriod = 2*3
    self.Branches[1010101].currentVotePeriod = (block.timestamp / 15) - 1
    self.Branches[1010101].periodLength = 15
    # .5%
    self.Branches[1010101].minTradingFee = 92233720368547760 
    self.branchListCount = 1
    self.branchList[0] = 1010101
    # since only have to report on half this targets 3
    self.Branches[1010101].baseReporters = 2*3
    # test initial funds
    self.cashcoinBalances[msg.sender] = 100000*ONE

inset('refund.se')

macro POINTSEVEN: 12912720851596685312
macro POINTZEROONE: 184467440737095520

# Error -1: Hey, you're not broke!
def cashFaucet():
    refund()
    if self.balance(msg.sender) > 5*ONE:
        return(-1)
    self.setCash(msg.sender, 10000*ONE)
    return(1)

def reputationFaucet(branch):
    refund()
    if self.repIDToIndex(branch, tx.origin) != 0 or self.getReporterID(branch, 0) == tx.origin:
        index = self.repIDToIndex(branch, tx.origin)
    else:
        index = self.getNumberReporters(branch)
        self.addReporter(branch, tx.origin, 0, 0, 0)
    self.setRep(branch, index, 47*ONE)
    self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
    return(1)

def fundNewAccount(branch):
    self.send(self, 0)
    self.reputationFaucet(branch)
    self.setCash(msg.sender, 10000*2^64)
    return(1)

# Used to claim rep on a fork or on a new branch
def claimInitialRep(parent, branch):
    refund()
    if(self.getParent(branch)!=parent):
        return(0)
    # have 1 month to claim
    if(self.repIDToIndex(branch, msg.sender)==0 && block.timestamp < (self.getCreationDate(branch) + TWENTYFOURHR*30)):
        parentPeriod = self.getParentPeriod(branch)
        forkPeriod = self.getForkPeriod(parent)
        fork = self.getFork(parent)
        forkEvent = self.getEventForkedOver(parent)
        report = self.getReport(parent, forkPeriod, forkEvent, msg.sender)
        outcome = self.getUncaughtOutcome(forkEvent)
        if(binary(forkEvent)):
            outcome = catch(outcome)
        ethical = ethic_catch(self.getEthical(forkEvent))
        ethicReport = self.getEthicReport(parent, forkPeriod, forkEvent, msg.sender)
        rep = self.getBeforeRep(parent, parentPeriod, msg.sender)
        repDecrease = 0
        # if forked and (reported with original consensus or didn't report or (reported with original ethicality and forked over ethicality))
        if(fork && ((report >= (outcome-POINTZEROONE) && report <= (outcome+POINTZEROONE)) || report==0 || (self.getForkedOverEthicality(forkEvent) && ethical==ethicReport))):
            # take away 30% of rep from liars and those who didn't report
            repDecrease = rep - rep*POINTSEVEN/ONE
            rep = rep - repDecrease
            amountLeftToPayBonder = self.getBondAmount(forkEvent) - self.getForkBondPaid(forkEvent)
            if(repDecrease < amountLeftToPayBonder):
                # send all the rep to the fork bond poster
                self.addRep(branch, self.repIDToIndex(branch, self.getForkBondPoster(forkEvent)), repDecrease)
            else:
                # send amountLeftToPayBonder [if positive] to the fork bond poster
                if(amountLeftToPayBonder > 0):
                    self.addRep(branch, self.repIDToIndex(branch, self.getForkBondPoster(forkEvent)), amountLeftToPayBonder)    
                    # send the rest to the new branch's redistribution pool
                    self.addRep(branch, self.repIDToIndex(branch, branch), (repDecrease - amountLeftToPayBonder))
                else:
                    # send to new branch's redistribution pool
                    self.subtractRep(branch, self.repIDToIndex(branch, branch), repDecrease)
        if(fork):
            self.setPenalizedUpTo(branch, msg.sender, forkPeriod)
        else:
            self.setPenalizedUpTo(branch, msg.sender, (self.getVotePeriod(branch)-1))
        dormantRep = self.getPeriodDormantRep(parent, self.getParentPeriod(branch), msg.sender)
        self.addReporter(branch, msg.sender, rep, dormantRep, repDecrease)
        return(1)
    else:
        # already claimed or too late
        return(0)

        
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
        
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

inset('refund.se')

event log_price(market:indexed, type, price, amount, timestamp, outcome, trader:indexed)
event log_add_tx(market:indexed, sender:indexed, type, price, amount, outcome, tradeid)
event log_fill_tx(market:indexed, sender:indexed, owner:indexed, type, price, amount, tradeid, outcome)
event log_cancel(market:indexed, sender:indexed, price, amount, tradeid, outcome, type)

# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 8
# Boolean success/failure
macro SUCCESS: 1
macro FAILURE: 0
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_ALREADY_EXISTS: 21
macro TRADE_SAME_BLOCK_PROHIBITED: 22

macro fee_percent($market_fee, $price, $cumScale):
    4 * $market_fee * $price * (ONE-$price*2**64/$cumScale) / ($cumScale*ONE)

macro save_trade($type, $amount, $price, $market, $outcome, $branch, $participantNumber, $fee, $sender):
    trade = [$type, $market, $amount, $price, $sender, block.number, $outcome]
    trade_id = sha3(trade, items=7)
    cumScale = self.getCumScale($market)

    # Save trade
    if !self.getID(trade_id):
        self.saveTrade(trade_id, $type, $market, $amount, $price, $sender, $outcome)
        # Update market
        last_id = self.getLastTrade($market)
        self.addTrade($market, trade_id, last_id)
        # Update available and trading amounts for asks
        if $type == ASK:
            self.modifyParticipantShares($market, $participantNumber, $outcome, -$amount, 0)
            if($fee):
                self.sendFrom($market, ($amount * $price * $fee / ONE^2), $sender)
        # Send / escrow cash for bids
        if $type == BID:
            self.sendFrom($market, $amount * $price / ONE, $sender)
            if($fee):
                self.sendFrom($market, ($amount * $price * $fee / ONE^2), $sender)
    else:
        return(TRADE_ALREADY_EXISTS)
    log(type=log_add_tx, $market, $sender, $type, $price, $amount, $outcome, trade_id)
    return(trade_id)

#
# Cancellation: cancels a trade, if a bid refunds money, if an ask returns shares
# @returns 1 if success, 0 if failure
#
# 200k gas
def cancel(trade_id):
    refund()
    # user can cancel anytime
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = self.get_trade(trade_id, outitems=TRADE_FIELDS)
    if !trade:
        return(0)
    type = trade[1]
    market = trade[2]
    amount = trade[3]
    price = trade[4]
    owner = trade[5]
    outcome = trade[7]
    branch = self.getBranchID(market)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    # Check the owner
    if msg.sender == owner:
        # Clear the trade first
        remove_trade(trade_id, market)
        # Issue refunds
        if type == BID:
            # cash refund
            amt = amount * price * (fee + ONE) / ONE^2
            self.subtractCash(market, amt)
            self.addCash(msg.sender, amt)
        elif type == ASK:
            # shares refund
            participantNumber = self.getParticipantNumber(market, msg.sender)
            self.modifyParticipantShares(market, participantNumber, outcome, amount, 1)
            self.subtractCash(market, (amount * price * fee / ONE^2))
            self.addCash(msg.sender, (amount * price * fee / ONE^2))
        # Log cancellation
        log(type=log_cancel, market, msg.sender, price, amount, trade_id, outcome, type)
        return(SUCCESS)
    return(FAILURE)

macro remove_trade($trade_id, $market):
    self.remove_trade($trade_id)
    self.remove_trade_from_market($market, $trade_id)

#
# Buy / Sell actions: puts orders on the book
# Errors:
    #  0: market doesn't exist
    # -1: amount/price bad
    # -2: oracle only branch
    # -3: trader doesn't exist in market
    # -4: not enough money or shares
#
# costs 532k gas
# smallest trade value is 0.00000001
def buy(amount, price, market, outcome):
    refund()
    if(!self.getCreationTime(market)):
        return(0)
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-2)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    # if participant doesn't exist in market, add them
    if(msg.sender != self.getParticipantID(market, participantNumber)):
        participantNumber = self.addParticipant(market, msg.sender)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    # price cannot be greater than max share value, value traded can't be <.00000001, and value can't be > 2**126 in unfixed point so we don't get overflow issues
    if(price>cumScale or amount*price < 3402823669209384705829531287552 or amount*price >= 2**190):
        return(-1)
    if(self.balance(msg.sender) < (amount * price * (fee + ONE) / ONE^2)):
        return(-4)
    save_trade(BID, amount, price, market, outcome, branch, participantNumber, fee, msg.sender)
    return(FAILURE)

# costs 532k gas
# smallest trade value is 0.00000001
def sell(amount, price, market, outcome):
    refund()
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-2)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    if(self.getParticipantID(market, participantNumber) != msg.sender):
        return(-3)
    if(self.getParticipantSharesPurchased(market, participantNumber, outcome) < amount):
        return(-4)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    fee = fee_percent(trading_fee, price, cumScale) * self.getMakerFees(market) / ONE
    # price cannot be greater than max share value, value traded can't be <.00000001, and value can't be > 2**126 in unfixed point so we don't get overflow issues
    if(price>cumScale or amount*price < 3402823669209384705829531287552L or amount*price >= 2**190):
        return(-1)
    if(self.balance(msg.sender) < (amount * price * fee / ONE^2)):
        return(-4)
    save_trade(ASK, amount, price, market, outcome, branch, participantNumber, fee, msg.sender)
    return(FAILURE)

# Allows a user to "short" by buying n complete sets and selling n shares of the unwanted outcome to a bid on the book
# Example:
    #buyer gives up say 20
    #complete set cost is say 100
    #fee is say 2
    #market should lose 20 from buyer's escrowed money
    #market should gain 100 from complete set
    #person short selling should give the market 80 [complete set cost less shares sold]
    #plus fees
        #1 should go to branch
        #1 should go to creator
def short_sell(buyer_trade_id, max_amount):
    refund()
    # check trade hash
    tradeInfo = array(3)
    tradeInfo[0] = buyer_trade_id
    tradeInfo[1] = max_amount
    tradeInfo[2] = 0
    tradeHash = sha3(tradeInfo, items=3)
    if(self.checkHash(tradeHash, msg.sender)==-1):
        return(-2)
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = self.get_trade(buyer_trade_id, outitems=TRADE_FIELDS)
    if !trade:
        return(3)
    # Get market
    type = trade[1]
    if(type!=BID):
        return(4)
    market = trade[2]
    if(self.getOneWinningOutcome(market, 0)):
        return(-4)
    orig_amount = trade[3]
    price = trade[4]
    owner = trade[5]
    outcome = trade[7]
    if(owner == msg.sender or owner == tx.origin):
        return(5)
    # Make sure the trade has been mined, obvious HFT prevention
    if block.number <= trade[6]:
        return(TRADE_SAME_BLOCK_PROHIBITED)
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-1)
    creator = self.getCreator(market)
    trading_fee = self.getTradingFee(market)
    cumScale = self.getCumScale(market)
    amount = min(orig_amount, max_amount)
    if(amount < 0):
        return(INSUFFICIENT_BALANCE)
    fee = amount * price * fee_percent(trading_fee, price, cumScale) / ONE^2
    makerFeeRate = self.getMakerFees(market)
    branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE
    creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE
    takerFeesTotal = branchFees + creatorFees
    cost = amount*cumScale/ONE - (amount*price/ONE - takerFeesTotal)
    if(self.balance(msg.sender) < cost):
        return(INSUFFICIENT_BALANCE)

    if(amount*price/ONE < 184467440738):
        return(-4)

    numOutcomes = self.getMarketNumOutcomes(market)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    # if participant doesn't exist in market, add them
    if(msg.sender != self.getParticipantID(market, participantNumber)):
        participantNumber = self.addParticipant(market, msg.sender)

    i = 1
    # send shares of the event to user address
    while i <= numOutcomes:
        self.modifyShares(market, i, amount)
        self.modifyParticipantShares(market, participantNumber, i, amount, 0)
        i += 1
    if(self.getVotePeriod(branch)<self.getTradingPeriod(market)):
        self.modifySharesValue(market, amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), amount*cumScale/ONE)

    # send money from user acc. to market address/account
    # cost for shares
    self.sendFrom(market, cost-takerFeesTotal, msg.sender)

    # Fill buy order
    # Determine fill amount
    fill = amount
    # Update trade amount or remove
    if fill < orig_amount:
        self.fill_trade(trade_id, fill)
    else:
        remove_trade(trade_id, market)
    # Update balances
    ownerNum = self.getParticipantNumber(market, owner)
    self.modifyParticipantShares(market, participantNumber, outcome, -fill, 0)
    self.modifyParticipantShares(market, ownerNum, outcome, fill, 0)
    # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
    # 75% to branch + .5% more to branch per maker fee 1% decrease 
    self.sendFrom(branch, branchFees, msg.sender)
    # 25% to creator + .5% more to creator per 1% decrease in maker fees
    self.sendFrom(creator, creatorFees, msg.sender)

    # other party [maker] pay their part of the fee here too
    fee = fee * makerFeeRate / ONE
    self.subtractCash(market, fee)
    self.addCash(creator, fee/2)
    self.addCash(branch, fee/2)
    
    # only count branch fees here
    self.addFees(market, fee/2+branchFees)

    max_amount -= fill
    # Log transaction
    log(type=log_fill_tx, market, msg.sender, owner, ASK, price, fill, trade_id, outcome)
    # Log price, fill amount, type and timestamp
    log(type=log_price, market, type, price, fill, block.timestamp, outcome, msg.sender)
    self.setPrice(market, outcome, price)
    return([SUCCESS, max_amount, fill, price]: arr)
inset('refund.se')

macro ONEPOINTTWO: 22136092888451461120

macro POINTZEROZEROONE: 18446744073709552

macro POINTONE: 1844674407370955264

macro POINTNINE: 16602069666338596864

# Prove both that a reporter voted on less than he/she actually could have and it was <.5 of what they should have reported on using an example event
# The rep lost here is then sent to the branch's rep account and distributed like other redistributed rep.
# Note:
    # Reporters pay an eth bond for this on their first report --- if never called then during collect fees they get it back else it goes back to pay someone who correctly calls this function, so the bond is returned to the poster if not enough penalized is 0 or self.getForkPeriod(branch)+1 == lastPeriod during collect fees [which means it's the first period after a fork is initiated]
# Returns 1 if successful
# Errors:
    # -1: already done
    # -2: not in right part of period
def proveReporterDidntReportEnough(branch, reporter, eventExample):
    refund()
    lastPeriod = self.getVotePeriod(branch)-1
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(self.getNotEnoughPenalized(branch, reporter, lastPeriod)):
        return(-1)
    if(self.getForkPeriod(branch)+1 == lastPeriod):
        self.setNotEnoughPenalized(branch, reporter, lastPeriod)
        return(1)
    if(residual > periodLength/2):
        return(-2)
    # events a user should be reporting on
    # eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2))
    # a^b=exp(b*ln(a))=e^(b*ln(a)).
    prelim = self.getNumEventsToReportOn(branch, lastPeriod)
    # need to do active rep on a period by period basis.. todo
    exp = self.fx_exp(ONEPOINTTWO*self.fx_log(self.getBeforeRep(branch, lastPeriod, sender))/ONE)*2**64/self.fx_exp(ONEPOINTTWO*self.fx_log(self.getActiveRep(branch))/ONE)
    baseReporters = self.getBaseReportersLastPeriod(branch)
    # if total [which is mult by num events to report on via the prelim amount] is too high [>1] then numevents will estimate a higher number than reality, so need to correct for this below
    total = exp*baseReporters
    numEvents = exp*prelim + self.getNumRequired(branch, lastPeriod)*ONE
    eventsInPeriod = self.getNumberEvents(branch, lastPeriod)-self.getNumRemoved(branch, lastPeriod)
    if(repConstant >= POINTZEROONE):
        minimum = min(30+self.getNumRequired(branch, lastPeriod), eventsInPeriod)
        if(numEvents/ONE < minimum):
            numEvents = minimum*ONE
    # correction for if people have more than x [4.6% of at 40 min reporters] rep in one account - they report on everything (hence incentive to divy rep into mult. accounts and not pool) i.e. if((exp(ln(rep%)*1.2)+0.001)*40 > 1)
    if(total > ONE):
        numEvents = (self.getNumEventsToReportOn(branch, lastPeriod)/baseReporters)*ONE + self.getNumRequired(branch, lastPeriod)*ONE
    numReportsActual = self.getNumReportsActual(branch, lastPeriod, reporter)
    # reporter couldve reported on event example but didnt
    couldveReported = self.getEventCanReportOn(branch, lastPeriod, reporter, eventExample)
    if(numEvents/2 > numReportsActual*ONE && couldveReported):
        # typically meant for people who did report but not enough [those who didnt at all use pen. catchup] so using before rep is fine, but if not use rep balance
        originalRep = self.getBeforeRep(branch, lastPeriod, reporter)
        if(originalRep==0):
            originalRep = self.getRepBalance(branch, reporter)
        # penalize people
        newRep = POINTONE*numReportsActual*originalRep / numEvents
        oldRep = originalRep*POINTNINE / ONE
        repChange = (oldRep+newRep) - originalRep
        if(repChange > 0):
            return(1)
        # removes rep from reporter who lost it
        self.addRep(branch, self.repIDToIndex(branch, reporter), repChange)
        # sends that rep to the branch rep pool
        self.addRep(branch, self.repIDToIndex(branch, branch), -repChange)
        self.setBeforeRep(branch, lastPeriod, oldRep+newRep, reporter)
        afterRep = self.getAfterRep(branch, lastPeriod, reporter)
        newAfterRep = afterRep + repChange
        if(afterRep==0):
            newAfterRep = oldRep+newRep
        self.setAfterRep(branch, lastPeriod, newAfterRep, reporter)
        self.setNotEnoughPenalized(branch, reporter, lastPeriod)
        self.doRefund(msg.sender, reporter)
        return(1)
    else:
        return(0)
inset('refund.se')

# first param is the market, second param is the subcurrency contract
data cash[][]

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF

macro CATCH_TOLERANCE: ONE / 10


# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

# If ethicality value <.5 it's 0, otherwise it's ethical
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

# Loop through events in the market, get their outcomes && use those to determine the winning outcomes and resolve a market!
# @return 0 if fail/trading not over yet/event not expired or closed already, if success 1
# Error messages otherwise
    # -1: Market has no cash anyway / already closed
    # -2: 0 outcome / not reported on yet
    # -3: not final round 2 event
    # -4: market isn't in branch
    # -5: Event forked and not final yet
    # -6: bonded pushed forward market not ready to be resolved
# if market's events have moved due to a fork branch param passed should be the new fork
def closeMarket(branch, market, sender):
    refund()
    if(self.getBranchID(market)!=branch):
        return(-4)
    if(self.balance(market)<=0):
        return(-1)
    numberEvents = self.getNumEvents(market)
    tradingPeriod = self.getTradingPeriod(market)
    period = self.getVotePeriod(branch)
    event = self.getMarketEvent(market, 0)
    reportingDone = 0
    # checks whether any events not already resolved
    resolved = 1
    if(self.getOutcome(event)==0 && self.getmode(event)==0):
        resolved = 0
    # checks if all the precommitted reports have been revealed already
    numReports = self.getNumReportsEvent(branch, self.getExpiration(event)/self.getPeriodLength(branch), event)
    numExpected = self.getNumReportsExpectedEvent(branch, self.getExpiration(event)/self.getPeriodLength(branch), event)
    if(numReports == numExpected && numReports!=0 && numExpected!=0):
        reportingDone = 1
    if((period > tradingPeriod || reportingDone) && !resolved):
        # look at through event in the market, get its outcomes, resolve it && use those to determine the winning outcomes for a given market!
        votingPeriodEvent = self.getExpiration(event)/self.getPeriodLength(branch)
        fxpOutcome = self.getOutcome(event)
        resolution = 1
        if(self.getUncaughtOutcome(event)==0):
            return(-2)
        if(self.getRoundTwo(event) && !self.getFinal(event)):
            return(-3)
        forkPeriod = self.getForkPeriod(self.getEventBranch(event))
        currentPeriod = block.timestamp / self.getPeriodLength(branch)
        if((self.getForked(event) && !self.getForkedDone(event)) or (currentPeriod <= (forkPeriod+1))):
            return(-5)
        if(binary(event) && fxpOutcome==0):
                resolution = self.resolveBinary(event, market, branch, votingPeriodEvent)
        elif(scalar(event) && self.getmode(event)==0):
                resolution = self.resolveCategoricalOrScalar(self.getMinValue(event), self.getMaxValue(event), event, market, branch, votingPeriodEvent)
        elif(categorical(event) && self.getmode(event)==0):
                resolution = self.resolveCategoricalOrScalar(ONE, ONE*self.getNumOutcomes(event), event, market, branch, votingPeriodEvent)
        if(resolution==-6):
            return(-6)
        winningOutcomes = array(8)
        winningOutcomes = self.determineWinningOutcomes(event, outitems=8)
        self.setWinningOutcomes(market, winningOutcomes)
        # refunds closing cost
        self.refundClosing(self.getgasSubsidy(market), sender)
        return(1)
    else:
        return(0)

# Claim trading profits/value per share after a market is resolved
# @returns 1 if successful
# Errors:
    # 0: reporting not done
    # -1: trader doesn't exist
def claimProceeds(branch, market):
    refund()
    if(self.getBranchID(market)!=branch):
        return(-8)
    numberEvents = self.getNumEvents(market)
    tradingPeriod = self.getTradingPeriod(market)
    period = self.getVotePeriod(branch)
    event = self.getMarketEvent(market, 0)
    reportingDone = 1
    resolved = 1
    numReports = self.getNumReportsEvent(branch, self.getExpiration(event)/self.getPeriodLength(branch), event)
    numExpected = self.getNumReportsExpectedEvent(branch, self.getExpiration(event)/self.getPeriodLength(branch), event)
    if(self.getOutcome(event)==0 && self.getmode(event)==0):
        resolved = 0
    if(numReports != numExpected && numReports!=0 and numExpected!=0):
        reportingDone = 0
        i = numberEvents
    # as long as it's resolved money can be collected
    if((period > tradingPeriod || reportingDone) && resolved):
        winningOutcomes = array(8)
        winningOutcomes = self.getWinningOutcomes(market, outitems=8)
        outcome = 0
        # market not resolved
        if(winningOutcomes[0]==0):
            return(0)
        if(winningOutcomes[1]==0):
            minval = self.getMinValue(event)
            ethical = ethic_catch(self.getEthical(event))
            # unethical or .5 categorical 1d market is resolved with all outcomes having equal values
            if(categorical(event) && (self.getmode(event)==ONEHALF or !ethical)):
                outcome = self.oneOutcome(market, winningOutcomes[0], msg.sender, 1, self.getNumOutcomes(event))
            else:
                # resolves a regular binary market
                outcome = self.oneOutcome(market, winningOutcomes[0], msg.sender, 0, 0)
        elif(winningOutcomes[1]):
            outcome = self.twoOutcomes(market, winningOutcomes, event, msg.sender)
        return(outcome)
    else:
        return(0)

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro binary($event):
    (self.getNumOutcomes($event)==2 and ONE*self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)

macro categorical($event):
    (self.getNumOutcomes($event)>2)
inset('refund.se')

# Create a new branch given a parent branch - a branch is essentially a fork of rep where new markets can be created
# period length is given in seconds
# @return branchID if success
# error messages otherwise
    # -1: bad input or parent doesn't exist
    # -2: no money for creation fee
    # -3: branch already exists
def createSubbranch(description:str, periodLength, parent, mintradingFee, oracleOnly):
    refund()
    if(periodLength<=0 || !self.getPeriodLength(parent) || description==0):
        return(-1)
    if(minTradingFee < 0 or minTradingFee > 2**62):
        return(-1)
    parentPeriod = self.getVotePeriod(parent)
    branchInfo = string(7*32+len(description))
    branchInfo[0] = msg.sender
    #creation fee
    branchInfo[1] = 47*ONE
    #length of voting cycle
    branchInfo[2] = periodLength
    branchInfo[3] = block.timestamp
    branchInfo[4] = parent
    branchInfo[5] = minTradingFee
    branchInfo[6] = oracleOnly
    mcopy(branchInfo + 7*32, description, len(description))
    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash && characteristics && say, "don't trust me? check"
    branchID = sha3(branchInfo, chars=len(branchInfo))
    currentVotePeriod = (block.timestamp / periodLength) - 1
    if(self.balance(msg.sender)<47*ONE):
        return(-2)
    # provided event doesn't already exist, create it
    if(self.getCreator(branchID)==0):
        self.initializeBranch(branchID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod, parent)
    else:
        return(-3)
    # pay creation fee, initialize branch info
    if(self.sendFrom(parent, 47*ONE, msg.sender) && self.setInfo(branchID, description, tx.origin, 47*ONE) && self.setInitialReporters(parent, branchID)):
        return(branchID)
    else:
        return(-2)
inset('refund.se')

#event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)

macro POINTZEROONE: 184467440737095520
macro POINTEIGHT: 14757395258967642112
macro POINTTWO: 3689348814741910528
macro POINTFOUR: 7378697629483821056
macro MINBOND: 200*ONE

# Penalizes a reporter for reporting wrongly on a round 2 reporting / backstop 1 event
# So we want to do the rep redistribution for both period 1 and period 2 at this time
# essentially penalizeWrong for backstop 1 [where everyone reports on a given event]
# in a fork this is called on the original branch and event is reported on again on new branch
# Errors:
    #  0: event isn't eligible/up for round two penalization
    # -2: already past first half of new period and needed to penalize before then
    # -3: round two resolve wasn't successful
    # -4: in fork period only thing that rep redistribution is done on is the round 2 event in the original branch via round 2 penalize
    # -5: already done for all events in this period
# force event to be resolved first if it can be
# roundTwoResolve needs to be called for any event here before can be penalized if it's a backstop 1 event, a la close market for other events before being penalized
# todo go over penalty amounts like .2 for ethicality seems too high
def penalizeRoundTwoWrong(branch, event):
    refund()
    roundTwo = self.getRoundTwo(event)
    repBalance = self.getRepBalance(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    forkPeriod = self.getForkPeriod(branch)
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    newRep = 0
    newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)
    if(self.getPenalizedUpTo(branch, msg.sender)==lastPeriod):
        return(-5)
    # if no events in a period
    if(self.getNumberEvents(branch, lastPeriod)<=0):
        self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
        self.increaseDenominator(branch, lastPeriod, repBalance)
        return(1)
    elif(self.getForkPeriod(branch) == lastPeriod && event!=forkEvent):
        return(-4)
    # if no outcome / event not resolved yet, resolve it [as long as it wasn't an event that was pushed fwd and got rejected and thus hasn't actually resolved yet]
    uncaught = self.getUncaughtOutcome(event)
    if(!uncaught):
        if(self.roundTwoResolve(branch, event, self.getEventIndex(votePeriod, event), msg.sender)==0):
            return(-3)
    outcome = catch(uncaught)
    if(scalar(event) or categorical(event)):
        outcome = uncaught
    forkEvent = self.getEventForkedOver(branch)
    p = self.proportionCorrect(event)
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    lastPenalizationPeriod = lastPeriod - 1
    oldReport = self.getReport(branch,lastPenalizationPeriod,event,msg.sender)
    ethics = self.getEthicReport(branch, lastPeriod, event, msg.sender)
    oldEthics = self.getEthicReport(branch, lastPenalizationPeriod, event, msg.sender)
    avgAdjCost = self.getInitialBalance(branch, votePeriod)/self.getNumberEvents(branch, votePeriod)
    bond = avgAdjCost + self.getSharesValue(market)*(POINTZEROONE + self.getTradingFee(market)/2) / 2**64
    bond = min(bond, MINBOND)
    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period
    elif(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
        return(-2)
    # if overruled / different outcome after reporting on again
    overruled = 0
    if(scalar(event) or categorical(event)):
        if((self.getOriginalOutcome(event) != self.getUncaughtOutcome(event) or self.getOriginalEthicality(event)!=ethic_catch(self.getEthical(event)))):
            overruled = 1
    elif((self.getOriginalOutcome(event) != catch(self.getUncaughtOutcome(event)) or self.getOriginalEthicality(event)!=ethic_catch(self.getEthical(event)))):
        overruled = 1
        
    numReportedOn = self.getNumReportsActual(branch, lastPeriod, msg.sender)

    # penalization on a round 2 event if not already penalized, it has outcome, and user reported on it
    # if it's penalizing in the period it was pushed back to we can do the penalization, should do it for both the first and second period
    if(self.getRoundTwo(event) && (self.getFinal(event) or event==forkEvent) && !self.getPenalized(branch, lastPeriod, msg.sender, event) && (reportValue or oldReport)):
        newAfterRep = 0
        smoothedRep = 0
        # Do the first rep redistribution based on first report and final outcome if reported first time
        if(oldReport && outcome!=0):
            # wrong
            #184467440737095520 == 0.01 in fxp
            if(oldReport > outcome+POINTZEROONE or oldReport < outcome-POINTZEROONE):
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = oldReport - outcome
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*p - ONE)/ONE
            # right
            else:
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = oldReport - outcome
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
            # (1-k) * old rep + k * new rep where k = 0.4 / (number of events you reported on last period) for penalization and pen. rate for backstop 1
            # use .04 as a max penalty per event for round 2 liars who lied on first report --- todo should do .02 in the not-overruled case
            if(numReportedOn<10):
                repChange = oldRep * (ONE - POINTFOUR/10)/ONE + newRep*(POINTFOUR/10)/ONE - oldRep
            else:
                repChange = oldRep * (ONE - POINTFOUR/numReportedOn)/ONE + newRep*(POINTFOUR/numReportedOn)/ONE - oldRep
            newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
            # for ethicality if diff. appeal then pay back the appeal bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively
            if(oldEthics != ethic_catch(self.getEthical(event)) && repChange >=0):
                repChange = -POINTTWO*repBalance / ONE
            if(repBalance + repChange <= 0):
                repChange = -1*repBalance
            # if overruled: reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, rest goes to branch as usual later in the process
            if(overruled && self.getBondPaid(event) < 2*bond && repChange < 0 && event!=forkEvent):
                # done instead of sending to redistrib. pool
                self.addRep(branch, self.repIDToIndex(branch, msg.sender), repChange)
                # sends that rep to the bonded challenger
                self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), -repChange)
                self.increaseBondPaid(event, (-1*repChange))
        # Do the second (for each user) based on second report and final outcome
        if(reportValue && outcome!=0):
            # wrong
            #184467440737095520 == 0.01 in fxp
            if(reportValue > outcome+POINTZEROONE or reportValue < outcome-POINTZEROONE):
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = reportValue - outcome
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*p - ONE)/ONE
            # right
            else:
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = reportValue - outcome    
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
            # (1-k) * old rep + k * new rep where k = 0.2 / (number of events you reported on last period) for penalization and pen. rate for backstop 1
            # use .02 as a max penalty per event for round 2 on second report
            if(numReportedOn<10):
                repChange = oldRep * (ONE - POINTTWO/10)/ONE + newRep*(POINTTWO/10)/ONE - oldRep
            else:
                repChange = oldRep * (ONE - POINTTWO/numReportedOn)/ONE + newRep*(POINTTWO/numReportedOn)/ONE - oldRep
            newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
            # for ethicality if diff. appeal then pay back the appeal bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively - or should this only be done for last period?
            if(ethics != ethic_catch(self.getEthical(event)) && repChange >=0):
                repChange = -POINTTWO*repBalance / ONE
            if(repBalance + repChange <= 0):
                repChange = -1*repBalance
            if(overruled && self.getBondPaid(event) < 2*bond && repChange < 0 && event!=forkEvent):
                # done instead of sending to redistrib. pool
                self.addRep(branch, self.repIDToIndex(branch, msg.sender), repChange)
                # sends that rep to the bonded challenger
                self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), -repChange)
                self.increaseBondPaid(event, (-1*repChange))
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    else:
        return(0)
    # if a fork event in original branch, only event needed to report on in this period is that one [b/c the original branch resolves it as a regular round 2 event, fork reports again]
    if(event==forkEvent):
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, (numReportedOn - 1))
    # penalization on a regular event if not already penalized, it has outcome, and user reported on it
    if(numReportedOn==self.getPenalizedNum(branch, lastPeriod, msg.sender)):
        if(newAfterRep <= 0):
            newAfterRep = 0
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        if(oldRep==0):
            self.setAfterRep(branch, lastPeriod, repBalance, msg.sender)
            self.setBeforeRep(branch, lastPeriod, repBalance, msg.sender)
            newAfterRep = repBalance
            oldRep = repBalance
        self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
        self.increaseDenominator(branch, lastPeriod, newAfterRep)
        totalRepDifference = newAfterRep - oldRep
        if(repBalance + totalRepDifference <= 0):
            totalRepDifference = -1*repBalance
        if(totalRepDifference<0):
            # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
            self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
            # sends that rep to the branch
            self.addRep(branch, self.repIDToIndex(branch, branch), -totalRepDifference)
    return(1)


### Helper functions:
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro categorical($event):
    (self.getNumOutcomes($event)>2)

macro abs($a):
    if($a<0):
        $a = -$a
    $a

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE
inset('refund.se')

# Payout traders in markets with number of winningOutcomes of 2 [one scalar with any combination of binary + categorical for the other 2 dimensions, or just 1D]
def twoOutcomes(market, winningOutcome: arr, event, sender):
    refund()
    # fetch outcome and min/max values for the scalar
    outcome = self.getOutcome(event)
    minValue = self.getMinValue(event)
    maxValue = self.getMaxValue(event)
    # price is in fixed point
    # share two goes with the high side
    pricePerShare2 = ONE*(outcome - minValue) / (maxValue - minValue)
    # share one goes with the low side of the calc
    pricePerShare1 = ONE - pricePerShare1
    # distribute cashcoin to the people who won money by holding winning shares
    participantNumber = self.getParticipantNumber(market, sender)
    participant = self.getParticipantID(market, participantNumber)
    # for each winning outcome get rid of shares and send money to the trader
    n = 0
    cumScale = self.getCumScale(market)
    while(winningOutcome[n]!=0):
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])
        self.modifyParticipantShares(market, participantNumber, winningOutcome[n], -sharesOwned)
        # low side
        if(n==0):
            self.subtractCash(market, sharesOwned*cumScale/ONE*pricePerShare1/ONE)
            self.addCash(participant, sharesOwned*cumScale/ONE*pricePerShare1/ONE)
        # high side (of the scalar part)
        elif(n==1):
            self.subtractCash(market, sharesOwned*cumScale/ONE*pricePerShare2/ONE)
            self.addCash(participant, sharesOwned*cumScale/ONE*pricePerShare2/ONE)
        n+=1
    return(1)
inset('refund.se')

def makeHash(salt, report, eventID, sender):
    hashInfo = array(4)
    hashInfo[0] = sender
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha3(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# Allows a user to submit the hash of their report / commit
# Error: 0: not caught up on rep redistributions
# Error -1: invalid event
# Error -2: not in first half of period [commit part]
def submitReportHash(event, reportHash):
    branch = self.getBranch(event)
    votePeriod = self.getVotePeriod(branch)

    # makes sure a user is up to date on penalizations
    lastPeriodPenalized = self.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)
    if(!self.getRRDone(branch, msg.sender)):
        return(0)

    # if first report of period, num events not set
    if(self.getNumEventsToReportOn(branch, votePeriod)==0):
        self.setNumEventsToReportOn(branch)
        self.setInitialBalance(branch, votePeriod, self.balance(branch))
    eventIndex = self.getEventIndex(votePeriod, event)
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    if(eventIndex==0 && (eventID==0 || event!=eventID)):
        return(-1)
    reportingThreshold = 0
    if(self.getRequired(event) || self.getReportingThreshold(event)):
        reportingThreshold = 2**192
    else:
        if(self.getLesserReportNum(branch, votePeriod, event)==0):
            self.calculateReportTargetForEvent(branch, event, votePeriod, msg.sender)
        reportingThreshold = self.calculateReportingThreshold(branch, event, votePeriod, msg.sender)
    x = array(1)
    x[0] = msg.sender + event
    # do abs then mult by 2 to ensure pos. and between 0 and 1
    shaHash = sha3(x, items=1)
    shaHashAbs = abs(shaHash)/ONE
    shaHash = 2*shaHashAbs
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual <= periodLength/2 && shaHash <= reportingThreshold):
        if(self.getReportHash(branch, votePeriod, msg.sender, event)==0):
            self.addReportExpected(branch, votePeriod, event)
        self.setReportHash(branch, votePeriod, msg.sender, reportHash, event)
        return(1)
    return(-2)

# Submits / reveals a report for a period
# @return 1 if success
# Error messages
    # 0: reporter doesn't exist or has <1 rep
    # -1: has already reported
    # -2: not in second half of period [reveal part]
    # -3: hash doesn't match
    # -4: bad report
    # -5: invalid event
    # -6: already resolved
    # -7: <48 hr left in period, too late to report, able to put up readj. bonds though
    # -8: fees couldn't be collected
    # -9: need to pay not reporting bond
def submitReport(event, salt, report, ethics):
    branch = self.getBranch(event)
    balance = self.getRepBalance(branch, msg.sender)
    votePeriod = self.getVotePeriod(branch)
    if(balance<ONE):
        return(0)
    # if 1st report of the period for a reporter
    if(!self.getNumReportsActual(branch, votePeriod, msg.sender)):
        if(msg.value <= 500000*tx.gasprice):
            return(-9)
        dormantRep = self.balanceOf(branch, msg.sender)
        # Record rep at start of report period
        self.setBeforeRep(branch, votePeriod, balance, msg.sender)
        self.setAfterRep(branch, votePeriod, balance, msg.sender)
        self.setPeriodDormantRep(branch, votePeriod, dormantRep, msg.sender)
        self.setRefund(msg.sender, msg.value)
        send(CONSENSUS, msg.value)
    if(self.getReport(branch, votePeriod, event, msg.sender)):
        return(-1)
    eventIndex = self.getEventIndex(votePeriod, event)
    # makes sure event is in the given branch and vote period
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    if(eventIndex==0 && (eventID==0 || event!=eventID)):
        return(-5)
    elif(self.getOutcome(event)!=0):
        return(-6)
    periodLength = self.getPeriodLength(branch)
    # ensures user has collected fees for last reporting period
    if(!self.getFeesCollected(branch, msg.sender, votePeriod-1)):
        if(self.collectFees(branch, msg.sender)<1):
            return(-8)
    # commented out for testing
    #if(block.timestamp/periodLength!=((block.timestamp + 2*TWENTYFOURHR)/periodLength)):
    #    return(-7)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        realHash = self.getReportHash(branch, votePeriod, msg.sender, event)
        if(self.makeHash(salt, report, eventID, msg.sender)!=realHash || realHash==0):
            return(-3)
        forkedOverEthicality = self.getForkedOverEthicality(event)
        forkedOverThisEvent = 0
        if(self.getEventForkedOver(branch) == event):
            forkedOverThisEvent = 1
        roundTwo = self.getRoundTwo(event)
        report = self.validateReport(event, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance)
        if(report == -4):
            return(-4)
        self.setReport(branch, votePeriod, eventID, report, msg.sender)
        # set ethics value for event
        ethics = ethics
        if(ethics!=ONE and ethics!=0):
            ethics = ONE
        # set ethicality for forked event
        if(forkedOverThisEvent):
            # fork remove ethicality option if was forked over ethicality, other ethicality choice is the ethicality
            if(forkedOverEthicality):
                oldEthical = ethic_catch(self.getEthical(event))
                if(oldEthical == ONE):
                    ethics = 0
                else:
                    ethics = ONE
            self.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
            ethics = (self.getForkEthicality(event)*self.getRepEvent(branch, votePeriod, event) + ethics*balance) / (self.getRepEvent(branch, votePeriod, event) + balance)
            self.setForkEthicality(event, ethics)
        # set ethicality for a regular event
        else:
            self.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
            if(roundTwo):
                ethics = (self.getEthics(event)*self.getRepEvent(branch, votePeriod, event) + ethics*balance) / (self.getRepEvent(branch, votePeriod, event) + balance)
            else:
                ethics = (self.getEthics(event)*self.getNumReportsEvent(branch, votePeriod, event) + ethics) / (self.getNumReportsEvent(branch, votePeriod, event) + 1)
            self.setEthics(eventID, ethics)
        self.addReportToEvent(branch, votePeriod, eventID, msg.sender)
        # round 2 and fork events are weighted by rep    
        if(roundTwo or forkedOverThisEvent):
            self.addRepEvent(branch, votePeriod, event, self.getBeforeRep(branch, votePeriod, msg.sender))
        reportsNum = self.getLesserReportNum(branch, votePeriod, event)
        paidBack = self.getReportersPaidSoFar(branch, event)
        diff = reportsNum - paidBack
        # used to pay reporters after reporting for their gas costs
        if(diff >= 1):
            self.addReportersPaidSoFar(branch, event)
            self.subtractCash(branch, 3500000*tx.gasprice*ONE / WEITOETH)
            self.addCash(msg.sender, 3500000*tx.gasprice*ONE / WEITOETH)
        return(1)
    return(-2)

# validates and submits report
# weights reports by rep if round 2 and fork
# Returns -4 if report is invalid
    # isn't between 1 and 2 if binary
    # if same report as original outcome / ethicality if a forked event not forked over ethicality it's also invalid b/c this option was removed as a poss. answer
def validateReport(eventID, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance):
    outcome = 0
    # binary
    if(self.getNumOutcomes(eventID)==2 and self.getMaxValue(eventID)==TWO && self.getMinValue(eventID)==ONE):
        if(report>2*ONE or report<ONE or report==0):
            return(-4)
        # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        elif(forkedOverThisEvent):
            # in case of fork remove the original outcome as a possible response if didn't fork over ethics
            if(!forkedOverEthicality && report == catch(self.getUncaughtOutcome(eventID))):
                return(-4)
            outcome = (self.getForkOutcome(eventID)*self.getRepEvent(branch, votePeriod, eventID) + report*balance) / (self.getRepEvent(branch, votePeriod, eventID) + balance)
            self.setForkOutcome(eventID, outcome)
        else:
            if(roundTwo):
                outcome = (self.getUncaughtOutcome(eventID)*self.getRepEvent(branch, votePeriod, eventID) + report*balance) / (self.getRepEvent(branch, votePeriod, eventID) + balance)
            else:
                outcome = (self.getUncaughtOutcome(eventID)*self.getNumReportsEvent(branch, votePeriod, eventID) + report) / (self.getNumReportsEvent(branch, votePeriod, eventID) + 1)
            self.setUncaughtOutcome(eventID, outcome)
    # scalar or categorical
    else:
        if(report > ONE):
            report = ONE
        elif(report<=0):
            # 1 is the new 0
            report = 1
        if(forkedOverThisEvent):
            # in case of fork remove the original outcome as a possible response if didn't fork over ethics
            if(!forkedOverEthicality && report == self.getUncaughtOutcome(eventID)):
                return(-4)
            # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
            self.addToWeightOfReport(votePeriod, eventID, report, balance)
            if(self.getWeightOfReport(votePeriod, eventID, report) > self.getCurrentModeItems(votePeriod, eventID)):
                self.setCurrentMode(votePeriod, eventID, report)
                self.setCurrentModeItems(votePeriod, eventID, report)
            outcome = self.getCurrentMode(votePeriod, eventID)
            self.setForkOutcome(eventID, outcome)
        else:
            if(roundTwo):
                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
                self.addToWeightOfReport(votePeriod, eventID, report, balance)
                if(self.getWeightOfReport(votePeriod, eventID, report) > self.getCurrentModeItems(votePeriod, eventID)):
                    self.setCurrentMode(votePeriod, eventID, report)
                    self.setCurrentModeItems(votePeriod, eventID, report)
                outcome = self.getCurrentMode(votePeriod, eventID)
            else:
                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
                self.addToWeightOfReport(votePeriod, eventID, report, 1)
                if(self.getWeightOfReport(votePeriod, eventID, report) > self.getCurrentModeItems(votePeriod, eventID)):
                    self.setCurrentMode(votePeriod, eventID, report)
                    self.setCurrentModeItems(votePeriod, eventID, report)
                outcome = self.getCurrentMode(votePeriod, eventID)
            self.setUncaughtOutcome(eventID, outcome)
    return(report)

### Helper functions:
# calculates how many reports should be on a given event
def calculateReportTargetForEvent(branch, eventID, votePeriod, sender):
    numMarkets = self.getNumMarkets(eventID)
    if(numMarkets>25):
        numMarkets = 25
    markets = array(numMarkets)
    markets = self.getMarkets(eventID, outitems=numMarkets)
    totalFees = 0
    shareValue = 0
    i = 0
    while i < numMarkets:
        shareValue += self.getSharesValue(markets[i])
        totalFees += self.getFees(markets[i])
        i += 1
    totalVal = self.getShareValue(branch, votePeriod)
    shareFraction = shareValue*ONE/totalVal
    numReportersOnMarket = self.getBaseReporters(branch)*((-(267*shareFraction**2)/(2*ONE) + (533*shareFraction)/2 + 1*ONE))
    totalFeesInWei = totalFees * WEITOETH / ONE
    canPayForThisManyReporters = totalFeesInWei/(3500000*tx.gasprice)
    lesser = min(canPayForThisManyReporters*ONE, numReportersOnMarket)
    if(self.getLesserReportNum(branch, period, event)==0):
        self.refundCost(sender, self.getSubsidy(branch, votePeriod, eventID))
        self.setLesserReportNum(branch, votePeriod, eventID, lesser)
    return(lesser)

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
        
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE
        
macro abs($a):
    if($a<0):
        $a = -$a
    $a
inset('refund.se')

macro POINTZEROSIX: 1106804644422573056
macro COSTPERREPORTER: 3500000

def createSingleEventMarket(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution:str, tradingFee, tag1, tag2, tag3, makerFees, extraInfo:str):
    event = self.createEvent(branch, description, expDate, minValue, maxValue, numOutcomes, resolution)
    market = self.createMarket(branch, description, tradingFee, [event], tag1, tag2, tag3, makerFees, extraInfo)
    return(market)

# Create an event. Events are the basic units / questions that are reported on in Augur by reporters
# @param numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0 to 11.0 would be 11 outcomes (if incremented by 0.1)
# @param minValue should be 2**64 for a binary event, maxValue should be 2**65 for a binary event
# @param minValue for a scalar from 0 to 100 should be 0 and max should be 100*2**64, for -100 to 200, it should be -100*2**64 and 200*2**64 respectively
# @param description is a description of the event / the question itself
# @param resolution is the string source/link to resolve the event
# @param branch is the branch the event is created in
# @param expDate is the epoch time in which the event expires
# @return eventID if success
# error messages otherwise
    #  0: not enough money to pay fees or event already exists
    # -1: we're either already past that date, branch doesn't exist, or description is bad
    # -2: max value < min value or range < 1
    # -3: invalid number of outcomes
    # -4: would expire during non-reporting fork period
# .025 eth to create
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution: str):
    refund()
    periodLength = self.getPeriodLength(branch)
    forkPeriod = self.getForkPeriod(branch)
    if(forkPeriod && ((expDate / periodLength)==forkPeriod or (expDate / periodLength)==(forkPeriod+1))):
        return(-4)
    if(maxValue < minValue or (maxValue-minValue) < ONE):
        return(-2)
    eventID = 0
    if(periodLength && description != 0 && expDate > block.timestamp):
        eventinfo = string(7*32 + len(description))
        eventinfo[0] = branch                                       #branchID
        eventinfo[1] = expDate                                      #expiration date
        eventinfo[2] = msg.sender                                   #creator address
        eventinfo[3] = periodLength
        eventinfo[4] = minValue                                     #minimum outcome value
        eventinfo[5] = maxValue                                     #maximum outcome value
        eventinfo[6] = numOutcomes                                  #number of outcomes
        mcopy(eventinfo + 7*32, description, len(description))
        eventID = sha3(eventinfo, chars=len(eventinfo))
    else:
        return(-1)
    if(numOutcomes < 2 || numOutcomes > 8):
        return(-3)
    currentVotePeriod = self.getVotePeriod(branch)
    self.initiateOwner(eventID)
    if(!self.getCreator(eventID)):
        if(self.setInfo(eventID, description, msg.sender, 0) && self.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes, resolution)):
            return(eventID)
        else:
            return(0)
    else:
        return(0)

# Create a market. Markets are the basic _tradable_ units / questions that are traded on in Augur
# @param branch is the branch of the market
# @param description is the description for a market
# @param tradingFee is percent in fixedPoint
# @param events array is the list of events in a market [up to 3]
# @params tag1, tag2, and tag3 are the tags describing a market
# @param makerFees are the percent of the trading fee a maker pays [0-50% in fixed point]
# @param extraInfo is a string of any extra info associated with a market
# @return marketID if success or 1 if on an oracle only branch creation we have success
# error messages otherwise
    # -1: bad input or parent doesn't exist
    # -2: too many events
    # -3: too many outcomes
    # -4: not enough money to pay all the event bonds
    # -5: fee too low
    # -6: duplicate events
    # -7: event already expired
    # -8: market already exists
    # -9: would expire during non-reporting fork period
# .05 eth to create
# need to check that it's an actual subcurrency upon market creation (maybe check send/balance funs)
def createMarket(branch, description:str, tradingFee, event, tag1, tag2, tag3, makerFees, extraInfo:str):
    if(makerFees<0 or makerFees > ONEHALF):
        return(0)
    numOutcomes = self.getNumOutcomes(event)
    if(numOutcomes > 8):
        return(-3)
    periodLength = self.getPeriodLength(branch)
    creationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / (2*tradingFee)
    # gives ether/cash amount in fixed point
    minFee = COSTPERREPORTER*self.getBaseReporters(branch)*tx.gasprice*ONE/WEITOETH
    if(creationFee < minFee):
        creationFee = minFee
    validity_bond = (creationFee * (1 + self.getPast24(period)) / (1 + self.getNumberEvents(branch, self.getVotePeriod(branch))))/2
    if(self.balance(msg.sender) < (creationFee+validity_bond)):
        return(-4)
    # will need to get equivalent value in usd or eth or w/e via etherex exchange for subcurrency markets
    if(periodLength==0 or len(description)==0 || tradingFee < self.getMinTradingFee(branch) or tradingFee > 2^61):
        return(-1)
    # need at least 1.2M gas @ gas price to cover resolution + 1M for each additional event + 500k per event to calc. num reports for it
    if(msg.value < (1200000*tx.gasprice + 1000000*tx.gasprice*(eventNum-1) + 500000*tx.gasprice)):
        send(msg.sender, msg.value)
        return(0)

    # check that events have same exp. dates && branch
    cumulativeScale = 0
    # market's trading period is the same as the last expiring event in the market
    expirationDate = self.getExpiration(event)
    futurePeriod = expirationDate / periodLength
    if(expirationDate < block.timestamp):
        return(-7)
    forkPeriod = self.getForkPeriod(branch)
    if(forkPeriod && (futurePeriod == forkPeriod or futurePeriod == (forkPeriod+1))):
        return(-9)
    if(self.getEventBranch(event) != branch || !self.getCreator(event)):
        return(-1)
    if(!self.getBond(event)):
        # pay validity / indeterminate protection bond
        period = block.timestamp / TWENTYFOURHR
        if(!self.sendFrom(event, validity_bond, msg.sender)):
            return(-4)
        self.setBond(event, validity_bond)
        self.addPast24(period)
    #scalars
    maxValue = self.getMaxValue(event)
    minValue = self.getMinValue(event)
    if((maxValue!=TWO || minValue !=ONE) && self.getNumOutcomes(event)==2):
        # is a valid scalar
        # cumulativeScale is the range of a scalar
        cumulativeScale += maxValue - minValue
    if(cumulativeScale==0):
        cumulativeScale = ONE
    lastExpDate = expirationDate

    # formation of marketID (hash)
    marketinfo = string(8*32 + len(description))
    marketinfo[0] = futurePeriod
    marketinfo[1] = tradingFee
    marketinfo[2] = block.timestamp
    marketinfo[3] = tag1
    marketinfo[4] = tag2
    marketinfo[5] = tag3
    marketinfo[6] = lastExpDate
    marketinfo[7] = len(description)
    mcopy(marketinfo + 8*32, description, chars=len(description))
    marketID = sha3(marketinfo, chars=len(marketinfo))
    
    # if it's already been created return 0
    if(self.getCreator(marketID) || self.getMarketNumOutcomes(marketID)):
        return(-8)
    events = array(1)
    events[0] = event
    # initialize market and send money to pay for resolution
    if(self.sendFrom(branch, creationFee, msg.sender) && send(MARKETS, (msg.value-500000*eventNum*tx.gasprice)) && self.setInfo(marketID, description, msg.sender, creationFee) && self.addMarketToBranch(branch, marketID) && self.initializeMarket(marketID, events, futurePeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumulativeScale, numOutcomes, extraInfo, msg.value-500000*eventNum*tx.gasprice, creationFee, lastExpDate)):
        # add events to the appropriate reporting period
        self.addMarket(event, marketID)
        if(self.getEvent(branch, futurePeriod, self.getEventIndex(futurePeriod, event))!=event):
            self.addEvent(branch, futurePeriod, event, 500000*tx.gasprice)
            # cost for calculating num. of reports for an event
            self.send(EXPEVENTS, 500000*tx.gasprice)
        self.addToMarketsHash(branch, marketID)
        self.initiateOwner(marketID)
        return(marketID)
    else:
        return(0)

def updateTradingFee(branch, market, tradingFee):
    refund()
    if(msg.sender != self.getCreator(market) || tx.origin != self.getCreator(market)):
        return(-4)
    oldFee = self.getTradingFee(market)
    oldCreationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / oldFee
    newCreationFee = POINTZEROSIX * self.getBaseReporters(branch) * ONE / tradingFee
    if(tradingFee < self.getMinTradingFee(branch) or tradingFee > oldFee):
        return(-1)
    self.sendFrom(branch, newCreationFee-oldCreationFee, msg.sender)
    return(self.setTradingFee(market, tradingFee))

# Anyone can post an "Early Resolution Bond"
# This bond is equal to 0.5 * Market_Fee * Market_Value
# This amount is the amount needed to pay the reporters in case this was frivolous.
# The market goes up for early resolution and reporters place claim to what is truth, however for early resolution, they have an additional option: 'Market is not ready to resolve'
    # this addl option is just the normal indeterminate (except here it's a bit of a special case, see below)
# In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and market remains with old expiration dateevent
# In the event any other option is found to be the consensus the early resolution bond is returned to the poster and then resolution is handled just like any other case.
def pushMarketForward(branch, market):
    refund()
    # can't do while forking
    forkPeriod = self.getForkPeriod(branch)
    periodLength = self.getPeriodLength(branch)
    currentPeriod = block.timestamp / periodLength
    if(forkPeriod == currentPeriod or currentPeriod == (forkPeriod+1)):
        return(-1)
    # if market closed or already pushed forward, return 0
    if(self.getOneWinningOutcome(market, 0) or self.getPushedForward(market)):
        return(-2)
    if(self.sendFrom(market, self.getTradingFee(market)*self.getTotalSharesPurchased(market)/(2*ONE), msg.sender)==0):
        return(-3)
    event = self.getMarketEvent(market, 0)
    expiration = self.getExpiration(event)
    if(self.getRejectedPeriod(event) || expiration!=self.getOriginalExpiration(event) || self.getOutcome(event) || self.getRoundTwo(event) || expiration/periodLength==block.timestamp/periodLength):
            return(-4)
    # push into next vote period
    period = block.timestamp/periodLength
    # figure out what's going on with subsidy system here
    self.addEvent(branch, period, event, 0)
    # set event expiration date to be after the current reporting period ends
    self.setExpiration(event, block.timestamp)
    self.setTradingPeriod(market, period)
    self.setPushedForward(market, 1, msg.sender)
    self.setEventPushedUp(event, 1)
    return(1)
inset('refund.se')

# Buys amount of every outcome
# cost 850k gas
# Errors:
    # 0: invalid market
    # -3: not enough money
def buyCompleteSets(market, amount):
    refund()
    if(!self.getCreationTime(market)):
        return(0)
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-1)
    numOutcomes = self.getMarketNumOutcomes(market)
    cumScale = self.getCumScale(market)
    cost = amount*cumScale/ONE
    if(self.balance(msg.sender) < cost):
        return(-3)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    # if participant doesn't exist in market, add them
    if(msg.sender != self.getParticipantID(market, participantNumber)):
        participantNumber = self.addParticipant(market, msg.sender)
    i = 1
    # send shares of the event to user address
    while i <= numOutcomes:
        self.modifyShares(market, i, amount)
        self.modifyParticipantShares(market, participantNumber, i, amount, 0)
        i += 1
    if(self.getVotePeriod(branch)<self.getTradingPeriod(market)):
        self.modifySharesValue(market, amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), amount*cumScale/ONE)
    # send money from user acc. to market address/account
    self.sendFrom(market, cost, msg.sender)
    return(1)

# Sells amount of every outcome [if user owns it]
# cost 850k gas
# Errors:
    # -2: trader doesn't exist
    # -3: user doesn't own enough shares 
def sellCompleteSets(market, amount):
    refund()
    branch = self.getBranchID(market)
    if(self.getOracleOnly(branch)):
        return(-1)
    participantNumber = self.getParticipantNumber(market, msg.sender)
    numOutcomes = self.getMarketNumOutcomes(market)
    cumScale = self.getCumScale(market)
    branch = self.getBranchID(market)
    if(self.getParticipantID(market, participantNumber) != msg.sender):
        return(-2)
    # these prices are in fixed point
    cost = amount*cumScale/ONE
    i = 1
    while i <= numOutcomes:
        if(self.getParticipantSharesPurchased(market, participantNumber, i) < amount):
            return(-3)
        i += 1
    i = 1
    while i <= numOutcomes:
        self.modifyShares(market, i, -amount)
        self.modifyParticipantShares(market, participantNumber, i, -amount, 0)
        i += 1
    if(self.getVotePeriod(branch)<self.getTradingPeriod(market)):
        self.modifySharesValue(market, -amount*cumScale/ONE)
        self.adjustPeriodShareValueOutstanding(branch, self.getTradingPeriod(market), -amount*cumScale/ONE)
    # send funds from the market to the user acc.
    self.subtractCash(market, cost)
    self.addCash(msg.sender, cost)
    return(1)
inset('refund.se')

# Returns the proportion of reporters who reported correctly on a given binary event 
def proportionCorrect(event):
    refund()
    p = 0
    outcome = catch(self.getUncaughtOutcome(event))
    if(outcome!=0):
        # binary
        if(self.getNumOutcomes(event)==2 and self.getMaxValue(event)==TWO and self.getMinValue(event)==ONE):
            # subtract 1 to get it from 0 to 1
            avgOutcome = self.getUncaughtOutcome(event) - ONE
            # say we have outcome of 0, avg is .4, what is p?
            # p is .6 or 60%
            if(outcome == ONE):
                p = ONE - avgOutcome
            # say we have outcome of 1, avg is .8, what is p (proportion correct)?
            # p is .8 or 80%
            if(outcome == 2 * ONE):
                p = avgOutcome
            if(outcome == 3 * ONEHALF):
                return(0)
        return(p)
    else:
        return(0)

inset('refund.se')

# sender/owner, then spender
data amountCanSpend[][]

event Transfer(_from:indexed, _to:indexed, _value)
event Approval(_owner:indexed, _spender:indexed, value)

# fix sender, tx.origin stuff here

# send active reputation
# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
def sendReputation(branch, recver, value):
    refund()
    # Rep cannot be simultaneously spent (transferred) and used to vote
    currentVotePeriod = self.getVotePeriod(branch)
    # you can't trade if you or the person you're sending to have submitted a report, or at all in the second half of the period [b/c you can messup / cheat w/ reporting by gettin extra claims on fees] and you can't trade in the first half of a period until you've been penalized for reporting wrongly/not reporting
    # use a diff. fun. than getReport here
    #if(value<=0 || self.getReport(branch, currentVotePeriod, tx.origin, 0) != 0 || self.getReport(branch, currentVotePeriod, msg.sender, 0) != 0 || self.getReport(branch, currentVotePeriod, recver, 0) != 0):
    # self.getNumReportsActual(branch, currentVotePeriod, msg.sender)
    #    return(0)
    
    lastPeriodPenalized = self.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)

    # need to check all this for the person it's being sent to as well
    if(!self.getRRDone(branch, msg.sender)):
        return(0)
    #if(self.getRRUpToDate()!=1):
    #    doIt()
    #    self.RRDone = true
    #if(hasReported(lastPeriod) && periodOver && hasntcollectedfees && residual > periodLength/2):
    #    self.collectFees(lastPeriod)
    # before rep, after rep, balance
    # person you're sending to needs rr up to date / done as well
    # auto increment vote period if needed
    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one, only if in first half of period
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.getRepBalance(branch, sender)
    if(senderBalance >= value && value > 0):
        if(self.subtractRep(branch, senderIndex, value) && self.addRep(branch, receiverIndex, value)):
            return(value)
        else:
            return(0)
    else:
        return(0)

# Transfer dormant rep
# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
# sendDormantRep
def transfer(branch, recver, value):
    refund()
    currentVotePeriod = self.getVotePeriod(branch)
    if(value<=0):
        return(0)
    sender = msg.sender
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=msg.sender):
        self.setPenalizedUpTo(branch, msg.sender, (self.getVotePeriod(branch)-1))
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, msg.sender, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value && value > 0):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addDormantRep(branch, receiverIndex, value)):
            log(type=Transfer, msg.sender, recver, value)
            return(value)
        else:
            return(0)
    else:
        return(0)

# TransferFrom per token api for dormant rep
# fails unless from has authorized sender
def transferFrom(branch, from, recver, value):
    refund()
    currentVotePeriod = self.getVotePeriod(branch)
    if(value<=0):
        return(0)
    sender = from
    senderIndex = self.repIDToIndex(branch, sender)
    receiverIndex = self.repIDToIndex(branch, recver)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=from):
        self.setPenalizedUpTo(branch, from, (self.getVotePeriod(branch)-1))
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, from, (self.getVotePeriod(branch)-1))
        return(-1)

    if(self.getReporterID(branch, receiverIndex)!=recver):
        return(-2)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value && value > 0 && self.amountCanSpend[from][msg.sender]>=value):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addDormantRep(branch, receiverIndex, value)):
            self.amountCanSpend[from][msg.sender] -= value
            log(type=Transfer, from, recver, value)
            return(value)
        else:
            return(0)
    else:
        return(0)
    
# Allows spender to withdraw from your dormant rep account
def approve(branch, spender, value):
    self.amountCanSpend[msg.sender][spender] = value
    log(type=Approval, msg.sender, spender, value)
    return(1)

# Returns amount spender can withdraw from owner
def allowance(owner, spender):
    return(self.amountCanSpend[owner][spender])

# Convert active rep to dormant rep
# error messages
    # -1: not in first half of reporting period
# shouldn't be penalized for dormant rep when converting back to active due to not reporting beyond the dormant penalization
def convertToDormantRep(branch, value):
    refund()
    # if not in first half of reporting period
    periodLength = self.getPeriodLength(branch)
    if(!self.getRRDone(branch, msg.sender)):
        return(0)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
      return(-1)
		# benny comment:
            #```Maybe still have this sort-of variable "power" to it, but REP initially doesn't have "full-power", or REP that hasn't been used to report over the past week has now let it's "power-meter" drop to only 20% earning power (it's kind-of dormant), that then ramps back up to 100% power once it gets used a bit. Could there be an element of this type of time-decay programmed into the REP that's helps incentive? Something like this would make the system more automatic, rather than relying on the user to manually switch "on" or switch "off" the self. If a user knows, "I better report this week or my REP's power meter goes down to 20% again, and it's gonna take extra effort to get it back to full-power", well that's pretty good incentive to keep the user active, without actually taking it from them.```

    if(value<=0):
        return(0)
    
    lastPeriodPenalized = self.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)

    #if(self.getRRUpToDate()!=1):
    #    doIt()

    #if(hasReported(lastPeriod) && periodOver):
        #self.collectFees(lastPeriod)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    senderBalance = self.getRepBalance(branch, sender)
    if(senderBalance >= value):
        if(self.subtractRep(branch, senderIndex, value) && self.addDormantRep(branch, senderIndex, value)):
            self.adjustActiveRep(branch, -value)
            return(value)
        else:
            return(0)
    else:
        return(0)

# Convert dormant rep to active rep
# error messages
    # -1: not in first half of reporting period
def convertToActiveRep(branch, value):
    refund()
    # if not in first half of reporting period
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
      return(-1)
      
    lastPeriodPenalized = self.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(self.penalizationCatchup(branch, msg.sender)!=1):
            return(0)
    if(!self.getRRDone(branch, msg.sender)):
        return(0)
    if(value<=0):
        return(0)

    #if(self.getRRUpToDate()):
        #doIt()
    #if(hasReported(lastPeriod) && periodOver):
        #self.collectFees(lastPeriod)

    sender = tx.origin
    senderIndex = self.repIDToIndex(branch, sender)

    # if the sender's rep. account doesn't exist, make one
    if(self.getReporterID(branch, senderIndex)!=tx.origin):
        self.addReporter(branch, sender)
        self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
        return(-1)

    senderBalance = self.balanceOf(branch, sender)
    if(senderBalance >= value):
        if(self.subtractDormantRep(branch, senderIndex, value) && self.addRep(branch, senderIndex, value)):
            self.adjustActiveRep(branch, value)
            return(value)
        else:
            return(0)
    else:
        return(0)
        
    
macro hasReported($branch, $period):
    self.getNumReportsActual($branch, $period, msg.sender)
inset('refund.se')

macro POINTNINE: 16602069666338596864

# Call when a user who hasn't reported for a while [and had their rep active] and wants to start again and needs to catch up on penalizations
def penalizationCatchup(branch, sender):
    refund()
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    # should only be allowed in 1st half of any period b/c rep removal / sending to branch should only be done then
    if(residual > periodLength/2):
        return(-2)
    # find delta between this last period and the last one a reporter was penalized up to
    lastPeriodPenalized = self.getPenalizedUpTo(branch, sender)
    lastPeriod = self.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    oldRep = self.getRepBalance(branch, sender)
    # provided user is at least one period behind and they didn't report in the last period
    if(lastPeriodPenalized!=lastPeriod && !self.getNumReportsActual(branch, lastPeriod, sender)):
        if(delta <= 0):
            return(0)
        # dock 10% for each period they didn't penalize on
        smoothedRep = oldRep*POINTNINE/ONE
        i = 1
        # if delta >22, max is 23 [1 above, 1 below, and 21 in while loop] penalizations simply so we don't run into out of gas issues
        if(delta>22):
            smoothedRep = smoothedRep*POINTNINE/ONE
            delta = 22
        while i < delta:
            smoothedRep = smoothedRep*POINTNINE/ONE
            i += 1
        # and send it to branch for penalty rep collection
        repChange = oldRep - smoothedRep
        # removes rep from reporter who lost it
        self.subtractRep(branch, self.repIDToIndex(branch, sender), repChange)
        # sends that rep to the branch rep pool
        self.addRep(branch, self.repIDToIndex(branch, branch), repChange)
        self.setPenalizedUpTo(branch, sender, lastPeriod)
        return(1)
    else:
        return(0)
inset('refund.se')

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

## helper function to close an event for resolution
macro closeOut($event, $market, $branch, $votingPeriodEvent, $fxpOutcome, $periodLength, $ethical, $scalarorcat, $mode, $ethicOutcome):
    # In the $event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.
    # and $market remains with old expiration date
    # UI needs to call penalizeWrong for ones that are pushed back in both pushed back period and regular period with actual reporting
    $indeterminate = ONEHALF*3
    if(($fxpOutcome == $indeterminate or $mode==ONEHALF) && self.getEventPushedUp($event)):
        if(self.getPushedForward($market)):
            self.addCash($branch, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
            self.subtractCash($market, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
        self.setTradingPeriod($market, self.getOriginalTradingPeriod($market))
        self.setPushedForward($market, 0, msg.sender)
        self.setNumReportsExpectedEvent($branch, $votingPeriodEvent, $event, 0)
        self.setNumReportsEvent($branch, $votingPeriodEvent, $event, 0)
        #set outcome to 0
        self.setOutcome($event, 0)
        self.setmode($event, 0)
        self.setEthics($event, 0)
        #set uncaughtoutcome to 0
        self.setUncaughtOutcome($event, 0)
        self.setEventPushedUp($event, 0)
        # need to store which period it was "rejected" in
        self.setRejected($event, self.getExpiration($event)/$periodLength)
        #set $event expiration to be the old date
        self.setExpiration($event, self.getOriginalExpiration($event))
        -6
    elif(($fxpOutcome==$indeterminate or $mode==ONEHALF) || !$ethical):
        # give $event bond money to reporters
        self.subtractCash($event, self.getBond($event))
        self.addCash($branch, self.getBond($event))
        # not $ethical is same as .5 outcome
        if($scalarorcat):
            # the mode is used to compare for reporting accuracy. so still the same as the reported uncaught outcome/mode, but resolving the market as .5 right in the middle of the range so payouts are done right for an unethical [or indeterminate] market
            self.setOutcome($event, $ethicOutcome)
        else:
            self.setOutcome($event, $indeterminate)
        1
    else:
        # return bond as a normal event resolution
        self.subtractCash($event, self.getBond($event))
        self.addCash(self.getCreator($event), self.getBond($event))
        if(self.getPushedForward($market)):
            self.addCash(self.getBondsMan($market), self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
            self.subtractCash($market, self.getTradingFee($market)*self.getTotalSharesPurchased($market)/(2*ONE))
        if(self.getEventPushedUp($event)):
            # delete old $event from future events exp
            $period = self.getOriginalExpiration($event)/$periodLength
            self.removeEvent($branch, $period)
            self.deleteEvent($branch, $period, $event)
            self.setOriginalExpiration($event, self.getExpiration($event))
        1

# Resolves a binary market
def resolveBinary(event, market, branch, votingPeriodEvent):
    refund()
    fxpOutcome = catch(self.getUncaughtOutcome(event))
    periodLength = self.getPeriodLength(branch)
    ethical = ethic_catch(self.getEthical(event))
    # outcome is set to the binned version of the raw reported outcome
    self.setOutcome(event, fxpOutcome)
    # ethics is set to the binned version of the raw ethicality outcome
    self.setEthics(event, ethical)
    val = closeOut(event, market, branch, votingPeriodEvent, fxpOutcome, periodLength, ethical, 0, 0, 0)
    return(val)

# Resolves a categorical market
def resolveCategoricalOrScalar(scaled_min, scaled_max, event, market, branch, votingPeriodEvent):
    refund()
    mode = self.getUncaughtOutcome(event)
    self.setmode(event, mode)
    fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
    # outcome is set to the mode of the reported outcomes
    self.setOutcome(event, fxpOutcome)
    periodLength = self.getPeriodLength(branch)
    # ethics is set to the binned version of the raw ethicality outcome
    ethical = ethic_catch(self.getEthical(event))
    ethicOutcome = 2**63 * (scaled_max - scaled_min)/ONE + scaled_min
    self.setEthics(event, ethical)
    val = closeOut(event, market, branch, votingPeriodEvent, fxpOutcome, periodLength, ethical, 1, mode, ethicOutcome)
    return(val)

# Determines the "winning outcomes" for a given market
# Easiest to give examples:
    # 1D Markets:
        # Binary or Categorical will have 1 winning outcome [1 or 2 for binary, 1 thru numOutcomes for categorical is the poss. value for the winning outcome]
def determineWinningOutcomes(event):
    refund()
    winningOutcomes = array(8)
    fxpOutcome = self.getOutcome(event)
    outcome = fxpOutcome/ONE
    if(n==0):
        #scalar or .5
        if(scalar(event) || fxpOutcome==3*ONEHALF):
            winningOutcomes[0] = 1
            winningOutcomes[1] = 2
        # anything besides scalar or .5
        else:
            winningOutcomes[0] += outcome
    return(winningOutcomes: arr)
inset('refund.se')


# Penalizes a reporter for reporting wrongly on a forked event / backstop 2
# Notes:
    # essentially penalizeWrong for backstop 2 [where everyone reports on a forked event on the new branch]
    # only called on the fork not the parent, normal penalization except the outcome values are forkOutcome and forkEthicality as opposed to anything else
    # some rep from this goes to bond poster
    # branch is the fork, not the parent
    # fork event needs to be resolved first before this can be called
# Errors:
    #  0: not enough rep to report/penalize
    # -2: already past first half of new period and needed to penalize before then
    # -4: fork event isn't resolved yet
    # -5: already done for all events in this period
def penalizeOnForkedEvent(branch, event):
    refund()
    repBalance = self.getRepBalance(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    newRep = 0
    newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)
    if(repBalance < ONE):
        return(0)
    forkOutcome = self.getForkOutcome(event)
    outcome = catch(forkOutcome)
    if(scalar(event) or categorical(event)):
        outcome = forkOutcome
    p = self.proportionCorrectForkEvent(event)
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    ethics = self.getEthicReport(branch, lastPeriod, event, msg.sender)
    bond = self.getBondAmount(event)
    if(self.getPenalizedUpTo(branch, msg.sender)==lastPeriod):
        return(-5)
    # means event / fork isn't resolved
    if(self.getForkedDone(event)==0):
        return(-4)
    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period
    if(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
        return(-2)
    numReportedOn = self.getNumReportsActual(branch, lastPeriod, msg.sender)
    # penalization on a forked event
    # if didn't report [reportValue of 0] then it's a bad report here
    # Do (for each user) based on forking report and final outcome
    if(!self.getPenalized(branch, lastPeriod, msg.sender, event)):
        if(outcome!=0):
            # wrong
            #184467440737095520 == 0.01 in fxp
            if(reportValue > outcome+POINTZEROONE or reportValue < outcome-POINTZEROONE):
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = reportValue - outcome
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*p - ONE)/ONE
            # right
            else:
                if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                    diff = reportValue - outcome    
                    p = -(abs(diff)/2) + ONE
                newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
            # (1-k) * old rep + k * new rep where k = 1 / (number of events you reported on last period) for forking
            # use .10 as a max penalty per fork event
            if(numReportedOn<10):
                repChange = oldRep * (ONE - ONE/10)/ONE + newRep*(ONE/10)/ONE - oldRep
            else:
                repChange = oldRep * (ONE - ONE/numReportedOn)/ONE + newRep*(ONE/numReportedOn)/ONE - oldRep
            newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
            # for ethicality if diff. appeal then pay back the fork bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively
            if(ethics != ethic_catch(self.getEthical(event)) && repChange >=0):
                repChange = -POINTTWO*repBalance / ONE
            if(repBalance + repChange <= 0):
                repChange = -1*repBalance
            if(self.getForkBondPaid(event) < self.getBondAmount(event)*2 && repChange < 0):
                # done instead of sending to redistrib. pool
                self.addRep(branch, self.repIDToIndex(branch, msg.sender), repChange)
                # sends that rep to the bonded challenger
                self.addRep(branch, self.repIDToIndex(branch, self.getForkBondPoster(event)), -repChange)
                self.adjForkBondPaid(event, -1*repChange)
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    # once penalized for all events actually get rid of net rep lost
    if(numReportedOn==self.getPenalizedNum(branch, lastPeriod, msg.sender)):
        if(newAfterRep <= 0):
            newAfterRep = 0
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        if(oldRep==0):
            self.setAfterRep(branch, lastPeriod, repBalance, msg.sender)
            self.setBeforeRep(branch, lastPeriod, repBalance, msg.sender)
            newAfterRep = repBalance
            oldRep = repBalance
        self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
        self.increaseDenominator(branch, lastPeriod, newAfterRep)
        totalRepDifference = newAfterRep - oldRep
        if(repBalance + totalRepDifference <= 0):
            totalRepDifference = -1*repBalance
        if(totalRepDifference<0):
            # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
            self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
            # sends that rep to the branch
            self.addRep(branch, self.repIDToIndex(branch, branch), -totalRepDifference)
    return(1)

# Calculates the proportion of correct reports for a binary forked event
def proportionCorrectForkEvent(event):
    refund()
    p = 0
    outcome = catch(self.getForkOutcome(event))
    if(outcome!=0):
        # binary
        if(self.getNumOutcomes(event)==2 and self.getMaxValue(event)==TWO and self.getMinValue(event)==ONE):
            # subtract 1 to get it from 0 to 1
            avgOutcome = self.getForkOutcome(event) - ONE
            # say we have outcome of 0, avg is .4, what is p?
            # p is .6 or 60%
            if(outcome == ONE):
                p = ONE - avgOutcome
            # say we have outcome of 1, avg is .8, what is p (proportion correct)?
            # p is .8 or 80%
            if(outcome == 2 * ONE):
                p = avgOutcome
            if(outcome == 3 * ONEHALF):
                return(0)
        return(p)
    else:
        return(0)

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)
        
macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)
        
macro categorical($event):
    (self.getNumOutcomes($event)>2)
    
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro abs($a):
    if($a<0):
        $a = -$a
    $a
    
# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
inset('refund.se')

macro POINTZEROONE: 184467440737095520

macro MINBOND: 200*2**64

# Allows a user to post a bond to enter round two of consensus
# Appeal_Bond = Market_Value * (0.01 + Market_Fee / 2) + Average_Adjudication_Cost
    # Average_Adjudication_Cost = Total fees paid to reporters for all markets in this reporting round / number of markets in this reporting round.
        # needs an abs min of ~200 rep.
# Reporting period is 2 months minus 48 hours.  This 48 hours allows for the appeals to take place before the next reporting round begins.
# Returns 1 upon success
# Errors:
    #  0: invalid votePeriod/branch
    # -1: Pushed forward event, bonding not allowed during this
    # -2: branch is in the middle of a fork
    # -3: not enough rep to cover bond
def roundTwoPostBond(branch, event, eventIndex, votePeriod):
    refund()
    if(self.getVotePeriod(branch)!=votePeriod):
        return(0)
    # if pushed forward don't allow until no longer pushed fwd
    if(self.getOriginalExpiration(event)!=self.getExpiration(event)):
        return(-1)
    market = self.getMarket(event, 0)
    forkPeriod = self.getForkPeriod(branch)
    if(forkPeriod == votePeriod or (forkPeriod+1) == votePeriod):
        return(-2)
    # todo find actual cost
    if(msg.value < 500000*tx.gasprice):
        return(0)
    # pays money to cover resolution cost
    send(BACKSTOPS, msg.value)
    self.setRoundTwoRefund(event, msg.value)
    avgAdjCost = self.getInitialBalance(branch, votePeriod)/self.getNumberEvents(branch, votePeriod)
    bond = avgAdjCost + self.getSharesValue(market)*(POINTZEROONE + self.getTradingFee(market)/2) / ONE
    bond = min(bond, MINBOND)
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    # if so, we're in the final 48 hours and event is in this branch + votePeriod
    if(!resolving && block.timestamp/self.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/self.getPeriodLength(branch)) && eventID!=0 && event==eventID && self.getRoundTwo(event)==0 && self.getForked(event)==0):
        # send the bond to the branch
        if(self.sendReputation(branch, event, bond)==0):
            return(-3)
        period = self.getVotePeriod(branch)
        # remove from events in # to report on calc for last period
        self.removeEvent(branch, period)
        # makes event required reporting in round 2 (the next period) as well
        self.setEventRequired(branch, period+1, event)
        # push event into next period
        self.addEvent(branch, period+1, event)
        # set event expiration date to be after the current reporting period ends
        self.setExpiration(event, block.timestamp)
        # set round two to true so can't be done again
        self.setRoundTwo(event, 1)
        self.setOriginalVotePeriod(event, votePeriod)
        if(scalar(event) or categorical(event)):
            self.setOriginalOutcome(event, self.getUncaughtOutcome(event))
        else:
            self.setOriginalOutcome(event, catch(self.getUncaughtOutcome(event)))
        self.setOriginalEthicality(event, ethic_catch(self.getEthical(event)))
        self.addRoundTwo(branch, period)
        self.setBondPoster(event, msg.sender)
        self.setUncaughtOutcome(event, 0)
        self.setmode(event, 0)
        self.setEthics(event, 0)
        return(1)

# Resolves a round 2 event scenario
# Errors:
    # 0: returned if not reported on again yet
def roundTwoResolve(branch, event, eventIndex, sender):
    refund()
    votePeriod = self.getVotePeriod(branch)
    market = self.getMarket(event, 0)
    avgAdjCost = self.getInitialBalance(branch, votePeriod-1)/self.getNumberEvents(branch, votePeriod-1)
    bond = avgAdjCost + self.getSharesValue(market)*(POINTZEROONE + self.getTradingFee(market)/2) / ONE
    bond = min(bond, MINBOND)
    votedOnAgain = 0
    eventID = self.getEvent(branch, votePeriod, eventIndex)
    overruled = 1
    # checks if the event's outcome was overruled or the same as the original reporting cycle
    if(scalar(event) or categorical(event)):
        if(self.getOriginalOutcome(event) == self.getUncaughtOutcome(event) && self.getOriginalEthicality(event)==ethic_catch(self.getEthical(event))):
            overruled = 0
    elif(self.getOriginalOutcome(event) == catch(self.getUncaughtOutcome(event)) && self.getOriginalEthicality(event)==ethic_catch(self.getEthical(event))):
        overruled = 0
    if(votePeriod > (self.getExpiration(event) / self.getPeriodLength(branch))):
        votedOnAgain = 1
    forkPeriod = self.getForkPeriod(branch)
    # if forking and this isn't the fork event
    if(forkPeriod==votePeriod or votePeriod==(forkPeriod+1) && (self.getEventForkedOver(branch)!=event && self.getBondReturned(event)==0 && self.getRoundTwo(event))):
        # return the bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), bond)
        self.setBondReturned(event)
        self.setRoundTwo(event, 0)
        self.doRoundTwoRefund(sender, event)
        return(1)
    # overruled and bond poster was right
    elif(overruled && votedOnAgain && self.getRoundTwo(event) && votePeriod!=self.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked && !self.getBondReturned(event)):
        # return the bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), bond)
        # and set final outcome / event bond, etc
        self.resolve(branch, event)
        # reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, then beyond that the people who originally reported whatever the actual truth was would get the rest. then regular rep redistribution for the round 2 reporting
        self.setFinal(event)
        self.setBondReturned(event)
        self.doRoundTwoRefund(sender, event)
        return(2*bond)
    # same as original consensus and bond poster was wrong [or malicious]
    elif(votedOnAgain && self.getRoundTwo(event) && votePeriod!=self.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked && !self.getBondReturned(event)):
        # lose bond
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, branch), bond)
        # and set final outcome / event bond, etc
        self.resolve(branch, event)
        # rep redistribution from original period/orig. outcome stands, rep redistribution from round 2 happens as usual as well
        self.setFinal(event)
        self.setBondReturned(event)
        self.doRoundTwoRefund(sender, event)
        return(1)
    # not voted on again yet
    else:
        return(0)
        
### Helper functions

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)
        
macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==2**6Z)
        
macro categorical($event):
    (self.getNumOutcomes($event)>2)
    
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
        
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

# Actually sets the outcome for a round 2 event
# Errors:
    # 0: event isn't binary, categorical, or scalar [hell has frozen over or quantum events have been invented]
def resolve(branch, event):
    refund()
    bond = self.getBond(event)
    # set ethicality to the binned version of the ethics
    ethical = ethic_catch(self.getEthical(event))
    self.setEthics(event, ethical)
    # binary
    if(binary(event)):
        # set outcome to the binned version of the outcome
        fxpOutcome = catch(self.getUncaughtOutcome(event))
        self.setOutcome(event, fxpOutcome)
        if(fxpOutcome==3*ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as 1.5 outcome w/ binary
            fxpOutcome = 3*ONEHALF
            self.setOutcome(event, fxpOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # scalar
    elif(scalar(event) or categorical(event)):
        mode = self.getUncaughtOutcome(event)
        # sets mode which is used to penalize/reward reporters
        self.setmode(event, mode)
        scaled_max = self.getMaxValue(event)
        scaled_min = self.getMinValue(event)
        if(categorical(event)):
            scaled_min = ONE
            scaled_max = ONE*self.getNumOutcomes(event)
        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
        # sets outcome which is used in calculating payouts 
        self.setOutcome(event, fxpOutcome)
        ethicOutcome = 2**63 * (scaled_max - scaled_min)/ONE + scaled_min
        if(mode==ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as .5 outcome w/ scalar
            # mode is used to compare for reporting acc. so still the same as reported outcome, but resolving the market as .5
            self.setOutcome(event, ethicOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # (should never be reached)
    else:
        return(0)
inset('refund.se')

event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)

macro POINTZEROONE: 184467440737095520
macro POINTEIGHT: 14757395258967642112
macro POINTTWO: 3689348814741910528

# Penalizes a reporter for reporting wrongly on an event
    # examples from the start of a new branch:
        # ex:
            #period 0 voteperiod -1 - last period penalized should be -1 or starting vote period
            #add some events to period 0
            #increment
            #period 1 voteperiod 0 - shouldn't be penalizing anything yet b/c still reporting on period 0
            #increment
            #period 2 voteperiod 1 - penalize on events in voteperiod 0
        # ex 2:
            #currently in period 100, voteperiod 99 - last period penalized up to should be 99 or starting vote period
            #add some events to period 100
            #increment to period 101
            #period 101, voteperiod 100 - shouldn't be penalizing anything yet
            #increment
            #period 102, voteperiod 101 - penalize on events in voteperiod 100
#1. Record rep at start of report period [before rep in make reports]
#2. Penalize for each event
#3. Each reporter needs to do this for all events they reported on, if not get docked
#4. For first half of the new period, people can do penalization for the last period, for the second half users have to claim rep then trading fees
#5. If a reporter doesn't do it for all events, they autolose 10% rep each period one doesn't do it (b/c they're trying to cheat)
# Errors:
    #  0: event is a fork event
    # -1: need to penalize in round 2 penalize function
    # -2: already past first half of new period and needed to penalize before then
    # -4: in fork period only thing that rep redistribution is done on is the round 2 event in the original branch via round 2 penalize
    # -5: already done for all events in this period
    # -6: forked events should be penalized using the fork penalization function
    # -7: no outcome
# force event to be resolved first if it can be
def penalizeWrong(branch, event):
    refund()
    repBalance = self.getRepBalance(branch, msg.sender)
    lastPeriod = self.getVotePeriod(branch)-1
    forkPeriod = self.getForkPeriod(branch)
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    newRep = 0
    rejected = self.getRejected(event)
    newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)
    roundTwo = self.getRoundTwo(event)
    uncaught = self.getUncaughtOutcome(event)
    if(repBalance < ONE):
        return(0)
    if(self.getPenalizedUpTo(branch, msg.sender)==lastPeriod):
        return(-5)
    if(forkPeriod == lastPeriod):
        return(-4)
    elif(self.getForked(event)):
        return(-6)
    # if no events in a period
    elif(self.getNumberEvents(branch, lastPeriod)<=0):
        self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
        self.increaseDenominator(branch, lastPeriod, repBalance)
        return(1)
    # if no outcome / event not resolved yet, resolve it [as long as it wasn't an event that was pushed fwd and got rejected and thus hasn't actually resolved yet]
    elif(!uncaught && !(rejected && self.getRejectedPeriod(event)==lastPeriod)):
        if(self.closeMarket(branch, self.getMarket(event, 0), msg.sender)!=1):
            return(-7)

    outcome = catch(uncaught)
    if(scalar(event) or categorical(event)):
        outcome = uncaught
    p = self.proportionCorrect(event)
    if(roundTwo && outcome!=0):
        return(-1)
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    numReportedOn = self.getNumReportsActual(branch, lastPeriod, msg.sender)
    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period
    # commented for testing
    #elif(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
    #    return(-2)
    # lastperiod is where people who originally voted on a round 2 event voted the first time - want num events penalized to go up but not to actually be penalized for it yet
        # shouldn't be penalized until the next period resolution is over [since it's a round 2 event]
    if(roundTwo && !self.getPenalized(branch, lastPeriod, msg.sender, event) && reportValue):
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
        # if a person reported on a round 2 event, they cannot convert their rep to dormant or send rep until they've finished the resolution process for that round 2 event todo
            # unless this just happened to them last period and they reported correctly then
    # if this event was a pushed forward event that got rejected, don't penalize on it, only penalize on the final reporting, i.e. if appealed don't allow rep redistribution until after the appeal process is over in the first period
    elif(!self.getPenalized(branch, lastPeriod, msg.sender, event) && reportValue && rejected && self.getRejectedPeriod(event)==lastPeriod):
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    # penalization on a regular event if not already penalized, it has outcome, and user reported on it
    elif(!self.getPenalized(branch, lastPeriod, msg.sender, event) && reportValue && outcome!=0):
        # wrong
        if(reportValue > outcome+POINTZEROONE or reportValue < outcome-POINTZEROONE):
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                diff = reportValue - outcome
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*p - ONE)/ONE
        # right
        else:
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                diff = reportValue - outcome
                # perhaps for right we should do diff todo so adds to more than 1 --- can actually do proportion correct for this i think now
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
        # (1-k) * old rep + k * new rep where k = 0.2 / (number of events you reported on last period) for penalization and pen. rate for forking and backstop 1
        # use .02 as a max penalty per event
        if(numReportedOn<10):
            repChange = oldRep * (ONE - POINTTWO/10)/ONE + newRep*(POINTTWO/10)/ONE - oldRep
        else:
            repChange = oldRep * (ONE - POINTTWO/numReportedOn)/ONE + newRep*(POINTTWO/numReportedOn)/ONE - oldRep
        newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender) + repChange
        log(type=penalize, msg.sender, outcome, oldRep, repChange, newAfterRep, p, reportValue)
        self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    # once penalized for all events actually get rid of net rep lost and send it to the branch for redistribution
    if(numReportedOn==self.getPenalizedNum(branch, lastPeriod, msg.sender)):
        if(newAfterRep <= 0):
            newAfterRep = 0
            self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        if(oldRep==0):
            self.setAfterRep(branch, lastPeriod, repBalance, msg.sender)
            self.setBeforeRep(branch, lastPeriod, repBalance, msg.sender)
            newAfterRep = repBalance
            oldRep = repBalance
        self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
        self.increaseDenominator(branch, lastPeriod, newAfterRep)
        totalRepDifference = newAfterRep - oldRep
        if(repBalance + totalRepDifference <= 0):
            totalRepDifference = -1*repBalance
        if(totalRepDifference<0):
            # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
            self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
            # sends that rep to the branch
            self.addRep(branch, self.repIDToIndex(branch, branch), -totalRepDifference)
    return(1)

# Increments the period after reporting
# ui has to call this to stay cheap / not check it elsewhere
def incrementPeriodAfterReporting(branch):
    refund()
    # do this after reporting is finished
    if(periodOver(branch)):
        period = block.timestamp / self.getPeriodLength($branch) - 1
        lastPeriod = period - 1
        percentAppealed = (self.getNumRoundTwo(branch, period)*ONE/self.getNumberEvents(branch, period) + self.getNumRoundTwo(branch, lastPeriod)*ONE/self.getNumberEvents(branch, lastPeriod)) / 2
        self.incrementPeriod(branch)
        # mult. by 2 b/c reporters only have to report on half the things they're selected to report on
        base_reporter_quantity = 2*(3*ONE + ((333*ONE * Percent_Appealed/ONE)**3 / 2**128))/ONE
        self.setBaseReportersLastPeriod(branch, self.getBaseReporters(branch))
        self.setBaseReporters(branch, base_reporter_quantity)
        return(1)
    else:
        return(0)

### Helper functions:
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

macro periodOver($branch):
    # what the current vote period should be
    currentVotePeriod = block.timestamp / self.getPeriodLength($branch) - 1
    # if actual vote period is less than what the current one should be, return 1, it can be incremented
    if(self.getVotePeriod($branch) < currentVotePeriod):
        1
    else:
        0
        
# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro categorical($event):
    (self.getNumOutcomes($event)>2)

macro abs($a):
    if($a<0):
        $a = -$a
    $a

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE
inset('refund.se')

# Anti cheat/collusion mechanism: provide ballot and random salt to steal rep from a colluder
# Returns:
    # 0: not a valid claim
    # 1: on success
    # -1: invalid vote period
    # -2: past reveal date
    # -3: reporter being slashed doesn't exist
def slashRep(branch, salt, report, reporter, eventID):
    refund()
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        return(-2)
    votePeriod = self.getVotePeriod(branch)
    # if actually past vote period dont allow it
    votePeriodShouldBe = block.timestamp / periodLength - 1
    if(votePeriodShouldBe!=votePeriod):
        return(-1)
    realHash = self.getReportHash(branch, votePeriod, reporter, eventID)
    hashInfo = array(4)
    hashInfo[0] = reporter
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha3(hashInfo, chars=32*len(hashInfo))
    # make sure that the colluding reporter's commit is the same as the info provided in the params
    if(reportHash!=realHash):
        return(0)
    else:
        if(!self.getSlashed(branch, votePeriod, reporter)):
            self.setSlashed(branch, votePeriod, reporter)
            reporterIndex = self.repIDToIndex(branch, reporter)
            trutherIndex = self.repIDToIndex(branch, msg.sender)
            # if the truther's rep. account doesn't exist, make one
            if(self.getReporterID(branch, trutherIndex)!=msg.sender):
                trutherIndex = self.getNumberReporters(branch)
                self.addReporter(branch, msg.sender)
            if(self.getReporterID(branch, reporterIndex)!=reporter):
                return(-3)
            reporterBalance = self.getRepBalance(branch, reporter)
            # removes rep from colluder
            self.subtractRep(branch, reporterIndex, reporterBalance)
            # gives truther half 
            self.addRep(branch, trutherIndex, (reporterBalance*ONEHALF / ONE))
            # other half sent to branch
            self.addRep(branch, self.repIDToIndex(branch, branch), reporterBalance*ONEHALF/ONE)
        else:
            return(0)
    return(1)
inset('refund.se')

macro POINTZEROONE: 184467440737095520

# UI has to handle function calls for these

#Notes:
    #Anyone can pay some amount significantly greater than the bond amount to force a branching event, splitting rep into two classes.  
    #In one class the reported outcome for whatever event was the cause of dispute is said to be right, and rep is redistributed accordingly.  
    #In the other class/branch, the event is readjudicated and remove the outcome on the pre fork branch and rep is redistributed as normal, except people who said the original outcome in the original fork lose rep.  
    # Note: Whichever outcome was truly the correct one would determine which branch had rep that actually held value.  This would be akin to a Bitcoin hard fork scenario.  The winning fork, of course, would be the one with the most voluminous markets, which would be determined by the fork that represented reality, which would have a higher market cap.  Markets go to the most popular fork by default after 2 months.

# Period where we forked, at the end of it
    # don't penalize for this period / anything that happened here should be considered to not have happened - done
    # let period be incremented as normal - done
    # no rep redistribution on this period besides for event forked over on original. parent but don't actually resolve the event until later per below - done
    # fork users get a free pass for not reporting on this period - done
# Period after fork where we need to do nothing while waiting for fork to resolve
    # free pass for not reporting during this period in og branch - done, UI needs to call penalizeWrong with a 0 as event param or todo do this contract side after doing penalize wrong
    # no reporting or rep redistribution in this period except for on fork branch we re-report on the forked market and that's it, so no free pass on fork for that one event - done
# Period after fork is resolved
    # markets can't be moved until now - done
    # all markets have early exp disabled until this point - done
    # each event which should've resolved in the past 2 periods and this one is pushed up into this period and voted on in period after this - done
        # stays in parent if it wins, otherwise goes to new fork - done
    # each event resolving further in the future is pushed into the respective period on whichever fork wins - done
# todo if already moved once don't allow again after another fork
def move_event(event):
    forkPeriod = self.getForkPeriod(self.getEventBranch(event))
    branch = self.getEventBranch(event)
    eventForkedOver = self.getEventForkedOver(branch)
    expPeriod = self.getExpiration(event)/self.getPeriodLength(branch)
    eventIndex = self.getEventIndex(expPeriod, event)
    currentPeriod = block.timestamp / self.getPeriodLength(branch)
    if(forkPeriod && currentPeriod == (forkPeriod+2) && !self.getOutcome(event) && !self.getMoved(event)):
        winner = self.getResolved(branch, forkPeriod)
        if(winner==0):
            winner = self.resolve_fork(branch)
        self.setMoved(event)
        if(event == eventForkedOver):
            return(1)
        elif(winner == self.getEventBranch(event)):
            # set outcomes to 0
            self.setOutcome(event, 0)
            self.setmode(event, 0)
            self.setEthics(event, 0)
            self.setUncaughtOutcome(event, 0)
            # return bond if it's a round 2 event and make it not one anymore
            self.roundTwoResolve(branch, event, eventIndex)
            
            # leave event here
            # if should've resolved in past periods
            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1)):
                # push it into next [this] period
                self.addEvent(branch, currentPeriod, eventID)
                self.setExpiration(event, block.timestamp)
            # otherwise it's set to expire in the period it would've expired in as normal, no changes needed
        else:
            self.setBranch(event, winner)
            # set outcomes to 0
            self.setOutcome(event, 0)
            self.setmode(event, 0)
            self.setEthics(event, 0)
            self.setUncaughtOutcome(event, 0)
            # return bond if it's a round 2 event and make it not one anymore
            self.roundTwoResolve(branch, event, eventIndex)

            # move event to fork
            # and place it into the next reporting period w/ outcomes to 0
            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1)):
                # push it into next [this] period
                self.addEvent(branch, currentPeriod, eventID)
                self.setExpiration(event, block.timestamp)
            else:
                # push into period it wouldve expired in
                self.addEvent(branch, expPeriod, eventID)
                # expiration time doesnt need to change
    else:
        return(0)

# parent branch is branch here
# todo fork use address picked in market creation to resolve it and have a default fork resolve option
def resolve_fork(branch):
    # do whitelist
    forkPeriod = self.getForkPeriod(self.getEventBranch(event))
    currentPeriod = block.timestamp / self.getPeriodLength(branch)
    origCap = self.exchangeRate(branch)
    fork = self.getFork(branch)
    forkCap = self.exchangeRate(fork)
    if(origcap >= forkCap):
        winner = branch
        self.setResolved(branch, forkPeriod, winner)
        return(winner)
    else:
        winner = fork
        self.setResolved(branch, forkPeriod, winner)
        return(winner)

# Resolve fork method that gets exchange rate
def exchangeRate(branch):
    # get rep exchange rate from etherex for (branch)
    #return(exchangeRate)
    # for testing we'll just rng the exchange rate :)
    return(sha3(branch))

# In the last 48 hours during period where a round 2 was pushed back to, can be made to fork instead of just round 2, so round 2 bond poster gets bond back
# bond is 1% of rep
def fork(event, branch, forkedOverEthicality):
    forkPeriod = self.getForkPeriod(branch)
    currentPeriod = block.timestamp / self.getPeriodLength(branch)
    # no fork for 1 period after a fork
    if(forkPeriod == currentPeriod or currentPeriod == (forkPeriod+1) or currentPeriod == (forkPeriod+2)):
        return(-3)
    if(!self.getRoundTwo(event) || self.getFinal(event) || self.getForked(event)):
        return(-1)
    if(self.getBranch(event)!=branch):
        return(0)
    # todo find actual gas cost for resolution here and charge that
    if(msg.value < 200000*tx.gasprice):
        return(0)
    send(CONSENSUS, msg.value)
    self.setRefund(event, msg.value)
    # if pushed forward event don't allow
    if(self.getOriginalExpiration(event)!=self.getExpiration(event)):
        return(-4)
    # if in last 48 hr of period
    if(block.timestamp/self.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/self.getPeriodLength(branch)) && self.getUncaughtOutcome(event)!=0 && !self.getForked(event)):
        bond = POINTZEROONE*self.getTotalRep(branch)/ONE
        self.setBondAmount(event, bond)
        # lose fork bond in branch 1
        # results same as roundtwobond, let it resolve as that on original network
        if(self.sendReputation(branch, event, bond)==0):
            return(-2)
        # on branch 2 fork bond isn't lost
        # on fork bond isn't lost, gets paid up to 2x from "liars"
        # make the fork
        newBranch = self.createSubbranch(text("fork"), self.getPeriodLength(branch), branch, self.getMinTradingFee(branch), 0)
        self.setFork(newBranch)
        period = self.getVotePeriod(newBranch)
        self.setEventRequired(newBranch, period+1, event)
        self.addEvent(newBranch, period+1, event)
        self.setExpiration(event, block.timestamp)
        self.setOriginalBranch(event, branch)
        self.setForkBondPoster(event, msg.sender)
        self.setForked(event)
        self.setFinal(event)
        self.setForkPeriod(branch)
        self.setForkPeriod(newBranch)
        self.setEventForkedOver(newBranch, event)
        self.setEventForkedOver(branch, event)
        if(forkedOverEthicality):
            self.setForkedOverEthicality(event)
        # return round 2 bond on orig. branch
        market = self.getMarket(event, 0)
        avgAdjCost = self.getInitialBalance(branch, period-1)/self.getNumberEvents(branch, period-1)
        bond = avgAdjCost + self.getSharesValue(market)*(184467440737095520 + self.getTradingFee(market)/2) / 2**64
        bond = min(bond, 200*ONE)
        self.subtractRep(branch, self.repIDToIndex(branch, event), bond)
        self.addRep(branch, self.repIDToIndex(branch, self.getBondPoster(event)), bond)
        self.setBondReturned(event)
    else:
        return(0)


# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
# branch is orig. branch
def resolveForkedEvent(branch, event):
    refund()
    bond = 100*ONE
    votedOnAgain = 0
    # checks for orig. branch
    if(self.getBranch(event)!=branch or self.getEventForkedOver(branch)!=event):
        return(0)
    if(self.getVotePeriod(branch) > (self.getExpiration(event) / self.getPeriodLength(branch))):
        votedOnAgain = 1
    if(!self.getForked(event)):
        return(-1)
    if(self.resolveForkEvent(branch, event)):
        self.setForkDone(event)
        self.doRefund(msg.sender, event)
        return(1)
    # fork not done yet
    else:
        return(0)

# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
def resolveForkEvent(branch, event):
    refund()
    # whitelist
    bond = self.getBond(event)
    winner = self.getResolved(branch, self.getForkPeriod(branch))
    if(!winner):
        return(-5)
    # binary
    if(binary(event)):
        fxpOutcome = 0
        ethical = 0
        # original parent won
        if(winner==branch):
            fxpOutcome = catch(self.getUncaughtOutcome(event))
            ethical = ethic_catch(self.getEthical(event))
        # fork won
        else:
            fxpOutcome = catch(self.getForkOutcome(event))
            ethical = ethic_catch(self.getForkEthicality(event))
        self.setOutcome(event, fxpOutcome)
        self.setEthics(event, ethical)
        if(fxpOutcome==3*ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as .5 outcome
            fxpOutcome = 3*ONEHALF
            self.setOutcome(event, fxpOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # scalar
    elif(scalar(event) or categorical(event)):
        mode = 0
        ethical = 0
        # original parent won
        if(winner==branch):
            mode = self.getUncaughtOutcome(event)
            ethical = ethic_catch(self.getEthical(event))
        # fork won
        else:
            mode = self.getForkOutcome(event)
            ethical = ethic_catch(self.getForkEthicality(event))
        self.setmode(event, mode)
        self.setEthics(event, ethical)
        scaled_max = self.getMaxValue(event)
        scaled_min = self.getMinValue(event)
        if(categorical(event)):
            scaled_min = ONE
            scaled_max = ONE*self.getNumOutcomes(event)
        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
        ethicOutcome = 2**63 * (scaled_max - scaled_min)/ONE + scaled_min
        self.setOutcome(event, fxpOutcome)
        if(mode==ONEHALF || !ethical):
            # give event bond money to reporters
            self.subtractCash(event, bond)
            self.addCash(branch, bond)
            # not ethical is same as .5 outcome
            self.setOutcome(event, ethicOutcome)
        else:
            # return bond
            self.subtractCash(event, bond)
            self.addCash(self.getCreator(event), bond)
        return(1)
    # (should never be reached)
    else:
        return(0)

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)
        
macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)
        
macro categorical($event):
    (self.getNumOutcomes($event)>2)
    
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro abs($a):
    if($a<0):
        $a = -$a
    $a
    
# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD
inset('refund.se')


# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 8
# Boolean success/failure
macro SUCCESS: 1
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_SAME_BLOCK_PROHIBITED: 22

# calculates trading fee percentage
# 4*fee*price*(1-price/range)/range keeps fees lower at the edges
macro fee_percent($market_fee, $price, $cumScale):
    4 * $market_fee * $price * (ONE-$price*2**64/$cumScale) / ($cumScale*ONE)

# removes a trade from the book
macro remove_trade($trade_id, $market):
    self.remove_trade($trade_id)
    self.remove_trade_from_market($market, $trade_id)

#
# Trade [allows a user to pick up/fill orders off the book]
#
# Errors:
    # -1: oracle only branch
    # -2: bad trade hash
    # -3: trader doesn't exist / own shares in this market
    # -4: must buy at least .00000001 in value
    # 10: insufficient balance
    # 22: trade in same block prohibited
# max value is max money to spend to buy [including fees] filling ask orders
# max amount is max shares to sell filling bid orders
# 500k gas cost
# picks orders off the book
def trade(max_value, max_amount, trade_ids:arr):
    refund()
    if(self.getOracleOnly(branch)):
        return([-1]: arr)
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeInfo[2] = max_value
    tradeHash = sha3(tradeInfo, items=3)
    if(self.checkHash(tradeHash, msg.sender)==-1):
        return([-2]: arr)
    max_value = max_value
    max_amount = max_amount
    # Try to fulfill each trade passed
    t = 0
    while t < len(trade_ids):
        trade_id = trade_ids[t]
        # Get trade
        trade = array(TRADE_FIELDS)
        trade = self.get_trade(trade_id, outitems=TRADE_FIELDS)
        if !trade:
            return([0]: arr)
        # Get market
        type = trade[1]
        market = trade[2]
        creator = self.getCreator(market)
        amount = trade[3]
        price = trade[4]
        owner = trade[5]
        outcome = trade[7]
        if(owner == msg.sender or owner == tx.origin):
            return([0]: arr)
        # Make sure the trade has been mined, obvious HFT prevention
        if block.number <= trade[6]:
            return([TRADE_SAME_BLOCK_PROHIBITED]: arr)
        branch = self.getBranchID(market)
        trading_fee = self.getTradingFee(market)
        cumScale = self.getCumScale(market)
        fee = fee_percent(trading_fee, price, cumScale)

        # Fill buy order
        if type == BID:
            # Get available balance of shares
            participantNumber = self.getParticipantNumber(market, msg.sender)
            balance = self.getParticipantSharesPurchased(market, participantNumber, outcome)
            if(balance > 0 and max_amount > 0):
                if(self.getParticipantID(market, participantNumber) != msg.sender):
                    return([-3]: arr)
                makerFeeRate = self.getMakerFees(market)
                sender = self.getParticipantNumber(market, msg.sender)
                ownerNum = self.getParticipantNumber(market, owner)
                # Determine fill amount
                fill = min(amount, min(balance, max_amount))
                # Calculate value
                value = (fill * price)/ONE
                # must trade at least 0.00000001 in value
                if(value < 184467440738):
                    return([-4]: arr)
                # Update trade amount or remove
                if fill < amount:
                    self.fill_trade(trade_id, fill)
                else:
                    remove_trade(trade_id, market)
                # Update balances
                self.modifyParticipantShares(market, sender, outcome, -fill, 0)
                self.modifyParticipantShares(market, ownerNum, outcome, fill, 0)
                # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
                fee = value * fee / ONE
                branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE
                creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE
                takerFeesTotal = branchFees + creatorFees
                self.addCash(msg.sender, value-takerFeesTotal)
                # 75% to branch + .5% more to branch per maker fee 1% decrease 
                self.addCash(branch, branchFees)
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                self.addCash(creator, creatorFees)
                self.subtractCash(market, value)

                # other party [maker] pay their part of the fee here too
                fee = fee * makerFeeRate / ONE
                self.subtractCash(market, fee)
                self.addCash(creator, fee/2)
                self.addCash(branch, fee/2)
                
                # needed to keep track of how many fees a market has raised
                # only count branch fees here
                self.addFees(market, fee/2+branchFees)
                # Update max_amount
                max_amount -= fill
                # Log transaction
                log(type=log_fill_tx, market, msg.sender, owner, ASK, price, fill, trade_id, outcome)
            else:
                return([INSUFFICIENT_BALANCE]: arr)
        elif type == ASK:
            balance = self.balance(msg.sender)
            makerFeeRate = self.getMakerFees(market)
            feeRate = 3*2**64/2**65 - makerFeeRate
            maxAmountGivenBalance = balance*2**64/(feeRate+2**64)
            max_value = min(maxAmountGivenBalance, max_value)
            if max_value > 0:
                # Calculate value of trade
                trade_value = amount * price / ONE
                # Determine fill value
                value = min(max_value, trade_value)
                if(value < 184467440738):
                    return([-4]: arr)
                fee = value * fee / ONE
                branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE
                creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE
                takerFeesTotal = branchFees + creatorFees
                if(balance < (value + takerFeesTotal)):
                    return([INSUFFICIENT_BALANCE]: arr)
                fill = 0
                # Calculate fill amount, update trade amount or remove filled trade
                if value < trade_value:
                    fill = value*ONE / price
                    self.fill_trade(trade_id, fill)
                else:
                    fill = amount
                    remove_trade(trade_id, market)
                participantNumber = self.getParticipantNumber(market, msg.sender)
                # if participant doesn't exist in market, add them
                if(msg.sender != self.getParticipantID(market, participantNumber)):
                    participantNumber = self.addParticipant(market, msg.sender)
                
                # Update balances [user asking has already gotten rid of shares in escrow, just need to add them to the buyer]
                self.modifyParticipantShares(market, participantNumber, outcome, fill, 0)
                # Transfer cash from user to person who has ask order and pay fee to branch and market creator
                # 75% to branch + .5% more to branch per maker fee 1% decrease 
                self.addCash(branch, branchFees)
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                self.addCash(creator, creatorFees)
                cost = value + takerFeesTotal
                self.addCash(owner, value)
                self.subtractCash(msg.sender, cost)

                # other party [maker] pay their part of the fee here too
                fee = fee * makerFeeRate / ONE
                self.subtractCash(market, fee)
                self.addCash(creator, fee/2)
                self.addCash(branch, fee/2)
                
                # only count branch fees here
                self.addFees(market, fee/2+branchFees)
                # Update max_value
                max_value -= value
                # Log transaction
                log(type=log_fill_tx, market, msg.sender, owner, BID, price, fill, trade_id, outcome)
            else:
                return([INSUFFICIENT_BALANCE]: arr)

        # Log price, fill amount, type and timestamp
        self.setPrice(market, outcome, price)
        log(type=log_price, market, type, price, fill, block.timestamp, outcome, msg.sender)
        # Next trade
        t += 1
    return([SUCCESS, max_value, max_amount]: arr)
macro refund():
    if self.test_callstack() != 1: return(-1)
    if(msg.value > 0):
        send(msg.sender, msg.value)

#def test_callstack(): return(1)

macro WEITOETH: 10^18

macro THREEFOURTHS: 13835058055282163712

macro ONEFOURTH: 2**62

macro ONEHALF: 2**63

macro TWO: 2**65

macro TWENTYFOURHR: 86400
inset('refund.se')

# Payout a trader in a market with one winning outcome [so not scalar]
def oneOutcome(market, winningOutcome, sender, categoricalPointFive, numOutcomes):
    participantNumber = self.getParticipantNumber(market, sender)
    cumScale = self.getCumScale(market)
    # if it's an indeterminate categorical market resolve with all outcomes having an equal value
    if(categoricalPointFive):
        i = 0
        while(i < numOutcomes):
            sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, i+1)
            self.modifyParticipantShares(market, participantNumber, i+1, -sharesOwned)
            self.subtractCash(market, sharesOwned*self.getCumScale(market)/(numOutcomes*ONE))
            self.addCash(participant, sharesOwned*self.getCumScale(market)/(numOutcomes*ONE))
            i+=1
    else:
        # distribute profit to the people who won money by holding winning shares
        sharesOwned = self.getParticipantSharesPurchased(market, participantNumber, winningOutcome)
        participant = self.getParticipantID(market, participantNumber)
        self.modifyParticipantShares(market, participantNumber, winningOutcome, -sharesOwned)
        self.subtractCash(market, sharesOwned*cumScale/ONE)
        self.addCash(participant, sharesOwned*cumScale/ONE)
    return(1)
inset('refund.se')

# Allows a user to collect both redistributed rep and trading fees earned at the end of a period
# Errors:
    # -1: rep redistribution/rewards/penalizations in consensus not done yet
    # -2: needs to be second half of reporting period to claim rep [1st half is when redistribution is done]
        # after this window, any unclaimed rep is pushed to the next period's redistrib. pool via the first make report submission
# 2 means no errors but didnt report
def collectFees(branch, sender):
    refund()
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual <= periodLength/2):
        return(-2)
    if(!self.getRRDone(branch, sender)):
        # need to call penalize for all events and penalize for too lazy to report or catchup if necessary
        return(-1)
    lastPeriod = self.getVotePeriod(branch) - 1
    newRep = self.getAfterRep(branch, lastPeriod, sender)
    # need 1 rep to claim fees
    if(!self.getFeesCollected(branch, sender, lastPeriod) && newRep>ONE):
        denominator = self.getDenominator(branch, lastPeriod)
        # sets the amount of rep available for redistribution in the next period
        if(!self.getFeeFirst(branch, lastPeriod)):
            self.setFeeFirst(branch, lastPeriod, 1)
            self.setPeriodBalance(branch, lastPeriod, self.getRepBalance(branch, branch))
        gainedRep = newRep * self.getPeriodBalance(branch, lastPeriod) / denominator
        #if(lostRep) newRep should be == self.getAfterRep(branch, period, sender) + gainedRep
        #if(gainedRep) newRep should be == self.getBeforeRep(branch, period, sender) + gainedRep
        # give a reporter their portion of redistributed rep
        self.addRep(branch, self.repIDToIndex(branch, sender), gainedRep)
        self.subtractRep(branch, self.repIDToIndex(branch, branch), gainedRep)
        cash = self.getInitialBalance(branch, lastPeriod) * newRep / denominator
        # give a reporter their portion of the trading fees
        self.addCash(sender, cash)
        self.subtractCash(branch, cash)
        self.setFeesCollected(branch, sender, lastPeriod)
        # return not reported enough bond if not enough penalized is 0 or self.getForkPeriod(branch)+1 == lastPeriod during collect fees
        if(self.getNotEnoughPenalized(branch, msg.sender, lastPeriod)==0 or self.getForkPeriod(branch)+1 == lastPeriod):
            self.doRefund(msg.sender, msg.sender)
        return(1)
    # shouldn't be reached / if so no effect
    elif(!self.getFeesCollected(branch, sender, lastPeriod)):
        self.setFeesCollected(branch, sender, lastPeriod)
        return(2)
inset('refund.se')

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](description[2048], descriptionLength, creator, creationFee)


def getDescription(ID):
	refund()
	length=self.Info[ID].descriptionLength
	return(load(self.Info[ID].description[0], chars=length): str)

def getDescriptionLength(ID):
	refund()
	return(self.Info[ID].descriptionLength)

def getCreator(ID):
	refund()
	return(self.Info[ID].creator)

def getCreationFee(ID):
	refund()
	return(self.Info[ID].creationFee)

# @return 1 if success, 0 if creator already exists
def setInfo(ID, description: str, creator, fee):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#	return(-1)
	# check that msg.sender is one of our function contracts
	if(self.Info[ID].creator == 0):
		save(self.Info[ID].description[0], description, chars=len(description))
		self.Info[ID].descriptionLength = len(description)
		self.Info[ID].creationFee = fee
		self.Info[ID].creator = creator
		return(1)
	else:
		return(0)
inset('refund.se')

# Storage of all data associated with reporters
    # Reporting index is the branchID
    # Reporters index is the rep. address
    # We 0 index reputation so can walk thru for consensus - todo / wrong don't need 0 indexing anymore
    # RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
    # total rep is all the rep in augur
    # active rep is the amount which is actually active
    # fork is the child branch of a parent which forked
    # dormant rep stores dormant rep values
data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep, dormantRep[](repValue, reporterID), activeRep, fork)

data whitelists[](addresses[], taken)


def checkWhitelist(address):
    refund()
    return(self.whitelists[msg.sender].addresses[address])

def getActiveRep(branch):
    return(self.Reporting[branch].activeRep)
    
def adjustActiveRep(branch, amount):
    self.Reporting[branch].activeRep += amount
    return(1)

def setFork(branch):
    self.Reporting[branch].fork = branch
    return(1)
    
def getFork(branch):
    return(self.Reporting[branch].fork)

def checkContractWhitelist(contract, address):
    refund()
    return(self.whitelists[contract].addresses[address])

def setWhitelist(contract, addresses:arr):
    refund()
    if self.whitelists[contract].taken:
        return(text("ERROR: you have to vote to change a whitelist"):str)
    else:
        self.whitelists[contract].taken = 1
        i = 0
        l = len(addresses)
        while i <l:
            address = addresses[i]
            self.whitelists[contract].addresses[addresses] = 1
            i += 1
        return(text("SUCCESS"):str)

# @return reputation value
def getRepByIndex(branch, repIndex):
    refund()
    return(self.Reporting[branch].reputation[repIndex].repValue)

# @return reputation value
def getRepBalance(branch, address):
    refund()
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].reputation[repIndex].repValue)

def getDormantRepByIndex(branch, repIndex):
    refund()
    return(self.Reporting[branch].dormantRep[repIndex].repValue)

# @return reputation value
# getDormantRepBalance
def balanceOf(branch, address):
    refund()
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].dormantRep[repIndex].repValue)
    
# return total supply of dormant rep
def totalSupply(branch):
    return((self.Reporting[branch].totalRep - self.Reporting[branch].activeRep))

def getReporterID(branch, index):
    refund()
    return(self.Reporting[branch].reputation[index].reporterID)

def getTotalRep(branch):
    refund()
    return(self.Reporting[branch].totalRep)

# will return 0s for array values after it's looped through all the ones you
# have an actual balance in
def getReputation(address):
    refund()
    branchListCount = self.getNumBranches()
    if(address):
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    else:
        address = msg.sender
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    return(branches: arr)

def getNumberReporters(branch):
    refund()
    return(self.Reporting[branch].numberReporters)

def repIDToIndex(branch, repID):
    refund()
    return(self.Reporting[branch].repIDtoIndex[repID])

def hashReport(report: arr, salt):
    refund()
    hashInfo = array(len(report) + 2)
    hashInfo[0] = msg.sender
    hashInfo[1] = salt
    i = 2
    while i < (len(report) + 2):
        hashInfo[i] = report[i-2]
        i += 1
    reportHash = sha3(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# check that msg.sender is one of our function contracts
def setInitialReporters(parent, branchID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # add branch as a "reporter"
    self.Reporting[branchID].numberReporters = 1
    self.Reporting[branchID].repIDtoIndex[branchID] = 0
    self.Reporting[branchID].reputation[0].repValue = 0
    self.Reporting[branchID].reputation[0].reporterID = branchID
    return(1)

def addReporter(branch, sender, amount, dormant, repToBonderOrBranch):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    refund()
    reporterIndex = self.Reporting[branch].numberReporters
    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex
    self.Reporting[branch].reputation[reporterIndex].repValue = amount
    self.Reporting[branch].reputation[reporterIndex].reporterID = sender
    self.Reporting[branch].dormantRep[reporterIndex].reporterID = sender
    self.Reporting[branchID].dormantRep[i].repValue = dormant
    self.Reporting[branch].activeRep += amount + repToBonderOrBranch
    self.Reporting[branchID].totalRep += amount + dormant + repToBonderOrBranch
    self.Reporting[branch].numberReporters += 1
    return(1)

def addRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue += value
    return(1)

def subtractRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].reputation[index].repValue -= value
    return(1)

def setRep(branch, index, newRep):
    refund()
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    oldRep = self.Reporting[branch].reputation[index].repValue
    self.Reporting[branch].reputation[index].repValue = newRep
    self.Reporting[branch].activeRep += newRep - oldRep
    self.Reporting[branch].totalRep += newRep - oldRep
    return(1)

def addDormantRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue += value
    return(1)

def subtractDormantRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue -= value
    return(1)

# check that msg.sender is one of our function contracts
# Sets the initial distribution of rep
def setSaleDistribution(addresses: arr, balances: arr, branchID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    i = 0
    while i < len(addresses):
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].repValue = balances[i]
        self.Reporting[branchID].dormantRep[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].repIDtoIndex[addresses[i]] = self.Reporting[branchID].numberReporters
        self.Reporting[branchID].numberReporters += 1
        i+=1
    return(1)

inset('refund.se')

macro fx_floor_log2($x):
    with $y = $x / 0x10000000000000000:
        with $lo = 0:
            with $hi = 191:
                with $mid = ($hi + $lo)/2:
                    while (($lo + 1) != $hi):
                        if $y < 2**$mid:
                            $hi = $mid
                        else:
                            $lo = $mid
                        $mid = ($hi + $lo)/2
                    $lo

macro fx_log2_small($x):
    with $result = -0x48A49EAD9B2CD16BE:
        with $temp = $x:
            $result += 0x124DC64B2741E5F083*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x36A569D528A96FF419*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x880785B1DE09970584*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x10AF33C52EB996E92A6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x19FD6E8AC1305DD6D3F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x2086485A91622AE7378*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x210382DF5A3175686B4*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1B58D71F02D9DA4F7B6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1288E14C2FB8C4C1595*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0xA44C5BBEB599D5AB38*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A0E619C630B69BC17*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1AE8CAEA63CF2593A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x7C3EF5A5BFC21BA1F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1BD202FA82B683802*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A90858A0731AD74*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x8CB3CD4376E76EF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA6B8F8E68CD877*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result - 0x5D5316875D9E3*$temp / 0x10000000000000000

macro fx_log2($x):
    with $y = fx_floor_log2($x):
        with $z = $x / 2**$y:
            $y * 0x10000000000000000 + fx_log2_small($z)

macro fx_log($x):
    fx_log2($x) * 0x10000000000000000 / 0x171547652B82FE177

macro fx_exp2_small($x):
    with $result = 0x10000000000000000:
        with $temp = $x:
            $result += 0xB17217F7D1CF79AC*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x3D7F7BFF058B1D56*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xE35846B82505F32*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x276556DF749D7C6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x5761FF9E294A6F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA184897C5558D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xFFE5FE24386C*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x162C023B2A1D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1B5250C02BF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E4D3F1A83*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E87B8E21*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1C768AA3*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x164F0A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result + 0x1B08D3*$temp / 0x10000000000000000

macro fx_exp2($x):
    with $y = $x / 0x10000000000000000:
        with $z = $x % 0x10000000000000000:
            fx_exp2_small($z) * 2**$y

macro fx_exp($x):
    fx_exp2($x * 0x10000000000000000 / 0xB17217F7D1CF79AC)

# Calculates the exponential function given a fixed point [base 2^64] number, so e^x
def fx_exp(x):
    refund()
    return(fx_exp(x))

# Calculates the natural log function given a fixed point [base 2^64] number, so ln(x)
def fx_log(x):
    refund()
    return(fx_log(x))

# Takes the square root of a fixed point number
def sqrt(n):
    refund()
    val = n
    i = 0
    while i < 11:
        val = (val + n*ONE/val)/2
        i += 1
    return val
inset('refund.se')

# Keeps track of data for round two backstop [where everyone reports on something] using event as the index
    # final is whether an event is final
    # bondReturned is whether the bond principle has been returned
    # bondPaid is how much on top of the bond principle has been paid to the bond poster
    # refund is subsidy to pay for round 2 event resolution function call
    # bondPoster is the account which posted the bond
    # original ethicality, outcome, and voteperiod specify the first round of consensus values for ethicality, outcome, and voteperiod, respectively
    # roundTwo states whether an event is a round two event
data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, originalEthicality, final, bondPoster, bondReturned, bondPaid, refund)

# Keeps track of data for the forking backstop [wherein the network is forked into two sets of rep] using event as the index
    # moved is used for stating whether an event has been moved to the winning fork
    # bondPaid is how much on top of the bond principle has been paid to the bond poster
    # bondAmount is the amount of the bond
    # bondPoster is the account which posted the bond
    # forkedOverEthicality states whether the event was forked due to controversy of ethicality
    # originalBranch is the branch the event was originally on
    
data forking[](bondPoster, bondAmount, forkedOverEthicality, bondPaid, originalBranch, moved)

# Given a branch and a forkPeriod it states which fork the winner was
data resolved[][]

def setRoundTwoRefund(event, amt):
    self.roundTwo[event].refund = amt
    return(1)
    
def doRoundTwoRefund(sender, event):
    send(sender, self.roundTwo[event].refund)
    return(1)

def setForkBondPoster(event, poster):
    self.forking[event].bondPoster = poster
    return(1)

def getForkBondPoster(event):
    return(self.forking[event].bondPoster)

def setForkedOverEthicality(event):
    self.forking[event].forkedOverEthicality = 1
    return(1)

def getForkedOverEthicality(event):
    return(self.forking[event].forkedOverEthicality)
    
def adjForkBondPaid(event, amount):
    self.forking[event].bondPaid += amount
    return(1)

def getForkBondPaid(event):
    return(self.forking[event].bondPaid)

# sets bond amount for a fork bond
def setBondAmount(event, amount):
    self.forking[event].bondAmount = amount
    return(1)

# gets bond amount for a fork bond
def getBondAmount(event):
    return(self.forking[event].bondAmount)

def setOriginalBranch(event, branch):
    self.forking[event].originalBranch = branch
    return(1)

def getOriginalBranch(event):
    return(self.forking[event].originalBranch)
    
def setMoved(event):
    self.forking[event].moved = 1
    return(1)

def getMoved(event):
    return(self.forking[event].moved)
    
def setResolved(branch, forkPeriod, winner):
    self.resolved[branch][forkPeriod] = winner
    return(1)

def getResolved(branch, forkPeriod):
    return(self.resolved[branch][forkPeriod])

# gets how much of round 2 bond has been paid back
def getBondPaid(event):
    return(self.roundTwo[event].bondPaid)

# increases how much of round 2 bond has been paid back
def increaseBondPaid(event, amount):
    self.roundTwo[event].bondPaid += amount
    return(1)

# whether a round 2 bond's principle has been returned
def getBondReturned(event):
    return(self.roundTwo[event].bondReturned)
    
def setBondReturned(event):
    self.roundTwo[event].bondReturned = 1
    return(1)

def getRoundTwo(event):
    refund()
    return(self.roundTwo[event].roundTwo)
    
def setRoundTwo(event, roundTwo):
    self.roundTwo[event].roundTwo = roundTwo
    return(1)
    
def getBondPoster(event):
    refund()
    return(self.roundTwo[event].bondPoster)

def setBondPoster(event, bondPoster):
    self.roundTwo[event].bondPoster = bondPoster
    return(1)

# whether a round 2 event is final
def getFinal(event):
    refund()
    return(self.roundTwo[event].final)

def setFinal(event):
    self.roundTwo[event].final = 1
    return(1)
    
def getOriginalOutcome(event):
    refund()
    return(self.roundTwo[event].originalOutcome)

def setOriginalOutcome(event, originalOutcome):
    self.roundTwo[event].originalOutcome = originalOutcome
    return(1)

def getOriginalEthicality(event):
    refund()
    return(self.roundTwo[event].originalEthicality)
    
def setOriginalEthicality(event, ethicality):
    self.roundTwo[event].originalEthicality = ethicality
    return(1)

def getOriginalVotePeriod(event):
    refund()
    return(self.roundTwo[event].originalVotePeriod)

def setOriginalVotePeriod(event, period):
    self.roundTwo[event].originalVotePeriod = period
    return(1)
inset('refund.se')

macro ONEPOINTTWO: 22136092888451461120

macro POINTZEROONE: 184467440737095520

# [branchID][votingPeriod]
# reporthash is [reporterID][event] = hash
# subsidy is money for paying back a user for calculating the targeted num of reports for an event
data EventIDToIndex[][]
data EventsExpDates[][](numberEvents, numberRemoved, events[], numEventsToReportOn, reportHash[][], shareValue, roundTwoNumEvents, subsidy[])

# numReportsEvent is number of reports on an event, expected is how many have been committed for an event
# numReportsActual is the amount of reports a user has submitted in a period
# lesserReportNum is the number of reports an event should have [the lesser of how many it can afford from fees and how many it should have due to outstanding share value]
# periodRepConstant is 
data branches[](beforeRep[][], afterRep[][], periodDormantRep[][], ethics[][](event[]), report[][](event[]), numReportsEvent[][], numReportsExpectedEvent[][], numReportsActual[][], repEvent[][], lesserReportNum[][], periodRepConstant[][], reportersPaidSoFarForEvent[])


# branch, period as params
data numReqEvents[][]
data requiredEvents[]
data mode_items[][](report_value[], current_mode, current_mode_items)

def getReportersPaidSoFar(branch, event):
    return(self.branches[branch].reportersPaidSoFarForEvent[event])

def addReportersPaidSoFar(branch, event):
    self.branches[branch].reportersPaidSoFarForEvent[event] += 1
    return(1)
    
def refundCost(to, value):
    send(to, value)
    return(1)

def getSubsidy(branch, period, event):
    return(self.EventsExpDates[branch][period].subsidy[event])

def getPeriodRepConstant(branch, votePeriod, sender):
    return(self.branches[branch].periodRepConstant[votePeriod][sender])

def setPeriodRepConstant(branch, votePeriod, sender, value):
    self.branches[branch].periodRepConstant[votePeriod][sender] = value
    return(1)

def getLesserReportNum(branch, period, event):
    return(self.branches[branch].lesserReportNum[period][event])

def getCurrentModeItems(period, event):
    return(self.mode_items[period][event].current_mode_items)

def getCurrentMode(period, event):
    return(self.mode_items[period][event].current_mode)
    
# returns weight of a report value for the mode
def getWeightOfReport(period, event, report):
    return(self.mode_items[period][event].report_value[report])

def getRepEvent(branch, votePeriod, event):
    return(self.branches[branch].repEvent[votePeriod][event])

def getEthicReport(branch, period, event, sender):
    return(self.branches[branch].ethics[period][sender].event[event])

def getNumReportsExpectedEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsExpectedEvent[votePeriod][eventID])

def getNumReportsEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsEvent[votePeriod][eventID])

def getReport(branch, period, event, sender):
    #if(whitelist):
    return(self.branches[branch].report[period][sender].event[event])

def getBeforeRep(branch, period, sender):
    return(self.branches[branch].beforeRep[period][sender])

def getAfterRep(branch, period, sender):
    return(self.branches[branch].afterRep[period][sender])
    
def getPeriodDormantRep(branch, period, sender):
    return(self.branches[branch].periodDormantRep[period][sender])

def getNumReportsActual(branch, votePeriod, sender):
    return(self.branches[branch].numReportsActual[sender][votePeriod])

def getNumRoundTwo(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].roundTwoNumEvents)

def addRoundTwo(branch, period):
    refund()
    self.EventsExpDates[branch][period].roundTwoNumEvents += 1
    return(1)

def getRequired(event):
    return(self.requiredEvents[event])
    
def getNumRequired(branch, period):
    return(self.numReqEvents[branch][period])
    
# Return 0 means already required
def setEventRequired(branch, period, event):
    if(self.requiredEvents[event]==0):
        self.requiredEvents[event] = 1
        self.numReqEvents[branch][period] += 1
        return(1)
    else:
        return(0)

# With this function you can get the eventIDs and report on outcomes
# @return all events in a branch and expiration period
def getEvents(branch, expDateIndex):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        i += 1
    return(events: arr)
    
# 0, event means calculateReportTargetForEvent(branch, eventID, votePeriod, sender) in make reports should be called for that event
def getEventsToReportOn(branch, expDateIndex, sender):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents*2)
    i = 0
    while i < numEvents:
        if(self.getLesserReportNum(branch, votePeriod, event)==0):
            return([0, event]: arr)
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        reportingThreshold = self.calculateReportingThreshold(branch, events[i], expDateIndex, sender)
        x = array(1)
        x[0] = sender + events[i]
        # do abs then mult by 2 to ensure pos. and between 0 and 1
        shaHash = sha3(x, items=1)
        shaHashAbs = abs(shaHash)/ONE
        shaHash = 2*shaHashAbs
        if((shaHash < reportingThreshold || shaHash<self.getReportingThreshold(events[i]) || self.getRequired(events[i])) && !self.getOutcome(events[i])):
            events[i+1] = 1
        else:
            events[i+1] = 0
        i += 2
    return(events: arr)
    
def getEventCanReportOn(branch, expDateIndex, reporter, event):
    refund()
    reportingThreshold = self.calculateReportingThreshold(branch, event, expDateIndex, reporter)
    x = array(1)
    x[0] = reporter + event
    # do abs then mult by 2 to ensure pos. and between 0 and 1
    shaHash = sha3(x, items=1)
    shaHashAbs = abs(shaHash)/ONE
    shaHash = 2*shaHashAbs
    if(shaHash < reportingThreshold || shaHash<self.getReportingThreshold(event) || self.getRequired(events)):
        return(1)
    else:
        return(0)

# eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2))
    # exp(1.2*ln(repbal)) / exp(1.2*ln(totalrep)) is == (reporterList[n]/totalRep)**1.2
    # a^b=exp(b*ln(a))=e^(b*ln(a)).
def calculateReportingThreshold(branch, eventID, votePeriod, sender):
    repConstant = self.getPeriodRepConstant(branch, votePeriod, sender)
    if(repConstant==0):
        repConstant = self.fx_exp(ONEPOINTTWO*self.fx_log(self.getRepBalance(branch, sender))/ONE)*2**64/self.fx_exp(ONEPOINTTWO*self.fx_log(self.getActiveRep(branch))/ONE)
        expectedEventsForReporter = repConstant * self.getNumEventsToReportOn(branch, votePeriod)
        total = expectedEventsForReporter
        eventsInPeriod = self.getNumberEvents(branch, expDateIndex)-self.getNumRemoved(branch, votePeriod)
        numRequiredEvents = self.getNumRequired(branch, votePeriod)
        if(repFraction >= POINTZEROONE):
            minimum = min(30-numRequiredEvents, eventsInPeriod-numRequiredEvents)
            if(total/ONE < minimum):
                total = minimum*ONE
                repConstant = total / self.getNumEventsToReportOn(branch, votePeriod)
        self.setPeriodRepConstant(branch, votePeriod, sender, repConstant)
    # 1 is 2**192 here, lesserreportnum, repconstant, and one are all base 2**64
    reportingThreshold = self.getLesserReportNum(branch, votePeriod, eventID)*repConstant*ONE
    return(reportingThreshold)
    
def getEventsRange(branch, expDateIndex, start, end):
    refund()
    numEvents = end-start
    events = array(numEvents)
    i = start
    index = 0
    while i < end:
        events[index] = self.EventsExpDates[branch][expDateIndex].events[i]
        index += 1
        i += 1
    return(events: arr)
    
def getEventIndex(period, eventID):
    refund()
    return(self.EventIDToIndex[period][eventID])

# we should probably make this bonded too
# -1: voting not started
def setNumEventsToReportOn(branch):
    refund()
    # after voting has started
    expDateIndex = self.getVotePeriod(branch)
    self.EventsExpDates[branch][expDateIndex].numEventsToReportOn = (self.EventsExpDates[branch][expDateIndex].numberEvents - self.numReqEvents[branch][expDateIndex] - self.EventsExpDates[branch][expDateIndex].numberRemoved)*self.getBaseReporters(branch)
    return(1)

def getNumEventsToReportOn(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numEventsToReportOn)

def getShareValue(branch, expIndex):
    refund()
    return(self.EventsExpDates[branch][expIndex].shareValue)

def getNumberEvents(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numberEvents)

def getEvent(branch, expDateIndex, eventIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].events[eventIndex])

def getReportHash(branch, expDateIndex, reporter, event):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event])

# check that msg.sender is one of our function contracts
def addEvent(branch, futurePeriod, eventID, subsidy):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID
    self.EventIDToIndex[futurePeriod][eventID] = self.EventsExpDates[branch][futurePeriod].numberEvents
    self.EventsExpDates[branch][futurePeriod].numberEvents += 1
    self.EventsExpDates[branch][futurePeriod].subsidy[eventID] += subsidy
    return(1)

def deleteEvent(branch, period, event):
    i = self.EventIDToIndex[period][event]
    self.EventsExpDates[branch][period].events[i] = 0
    self.EventIDToIndex[period][event] = 0
    return(1)

def removeEvent(branch, period):
    refund()
    self.EventsExpDates[branch][period].numberRemoved += 1
    return(1)

def getNumRemoved(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].numberRemoved)

def adjustPeriodShareValueOutstanding(branch, expIndex, amount):
    refund()
    self.EventsExpDates[branch][expIndex].shareValue += amount
    return(1)

def setReportHash(branch, expDateIndex, reporter, reportHash, event):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event] = reportHash
    return(1)

# called in case an event doesn't get reported on at all in a period
def moveEvent(branch, event):
    if(self.getVotePeriod(branch) > self.getExpiration(event)/self.getPeriodLength(branch) && !self.getUncaughtOutcome(event)):
        # add to next expiration period
        self.addEvent(branch, block.timestamp/self.getPeriodLength(branch), event)
        self.setExpiration(event, block.timestamp)
        return(1)
    else:
        return(0)
        
def addToWeightOfReport(period, event, report, amount):
    self.mode_items[period][event].report_value[report] += amount
    return(1)
    
def setCurrentMode(period, event, mode):
    self.mode_items[period][event].current_mode = mode
    return(1)
    
# basically setting current mode's weight
def setCurrentModeItems(period, event, modeReport):
    self.mode_items[period][event].current_mode_items = self.mode_items[period][event].report_value[modeReport]
    return(1)

def addRepEvent(branch, votePeriod, event, amount):
    self.branches[branch].repEvent[votePeriod][event] += amount
    return(1)

def setEthicReport(branch, period, event, ethics, sender):
    self.branches[branch].ethics[period][sender].event[event] = ethics
    return(1)

def setNumReportsExpectedEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] = num
    return(1)

def setNumReportsEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsEvent[votePeriod][eventID] = num
    return(1)
    
def addReportToEvent(branch, votePeriod, eventID, sender):
    self.branches[branch].numReportsEvent[votePeriod][eventID] += 1
    self.branches[branch].numReportsActual[sender][votePeriod] += 1
    return(1)

def addReportExpected(branch, votePeriod, eventID):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] += 1
    return(1)

def setReport(branch, period, event, report, sender):
    self.branches[branch].report[period][sender].event[event] = report
    return(1)

def setBeforeRep(branch, period, rep, sender):
    self.branches[branch].beforeRep[period][sender] = rep
    return(rep)

def setAfterRep(branch, period, rep, sender):
    self.branches[branch].afterRep[period][sender] = rep
    return(rep)

def setPeriodDormantRep(branch, period, rep, sender):
    self.branches[branch].periodDormantRep[period][sender] = rep
    return(rep)
    
def setLesserReportNum(branch, period, event, num):
    self.branches[branch].lesserReportNum[period][event] = num
    return(1)
    
#In the rare possibility that no one gets randomly selected to report on a market in a given period, on the last day, we can change the sha3 threshold.
def setReportingThreshold(event):
    refund()
    # first check is if event expDate is in the current vote period and second is if blockNum is near expiration of commit period (within 24 hr.)
    # final check is if < 3 reports so far
    # so if in 24 hr we'd be in the next half of the vote period, we're within 24 hr of the end of this one
    branch = self.getBranch(event)
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    votePeriod = self.getVotePeriod(branch)
    if(votePeriod==self.getExpiration(event)/periodLength and (((block.timestamp + TWENTYFOURHR) % periodLength) > periodLength/2) and self.branches[branch].numReportsExpectedEvent[votePeriod][event]<3):
        self.setThreshold(event, 2**192)
        return(1)
    else:
        return(0)
        
macro abs($a):
    if($a<0):
        $a = -$a
    $a
inset('refund.se')

# Storage for branch data
# branch takes a branchID
    # penalized takes for a given period a user / address reported for a certain event and num of events they reported on in that period in total
    # penalizedUpTo is the latest period a user has done the penalization for
    # fees collected states whether for a given period a user collected fees
    # rep collected states whether for a given period a user collected rep
    # base reporters last period is the minimum number of reporters for the last period
data branch[](period[](denominator, penalized[](event[], num, notEnoughReportsPenalized), feesCollected[], feeFirst, periodBalance), penalizedUpTo[], baseReportersLastPeriod)

# refunds keeps track of subsidies for various consensus function calls paid for by the market creator or bonders
data refunds[]

# Keeps track of whether a reporter has been penalized for collusion while reporting
data slashed[][](reporter[])


def getSlashed(branch, votePeriod, reporter):
    return(self.slashed[branch][votePeriod].reporter[reporter])
    
def setSlashed(branch, votePeriod, reporter):
    self.slashed[branch][votePeriod].reporter[reporter] = 1
    return(1)

def setRefund(refunder, amt):
    self.refunds[refunder] = amt
    return(1)
    
def doRefund(sender, refunder):
    send(sender, self.refunds[refunder])
    return(1)

def getBaseReportersLastPeriod(branch):
    return(self.branch[branch].baseReportersLastPeriod)

def setBaseReportersLastPeriod(branch, amount):
    self.branch[branch].baseReportersLastPeriod = amount
    return(1)

# get whether the first fee has been claimed by a reporter yet
def getFeeFirst(branch, period):
    return(self.branch[branch].period[period].feeFirst)

def setFeeFirst(branch, period, val):
    self.branch[branch].period[period].feeFirst = val
    return(1)

def getPeriodBalance(branch, period):
    return(self.branch[branch].period[period].periodBalance)

def setPeriodBalance(branch, period, balance):
    self.branch[branch].period[period].periodBalance = balance

def getPenalizedUpTo(branch, sender):
    return(self.branch[branch].penalizedUpTo[sender])

def setPenalizedUpTo(branch, sender, period):
    self.branch[branch].penalizedUpTo[sender] = period
    return(1)

def getDenominator(branch, period):
    return(self.branch[branch].period[period].denominator)

def increaseDenominator(branch, period, amount):
    self.branch[branch].period[period].denominator += amount
    return(1)

def getFeesCollected(branch, address, period):
    return(self.branch[branch].period[period].feesCollected[address])

def setFeesCollected(branch, address, period):
    self.branch[branch].period[period].feesCollected[address] = 1
    return(1)
    
def getPenalized(branch, period, sender, event):
    return(self.branch[branch].period[period].penalized[sender].event[event])

def setPenalized(branch, period, sender, event):
    self.branch[branch].period[period].penalized[sender].event[event] = 1
    return(1)

def getPenalizedNum(branch, period, sender):
    return(self.branch[branch].period[period].penalized[sender].num)    

def increasePenalizedNum(branch, period, sender, amount):
    self.branch[branch].period[period].penalized[sender].num += amount
    return(1)

def setNotEnoughPenalized(branch, address, period):
    self.branch[branch].period[period].penalized[address].notEnoughReportsPenalized = 1
    return(1)
    
def getNotEnoughPenalized(branch, address, period):
    return(self.branch[branch].period[period].penalized[address].notEnoughReportsPenalized)
    
def getRRDone(branch, reporter):
    refund()
    return(repRedistributionDone(branch, reporter))

macro repRedistributionDone($branch, $reporter):
    lastPeriodPenalized = self.branch[$branch].penalizedUpTo[$reporter]
    lastPeriod = self.getVotePeriod($branch)-1
    if(lastPeriod==lastPeriodPenalized):
        1
    else:
        0
inset('refund.se')

# Branches keeps track of data associated with branches in augur
# Branches' index is the hash of the branch (aka branchID)
# currentVotePeriod is the current index in eventsExpDates and tells us which bucket of events are up to be
# voted on in the current vote period (should always be 1 behind block.timestamp/periodlength or current EventsExpDates index)
# currentExpPeriod = (block.timestamp / self.Branches[branch].periodLength)
# currentExpPeriod - 1 is what's up for reporting at any given time
# periodLength is the length in seconds of the branch's reporting period
# parentPeriod is the period the parent was in when the branch was created [useful for claiming rep after a fork]
# baseReporters the number of reporters which report on a market at a minimum
# forkPeriod is the period a branch was last forked over
# eventForkedOver is the event a branch was last forked over
# parent is the parent branch of the given branch
# How to set minimum reporting fee guidelines for reporters, abs. minimum should be calc. as follows:
    #Volume per period * .5 * fee * ev/ebit * 6 >= rep market cap
    #Say ev/ebit or valuation is 15, so:
    #45 * fee * volume per period = rep market cap
    #Want:
        #Rep market cap >> outstanding shares value at all times
data Branches[](currentVotePeriod, periodLength, markets[], numMarkets, minTradingFee, balance[], creationDate, oracleOnly, parentPeriod, baseReporters, forkPeriod, eventForkedOver, parent)

# first param is the branch, second param is the subcurrency contract
data cash[][]

# keeps track of a list of all branches
data branchList[]
data branchListCount


# call once after uploading (externed method not allowed in init)
def initDefaultBranch():
    refund()
    return(self.initiateOwner(1010101))

# event a branch was most recently forked over
def getEventForkedOver(branch):
    return(self.Branches[branch].eventForkedOver)

def setEventForkedOver(branch, event):
    self.Branches[branch].eventForkedOver = event
    return(1)

def getBaseReporters(branch):
    refund()
    return(self.Branches[branch].baseReporters)
    
def setBaseReporters(branch, num):
    refund()
    self.Branches[branch].baseReporters = num
    return(1)

def getOracleOnly(branch):
    refund()
    return(self.Branches[branch].oracleOnly)

def getVotePeriod(branch):
    refund()
    return(self.Branches[branch].currentVotePeriod)

def getPeriodLength(branch):
    refund()
    return(self.Branches[branch].periodLength)

# branch cash balance at start of period
def setInitialBalance(branch, period, balance):
    refund()
    self.Branches[branch].balance[period] = balance
    return(balance)

def getInitialBalance(branch, period):
    refund()
    return(self.Branches[branch].balance[period])

# @return all markets in a branch
def getMarketsInBranch(branch):
    refund()
    numMarkets = self.Branches[branch].numMarkets
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[i]
        i += 1
    return(markets: arr)
   
   
def getParent(branch):
    return(self.Branches[branch].parent)

# @return all markets in a branch
def getSomeMarketsInBranch(branch, initial, last):
    refund()
    numMarkets = last - initial
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[initial+i]
        i += 1
    return(markets: arr)

def getNumMarketsBranch(branch):
    refund()
    return(self.Branches[branch].numMarkets)

def getMinTradingFee(branch):
    refund()
    return(self.Branches[branch].minTradingFee)

# @return all branches
def getBranches():
    refund()
    b = 0
    numBranches = self.branchListCount
    branches = array(numBranches)
    while b < numBranches:
        branches[b] = self.branchList[b]
        b += 1
    return(branches: arr)

def getNumBranches():
    refund()
    return(self.branchListCount)

def getBranchByNum(branchNumber):
    refund()
    return(self.branchList[branchNumber])

def getCreationDate(ID):
    refund()
    return(self.Branches[ID].creationDate)

# check that msg.sender is one of our function contracts
def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod, parent):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    if(self.Branches[ID].periodLength==0):
        self.Branches[ID].currentVotePeriod = currentVotePeriod
        self.Branches[ID].periodLength = periodLength
        self.Branches[ID].minTradingFee = minTradingFee
        self.branchList[self.branchListCount] = ID
        self.branchListCount += 1
        self.Branches[ID].creationDate = block.timestamp
        self.Branches[ID].parentPeriod = parentPeriod
        self.Branches[ID].oracleOnly = oracleOnly
        self.Branches[ID].parent = parent
        self.Branches[ID].baseReporters = self.Branches[parent].baseReporters
        self.initiateOwner(ID)
        return(1)
    else:
        return(0)

def getParentPeriod(branch):
    refund()
    return(self.Branches[branch].parentPeriod)

def incrementPeriod(branch):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    self.Branches[branch].currentVotePeriod += 1
    return(1)

# check that msg.sender is one of our function contracts
def addMarketToBranch(branch, market):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    numMarkets = self.Branches[branch].numMarkets
    self.Branches[branch].markets[numMarkets] = market
    self.Branches[branch].numMarkets += 1
    return(1)
    
def setForkPeriod(branch):
    self.Branches[branch].forkPeriod = self.Branches[branch].currentVotePeriod
    return(1)
    
# gets the period in which a branch was most recently forked
def getForkPeriod(branch):
    return(self.Branches[branch].forkPeriod)
macro refund():
    if self.test_callstack() != 1: return(-1)
    if(msg.value > 0):
        send(msg.sender, msg.value)

def test_callstack(): return(1)

macro ONE: 2^64

macro WEITOETH: 10^18

macro THREEFOURTHS: 13835058055282163712

macro ONEFOURTH: 2**62

macro ONEHALF: 2**63

macro TWO: 2**65

macro TWENTYFOURHR: 86400
inset('refund.se')

# Markets' index is the marketID, markets stores data about markets [which are able to be traded on] in augur
    # Events is a 0 indexed array of events in the market in the format of
    	# [1, event, event, 2, event, 3, event, event, event]
    	# 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
    # Sharespurchased keeps track of the number of shares purchased for each outcome
    	# sharesPurchased states starts at 1 - (same for participants[].shares[] array)
    # Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event
    # currentParticipant is the number of participants [traders] in the market
    # cumulativeScale == range of the market for scalars
    # numOutcomes is the number of outcomes in a market [up to 8 for now]
    # a binary outcome state 1 is no, 2 is true, 0 if not done, 1.5 if indeterminate
    # tradingFee is a percent in fixedPoint and the base trading fee for a market: takers pay 100%-150% of this, makers pay 0-50% of this
    # tradingPeriod is which eventexpperiod market expires in
    # pushing forward is whether a market has been pushed forward to attempt early resolution
    # bondsman is the person/address who/that posted the early resolution bond
    # originalPeriod is the original period the market's event would resolve in
    # trade_ids stores trades for a given market
    # last_trade is the last trade that happened in a given market
    # total_trades is the total number of trades in a give market
    # tags are the subject tags / categories / keywords for a given market
    # makerFees - from 0-50% - amount of fee that the maker orders pay
    # extraInfo is any extra info that didn't fit well in the regular description
    # sharesValue is the value of the shares traded in a given market
    # gasSubsidy is paid by the creator to pay for closing the market [closing is just setting the winning outcomes and allowing people to withdraw funds if they own winning shares]
    # fees is total amount of fees a market has paid to a branch [the reporters]
    # lastExpDate is when the market's last event expires
    # prices keeps track of the latest traded price for a given outcome in a market
data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch, volume, pushingForward, bondsMan, originalPeriod, trade_ids[](id, next_id, prev_id), last_trade, total_trades, tag1, tag2, tag3, makerFees, extraInfo[], extraInfoLen, sharesValue, gasSubsidy, fees, creationTime, lastExpDate, prices[])

# takes branch as param, composite hash of all markets in the system
data marketsHash[]

def getMarketsHash(branch):
	return(self.marketsHash[branch])

def addToMarketsHash(branch, newHash):
	x = array(2)
	x[0] = self.marketsHash[branch]
	x[1] = newHash
	self.marketsHash[branch] = sha3(x, items=2)
	return(1)

def addFees(market, amount):
	self.Markets[market].fees += amount
	return(1)
	
def setPrice(market, outcome, price):
	self.Markets[market].prices[outcome] = price
	return(1)

# refund closing cost for a market
def refundClosing(amount, to):
	send(amount, to)
	return(1)

def getFees(market):
	return(self.Markets[market].fees)

def getMakerFees(market):
	return(self.Markets[market].makerFees)

def getgasSubsidy(market):
	return(self.Markets[market].gasSubsidy)

def getSharesValue(market):
	return(self.Markets[market].sharesValue)

def returnTags(market):
	tags = array(3)
	tags[0] = self.Markets[market].tag1
	tags[1] = self.Markets[market].tag2
	tags[2] = self.Markets[market].tag3
	return(tags: arr)

def getTotalSharesPurchased(market):
	refund()
	total = 0
	n = self.Markets[market].numOutcomes
	i = 1
	while i <= n:
	  total += self.Markets[market].sharesPurchased[i]
	  i += 1
	return(total)

def getMarketEvent(market, index):
	refund()
	return(self.Markets[market].events[index])

def getCreationTime(market):
	return(self.Markets[market].creationTime)

def getMarketEvents(market):
	refund()
	return(load(self.Markets[market].events[0], items=self.Markets[market].lenEvents): arr)

def getSharesPurchased(market, outcome):
	refund()
	return(self.Markets[market].sharesPurchased[outcome])

def getExtraInfo(market):
	refund()
	length=self.Markets[market].extraInfoLen
	return(load(self.Markets[market].extraInfo[0], chars=length): str)

def getVolume(market):
	refund()
	return(self.Markets[market].volume)

def getParticipantNumber(market, address):
	refund()
	participantNumber = self.Markets[market].addr2participant[address]
	return(participantNumber)

def getParticipantID(market, participantNumber):
	refund()
	return(self.Markets[market].participants[participantNumber].participantID)

def getParticipantSharesPurchased(market, participantNumber, outcome):
	refund()
	return(self.Markets[market].participants[participantNumber].shares[outcome])

def getNumEvents(market):
	refund()
	return(self.Markets[market].lenEvents)

def getCurrentParticipantNumber(market):
	refund()
	return(self.Markets[market].currentParticipant)

def getCumScale(market):
	refund()
	return(self.Markets[market].cumulativeScale)

def getMarketNumOutcomes(market):
	refund()
	return(self.Markets[market].numOutcomes)

def getTradingPeriod(market):
	refund()
	return(self.Markets[market].tradingPeriod)

def getOriginalTradingPeriod(market):
	refund()
	return(self.Markets[market].originalPeriod)

def setTradingPeriod(market, period):
	refund()
	self.Markets[market].tradingPeriod = period
	return(1)

def getTradingFee(market):
	refund()
	return(self.Markets[market].tradingFee)

def getBranchID(market):
	refund()
	return(self.Markets[market].branch)

macro market($marketID):
	self.Markets[$marketID]

macro cumScale($marketID):
	market($marketID).cumulativeScale

macro numOutcomes($marketID):
	market($marketID).numOutcomes

macro sharesPurchased($marketID):
	market($marketID).sharesPurchased

# check that msg.sender is one of our function contracts
def initializeMarket(marketID, events: arr, tradingPeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumScale, numOutcomes, extraInfo: str, gasSubsidy, creationFee, lastExpDate):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	# add event list to the market
	save(self.Markets[marketID].events[0], events, items=len(events))
	self.Markets[marketID].lenEvents = len(events)
	save(self.Markets[marketID].extraInfo[0], extraInfo, chars=len(extraInfo))
	self.Markets[marketID].extraInfoLen = len(extraInfo)
	self.Markets[marketID].tradingPeriod = tradingPeriod
	self.Markets[marketID].originalPeriod = tradingPeriod
	self.Markets[marketID].tradingFee = tradingFee
	self.Markets[marketID].branch = branch
	self.Markets[marketID].cumulativeScale = cumScale
	self.Markets[marketID].numOutcomes = numOutcomes
	self.Markets[marketID].tag1 = tag1
	self.Markets[marketID].tag2 = tag2
	self.Markets[marketID].gasSubsidy = gasSubsidy
	self.Markets[marketID].tag3 = tag3
	self.Markets[marketID].makerFees = makerFees
	self.Markets[marketID].fees = creationFee
	self.Markets[marketID].creationTime = block.timestamp
	self.Markets[marketID].lastExpDate = lastExpDate
	return(1)

def addParticipant(market, address):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	participantNumber = self.Markets[market].currentParticipant
	self.Markets[market].participants[participantNumber].participantID = address
	self.Markets[market].addr2participant[address] = participantNumber
	self.Markets[market].currentParticipant += 1
	return(participantNumber)

def modifyShares(marketID, outcome, amount):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	sharesPurchased(marketID)[outcome] += amount
	return(1)
	
def modifySharesValue(marketID, amount):
	self.Markets[marketID].sharesValue += amount
	return(1)

def modifyParticipantShares(marketID, participantNumber, outcome, amount, cancel):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	self.Markets[marketID].participants[participantNumber].shares[outcome] += amount
	if(amount<0):
		amount = amount*-1
	if(cancel):
		amount = -1*amount
	self.Markets[marketID].volume += amount
	return(1)

def setWinningOutcomes(market, outcomes: arr):
	refund()
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	# largest # of winning outcomes is 8
	save(self.Markets[market].winningOutcomes[0], outcomes, items=len(outcomes))
	return(1)

def getWinningOutcomes(market):
	refund()
	# do whitelist, if oracle system branch, always return outcome, if in whitelist it's good, if not, log
	#if(!self.whitelist.check(msg.sender)):
	#    return(-1)
	# largest # of winning outcomes is 8
	return(load(self.Markets[market].winningOutcomes[0], items=8): arr)
	
def getOneWinningOutcome(market, num):
	refund()
	# whitelist
	return(self.Markets[market].winningOutcomes[num])

def setTradingFee(market, fee):
	refund()
	self.Markets[market].tradingFee = fee
	return(fee)

def setPushedForward(market, bool, sender):
	refund()
	self.Markets[market].pushingForward = bool
	self.Markets[market].bondsMan = sender
	return(1)

def getPushedForward(market):
	refund()
	return(self.Markets[market].pushingForward)

def getBondsMan(market):
	refund()
	return(self.Markets[market].bondsMan)

def getLastTrade(market):
	refund()
	return(self.Markets[market].last_trade)
	
def addTrade(market, trade_id, last_id):
	refund()
	self.Markets[market].trade_ids[last_id].next_id = trade_id
	self.Markets[market].trade_ids[trade_id].prev_id = last_id
	self.Markets[market].trade_ids[trade_id].id = trade_id
	self.Markets[market].last_trade = trade_id
	self.Markets[market].total_trades += 1
	return(1)
	
def remove_trade_from_market(market_id, trade_id):
	refund()
	prev_id = self.Markets[market_id].trade_ids[trade_id].prev_id
	next_id = self.Markets[market_id].trade_ids[trade_id].next_id
	if prev_id and next_id:
		self.Markets[market_id].trade_ids[prev_id].next_id = next_id
		self.Markets[market_id].trade_ids[next_id].prev_id = prev_id
	elif prev_id:
		self.Markets[market_id].last_trade = prev_id
		self.Markets[market_id].trade_ids[prev_id].next_id = 0

	if next_id:
		self.Markets[market_id].trade_ids[trade_id].next_id = 0
	if prev_id:
		self.Markets[market_id].trade_ids[trade_id].prev_id = 0
	self.Markets[market_id].trade_ids[trade_id].id = 0
	self.Markets[market_id].total_trades -= 1
	return(1)

def get_trade_ids(market_id):
	refund()
	trades_count = self.Markets[market_id].total_trades
	trade_id = self.Markets[market_id].last_trade
	trade_ids = array(trades_count)

	i = 0
	while i < trades_count:
		trade_ids[i] = self.Markets[market_id].trade_ids[trade_id].id
		trade_id = self.Markets[market_id].trade_ids[trade_id].prev_id
		i = i + 1

	if trade_ids:
		return(trade_ids:arr)
	return([FAILURE]:arr)
	
def get_total_trades(market_id):
	refund()
	return(self.Markets[market_id].total_trades)

def getOrderBook(marketID):
	refund()
	numTrades = self.Markets[marketID].total_trades
	trades = self.get_trade_ids(marketID, outitems=numTrades)
	orderBook = array(8*numTrades)
	i = 0
	while i < numTrades:
		tradeInfo = self.get_trade(trades[i], outitems=8)
		j = 0
		while j < 8:
			orderBook[8*i + j] = tradeInfo[j]
			j += 1
		i += 1
	return(orderBook:arr)

macro EVENTS_FIELDS: 6
macro OUTCOMES_FIELDS: 2
macro WINNING_OUTCOMES_FIELDS: 8
macro FIELDS: 18

# todo move these getters to a new contract
def getMarketInfo(marketID):
	refund()
	index = FIELDS
	participantNumber = self.Markets[marketID].addr2participant[msg.sender]
	descriptionLength = self.getDescriptionLength(marketID)
	with info = array(FIELDS + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1):
		numEvents = self.Markets[marketID].lenEvents
		info[0] = marketID
		info[1] = self.Markets[marketID].currentParticipant
		info[2] = self.Markets[marketID].makerFees
		info[3] = participantNumber
		info[4] = self.Markets[marketID].numOutcomes
		info[5] = self.Markets[marketID].tradingPeriod
		info[6] = self.Markets[marketID].tradingFee
		info[7] = self.Markets[marketID].branch
		info[8] = numEvents
		info[9] = self.Markets[marketID].cumulativeScale
		info[10] = self.Markets[marketID].creationTime
		info[11] = self.Markets[marketID].volume
		info[12] = self.getCreationFee(marketID)
		info[13] = self.getCreator(marketID)
		info[14] = self.Markets[marketID].tag1
		info[15] = self.Markets[marketID].tag2
		info[16] = self.Markets[marketID].tag3
		info[17] = self.Markets[marketID].creationTime
		# gather event(s) info:
		# [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]
		with events = slice(load(self.Markets[marketID].events[0], chars=32*numEvents), items=0, items=numEvents):
			i = 0
			while i < numEvents:
				with eventInfo = self.getEventInfo(events[i], outitems=EVENTS_FIELDS):
					info[index + i*EVENTS_FIELDS] = events[i]
					j = 1
					while j < EVENTS_FIELDS:
						info[index + i*EVENTS_FIELDS + j] = eventInfo[j]
						j += 1
				i += 1
		index += numEvents*EVENTS_FIELDS

		# gather outcomes info: [sharesPurchased, price], winningOutcomes
		# (price of outcome = last trade)
		numTrades = self.Markets[marketID].total_trades
		numOutcomes = self.Markets[marketID].numOutcomes
		trades = self.get_trade_ids(marketID, outitems=numTrades)
		k = 0
		while k < numOutcomes:
			info[index + k*OUTCOMES_FIELDS] = self.Markets[marketID].sharesPurchased[k + 1]
			i = 0
			lastTrade = self.Markets[marketID].prices[k+1]
			info[index + k*OUTCOMES_FIELDS + 1] = lastTrade
			k += 1
		index += self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS
		k = 0
		while k < WINNING_OUTCOMES_FIELDS:
			info[index + k] = self.Markets[marketID].winningOutcomes[k]
			k += 1
		index += WINNING_OUTCOMES_FIELDS

		# append description character codes
		info[index] = descriptionLength
		index += 1
		with description = self.getDescription(marketID, outchars=descriptionLength):
			c = 0
			while c < descriptionLength:
				info[index + c] = getch(description, c)
				c += 1
		return(info: arr)

def getMarketsInfo(branch, offset, numMarketsToLoad):
	numMarkets = self.getNumMarketsBranch(branch)
	marketIDs = self.getSomeMarketsInBranch(branch, offset, offset+numMarketsToLoad, outitems=numMarketsToLoad)
	totalLen = numMarketsToLoad*10
	m = 0
	while m < numMarketsToLoad:
		totalLen += self.getDescriptionLength(marketIDs[m])
		m += 1
	data = array(totalLen)
	m = 0
	c = 0
	totalMarkets = min(numMarketsToLoad, numMarkets)
	while m < totalMarkets:
		descriptionLength = self.getDescriptionLength(marketIDs[m])
		data[c] = marketIDs[m]
		data[c + 1] = self.Markets[marketIDs[m]].tradingPeriod
		data[c + 2] = self.Markets[marketIDs[m]].tradingFee
		data[c + 3] = self.Markets[marketIDs[m]].creationTime
		data[c + 4] = self.Markets[marketIDs[m]].volume
		data[c + 5] = self.Markets[marketIDs[m]].tag1
		data[c + 6] = self.Markets[marketIDs[m]].tag2
		data[c + 7] = self.Markets[marketIDs[m]].tag3
		data[c + 8] = self.Markets[marketIDs[m]].lastExpDate
		data[c + 9] = descriptionLength
		c += 10
		description = self.getDescription(marketIDs[m], outchars=descriptionLength)
		d = 0
		while d < descriptionLength:
			data[c] = getch(description, d)
			d += 1
			c += 1
		m += 1
	return(data: arr)

def getSender():
	return(msg.sender)
inset('refund.se')

# Keeps track of data about events in augur
# Events' index is the eventID
# so max-min/numOutcomes is interval between outcomes (useful for ui for categoricals, e.g. 1 is >50, 2 is >100, etc.)
# markets keeps track of the markets associated with an event
# threshold is the min "random" sha threshold for reporting on an event
# mode is the mode reported value for a given event [only on categorical / scalar events]
# uncaughtOutcome is the average reported value for a binary event
# ethical is the ethicality for a given event
# originalExp is original expiry date in the case an event was pushed back and the expiration date gets changed - both are in epoch time
# pushedUp states that an event was pushed forward to attempt early resolution
# rejected states that a pushed forward market's event [so one that attempted to resolve before it was expired] got rejected and shouldn't have actually been pushed forward
    # rejectedPeriod is the period such an event was pushed forward to and failed to be resolved in
# bond is the indeterminate bond that's taken away if an event is reported on as indeterminate
# forked is whether an event was the event a branch was forked over
# forkOver is whether the event that was forked over is resolved
# forkOutcome is the outcome of an event that was forked over
# forkEthicality is the ethicality of an event that was forked over
# resolutionSource is a string with the recommended source for resolving a market
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes, markets[], numMarkets, threshold, mode, uncaughtOutcome, ethical, originalExp, rejected, rejectedPeriod, bond, forked, forkOver, forkOutcome, forkEthicality, resolutionSource[], resolutionSourceLength, pushedUp)

# Keeps track of number of events created in the past 24 hours
data past24Hours[]

def getEventPushedUp(event):
    return(self.Events[event].pushedUp)
    
def setEventPushedUp(event, val):
    self.Events[event].pushedUp = val
    return(1)

def getForkOutcome(event):
    return(self.Events[event].forkOutcome)

def setForkOutcome(event, value):
    self.Events[event].forkOutcome = value
    return(1)
    
def getForkEthicality(event):
    return(self.Events[event].forkEthicality)

def setForkEthicality(event, value):
    self.Events[event].forkEthicality = value
    return(1)

def getForked(event):
    return(self.Events[event].forked)

def setForked(event):
    self.Events[event].forked = 1
    return(1)
    
def setForkDone(event):
    self.Events[event].forkOver = 1
    return(1)
    
def getForkedDone(event):
    return(self.Events[event].forkOver)

def getEventResolution(event):
    resLen = self.Events[event].resolutionSourceLength
    return(load(self.Events[event].resolutionSource[0], chars=resLen): str)

def getEventInfo(event):
    refund()
    eventinfo = array(7)
    eventinfo[0] = self.Events[event].branch
    eventinfo[1] = self.Events[event].expirationDate 
    eventinfo[2] = self.Events[event].outcome
    eventinfo[3] = self.Events[event].minValue
    eventinfo[4] = self.Events[event].maxValue
    eventinfo[5] = self.Events[event].numOutcomes
    eventinfo[6] = self.Events[event].bond
    return(eventinfo: arr)
    
def getResolution(event):
    refund()
    length=self.Events[event].resolutionSourceLength
    return(load(self.Events[event].resolutionSource[0], chars=length): str)

def getPast24(period):
    refund()
    return(self.past24Hours[period])

def addPast24(period):
    refund()
    self.past24Hours[period] += 1
    return(1)

def getEventBranch(event):
    refund()
    return(self.Events[event].branch)

def getExpiration(event):
    refund()
    return(self.Events[event].expirationDate)

def getOriginalExpiration(event):
    refund()
    return(self.Events[event].originalExp)
    
def setOriginalExpiration(event, date):
    self.Events[event].originalExp = date
    return(1)

def setExpiration(event, date):
    refund()
    self.Events[event].expirationDate = date
    return(1)

def setBranch(event, branch):
    self.Events[event].branch = branch
    return(1)

def getOutcome(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].outcome)

def getEthics(event):
    refund()
    return(self.Events[event].ethical)

def setEthics(event, ethicality):
    refund()
    self.Events[event].ethical = ethicality
    return(ethicality)

def getEthical(event):
    refund()
    return(self.Events[event].ethical)

def getMinValue(event):
    refund()
    return(self.Events[event].minValue)

def getMaxValue(event):
    refund()
    return(self.Events[event].maxValue)

def getNumOutcomes(event):
    refund()
    return(self.Events[event].numOutcomes)

def setUncaughtOutcome(event, outcome):
    refund()
    self.Events[event].uncaughtOutcome = outcome
    return(1)

def getUncaughtOutcome(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].uncaughtOutcome)

def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes, resolution: str):
    refund()
    # check that msg.sender is one of our function contracts
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    if(self.Events[ID].expirationDate==0):
        self.Events[ID].branch = branch
        self.Events[ID].expirationDate = expirationDate
        self.Events[ID].originalExp = expirationDate
        self.Events[ID].minValue = minValue
        self.Events[ID].maxValue = maxValue
        self.Events[ID].numOutcomes = numOutcomes
        save(self.Events[ID].resolutionSource[0], resolution, chars=len(resolution))
        return(1)
    else:
        return(0)

def setBond(event, bond):
    refund()
    self.Events[event].bond = bond
    return(1)

def addMarket(event, marketID):
    refund()
    self.Events[event].markets[self.Events[event].numMarkets] = marketID
    self.Events[event].numMarkets += 1
    return(1)

def getBranch(event):
    return(self.Events[event].branch)

def getBond(event):
    refund()
    return(self.Events[event].bond)

def getMarkets(event):
    refund()
    i = 0
    markets = array(self.Events[event].numMarkets)
    while i < self.Events[event].numMarkets:
        markets[i] = self.Events[event].markets[i]
        i += 1
    return(markets: arr)
    
def getMarket(event, marketIndex):
    refund()
    return(self.Events[event].markets[marketIndex])

def getNumMarkets(event):
    refund()
    return(self.Events[event].numMarkets)

def setOutcome(ID, outcome):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.Events[ID].outcome = outcome
    return(1)

def getReportingThreshold(event):
    refund()
    return(self.Events[event].threshold)
    
def setThreshold(event, threshold):
    # do whitelist
    self.Events[event].threshold = threshold
    return(1)

def getmode(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].mode)

def setmode(event, mode):
    refund()
    self.Events[event].mode = mode
    return(1)

def setRejected(event, period):
    refund()
    self.Events[event].rejected = 1
    self.Events[event].rejectedPeriod = period
    return(1)

def getRejected(event):
    refund()
    return(self.Events[event].rejected)

def getRejectedPeriod(event):
    refund()
    return(self.Events[event].rejectedPeriod)
inset('refund.se')

### Storage of all data associated with trades

# reporterID is index
data tradeCommits[](hash, block)
# tradeID is index
data trades[](id, type, market, amount, price, owner, block, outcome)

def makeTradeHash(max_value, max_amount, trade_ids: arr):
    refund()
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeInfo[2] = max_value
    tradeHash = sha3(tradeInfo, items=3)
    return(tradeHash)

def commitTrade(hash):
    refund()
    self.tradeCommits[msg.sender].hash = hash
    self.tradeCommits[msg.sender].block = block.number
    return(1)

def zeroHash():
    refund()
    self.tradeCommits[msg.sender].hash = 0
    return(1)

def checkHash(tradeHash, sender):
    refund()
    if(self.tradeCommits[sender].hash != tradeHash || block.number <= self.tradeCommits[sender].block):
        return(-1)
    else:
        return(1)
        
def getID(tradeID):
    refund()
    return(self.trades[tradeID].id)
    
def saveTrade(trade_id, type, market, amount, price, sender, outcome):
    refund()
    self.trades[trade_id].id = trade_id
    self.trades[trade_id].type = type
    self.trades[trade_id].market = market
    self.trades[trade_id].amount = amount
    self.trades[trade_id].price = price
    self.trades[trade_id].owner = sender
    self.trades[trade_id].block = block.number
    self.trades[trade_id].outcome = outcome
    return(1)

def get_trade(id):
    refund()
    trade = array(8)
    trade[0] = self.trades[id].id
    trade[1] = self.trades[id].type
    trade[2] = self.trades[id].market
    trade[3] = self.trades[id].amount
    trade[4] = self.trades[id].price
    trade[5] = self.trades[id].owner
    trade[6] = self.trades[id].block
    trade[7] = self.trades[id].outcome
    if trade:
        return(trade:arr)
    return([0]:arr)    

def get_amount(id):
    refund()
    return(self.trades[id].amount)
    
def get_price(id):
    refund()
    return(self.trades[id].price)

def update_trade(id, price):
    refund()
    self.trades[id].price = price
    self.trades[id].block = block.number

def remove_trade(id):
    refund()
    self.trades[id].id = 0
    self.trades[id].type = 0
    self.trades[id].market = 0
    self.trades[id].amount = 0
    self.trades[id].price = 0
    self.trades[id].owner = 0
    self.trades[id].block = 0
    self.trades[id].outcome = 0
    return(1)
    
def fill_trade(id, fill):
    refund()
    self.trades[trade_id].amount -= fill
    return(1)
inset('refund.se')

# address -> value map of "cash [a made up subcurrency/token for testing"
data cashcoinBalances[]

# address -> address mapping of a cash address to the address that owns it
data owners[]


# @return: cash balance of address
def balance(address):
    refund()
    return(self.cashcoinBalances[address])

# A random market could have a balance, and when that account was created/first used in the subcurrency, it'd have whatever contract that created it be the owner, so for example...
# needs to be called when making a market, branch, etc. or a new cash user acc.
def initiateOwner(account):
    refund()
    if(self.owners[account]==0 and self.cashcoinBalances[account]==0):
        self.owners[account] = msg.sender
        return(1)
    else:
        return(0)

# Send cash to a receiver from msg.sender
# should send values as fixed point in UI (1 is ONE, 4 is 4*ONE, .5 is ONEHALF, etc.)
# @return: value sent, 0 if fails
def send(recver, value):
    refund()
    if(self.owners[msg.sender]==0):
        self.owners[msg.sender] = msg.sender
    #if(self.owners[recver]==0):
    #    return(0)
    sender = msg.sender
    senderBalance = self.cashcoinBalances[sender]
    if(senderBalance >= value && value > 0):
        self.cashcoinBalances[sender] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# Sends cash from a user to a receiver
# @return value of cash sent; fail is 0
def sendFrom(recver, value, from):
    refund()
    # sendFrom would check if the sender had an owner, if it did, then it'd check and see if the msg.sender was the owner.
    # it's not owned by a regular account nor a contract owned account (i.e. a market's hash from markets.)
    if(from!=tx.origin and msg.sender!=self.owners[from] and msg.sender!=from):
        return(0)
    #if(self.owners[recver]==0):
    #    return(0)
    senderBalance = self.cashcoinBalances[from]
    if(senderBalance >= value && value > 0):
        self.cashcoinBalances[from] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# make sure only coming from specific contracts
def subtractCash(ID, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    #if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):
    #    return(0)
    self.cashcoinBalances[ID] -= amount
    return(1)

def addCash(ID, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.cashcoinBalances[ID] += amount
    return(1)

def setCash(address, balance):
    refund()
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    self.cashcoinBalances[address] = balance
    return(1)

def depositEther():
    self.cashcoinBalances[msg.sender] += msg.value * ONE / WEITOETH
    return msg.value

def withdrawEther(to, value):
    if(value < 0):
        return(-1)
    if self.cashcoinBalances[msg.sender] >= value * ONE / WEITOETH:
        self.cashcoinBalances[msg.sender] -= value * ONE / WEITOETH
        send(to, value)
        return 1
    else:
        return 0
