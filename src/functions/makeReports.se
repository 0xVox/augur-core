# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import expiringEvents as EXPEVENTS
import info as INFO
import cash as CASH
import events as EVENTS
import markets as MARKETS
import reporting as REPORTING
import fxpFunctions as FXP

data numReports[]

# a no vote is -2^64, a yes vote is 2^64 && a can't determine vote is 3*2^63 (a empty ballot is 0)
# atm voters who do vote are req. to vote on all things in their respective ballots (rest just auto .5 them)
# ui should handle this by filling in things you didn't vote on automatically & ask to be sure you didn't want to vote on them
# UI makeBallot function does this
    # ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[votePeriod].numberEvents
    # && loop through the events[] array fr2om 0 to numberEvents -1 for the votes list / order
# people could report something like 16027*2^64 for a scalar
# if people get behind on voting (e.g the redeem tx isn't called <1 period after it can be called)
    # voteperiod is an optional parameter only used in the scenario that we get behind on voting periods
    # so people will need to vote on periods that are upcoming even if our currentVotePeriod is a bit behind (e.g. if current expperiod is 7 you should vote on stuff from voteperiod 6 (and then upon period 8 you can't vote anymore))
# @return 1 if success
# Error messages otherwise
    # -1: report isn't long enough
    # -2: reporter (you) doesn't (don't) exist, or voting period over or hasn't starred yet
    # -3: hash doesn't match
    # -4: no rep
    # -5: bad report
# We should consider making the second half of the reporting period a few days or week long period every two months to allow trading more.  The reason being, you cannot trade rep after submitting your plaintext ballot and salt, so limiting this portion of the period is best for liquidity.  Since you’ve already created your ballot in the first part of the period, you can simply log in to an Augur client and it’ll auto submit your plaintext report + salt when the time comes.  
def report(branch, report:arr, votePeriod, salt):
    # make sure the branch exists
    repIndex = REPORTING.repIDToIndex(branch, tx.origin)
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.number % periodLength
    if(residual > periodLength/2):
        # submit salt and votes
        # need report length to be same as number of items in the current eventexpdates voting period events!
        if(len(report)!=EXPEVENTS.getNumberEvents(branch, votePeriod)):
            return(-1)
        if(REPORTING.getRepBalance(branch, tx.origin)==0):
            return(-4)

        realHash = EXPEVENTS.getReportHash(branch, votePeriod, tx.origin)
        hashInfo = array(len(report) + 2)
        hashInfo[0] = tx.origin
        hashInfo[1] = salt
        i = 2
        while i < (len(report) + 2):
            hashInfo[i] = report[i-2]
            i += 1
        reportHash = sha256(hashInfo, chars=32*len(hashInfo))
        if(reportHash!=realHash):
            (return(-3))

        # if currentExpPeriod is more than 2 periods past the current vote period
        # then there can be no more voting for that voting period
        # (reasoning being: >=1 period past means all the events in that period have expired)
        # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)
        # currently requires events to expire to vote
        currentExpPeriod = (block.number / periodLength)
        if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
            return(-2)

        # check report validity
        events = array(len(report))
        events = EXPEVENTS.getEvents(branch, votePeriod, outitems=len(report))
        i = 0
        numOutcomes = 2
        while i < len(report):
            numOutcomes = EVENTS.getNumOutcomes(events[i])
            maxValue = EVENTS.getMaxValue(events[i])
            # binary
            if(numOutcomes==2 and maxValue==1):
                if(report[i]>2*2^64 or report[i]<2^64 or report[i]==0):
                    return(-5)
            # categorical
            elif(numOutcomes>2):
                minValue = 2^64
                range = numOutcomes*2^64 - minValue
                if(report[i]<=0):
                    return(-5)
                if((report[i]*range/2^64 + minValue)>numOutcomes*2^64):
                    report[i] = 2^64
            # scalar
            else:
                if(report[i]==0):
                    return(-5)
                minValue = EVENTS.getMinValue(events[i])
                range = maxValue*2^64 - minValue*2^64
                if((report[i]*range/2^64 + minValue*2^64) > maxValue*2^64):
                    report[i] = 2^64
                if((report[i]*range/2^64 + minValue*2^64) < minValue*2^64):
                    # 1 == really close to 0, but not a "no report"
                    report[i] = 1
        reputation = REPORTING.getRepBalance(branch, tx.origin)
        # need to update stuff for quorem
        # && store the report && the rep value
        if(EXPEVENTS.setReporterBallot(branch, votePeriod, tx.origin, report, reputation)):
            return(1)
        else:
            return(0)

# Error -1: reporter (you) doesn't (don't) exist, or voting period over or hasn't starred yet
# Error -2: not in hash submitting timeframe
# Python code to get the hash:
    #from bitcoin import encode
    #from hashlib import sha256
    #def sha256list(xs):
    #    data = ''.join(encode(x, 256, 32) for x in xs)
    #    hashed = int(sha256(data).hexdigest(), 16)
    #    if hashed > 2**255:
    #        return hashed - 2**256
    #    else:
    #        return hashed
def submitReportHash(branch, reportHash, votePeriod):
    # make sure the branch exists
    repIndex = REPORTING.repIDToIndex(branch, tx.origin)
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.number % periodLength
    currentExpPeriod = (block.number / periodLength)
    if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
        return(-1)
    if(residual < periodLength/2):
        # submit hash of (tx.origin, salt, Votes[])
        if(EXPEVENTS.setReportHash(branch, votePeriod, tx.origin, reportHash)):
            return(1)
        else:
            return(0)
    else:
        return(-2)

#a^b=exp(b*ln(a))=e^(b*ln(a)).
#eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))
# returns num events to report on in fxp
        est = numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001)
 
        repConstant = (reporterList[n]/totalRep)**1.2+.001
        if(est < 30):
            # min. of 30 events no matter how little rep you have
            repConstant = 30/numberReportEstimate
            eventsExpected.append(30)
        else:
            eventsExpected.append(numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))

def getNumEventsToReportOn(branch, votePeriod):
    prelim = EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)
    log = FXP.fx_log(REPORTING.getRepBalance(branch, tx.origin)*2**64/REPORTING.getTotalRep(branch))
    exp = FXP.fx_exp(22136092888451461120*log/2**64)
    exp += 18446744073709552
    return(exp*prelim)

# -5: set num events to report on first
# need min num rep to report
def submitReport(branch, votePeriod, eventIndex):
    if(REPORTING.getRepBalance(branch, tx.origin)<10*2**64):
        return(0)
    if(EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)==0):
        return(-5)
    x = array(1)
    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)
    x[0] = tx.origin + eventID
    i = 0
    numMarkets = EVENTS.getNumMarkets(eventID)
    markets = array(numMarkets)
    markets = EVENTS.getMarkets(eventID, outitems=numMarkets)
    volume = 0
    while i < numMarkets:
        volume += MARKETS.getVolume(markets[i])
    totalVol = EXPEVENTS.getPeriodVolume(branch, votePeriod)
    # if odds of reporting are >1, then 2**256 (we don't want to wrap around), so div by 2**64
    log = FXP.fx_log(REPORTING.getRepBalance(branch, tx.origin)*2**64/REPORTING.getTotalRep(branch))
    repConstant = FXP.fx_exp(22136092888451461120*log/2**64)
    repConstant += 18446744073709552
    volFraction = volume*2**64/totalVol
    # in fxp (2**192) == 2**256 / 2**64
    reportingThreshold = (40*(-(267*(volFraction**2)/(2*2**64) + (533*volFraction)/2 +1)*repConstant/2**64) * (2**192)
    # need a precomputing fix add another item
    shaHash = sha3(x, items=1)
    if(shaHash < reportingThreshold || shaHash<EVENTS.getThreshold(eventID)):
        # submit report
        self.numReports[tx.origin] += 1
        # outcome should be calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        # add 1 report to the event
        #def fx_exp(x)
        #def fx_log(x)
        report();
        return(1)
    else:
        return(0)

#So you could start off with 5000 rep, never report, and you’d “have” 5000 rep up until you tried to send it or get the balance, the dentist guys going to Vienna is gone as the villain and all of a sudden, like Schrodinger’s cat, it’s gone (dead)!  People could ping the network to ding dead accounts (although they wouldn’t need to do so for any good reason).
# Basically, if you don't access the account, the rep just sort of sits there, proverbially speaking, it's burned.  If you access the account, it's sent to the branch's rep account, and distributed like trading fees are except each person would make their own lazy claim on it.  To prevent double claiming, similarly to trading fees each rep acc. that hadn't claimed rep or trading fees but reported that past period would neither be able to send nor receive rep until they claimed.  You'd get % of people that reported fees / rep
#Q: Can we do lazy eval claiming of trading fees?
#A: Yes:
#      if(addrWasInThisConsensusPeriod):
#          send them cash of amount equal to fees from that period * rep owned by addr in that period / total #rep in that period
def penalizeNotEnoughReports(branch, votePeriod):
    if(self.getNumEventsToReportOn(branch, votePeriod)/(2*2**64) > self.numReports):
        # penalize people
        newRep = .2*self.numReports / self.getNumEventsToReportOn(branch, votePeriod)/(2*2**64) * REPORTING.getRepBalance(branch, tx.origin)
        oldRep = REPORTING.getRepBalance(branch, tx.origin)*.8
        REPORTING.setRep(branch, REPORTING.repIDToIndex(branch, tx.origin), oldRep+newRep)
    else:
        # you're good!
        return(47)

def sqrt(n):
    val = n
    i = 0
    while i < 11:
        val = (val + n*2^64/val)/2
        i += 1
    return val

# for ui client side
# @return 1 if success
# Error messages otherwise
    # -1: report isn't long enough
    # -2: reporter (you) doesn't (don't) exist, or voting period over or hasn't starred yet
def checkReportValidity(branch, report:arr, votePeriod):
       if(len(report)!=EXPEVENTS.getNumberEvents(branch, votePeriod)):
        return(-1)

        # if currentExpPeriod is more than 2 periods past the current vote period
        # then there can be no more voting for that voting period
        # (reasoning being: >=1 period past means all the events in that period have expired)
        # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)
        # currently requires events to expire to vote
        currentExpPeriod = (block.number / BRANCHES.getPeriodLength(branch))
        if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
            return(-2)
        else:
            return(1)

# anti cheat provide ballot and randomNum mechanism steal deposit
def slashRep(branch, votePeriod, salt, report:arr, reporter):
        realHash = EXPEVENTS.getReportHash(branch, votePeriod, reporter)
        hashInfo = array(len(report) + 2)
        hashInfo[0] = reporter
        hashInfo[1] = salt
        i = 2
        while i < (len(report) + 2):
            hashInfo[i] = report[i]
            i += 1
        reportHash = sha256(hashInfo, chars=32*len(hashInfo))
        if(reportHash!=realHash):
            return(0)
        else:
            reporterIndex = REPORTING.repIDToIndex(branch, reporter)
            trutherIndex = REPORTING.repIDToIndex(branch, tx.origin)
            # if the truther's rep. account doesn't exist, make one
            if(REPORTING.getReporterID(branch, trutherIndex)!=tx.origin):
                trutherIndex = REPORTING.getNumberReporters(branch)
                REPORTING.addReporter(branch, tx.origin)

            if(REPORTING.getReporterID(branch, reporterIndex)!=reporter):
                return(-2)


            reporterBalance = REPORTING.getRepBalance(branch, reporter)

            REPORTING.subtractRep(branch, reporterIndex, reporterBalance)
            REPORTING.addRep(branch, trutherIndex, reporterBalance*2^58 / 2^64)
        return(reporterBalance)
