# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import expiringEvents as EXPEVENTS
import info as INFO
import cash as CASH
import events as EVENTS
import markets as MARKETS
import reporting as REPORTING
import fxpFunctions as FXP
inset('refund.se')

def makeHash(salt, report, eventID):
    hashInfo = array(4)
    hashInfo[0] = tx.origin
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha256(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# Error -1: invalid event
# Error -2: not in first half of period [commit part]
def submitReportHash(event, reportHash):
    branch = EVENTS.getBranch(event)
    votePeriod = BRANCHES.getVotePeriod(branch)
    # first report of period, num events not set
    if(EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)==0):
        EXPEVENTS.setNumEventsToReportOn(branch)
        BRANCHES.setInitialBalance(branch, votePeriod, CASH.balance(branch))
    eventIndex = EXPEVENTS.getEventIndex(votePeriod, event)
    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)
    if(eventIndex==0 && (eventID==0 || event!=eventID)):
        return(-1)
    reportingThreshold = 0
    if(EXPEVENTS.getRequired(event) || EVENTS.getReportingThreshold(event)):
        reportingThreshold = 2**192
    else:
        reportingThreshold = self.calculateReportingThreshold(branch, event, votePeriod)
    x = array(1)
    x[0] = tx.origin + event
    # div by ONE b/c is out of 2**192 rather than 2**256 [to avoid looping around]
    shaHash = sha3(x, items=1)/ONE
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual < periodLength/2 && shaHash <= reportingThreshold):
        if(EXPEVENTS.getReportHash(branch, votePeriod, tx.origin, event)==0):
            self.branches[branch].numReportsExpectedEvent[votePeriod][event] += 1
        EXPEVENTS.setReportHash(branch, votePeriod, tx.origin, reportHash, event)
        return(1)
    return(-2)

# @return 1 if success
# Error messages
    # 0: reporter doesn't exist or has <.5 rep
    # -1: has already reported
    # -2: not in second half of period [reveal part]
    # -3: hash doesn't match
    # -4: bad report
    # -6: hash not low enough
    # -8: invalid event
    # -9: already resolved
    # -10: <48 hr left in period, too late to report, able to put up readj. bonds though
def submitReport(event, salt, report, ethics):
    balance = REPORTING.getRepBalance(branch, tx.origin)
    if(balance<2**63):
        return(0)
    if(self.branches[branch].report[votePeriod][tx.origin].event[eventID]):
        return(-1)
    branch = EVENTS.getBranch(event)
    votePeriod = BRANCHES.getVotePeriod(branch)
    eventIndex = EXPEVENTS.getEventIndex(votePeriod, event)
    periodLength = BRANCHES.getPeriodLength(branch)
    # make sure event is in the given branch and vote period
    event = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)
    if(eventIndex==0 && (eventID==0 || event!=eventID)):
        return(-8)
    elif(EVENTS.getOutcome(eventID)!=0):
        return(-9)
    numMarkets = EVENTS.getNumMarkets(eventID)
    # comment out for testing
    #if(block.timestamp/BRANCHES.getPeriodLength(branch)!=((block.timestamp + 172800)/BRANCHES.getPeriodLength(branch))):
    #    return(-10)
    x = array(1)
    x[0] = tx.origin + eventID
    shaHash = sha3(x, items=1)/ONE
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        realHash = EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, eventID)
        reportHash = self.makeHash(salt, report, eventID)
        if(reportHash!=realHash || realHash==0):
            return(-3)
        report = self.validateReport(eventID, branch, votePeriod, report)
        if(report == -4):
            return(-4)
        # reporter has reported for 1 more event
        self.branches[branch].numReportsActual[tx.origin][votePeriod] += 1
        # set report value for event
        self.branches[branch].report[votePeriod][tx.origin].event[eventID] = report
        # set ethics value for event
        if(ethics!=ONE || ethics!=0):
            ethics = ONE
        if(forkedOverThisEvent):
            # fork remove ethicality option if was forked over ethicality, other ethicality choice is the ethicality
                #if so # ethics = fork ethic value
            ethics = (EVENTS.getForkEthicality(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + ethics) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)
            EVENTS.setForkEthicality(eventID, ethics)
            self.branches[branch].ethics[votePeriod][tx.origin].event[eventID] = ethics
        else:
            ethics = (EVENTS.getEthics(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + ethics) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)
            EVENTS.setEthics(eventID, ethics)
            self.branches[branch].ethics[votePeriod][tx.origin].event[eventID] = ethics
        # add 1 report to the event
        self.branches[branch].numReportsEvent[votePeriod][eventID] += 1
        # if 1st report of the period for a reporter
        if(!self.branches[branch].reportedPeriod[votePeriod][tx.origin]):
            dormantRep = REPORTING.balanceOf(branch, tx.origin)
            #Record rep at start of report period
            self.branches[branch].beforeRep[votePeriod][tx.origin] = balance
            self.branches[branch].afterRep[votePeriod][tx.origin] = balance
            self.branches[branch].periodDormantRep[period][tx.origin] = dormantRep
            self.branches[branch].reportedPeriod[votePeriod][tx.origin] = 1
        return(1)
    return(-2)

### Helper functions:
# could charge market creator for the part of this calc that only needs to be done once, first person to use gets a refund/rebate
def calculateReportingThreshold(branch, eventID, votePeriod):
    numMarkets = EVENTS.getNumMarkets(eventID)
    if(numMarkets>25):
        numMarkets = 25
    markets = array(numMarkets)
    markets = EVENTS.getMarkets(eventID, outitems=numMarkets)
    totalFees = 0
    shareValue = 0
    i = 0
    while i < numMarkets:
        # todo convert to value in w/e currency once we add subcurrencies
        shareValue += MARKETS.getSharesValue(markets[i])
        totalFees += MARKETS.getFees(markets[i])
        i += 1
    totalVal = EXPEVENTS.getShareValue(branch, votePeriod)
    logOutput = FXP.fx_log(REPORTING.getRepBalance(branch, tx.origin)*ONE/REPORTING.getActiveRep(branch))
    repConstant = FXP.fx_exp(22136092888451461120*logOutput/ONE)
    repConstant += 18446744073709552
    shareFraction = shareValue*ONE/totalVal
    numReportOn = EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)
    total = repConstant*numReportOn + EXPEVENTS.numReqEvents[branch][votePeriod]*ONE
    eventsInPeriod = EXPEVENTS.getNumberEvents(branch, expDateIndex)-EXPEVENTS.getNumRemoved(branch, votePeriod)
    minimum = min(30+EXPEVENTS.numReqEvents[branch][votePeriod], eventsInPeriod)
    if(total/ONE < minimum):
        total = minimum*ONE
    expectedEvents = repConstant * numReportOn
    numEventsAfterMinAccounting = total - EXPEVENTS.numReqEvents[branch][votePeriod]*ONE
    ratio = numEventsAfterMinAccounting * ONE / expectedEvents
    if(ratio > ONE):
        repConstant = repConstant*ratio / ONE
    numReportersOnMarket = BRANCHES.getBaseReporters(branch)*((-(267*shareFraction**2)/(2*ONE) + (533*shareFraction)/2 + 1*ONE))
    totalFeesInWei = totalFees * 10**18 / ONE
    canPayForThisManyReporters = totalFeesInWei/(3500000*tx.gasprice)
    lesser = max(canPayForThisManyReporters*ONE, numReportersOnMarket)
    reportingThreshold = lesser*repConstant*ONE
    return(reportingThreshold)

# eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))
    # a^b=exp(b*ln(a))=e^(b*ln(a)).
# returns num events to report on in fxp
def getNumEventsToReport(branch, votePeriod):
    prelim = EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)
    repConstant = REPORTING.getRepBalance(branch, tx.origin)*ONE/REPORTING.getActiveRep(branch)
    logOutput = FXP.fx_log(repConstant)
    exp = FXP.fx_exp(22136092888451461120*logOutput/ONE)
    exp += 18446744073709552
    total = exp*prelim + EXPEVENTS.numReqEvents[branch][votePeriod]*ONE
    eventsInPeriod = EXPEVENTS.getNumberEvents(branch, expDateIndex)-EXPEVENTS.getNumRemoved(branch, votePeriod)
    minimum = min(30+EXPEVENTS.numReqEvents[branch][votePeriod], eventsInPeriod)
    if(total/ONE < minimum):
        total = minimum*ONE
    return(total)

# validates and submits report
def validateReport(eventID, branch, votePeriod, report):
    # todo in case of fork remove the original outcome as a possible response
    # add a separate fork outcome and fork ethicality for where to submit report in case of fork
    # binary
    if(EVENTS.getNumOutcomes(eventID)==2 and EVENTS.getMaxValue(eventID)==2**65 && EVENTS.getMinValue(eventID)==ONE):
        if(report>2*ONE or report<ONE or report==0):
            return(-4)
        # todo weight by rep if round 2 and fork
        # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        if(forkedOverThisEvent):
            outcome = (EVENTS.getForkOutcome(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + report) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)
            EVENTS.setForkOutcome(eventID, outcome)
        else:
            outcome = (EVENTS.getUncaughtOutcome(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + report) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)
            EVENTS.setUncaughtOutcome(eventID, outcome)
    # scalar or categorical
    else:
        if(report > ONE && report!=3*2**63):
            report = ONE
        elif(report<=0):
            # 1 is the new 0
            report = 1
        # todo weight by rep in round 2 and fork
        # outcome (uncaught and mode) should be calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        self.mode_items[votePeriod][eventID].report_value[report] += 1
        if(self.mode_items[votePeriod][eventID].report_value[report] > self.mode_items[votePeriod][eventID].current_mode_items):
            self.mode_items[votePeriod][eventID].current_mode = report
            self.mode_items[votePeriod][eventID].current_mode_items = self.mode_items[votePeriod][eventID].report_value[report]
        outcome = self.mode_items[votePeriod][eventID].current_mode
        if(forkedOverThisEvent):
            EVENTS.setForkOutcome(eventID, outcome)
        else:
            EVENTS.setUncaughtOutcome(eventID, outcome)
    return(report)