# This software (Augur) allows buying and selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful, #    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import expiringEvents as EXPEVENTS
import cash as CASH
import events as EVENTS
import markets as MARKETS
import reporting as REPORTING
import backstops as BACKSTOPS
import consensusData as CONSENSUS
import collectFees as COLLECTFEES
import penalizationCatchup as CATCHUP
import reportingThreshold as THRESHOLD
inset('refund.se')
inset('eventHelpers.se')

def makeHash(salt, report, event, sender):
    hashInfo = array(4)
    hashInfo[0] = sender
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = event
    reportHash = sha3(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# Allows a user to submit the hash of their report / commit
# Error: 0: not caught up on rep redistributions/penalizations so should be done first [only 1 period behind]
# Error -1: invalid event
# Error -2: not in first half of period [commit part]
# Error -3: not able to report on this event
# Error -4: not caught up on penalizations [>1 period behind] and auto catchup failed
def submitReportHash(event, reportHash, encryptedSaltyHash):
    refund()
    branch = EVENTS.getBranch(event)
    votePeriod = BRANCHES.getVotePeriod(branch)
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    lastPeriodPenalized = CONSENSUS.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = votePeriod - 1
    delta = lastPeriod - lastPeriodPenalized
    eventIndex = EXPEVENTS.getEventIndex(branch, votePeriod, event)
    event = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)
    if(!eventIndex and (!event or event!=event)):
        return(-1)
    if(residual > periodLength/2):
        return(-2)
    if(delta > 1 and CATCHUP.penalizationCatchup(branch, msg.sender)!=1):
        return(-4)
    if(!CONSENSUS.getRepRedistributionDone(branch, msg.sender)):
        return(0)

    # if first report of period, num events not set
    if(!EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)):
        EXPEVENTS.setNumEventsToReportOn(branch)
        # set amount of fees to be distributed in this period from the branch
        BRANCHES.setInitialBalance(branch, votePeriod, CASH.balance(branch))
    reportingThreshold = 0
    # if required or threshold has been set b/c wasn't  yet
    if(EXPEVENTS.getRequired(event, votePeriod, branch) or EVENTS.getReportingThreshold(event)):
        reportingThreshold = 2**192
    # if number of reports event should have hasn't been calculated yet do it
    elif(!EXPEVENTS.getLesserReportNum(branch, votePeriod, event)):
        self.calculateReportTargetForEvent(branch, event, votePeriod, msg.sender)
        reportingThreshold = THRESHOLD.calculateReportingThreshold(branch, event, votePeriod, msg.sender)
    else:
        reportingThreshold = THRESHOLD.calculateReportingThreshold(branch, event, votePeriod, msg.sender)
    x = array(1)
    x[0] = msg.sender + event
    # do abs then mult by 2 to ensure pos. and between 0 and 1
    shaHash = sha3(x, items=1)
    shaHash = (abs(shaHash)/ONE) * 2
    # shaHash must be <= to the threshold for that user to be able to report on the given event
    if(shaHash <= reportingThreshold):
        EXPEVENTS.setReportHash(branch, votePeriod, msg.sender, reportHash, event)
        EXPEVENTS.setSaltyEncryptedHash(branch, votePeriod, msg.sender, encryptedSaltyHash, event)
        return(1)
    else:
        return(-3)

# Submits / reveals a report for a period
# @return 1 if success
# Error messages
    # 0: reporter doesn't exist or has <1 rep
    # -1: has already reported
    # -2: not in second half of period [reveal part]
    # -3: hash doesn't match
    # -4: bad report
    # -5: invalid ethics
    # -6: already resolved
    # -7: <48 hr left in period, too late to report, able to put up readj. bonds though
    # -8: fees couldn't be collected
def submitReport(event, salt, report, ethics):
    refund()
    branch = EVENTS.getBranch(event)
    balance = REPORTING.getRepBalance(branch, msg.sender)
    votePeriod = BRANCHES.getVotePeriod(branch)
    periodLength = BRANCHES.getPeriodLength(branch)
    forkedOverThisEvent = 0
    roundTwo = BACKSTOPS.getRoundTwo(event)
    weight = 1
    residual = block.timestamp % periodLength
    forkedOverEthicality = BACKSTOPS.getForkedOverEthicality(event)
    if(BRANCHES.getEventForkedOver(branch) == event):
        forkedOverThisEvent = 1
    if(roundTwo or forkedOverThisEvent):
        weight = balance
    if(balance < ONE):
        return(0)
    if(EXPEVENTS.getReport(branch, votePeriod, event, msg.sender)):
        return(-1)
    if(residual <= periodLength/2):
        return(-2)
    realHash = EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, event)
    if(self.makeHash(salt, report, event, msg.sender)!=realHash or !realHash):
        return(-3)
    if(ethics!=ONE and ethics!=0):
        return(-5)
    # todo get outcome may not work / be valid
    elif(EVENTS.getOutcome(event)!=0):
        return(-6)
    # commented out for easy testing
    #if(block.timestamp/periodLength!=((block.timestamp + 2*TWENTYFOURHR)/periodLength)):
    #    return(-7)
    # ensures user has collected fees for last reporting period
    if(!CONSENSUS.getFeesCollected(branch, msg.sender, votePeriod-1)):
        if(COLLECTFEES.collectFees(branch, msg.sender, value=msg.value)<0):
            return(-8)

    # actual submitting of report and ethicality
    report = self.validateReport(event, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, weight)
    if(report == -4):
        return(-4)
    EXPEVENTS.setReport(branch, votePeriod, event, report, msg.sender)
    # set ethicality for forked event
    if(forkedOverThisEvent):
        # fork remove ethicality option if was forked over ethicality, other ethicality choice is the ethicality
        if(forkedOverEthicality):
            oldEthical = ethic_catch(EVENTS.getEthics(event))
            if(oldEthical == ONE):
                ethics = 0
            else:
                ethics = ONE
        EXPEVENTS.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
        ethics = (EVENTS.getForkEthicality(event)*EXPEVENTS.getEventWeight(branch, votePeriod, event) + ethics*weight) / (EXPEVENTS.getEventWeight(branch, votePeriod, event) + weight)
        EVENTS.setForkEthicality(event, ethics)
    # set ethicality for a regular event
    else:
        EXPEVENTS.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
        ethics = (EVENTS.getEthics(event)*EXPEVENTS.getEventWeight(branch, votePeriod, event) + ethics*weight) / (EXPEVENTS.getEventWeight(branch, votePeriod, event) + weight)
        EVENTS.setEthics(event, ethics)
    # round 2 and fork events are weighted by rep, otherwise 1
    EXPEVENTS.countReportAsSubmitted(branch, votePeriod, event, msg.sender, weight)

    # pay reporters after reporting for their gas costs
    reportsNum = EXPEVENTS.getLesserReportNum(branch, votePeriod, event)
    paidBack = EVENTS.getReportersPaidSoFar(event)
    diff = reportsNum - paidBack
    if(diff >= 1):
        EVENTS.addReportersPaidSoFar(event)
        CASH.subtractCash(branch, 3500000*tx.gasprice*ONE / WEITOETH)
        CASH.addCash(msg.sender, 3500000*tx.gasprice*ONE / WEITOETH)
    return(1)

# validates and submits report
# weights reports by rep if round 2 and fork
# Returns -4 if report is invalid
    # isn't between 1 and 2 if binary
    # if same report as original outcome / ethicality if a forked event not forked over ethicality it's also invalid b/c this option was removed as a poss. answer
def validateReport(event, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, weight):
    outcome = 0
    # binary
    if(EVENTS.getNumOutcomes(event)==2 and EVENTS.getMaxValue(event)==TWO and EVENTS.getMinValue(event)==ONE):
        if(report>2*ONE or report<ONE or !report):
            return(-4)
        # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        elif(forkedOverThisEvent):
            # in case of fork remove the original outcome as a possible response if forked over outcome [i.e. didn't fork over ethics]
            if(!forkedOverEthicality and report == catch(EVENTS.getUncaughtOutcome(event))):
                return(-4)
            outcome = (EVENTS.getForkOutcome(event)*EXPEVENTS.getEventWeight(branch, votePeriod, event) + report*weight) / (EXPEVENTS.getEventWeight(branch, votePeriod, event) + weight)
            EVENTS.setForkOutcome(event, outcome)
        else:
            outcome = (EVENTS.getUncaughtOutcome(event)*EXPEVENTS.getEventWeight(branch, votePeriod, event) + report*weight) / (EXPEVENTS.getEventWeight(branch, votePeriod, event) + weight)
            EVENTS.setUncaughtOutcome(event, outcome)
    # scalar or categorical
    else:
        if(report > ONE):
            report = ONE
        elif(report <= 0):
            # 1 is the new 0 [1/2**64 is basically 0 but able to be differentiated from no report of 0]
            report = 1
        # in case of fork remove the original outcome as a possible response if didn't fork over ethics
        if(forkedOverThisEvent and (!forkedOverEthicality and report == EVENTS.getUncaughtOutcome(event))):
            return(-4)
        # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        # adding weight to a given poss. mode report
        EXPEVENTS.addToWeightOfReport(votePeriod, event, report, weight)
        if(EXPEVENTS.getWeightOfReport(votePeriod, event, report) > EXPEVENTS.getCurrentModeItems(votePeriod, event)):
            EXPEVENTS.setCurrentMode(votePeriod, event, report)
            EXPEVENTS.setCurrentModeItems(votePeriod, event, report)
        outcome = EXPEVENTS.getCurrentMode(votePeriod, event)
        if(forkedOverThisEvent):
            EVENTS.setForkOutcome(event, outcome)
        else:
            EVENTS.setUncaughtOutcome(event, outcome)
    return(report)

### Helper functions:
# calculates how many reports should be on a given event
# todo make sure max cost is actually 500k gas here
def calculateReportTargetForEvent(branch, event, votePeriod, sender):
    numMarkets = EVENTS.getNumMarkets(event)
    if(numMarkets>20):
        numMarkets = 20
    markets = array(numMarkets)
    markets = EVENTS.getMarkets(event, outitems=numMarkets)
    totalFees = 0
    shareValue = 0
    i = 0
    while i < numMarkets:
        shareValue += MARKETS.getSharesValue(markets[i])
        totalFees += MARKETS.getFees(markets[i])
        i += 1
    totalVal = EXPEVENTS.getShareValue(branch, votePeriod)
    shareFraction = shareValue*ONE/totalVal
    numReportersOnMarket = BRANCHES.getBaseReporters(branch)*((-(267*shareFraction**2)/(2*ONE) + (533*shareFraction)/2 + 1*ONE))
    totalFeesInWei = totalFees * WEITOETH / ONE
    canPayForThisManyReporters = totalFeesInWei/(3500000*tx.gasprice)
    lesser = min(canPayForThisManyReporters*ONE, numReportersOnMarket)
    if(!EXPEVENTS.getLesserReportNum(branch, votePeriod, event)):
        EXPEVENTS.refundCost(sender, branch, votePeriod, event)
        EXPEVENTS.setLesserReportNum(branch, votePeriod, event, lesser)
    return(lesser)
