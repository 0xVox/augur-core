# This software (Augur) allows buying and selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful, #    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

macro Controller: 0xC001D00D
extern Controller: [lookup:[int256]:int256, checkWhitelist:[int256]:int256]

BRANCHES = Controller.lookup('branches')
extern branches: [addCurrency:[int256,int256,int256,int256]:int256, addMarketToBranch:[int256,int256]:int256, disableCurrency:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getBranchesStartingAt:[int256]:int256[], getCreationDate:[int256]:int256, getBranchCurrency:[int256,int256]:int256, getCurrencyActive:[int256,int256]:int256, getCurrencyByContract:[int256,int256]:int256, getCurrencyRate:[int256,int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getForkTime:[int256]:int256, getInitialBalance:[int256,int256,int256]:int256, getMarketIDsInBranch:[int256,int256,int256]:int256[], getMinTradingFee:[int256]:int256, getMostRecentChild:[int256]:int256, getNumBranches:[]:int256, getNumCurrencies:[int256]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, getBranchWallet:[int256,int256]:int256, incrementPeriod:[int256]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256,int256,int256,int256]:int256, reactivateCurrency:[int256,int256]:int256, removeLastCurrency:[int256]:int256, replaceCurrency:[int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256,int256]:int256, setMostRecentChild:[int256,int256]:int256, updateCurrencyRate:[int256,int256,int256,int256]:int256, updateNumCurrencies:[int256,int256]:_]

EXPEVENTS = Controller.lookup('expiringEvents')
extern expiringEvents: [addEvent:[int256,int256,int256,int256,int256,int256,int256]:int256, addReportToReportsSubmitted:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodFeeValue:[int256,int256,int256]:int256, countReportAsSubmitted:[int256,int256,int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getActiveReporters:[int256,int256,int256,int256]:int256[], getAfterFork:[int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256,int256]:int256, getEventWeight:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getFeeValue:[int256,int256]:int256, getLesserReportNum:[int256,int256,int256]:int256, getNumActiveReporters:[int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsSubmitted:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepWeight:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportsCommitted:[int256,int256,int256]:int256, getRequired:[int256,int256,int256]:int256, getSaltyEncryptedHash:[int256,int256,int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setEventWeight:[int256,int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepWeight:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setSaltyEncryptedHash:[int256,int256,int256,int256,int256]:int256]

EVENTS = Controller.lookup('events')
extern events: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, addReportersPaidSoFar:[int256]:int256, getBond:[int256]:int256, getChallenged:[int256]:int256, getCreationTime:[int256]:int256, getEarlyResolutionBond:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventPushedUp:[int256]:int256, getEventResolution:[int256]:bytes, getExpiration:[int256]:int256, getExtraBond:[int256]:int256, getFirstPreliminaryOutcome:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForkResolveAddress:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getMode:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportersPaidSoFar:[int256]:int256, getReportingThreshold:[int256]:int256, getResolutionAddress:[int256]:int256, getResolutionLength:[int256]:int256, getResolveBondPoster:[int256]:int256, getUncaughtOutcome:[int256]:int256, getEventInfo:[int256]:int256[], initializeEvent:[int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setChallenged:[int256]:int256, setCreationTime:[int256]:int256, setEarlyResolutionBond:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setExtraBond:[int256,int256]:int256, setFirstPreliminaryOutcome:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setMode:[int256,int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256]

MARKETS = Controller.lookup('markets')
extern markets: [addFees:[int256,int256]:int256, addOrder:[int256,int256]:int256, addToMarketsHash:[int256,int256]:int256, getBondsMan:[int256]:int256, getBranch:[int256]:int256, getCumulativeScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getGasSubsidy:[int256]:int256, getLastExpDate:[int256]:int256, getLastOrder:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketShareContracts:[int256]:int256[], getMarketsHash:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOrderIDs:[int256]:int256[], getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPrevID:[int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalOrders:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256,int256[]]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, removeOrderFromMarket:[int256,int256]:int256, returnTags:[int256]:int256[], setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]

REPORTING = Controller.lookup('reporting')
extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOfReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, claimInitialRep:[]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReportedOnNonFinalRoundTwoEvent:[int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256]:int256, setRep:[int256,int256,int256]:int256, setReportedOnNonFinalRoundTwoEvent:[int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]

BACKSTOPS = Controller.lookup('backstops')
extern backstops: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getDisputedOverEthics:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setDisputedOverEthics:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256]

INFO = Controller.lookup('info')
extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getCurrency:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, getWallet:[int256]:int256, setCurrencyAndWallet:[int256,int256,int256]:int256, setInfo:[int256,bytes,int256,int256,int256,int256]:int256]

CONSENSUS = Controller.lookup('consensusData')
extern consensusData: [decreaseDenominator:[int256,int256,int256]:int256, doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepCollected:[int256,int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:int256, setRefund:[int256,int256]:int256, setRepCollected:[int256,int256,int256]:int256, setSlashed:[int256,int256,int256]:int256]

COLLECTFEES = Controller.lookup('collectFees')
extern collectFees: [collectFees:[int256,int256,int256]:int256, collectRep:[int256,int256]:int256]

CATCHUP = Controller.lookup('penalizationCatchup')
extern penalizationCatchup: [penalizationCatchup:[int256,int256]:int256]

THRESHOLD = Controller.lookup('reportingThreshold')
extern reportingThreshold: [calculateNumberOfEventsAReporterHasToReportOnAtMinimum:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, findLazyReportersAndLeechers:[int256,int256,int256,int256,int256,int256]:int256[], getEventCanReportOn:[int256,int256,int256,int256]:int256, getEventsToReportOn:[int256,int256,int256,int256,int256]:int256[], setReportingThreshold:[int256]:int256]

MUTEX = Controller.lookup('mutex')
extern mutex: [getMutex:[]:int256, setMutex:[]:int256, unsetMutex:[]:int256]


### Deals with the reporting process but not consensus / redistribution

extern subcurrency: [allowance:[uint256,uint256]:uint256, approve:[uint256,uint256]:uint256, balance:[]:uint256, balanceOf:[uint256]:uint256, transfer:[uint256,uint256]:uint256, transferFrom:[uint256,uint256,uint256]:uint256]

inset('../data_api/refund.se')
inset('eventHelpers.se')
inset('../data_api/periodStage.se')
inset('logReturn.se')
inset('../data_api/float.se')

event makeReportsLogReturn(returnValue)

macro GAS_SUBSIDY: 3500000
macro MAX_REPORT_THRESHOLD: 10^54
# used for gas limit reasons to ensure terminating loop
macro MARKETS_COUNTING_TOWARDS_SHARE_VALUE: 20

def makeHash(salt, fxpReport, event, sender, ethics):
    hashInfo = array(5)
    hashInfo[0] = sender
    hashInfo[1] = salt
    hashInfo[2] = fxpReport
    hashInfo[3] = event
    hashInfo[4] = ethics
    reportHash = sha3(hashInfo, chars = 32 * len(hashInfo))
    return(reportHash)

# Allows a user to submit the hash of their fxpReport / commit
# Error: 0: not caught up on rep redistributions/penalizations so should be done first [only 1 period behind] - if reported last period and called collectfees then call the penalization functions in consensus, if didn't report last period or didn't call collectfees last period then call penalizationCatchup
# Error -1: invalid event
# Error -2: not in first half of period [commit part]
# Error -3: not able to fxpReport on this event
# Error -4: not caught up on penalizations [>1 period behind] and auto catchup failed
def submitReportHash(event, reportHash, saltyEncryptedHash):
    refund()
    if(MUTEX.getMutex()):
        throw()
    MUTEX.setMutex()
    branch = EVENTS.getBranch(event)
    votePeriod = BRANCHES.getVotePeriod(branch)
    periodLength = BRANCHES.getPeriodLength(branch)
    lastPeriodPenalized = CONSENSUS.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = votePeriod - 1
    delta = lastPeriod - lastPeriodPenalized
    eventIndex = EXPEVENTS.getEventIndex(branch, votePeriod, event)
    event = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)
    checkSubmitReportHashPreconditions()

    reportingThresholdForUser = calculateReportingThreshold()
    # do abs then mult by 2 to ensure pos. and between 0 and 1
    hash = sha3([msg.sender, event], items = 2)
    shaHash = (abs(hash) / ONE) * 2
    # max value 10^54
    shaHash = shaHash / 57896044618658097711785L * ONE
    # shaHash must be <= to the threshold for that user to be able to fxpReport on the given event
    if(shaHash > reportingThresholdForUser):
        MUTEX.unsetMutex()
        logReturn(makeReportsLogReturn, -3)
    EXPEVENTS.setReportHash(branch, votePeriod, msg.sender, reportHash, event)
    EXPEVENTS.setSaltyEncryptedHash(branch, votePeriod, msg.sender, saltyEncryptedHash, event)
    MUTEX.unsetMutex()
    logReturn(makeReportsLogReturn, 1)

# Submits / reveals a fxpReport for a period
# @return 1 if success
# Error messages
    # 0: reporter doesn't exist or has <1 rep
    # -1: has already reported
    # -2: not in second half of period
    # -3: hash doesn't match
    # -4: bad fxpReport
    # -5: invalid fxpEthics
    # -6: already resolved
    # -7: <48 hr left in period, too late to fxpReport, able to put up readj. bonds though
    # -8: fees couldn't be collected
def submitReport(event, salt, fxpReport, fxpEthics):
    refund()
    if(MUTEX.getMutex()):
        throw()
    MUTEX.setMutex()

    branch = EVENTS.getBranch(event)
    balance = REPORTING.getRepBalance(branch, msg.sender)
    votePeriod = BRANCHES.getVotePeriod(branch)
    periodLength = BRANCHES.getPeriodLength(branch)
    forkedOverThisEvent = 0
    roundTwo = BACKSTOPS.getRoundTwo(event)
    weight = 1
    forkedOverEthicality = BACKSTOPS.getForkedOverEthicality(event)
    checkSubmitReportPreconditions()

    saveUsersReportAndHandleEthicality()
    coverGasCostIfPossible()
    MUTEX.unsetMutex()
    logReturn(makeReportsLogReturn, 1)

# validates and submits fxpReport
# weights reports by rep if round 2 and fork
# Returns -4 if fxpReport is invalid
    # isn't between 1 and 2 if binary
    # if same fxpReport as original outcome / ethicality if a forked event not forked over ethicality it's also invalid b/c this option was removed as a poss. answer
# needs whitelist
def validateReport(event, branch, votePeriod, fxpReport, forkedOverEthicality, forkedOverThisEvent, weight):
    outcome = 0
    # binary
    binary = EVENTS.getNumOutcomes(event) == 2 and EVENTS.getMaxValue(event) == TWO and EVENTS.getMinValue(event) == ONE
    if(binary):
        validateReportAndUpdateBinaryEvent()
    # scalar or categorical
    else:
        validateReportAndUpdateScalarOrCategoricalEvent()
    return(fxpReport)

### Helper functions:
# calculates how many reports should be on a given event
# whitelist
# @return fxp
def calculateReportTargetForEvent(branch, event, votePeriod, sender):
    numMarkets = EVENTS.getNumMarkets(event)
    # todo we should prob switch this to when we send fees don't add to a market but rather the event associated w/ the market, then assign reporters based on fees on event / total fees for all events, this'll save cost and be more appropriate for what we actually want and maybe move this fun to threshold
    if(numMarkets > MARKETS_COUNTING_TOWARDS_SHARE_VALUE):
        numMarkets = MAREKTS_COUNTING_TOWARDS_SHARE_VALUE
    markets = array(numMarkets)
    markets = EVENTS.getMarkets(event, outitems=numMarkets)
    totalFeesInWei = 0
    shareValue = 0
    i = 0
    while(i < numMarkets):
        totalFeesInWei += MARKETS.getFees(markets[i])
        i += 1
    allFeesForAllMarkets = EXPEVENTS.getFeeValue(branch, votePeriod)
    feeFraction = safeFxpDiv(totalFeesInWei, allFeesForAllMarkets)
    numReportersOnMarket = BRANCHES.getBaseReporters(branch) * (safeMul(-267, safeFxpMul(feeFraction, feeFraction))/2 + safeMul(533, feeFraction)/2 + ONE)
    canPayForThisManyReporters = totalFeesInWei / (GAS_SUBSIDY * tx.gasprice)
    lesser = min(canPayForThisManyReporters * ONE, numReportersOnMarket)
    if(!EXPEVENTS.getLesserReportNum(branch, votePeriod, event)):
        EXPEVENTS.refundCost(sender, branch, votePeriod, event)
        EXPEVENTS.setLesserReportNum(branch, votePeriod, event, lesser)
    return(lesser)

macro checkSubmitReportHashPreconditions():
    if(!eventIndex and (!event or event != event)):
        MUTEX.unsetMutex()
        logReturn(makeReportsLogReturn, -1)
    atFirstHalfOfPeriod()
    if(delta > 1 and CATCHUP.penalizationCatchup(branch, msg.sender) != 1):
        MUTEX.unsetMutex()
        logReturn(makeReportsLogReturn, -4)
    if(!CONSENSUS.getRepRedistributionDone(branch, msg.sender)):
        MUTEX.unsetMutex()
        logReturn(makeReportsLogReturn, 0)
    # if first fxpReport of period, num events not set
    if(!EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)):
        EXPEVENTS.setNumEventsToReportOn(branch)

macro checkSubmitReportPreconditions():
    if(BRANCHES.getEventForkedOver(BRANCHES.getParent(branch)) == event):
        forkedOverThisEvent = 1
    if(roundTwo or forkedOverThisEvent):
        weight = balance
    if(balance < ONE):
        MUTEX.unsetMutex()
        logReturn(makeReportsLogReturn, 0)
    if(EXPEVENTS.getReport(branch, votePeriod, event, msg.sender)):
        MUTEX.unsetMutex()
        logReturn(makeReportsLogReturn, -1)
    atSecondHalfOfPeriod()
    realHash = EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, event)
    if(self.makeHash(salt, fxpReport, event, msg.sender, fxpEthics) != realHash or !realHash):
        MUTEX.unsetMutex()
        logReturn(makeReportsLogReturn, -3)
    if(fxpEthics != ONE and fxpEthics != 0):
        MUTEX.unsetMutex()
        logReturn(makeReportsLogReturn, -5)
    if(EVENTS.getOutcome(event) != 0):
        MUTEX.unsetMutex()
        logReturn(makeReportsLogReturn, -6)
    # commented out for easy testing
    # if(block.timestamp / periodLength != ((block.timestamp + 2 * TWENTY_FOUR_HR) / periodLength)):
    #    logReturn(makeReportsLogReturn, -7)
    # ensures user has collected fees for last reporting period
    if(!CONSENSUS.getRepCollected(branch, msg.sender, votePeriod - 1)):
        if(COLLECTFEES.collectRep(branch, msg.sender, value = msg.value) < 0):
            MUTEX.unsetMutex()
            logReturn(makeReportsLogReturn, -8)
    # actual submitting of fxpReport and ethicality
    validatedFxpReport = self.validateReport(event, branch, votePeriod, fxpReport, forkedOverEthicality, forkedOverThisEvent, weight)
    if(validatedFxpReport == -4):
        MUTEX.unsetMutex()
        logReturn(makeReportsLogReturn, -4)

macro saveUsersReportAndHandleEthicality():
    EXPEVENTS.setReport(branch, votePeriod, event, validatedFxpReport, msg.sender)
    # set ethicality for forked event
    validatedFxpEthics = fxpEthics
    if(forkedOverThisEvent):
        # fork remove ethicality option if was forked over ethicality, other ethicality choice is the ethicality
        if(forkedOverEthicality):
            oldEthical = ethicCatch(EVENTS.getEthics(event))
            if(oldEthical == ONE):
                validatedFxpEthics = 0
            else:
                validatedFxpEthics = ONE
        EXPEVENTS.setEthicReport(branch, votePeriod, event, validatedFxpEthics, msg.sender)
        eventEthics = safeDiv(safeAdd(safeMul(EVENTS.getForkEthicality(event), EXPEVENTS.getEventWeight(branch, votePeriod, event)), safeMul(validatedFxpEthics, weight)), safeAdd(EXPEVENTS.getEventWeight(branch, votePeriod, event), weight))
        EVENTS.setForkEthicality(event, eventEthics)
    # set ethicality for a regular event
    else:
        EXPEVENTS.setEthicReport(branch, votePeriod, event, validatedFxpEthics, msg.sender)
        eventEthics = safeDiv(safeAdd(safeMul(EVENTS.getEthics(event), EXPEVENTS.getEventWeight(branch, votePeriod, event)), safeMul(validatedFxpEthics, weight)), safeAdd(EXPEVENTS.getEventWeight(branch, votePeriod, event), weight))
        EVENTS.setEthics(event, eventEthics)
    # round 2 and fork events are weighted by rep, otherwise 1
    EXPEVENTS.countReportAsSubmitted(branch, votePeriod, event, msg.sender, weight)

macro coverGasCostIfPossible():
    # pay reporters after reporting for their gas costs
    reportsNum = EXPEVENTS.getLesserReportNum(branch, votePeriod, event)
    paidBack = EVENTS.getReportersPaidSoFar(event)
    ableToPayForMore = reportsNum - paidBack
    if(ableToPayForMore):
        EVENTS.addReportersPaidSoFar(event)
        gasCostInWei = safeFxpDiv(GAS_SUBSIDY*tx.gasprice, WEI_TO_ETH)
        gasCostInSubcurrency = safeFxpDiv(gasCostInWei, BRANCHES.getCurrencyRate(branch, INFO.getCurrency(market)))
        INFO.getWallet(market).transfer(msg.sender, gasCostInSubcurrency)

macro calculateReportingThreshold():
    threshold = 0
    if(eventCreatedPriorToFork(event)):
        threshold = 0
    elif(EXPEVENTS.getRequired(event, votePeriod, branch) or EVENTS.getReportingThreshold(event)):
        threshold = MAX_REPORT_THRESHOLD
    # if number of reports event should have hasn't been calculated yet do it
    elif(!EXPEVENTS.getLesserReportNum(branch, votePeriod, event)):
        self.calculateReportTargetForEvent(branch, event, votePeriod, msg.sender)
        threshold = THRESHOLD.calculateReportingThreshold(branch, event, votePeriod, msg.sender)
    else:
        threshold = THRESHOLD.calculateReportingThreshold(branch, event, votePeriod, msg.sender)
    threshold

macro validateReportAndUpdateBinaryEvent():
    if(fxpReport > 2 * ONE or fxpReport < ONE or !fxpReport):
        logReturn(makeReportsLogReturn, -4)
    # outcome is calculated as we go along on a fxpReport by fxpReport basis (i.e. lazily evaluating things)
    elif(forkedOverThisEvent):
        # in case of fork remove the original outcome as a possible response if forked over outcome [i.e. didn't fork over fxpEthics]
        if(!forkedOverEthicality and fxpReport == catch(EVENTS.getUncaughtOutcome(event))):
            logReturn(makeReportsLogReturn, -4)
        outcome = safeDiv(safeAdd(safeMul(EVENTS.getForkOutcome(event), EXPEVENTS.getEventWeight(branch, votePeriod, event)), safeMul(fxpReport, weight)), safeAdd(EXPEVENTS.getEventWeight(branch, votePeriod, event), weight))
        EVENTS.setForkOutcome(event, outcome)
    else:
        outcome = safeDiv(safeAdd(safeMul(EVENTS.getUncaughtOutcome(event), EXPEVENTS.getEventWeight(branch, votePeriod, event)), safeMul(fxpReport, weight)), safeAdd(EXPEVENTS.getEventWeight(branch, votePeriod, event), weight))
        EVENTS.setUncaughtOutcome(event, outcome)

macro validateReportAndUpdateScalarOrCategoricalEvent():
    if(fxpReport > ONE):
        fxpReport = ONE
    if(fxpReport <= 0):
        # 1 is the new 0 [1/10**18 is basically 0 but able to be differentiated from no fxpReport of 0]
        fxpReport = 1
    # in case of fork remove the original outcome as a possible response if didn't fork over fxpEthics
    reportIsSameAsOutcomeOnOriginalBranch = fxpReport == EVENTS.getUncaughtOutcome(event)
    if(forkedOverThisEvent and (!forkedOverEthicality and reportIsSameAsOutcomeOnOriginalBranch)):
        logReturn(makeReportsLogReturn, -4)
    # outcome (uncaught and mode) is calculated as we go along on a fxpReport by fxpReport basis (i.e. lazily evaluating things)
    # adding weight to a given poss. mode fxpReport
    EXPEVENTS.addToWeightOfReport(votePeriod, event, fxpReport, weight)
    if(EXPEVENTS.getWeightOfReport(votePeriod, event, fxpReport) > EXPEVENTS.getCurrentModeItems(votePeriod, event)):
        EXPEVENTS.setCurrentMode(votePeriod, event, fxpReport)
        EXPEVENTS.setCurrentModeItems(votePeriod, event, fxpReport)
    outcome = EXPEVENTS.getCurrentMode(votePeriod, event)
    if(forkedOverThisEvent):
        EVENTS.setForkOutcome(event, outcome)
    else:
        EVENTS.setUncaughtOutcome(event, outcome)
