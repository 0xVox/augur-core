# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import expiringEvents as EXPEVENTS
import info as INFO
import cash as CASH
import events as EVENTS
import markets as MARKETS
import reporting as REPORTING
import fxpFunctions as FXP

# branches: votePeriod, reporterID (for both num hash submitted and num actual reports submitted) --- votePeriod, EventID --- eventID
data branches[](submittedHash[][], hasCommitted[][], commitIndex[][], numReportsHash[][], numReportsActual[][], numReportsEvent[][], numReportsExpectedEvent[][], hasReported[][](reported[]), repReported[], reportedPeriod[][], beforeRep[][], afterRep[][], report[][](event[]), dormantRep[][])

data reportable[][]

data requiredEvents[]

# branch, period as params
data numReqEvents[][]

def getReportable(votePeriod, eventID):
  return(self.reportable[votePeriod][eventID])

def setReportable(votePeriod, eventID):
  self.reportable[votePeriod][eventID] = 1
  return(1)

# Return 0 means already required
def setEventRequired(branch, period, event):
  if(self.requiredEvents[event]==0):
    self.requiredEvents[event] = 1
    self.numReqEvents[branch][period] += 1
    return(1)
  else:
    return(0)

def getNumReportsExpectedEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsExpectedEvent[votePeriod][eventID])

def getNumReportsEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsEvent[votePeriod][eventID])

def setNumReportsExpectedEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] = num
    return(1)

def setNumReportsEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsEvent[votePeriod][eventID] = num
    return(1)

def getReport(branch, period, event):
    return(self.branches[branch].report[period][tx.origin].event[event])

def getBeforeRep(branch,period):
    return(self.branches[branch].beforeRep[period][tx.origin])

def getAfterRep(branch, period):
    return(self.branches[branch].afterRep[period][tx.origin])

def setBeforeRep(branch, period, rep):
    self.branches[branch].beforeRep[period][tx.origin] = rep
    return(rep)

def setAfterRep(branch, period, rep):
    self.branches[branch].afterRep[period][tx.origin] = rep
    return(rep)

def getDormantRep(branch, period):
    return(self.branches[branch].dormantRep[period][tx.origin])

def getSubmittedHash(branch, period, reporter):
    return(self.branches[branch].submittedHash[period][reporter])

# Error -1: reporter (you) doesn't (don't) exist, or voting period over or hasn't started yet
# Error -2: not in hash submitting timeframe
# Error -3: not a valid event expiring then
# Error -4: already resolved
# Error -5: .99 market
# Python code to get the hash:
    #from bitcoin import encode
    #from hashlib import sha256
    #def sha256list(xs):
    #    data = ''.join(encode(x, 256, 32) for x in xs)
    #    hashed = int(sha256(data).hexdigest(), 16)
    #    if hashed > 2**255:
    #        return hashed - 2**256
    #    else:
    #        return hashed
def submitReportHash(branch, reportHash, votePeriod, eventID, eventIndex):
    reportIndex = self.branches[branch].numReportsHash[msg.sender][votePeriod]
    if(self.reportable[votePeriod][eventID]==-1):
        return(-5)
    # Whoever the first person to try to submit a report for period x on market y with events events checks if it needs to be reported on or not.
    if(self.reportable[votePeriod][eventID]==0):
        needsReportingOn = self.needsReportingOn(eventID)
        # If not, then no one can report on this market's event(s) and the event is "removed" from expEvents.
        # if yes, the value is 1 and everything proceeds normally
        self.reportable[votePeriod][eventID] = needsReportingOn
        if(needsReportingOn==-1):
            EXPEVENTS.removeEvent(branch, votePeriod)

    if(EVENTS.getOutcome(eventID)!=0):
        return(-4)
    # make sure event is in the given branch...
    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)
    if(eventID==0):
        return(-2)
    if(BRANCHES.getVotePeriod(branch)!=votePeriod):
        return(-1)
    # if updating commitment, use old commitment index
    if(self.branches[branch].hasCommitted[msg.sender][eventID]):
        reportIndex = self.branches[branch].commitIndex[msg.sender][eventID]
    # make sure the branch exists
    repIndex = REPORTING.repIDToIndex(branch, tx.origin)
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.number % periodLength
    currentExpPeriod = (block.number / periodLength)
    # if first report commitment this period
    if(self.branches[branch].submittedHash[period][msg.sender]==0):
      self.branches[branch].submittedHash[period][msg.sender] = 1
    if(REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
        return(-1)
    if(residual < periodLength/2):
        # submit hash of (tx.origin, salt, Votes[])
        if(EXPEVENTS.setReportHash(branch, votePeriod, tx.origin, reportHash, reportIndex)):
            # if so, don't want to increment num reports expected or numreportshash per reporter for updated commitment, just the first time
            if(self.branches[branch].hasCommitted[msg.sender][eventID]==0):
                self.branches[branch].numReportsHash[msg.sender][votePeriod] += 1
                self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] += 1
                self.branches[branch].commitIndex[msg.sender][eventID] = reportIndex
                self.branches[branch].hasCommitted[msg.sender][eventID] = 1
            return(1)
        else:
            return(0)
    else:
        return(-2)

def needsReportingOn(event):
# This only works for categorical and binary markets, not scalar
  if(eventIsScalar):
    return(1)
  # To determine whether a market needs to be resolved or not, the events can only have one market associated with them or all markets associated with the event fulfill the .99 qualification.
  numMarkets = EVENTS.getNumMarkets(event)
  markets = array(numMarkets)
  markets = EVENTS.getMarkets(event, outitems=numMarkets)
  if(numMarkets>100):
    return(1)
  i = 0
  while i < numMarkets:
    numOutcomes = MARKETS.getMarketNumOutcomes(markets[i])
    n = 0
    ninetynine = 0
    while n < numOutcomes:
      if(MARKETS.getSimulatedBuy(markets[i], n, 2**64) > 18262276632972456099):
        ninetynine = 1
        n = numOutcomes
      n += 1
    if(ninetynine == 0):
      return(1)
    i += 1
  # doesn't need reporting on, meets the .99 qualification
  return(-1)


#a^b=exp(b*ln(a))=e^(b*ln(a)).
#eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))
# returns num events to report on in fxp
def getNumEventsToReportOn(branch, votePeriod):
    prelim = EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)
    repConstant = REPORTING.getRepBalance(branch, msg.sender)*2**64/REPORTING.getTotalRep(branch)
    log = FXP.fx_log(repConstant)
    exp = FXP.fx_exp(22136092888451461120*log/2**64)
    exp += 18446744073709552
    return(exp*prelim + self.numReqEvents[branch][votePeriod]*2**64)

# a no vote is -2^64, a yes vote is 2^64 && a can't determine vote is 3*2^63
# -5: set num events to report on first
# need min num rep to report
# if people get behind on voting (e.g the redeem tx isn't called <1 period after it can be called)
    # voteperiod is an optional parameter only used in the scenario that we get behind on voting periods
    # so people will need to vote on periods that are upcoming even if our currentVotePeriod is a bit behind (e.g. if current expperiod is 7 you should vote on stuff from voteperiod 6 (and then upon period 8 you can't vote anymore))
# @return 1 if success
# Error messages otherwise
    # -1: has already reported
    # -2: reporter (you) doesn't (don't) exist, or voting period over or hasn't started yet
    # -3: hash doesn't match
    # -4: no rep
    # -5: bad report
    # -6: hash not low enough
    # -7: if an event isn’t in a market, it shouldn’t be reported on at all
    # -8: invalid event
    # -9: already resolved
    # -10: <24 hr left in period, too late to report, able to put up readj. bonds though
def submitReport(branch, votePeriod, eventIndex, salt, report, eventID, reportIndex, ethics):
    if(EVENTS.getOutcome(eventID)!=0):
        return(-9)
    if(REPORTING.getRepBalance(branch, tx.origin)<10*2**64):
        return(-4)
    if(BRANCHES.getVotePeriod(branch)!=votePeriod):
        return(-2)
    if(block.number/BRANCHES.getPeriodLength(branch)!=((block.number + 4800)/BRANCHES.getPeriodLength(branch))):
        return(-10)
    if(hasntDoneRRForLazyEventsAndWrongAnsForPastPeriods):
        doIt()
        self.RRDone = true
    numEvents = EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)
    #if(event'sMarketOdds>=.99 && evenHasOnly1Market):
        #don't report
    if(self.branches[branch].hasReported[eventID][tx.origin].reported[votePeriod]==1):
        return(-1)
    if(numEvents==0):
        return(-5)
    x = array(1)
    # make sure event is in the given branch and vote period...
    event = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)
    if(event==0 || eventID!=event):
        return(-8)
    x[0] = tx.origin + eventID
    i = 0
    numMarkets = EVENTS.getNumMarkets(eventID)
    if(numMarkets==0):
        return(-7)
    if(numMarkets>100):
        numMarkets = 100
    markets = array(numMarkets)
    markets = EVENTS.getMarkets(eventID, outitems=numMarkets)
    volume = 0
    while i < numMarkets:
        volume += MARKETS.getVolume(markets[i])
    totalVol = EXPEVENTS.getPeriodVolume(branch, votePeriod)
    # if odds of reporting are >1, then 2**256 (we don't want to wrap around), so div by 2**64
    log = FXP.fx_log(REPORTING.getRepBalance(branch, tx.origin)*2**64/REPORTING.getTotalRep(branch))
    repConstant = FXP.fx_exp(22136092888451461120*log/2**64)
    repConstant += 18446744073709552
    volFraction = volume*2**64/totalVol
    if(self.getNumEventsToReportOn(branch, votePeriod) < 30*2**64):
        repConstant = 30*2**64/numEvents
    # in fxp (2**192) == 2**256 / 2**64
    # TODO / need:
        # coefficient for reporting minimum based off of appeals
        #Base Reporter Amount = 3+(200*Appeal_Ratio)^3
        #This keeps the base reporter amount 3-10 until it starts getting over 1%, it makes 2% 67 and 3% 219
        #Calculated as opposed to a global variable that slowly changes over time that is.
        #I think perhaps the target number of reports per reporter could be something like   150+Base_Reporter_Amount
    reportingThreshold = (40*(-(267*(volFraction**2)/(2*2**64) + (533*volFraction)/2 +1)*repConstant/2**64) * (2**192)
    # need a precomputing fix add another item
    shaHash = sha3(x, items=1)
    if(shaHash < reportingThreshold || shaHash<EVENTS.getThreshold(eventID)):
        repIndex = REPORTING.repIDToIndex(branch, tx.origin)
        periodLength = BRANCHES.getPeriodLength(branch)
        residual = block.number % periodLength
        if(residual > periodLength/2):
            realHash = EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, reportIndex)
            hashInfo = array(4)
            hashInfo[0] = tx.origin
            hashInfo[1] = salt
            hashInfo[2] = report
            hashInfo[3] = eventID
            reportHash = sha256(hashInfo, chars=32*len(hashInfo))
            if(reportHash!=realHash):
                (return(-3))
            # if currentExpPeriod is more than 2 periods past the current vote period
            # then there can be no more voting for that voting period
            # (reasoning being: >=1 period past means all the events in that period have expired)
            # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)
            # currently requires events to expire to vote
            currentExpPeriod = (block.number / periodLength)
            if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
                return(-2)

            if(reportIsFirstReportInNetwork):
                BRANCHES.setInitialBalance(branch, votePeriod, CASH.balance(branch))
                REPORTING.setInitialRep(branch, votePeriod, REPORTING.getRepBalance(branch, branch))

            # check report validity
            numOutcomes = 2
            numOutcomes = EVENTS.getNumOutcomes(eventID)
            maxValue = EVENTS.getMaxValue(eventID)
            # binary
            if(numOutcomes==2 and maxValue==1):
                if(report>2*2^64 or report<2^64 or report==0):
                    return(-5)
                # submit report
                # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
                outcome = (EVENTS.getOutcome(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + report) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)
                EVENTS.setUncaughtOutcome(eventID, outcome)
            # categorical
            elif(numOutcomes>2):
                minValue = 2^64
                range = numOutcomes*2^64 - minValue
                if(report<=0):
                    return(-5)
                if((report*range/2^64 + minValue)>numOutcomes*2^64):
                    report = 2^64
                # submit report
                # outcome (uncaught and median) should be calculated as we go along on a report by report basis (i.e. lazily evaluating things)
                # for scalars and categoricals... if < 200 reports est. for an event use quicksort at the end, if more use order statistic tree contract way
            # scalar
            else:
                if(report==0):
                    return(-5)
                minValue = EVENTS.getMinValue(events[i])
                range = maxValue*2^64 - minValue*2^64
                if((report*range/2^64 + minValue*2^64) > maxValue*2^64):
                    report = 2^64
                if((report*range/2^64 + minValue*2^64) < minValue*2^64):
                    # 1 == really close to 0, but not a "no report"
                    report = 1
                # submit report
                # outcome should be calculated as we go along on a report by report basis (i.e. lazily evaluating things)
                # for scalars and categoricals... if < 200 reports est. for an event use quicksort at the end, if more use order statistic tree contract way
            # reporter has reported for 1 more event
            self.branches[branch].numReportsActual[tx.origin][votePeriod] += 1
            # add 1 report to the event
            self.branches[branch].numReportsEvent[votePeriod][eventID] += 1
            # record that reporter has reported for this event
            self.branches[branch].hasReported[eventID][tx.origin].reported[votePeriod] = 1
            self.branches[branch].repReported[eventID] += REPORTING.getRepBalance(branch, tx.origin)
            # set report value for event
            self.branches[branch].report[period][tx.origin].event[event] = report
            # set ethics value for event TODO:
            if(ethics!=2**64 || ethics!=0):
                ethics = 2**64
            ethics = (EVENTS.getEthics(eventID)*self.branches[branch].numReportsEvent[votePeriod][eventID] + ethics) / (self.branches[branch].numReportsEvent[votePeriod][eventID] + 1)
            EVENTS.setEthics(eventID, ethics)
            # if 1st report of the period for a reporter
            if(!self.branches[branch].reportedPeriod[votePeriod][tx.origin]):
                repReported = EXPEVENTS.getTotalRepReported(branch)
                balance = REPORTING.getRepBalance(branch, tx.origin)
                repReported += balance
                EXPEVENTS.setTotalRepReported(branch, votePeriod, repReported)
                #1. Record rep at start of report period
                self.branches[branch].beforeRep[votePeriod][tx.origin] = balance
                self.branches[branch].afterRep[votePeriod][tx.origin] = balance
                self.branches[branch].dormantRep[votePeriod][tx.origin] = REPORTING.getDormantRepBalance(branch, tx.origin)

            # store report for each event
            return(1)
        return(-2)
    else:
        return(-6)

#So you could start off with 5000 rep, never report, and you’d “have” 5000 rep up until you tried to send it or get the balance, and all of a sudden, like Schrodinger’s cat, it’s gone (dead)!  People could ping the network to ding dead accounts (although they wouldn’t need to do so for any good reason).
# Basically, if you don't access the account, the rep just sort of sits there, proverbially speaking, it's burned.  If you access the account, it's sent to the branch's rep account, and distributed like trading fees are except each person would make their own lazy claim on it.  To prevent double claiming, similarly to trading fees each rep acc. that hadn't claimed rep or trading fees but reported that past period would neither be able to send nor receive rep until they claimed.  You'd get % of people that reported fees / rep
# dormant/active rep
def penalizeNotEnoughReports(branch, votePeriod):
    if(alreadyPenalized):
        return(-1)
    numEvents = self.getNumEventsToReportOn(branch, votePeriod)
    # min. of 30 events no matter how little rep you have
    # whats going on here
    if(hasReported):
        # if has reported, don't count in rep reported for fee or rep redistrib. claims
        repReported = EXPEVENTS.getTotalRepReported(branch)
        repReported -= REPORTING.getRepBalance(branch, tx.origin)
        EXPEVENTS.setTotalRepReported(branch, votePeriod, repReported)
    if(numEvents < 30*2**64):
        numEvents = 30*2**64
    # what _if_ there are actually <30 events in augur?
    if(numEvents/(2*2**64) > self.branches[branch].numReportsActual[msg.sender][votePeriod]):
        originalRep = REPORTING.getRepBalance(branch, tx.origin)
        # penalize people
        newRep = .2*self.branches[branch].numReportsActual[msg.sender][votePeriod] / self.getNumEventsToReportOn(branch, votePeriod)/(2*2**64) * originalRep
        oldRep = REPORTING.getRepBalance(branch, tx.origin)*.8
        REPORTING.setRep(branch, REPORTING.repIDToIndex(branch, tx.origin), oldRep+newRep)
        # adds the rep to the branch's pool
        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), originalRep - (oldRep+newRep))
    # todo: separate heavier penalty for not reporting on a round 2 / readjudicated event
    return(1)


def sqrt(n):
    val = n
    i = 0
    while i < 11:
        val = (val + n*2^64/val)/2
        i += 1
    return val

# for ui client side
# @return 1 if success
# Error messages otherwise
    # -1: report isn't long enough
    # -2: reporter (you) doesn't (don't) exist, or voting period over or hasn't started yet
def checkReportValidity(branch, report:arr, votePeriod):
       if(len(report)!=EXPEVENTS.getNumberEvents(branch, votePeriod)):
        return(-1)

        # if currentExpPeriod is more than 2 periods past the current vote period
        # then there can be no more voting for that voting period
        # (reasoning being: >=1 period past means all the events in that period have expired)
        # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)
        # currently requires events to expire to vote
        currentExpPeriod = (block.number / BRANCHES.getPeriodLength(branch))
        if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
            return(-2)
        else:
            return(1)

# anti cheat provide ballot and randomNum mechanism steal deposit
def slashRep(branch, votePeriod, salt, report, reporter, reportIndex, eventID):
        realHash = EXPEVENTS.getReportHash(branch, votePeriod, reporter, reportIndex)
        hashInfo = array(len(report) + 2)
        hashInfo[0] = reporter
        hashInfo[1] = salt
        hashInfo[2] = report
        hashInfo[3] = eventID

        reportHash = sha256(hashInfo, chars=32*len(hashInfo))
        if(reportHash!=realHash):
            return(0)
        else:
            reporterIndex = REPORTING.repIDToIndex(branch, reporter)
            trutherIndex = REPORTING.repIDToIndex(branch, tx.origin)
            # if the truther's rep. account doesn't exist, make one
            if(REPORTING.getReporterID(branch, trutherIndex)!=tx.origin):
                trutherIndex = REPORTING.getNumberReporters(branch)
                REPORTING.addReporter(branch, tx.origin)

            if(REPORTING.getReporterID(branch, reporterIndex)!=reporter):
                return(-2)

            reporterBalance = REPORTING.getRepBalance(branch, reporter)

            REPORTING.subtractRep(branch, reporterIndex, reporterBalance)
            REPORTING.addRep(branch, trutherIndex, reporterBalance*2^58 / 2^64)
        return(reporterBalance)

def getNumReportsActual(branch, votePeriod):
    return(self.branches[branch].numReportsActual[msg.sender][votePeriod])
