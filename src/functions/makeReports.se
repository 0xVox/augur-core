# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import expiringEvents as EXPEVENTS
import info as INFO
import cash as CASH
import events as EVENTS
import markets as MARKETS
import reporting as REPORTING
import fxpFunctions as FXP

# branches: votePeriod, reporterID (for both num hash submitted and num actual reports submitted) --- votePeriod, EventID --- eventID
data branches[](numReportsHash[][], numReportsActual[][], numReportsEvent[][], hasReported[])


# Error -1: reporter (you) doesn't (don't) exist, or voting period over or hasn't starred yet
# Error -2: not in hash submitting timeframe
# Python code to get the hash:
    #from bitcoin import encode
    #from hashlib import sha256
    #def sha256list(xs):
    #    data = ''.join(encode(x, 256, 32) for x in xs)
    #    hashed = int(sha256(data).hexdigest(), 16)
    #    if hashed > 2**255:
    #        return hashed - 2**256
    #    else:
    #        return hashed
def submitReportHash(branch, reportHash, votePeriod):
    reportIndex = self.branches[branch].numReportsHash[msg.sender][votePeriod]
    # make sure the branch exists
    repIndex = REPORTING.repIDToIndex(branch, tx.origin)
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.number % periodLength
    currentExpPeriod = (block.number / periodLength)
    if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
        return(-1)
    if(residual < periodLength/2):
        # submit hash of (tx.origin, salt, Votes[])
        if(EXPEVENTS.setReportHash(branch, votePeriod, tx.origin, reportHash, reportIndex)):
            self.branches[branch].numReportsHash[msg.sender][votePeriod] += 1
            return(1)
        else:
            return(0)
    else:
        return(-2)

#a^b=exp(b*ln(a))=e^(b*ln(a)).
#eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))
# returns num events to report on in fxp
def getNumEventsToReportOn(branch, votePeriod):
    prelim = EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)
    repConstant = REPORTING.getRepBalance(branch, msg.sender)*2**64/REPORTING.getTotalRep(branch)
    log = FXP.fx_log(repConstant)
    exp = FXP.fx_exp(22136092888451461120*log/2**64)
    exp += 18446744073709552
    return(exp*prelim)

# a no vote is -2^64, a yes vote is 2^64 && a can't determine vote is 3*2^63
# -5: set num events to report on first
# need min num rep to report
# if people get behind on voting (e.g the redeem tx isn't called <1 period after it can be called)
    # voteperiod is an optional parameter only used in the scenario that we get behind on voting periods
    # so people will need to vote on periods that are upcoming even if our currentVotePeriod is a bit behind (e.g. if current expperiod is 7 you should vote on stuff from voteperiod 6 (and then upon period 8 you can't vote anymore))
# @return 1 if success
# Error messages otherwise
    # -1: has already reported
    # -2: reporter (you) doesn't (don't) exist, or voting period over or hasn't started yet
    # -3: hash doesn't match
    # -4: no rep
    # -5: bad report
def submitReport(branch, votePeriod, eventIndex, salt, report, eventID, reportIndex):
    if(REPORTING.getRepBalance(branch, tx.origin)<10*2**64):
        return(-4)
    numEvents = EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)
    if(self.branches[branch].hasReported[eventID]==1):
        return(-1)
    if(numEvents==0):
        return(-5)
    x = array(1)
    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)
    x[0] = tx.origin + eventID
    i = 0
    numMarkets = EVENTS.getNumMarkets(eventID)
    markets = array(numMarkets)
    markets = EVENTS.getMarkets(eventID, outitems=numMarkets)
    volume = 0
    while i < numMarkets:
        volume += MARKETS.getVolume(markets[i])
    totalVol = EXPEVENTS.getPeriodVolume(branch, votePeriod)
    # if odds of reporting are >1, then 2**256 (we don't want to wrap around), so div by 2**64
    log = FXP.fx_log(REPORTING.getRepBalance(branch, tx.origin)*2**64/REPORTING.getTotalRep(branch))
    repConstant = FXP.fx_exp(22136092888451461120*log/2**64)
    repConstant += 18446744073709552
    volFraction = volume*2**64/totalVol
    if(self.getNumEventsToReportOn(branch, votePeriod) < 30*2**64):
        repConstant = 30*2**64/numEvents
    # in fxp (2**192) == 2**256 / 2**64
    reportingThreshold = (40*(-(267*(volFraction**2)/(2*2**64) + (533*volFraction)/2 +1)*repConstant/2**64) * (2**192)
    # need a precomputing fix add another item
    shaHash = sha3(x, items=1)
    if(shaHash < reportingThreshold || shaHash<EVENTS.getThreshold(eventID)):
        repIndex = REPORTING.repIDToIndex(branch, tx.origin)
        periodLength = BRANCHES.getPeriodLength(branch)
        residual = block.number % periodLength
        if(residual > periodLength/2):
            realHash = EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, reportIndex)
            hashInfo = array(4)
            hashInfo[0] = tx.origin
            hashInfo[1] = salt
            hashInfo[2] = report
            hashInfo[3] = eventID
            reportHash = sha256(hashInfo, chars=32*len(hashInfo))
            if(reportHash!=realHash):
                (return(-3))
            # if currentExpPeriod is more than 2 periods past the current vote period
            # then there can be no more voting for that voting period
            # (reasoning being: >=1 period past means all the events in that period have expired)
            # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)
            # currently requires events to expire to vote
            currentExpPeriod = (block.number / periodLength)
            if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
                return(-2)

            # check report validity
            numOutcomes = 2
            numOutcomes = EVENTS.getNumOutcomes(eventID)
            maxValue = EVENTS.getMaxValue(eventID)
            # binary
            if(numOutcomes==2 and maxValue==1):
                if(report>2*2^64 or report<2^64 or report==0):
                    return(-5)
            # categorical
            elif(numOutcomes>2):
                minValue = 2^64
                range = numOutcomes*2^64 - minValue
                if(report<=0):
                    return(-5)
                if((report*range/2^64 + minValue)>numOutcomes*2^64):
                    report = 2^64
            # scalar
            else:
                if(report==0):
                    return(-5)
                minValue = EVENTS.getMinValue(events[i])
                range = maxValue*2^64 - minValue*2^64
                if((report*range/2^64 + minValue*2^64) > maxValue*2^64):
                    report = 2^64
                if((report*range/2^64 + minValue*2^64) < minValue*2^64):
                    # 1 == really close to 0, but not a "no report"
                    report = 1
            # reporter has reported for 1 more event
            self.branches[branch].numReportsActual[tx.origin][votePeriod] += 1
            # add 1 report to the event
            self.branches[branch].numReportsEvent[votePeriod][eventID] += 1
            # record that reporter has reported for this event
            self.branches[branch].hasReported[eventID] = 1
            # submit report
            # outcome should be calculated as we go along on a report by report basis (i.e. lazily evaluating things)
            report();
        return(1)
    else:
        return(0)

#So you could start off with 5000 rep, never report, and you’d “have” 5000 rep up until you tried to send it or get the balance, the dentist guys going to Vienna is gone as the villain and all of a sudden, like Schrodinger’s cat, it’s gone (dead)!  People could ping the network to ding dead accounts (although they wouldn’t need to do so for any good reason).
# Basically, if you don't access the account, the rep just sort of sits there, proverbially speaking, it's burned.  If you access the account, it's sent to the branch's rep account, and distributed like trading fees are except each person would make their own lazy claim on it.  To prevent double claiming, similarly to trading fees each rep acc. that hadn't claimed rep or trading fees but reported that past period would neither be able to send nor receive rep until they claimed.  You'd get % of people that reported fees / rep
#Q: Can we do lazy eval claiming of trading fees?
#A: Yes:
#      if(addrWasInThisConsensusPeriod):
#          send them cash of amount equal to fees from that period * rep owned by addr in that period / total #rep in that period
def penalizeNotEnoughReports(branch, votePeriod):
    numEvents = self.getNumEventsToReportOn(branch, votePeriod)
    # min. of 30 events no matter how little rep you have
    if(numEvents < 30*2**64):
        numEvents = 30*2**64
    if(numEvents/(2*2**64) > self.branches[branch].numReportsActual[msg.sender][votePeriod]):
        # penalize people
        newRep = .2*self.branches[branch].numReportsActual[msg.sender][votePeriod] / self.getNumEventsToReportOn(branch, votePeriod)/(2*2**64) * REPORTING.getRepBalance(branch, tx.origin)
        oldRep = REPORTING.getRepBalance(branch, tx.origin)*.8
        REPORTING.setRep(branch, REPORTING.repIDToIndex(branch, tx.origin), oldRep+newRep)
    else:
        # you're good!
        return(47)

def sqrt(n):
    val = n
    i = 0
    while i < 11:
        val = (val + n*2^64/val)/2
        i += 1
    return val

# for ui client side
# @return 1 if success
# Error messages otherwise
    # -1: report isn't long enough
    # -2: reporter (you) doesn't (don't) exist, or voting period over or hasn't starred yet
def checkReportValidity(branch, report:arr, votePeriod):
       if(len(report)!=EXPEVENTS.getNumberEvents(branch, votePeriod)):
        return(-1)

        # if currentExpPeriod is more than 2 periods past the current vote period
        # then there can be no more voting for that voting period
        # (reasoning being: >=1 period past means all the events in that period have expired)
        # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)
        # currently requires events to expire to vote
        currentExpPeriod = (block.number / BRANCHES.getPeriodLength(branch))
        if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
            return(-2)
        else:
            return(1)

# anti cheat provide ballot and randomNum mechanism steal deposit
def slashRep(branch, votePeriod, salt, report, reporter, reportIndex, eventID):
        realHash = EXPEVENTS.getReportHash(branch, votePeriod, reporter, reportIndex)
        hashInfo = array(len(report) + 2)
        hashInfo[0] = reporter
        hashInfo[1] = salt
        hashInfo[2] = report
        hashInfo[3] = eventID
        
        reportHash = sha256(hashInfo, chars=32*len(hashInfo))
        if(reportHash!=realHash):
            return(0)
        else:
            reporterIndex = REPORTING.repIDToIndex(branch, reporter)
            trutherIndex = REPORTING.repIDToIndex(branch, tx.origin)
            # if the truther's rep. account doesn't exist, make one
            if(REPORTING.getReporterID(branch, trutherIndex)!=tx.origin):
                trutherIndex = REPORTING.getNumberReporters(branch)
                REPORTING.addReporter(branch, tx.origin)

            if(REPORTING.getReporterID(branch, reporterIndex)!=reporter):
                return(-2)


            reporterBalance = REPORTING.getRepBalance(branch, reporter)

            REPORTING.subtractRep(branch, reporterIndex, reporterBalance)
            REPORTING.addRep(branch, trutherIndex, reporterBalance*2^58 / 2^64)
        return(reporterBalance)
