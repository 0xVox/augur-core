# This software (Augur) allows buying and selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
# 
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
# 
#    This program is distributed in the hope that it will be useful, #    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
# 
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

### Allows users to take orders off the book (i.e. fill trades)

# Trade scenarios:

    # - Buying and have all but one and bidding, seller doesn't have outcome.

    # - Buying and have all but one and bidding, seller has outcome.

    # - Buying and don't own anything and bidding, seller doesn't have outcome

    # - Buying and don't own anything doesn't bidding, seller has outcome

    # - Buying and have all but one and taking, seller doesn't have outcome.

    # - Buying and have all but one and taking, seller has outcome.

    # - Buying and don't own anything and taking, seller doesn't have outcome

    # - Buying and don't own anything doesn't taking, seller has outcome

import branches as BRANCHES
import info as INFO
import markets as MARKETS
import events as EVENTS
import trades as TRADES
import expiringEvents as EXPEVENTS
import mutex as MUTEX
extern subcurrency: [allowance:[uint256,uint256]:uint256, approve:[uint256,uint256]:uint256, balance:[]:uint256, balanceOf:[uint256]:uint256, transfer:[uint256,uint256]:uint256, transferFrom:[uint256,uint256,uint256]:uint256]
inset('../data_api/refund.se')
inset('logReturn.se')
inset('../data_api/float.se')

event logPrice(market:indexed, sender:indexed, owner:indexed, type, price, amount, timestamp, tradeid, outcome)

event tradeLogReturn(returnValue)
event tradeLogArrayReturn(returnArray: arr)

macro logArrayReturn($a):
    log(type=tradeLogArrayReturn, $a)
    return($a: arr)

macro ONE_POINT_FIVE: 1500000000000000000

macro MIN_TRADE_VALUE: 10000000000

macro ONEPOINTFIVE: 1500000000000000000
# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 10
# Boolean success/failure
macro SUCCESS: 1
# Error codes
macro INSUFFICIENT_BALANCE: -4
macro TRADE_SAME_BLOCK_PROHIBITED: -5

# removes a trade from the book
macro removeTrade($tradeID, $market):
    TRADES.removeTrade($tradeID)
    MARKETS.removeTradeFromMarket($market, $tradeID)

# 
# Trade [allows a user to pick up/fill orders off the book]
# 
# Errors:
    # 0: trade doesn't exist
    # -1: bad trade hash
    # -2: must buy at least .00000001 in
    # -3: can't pick up your own trade
    # -4: insufficient balance
    # -5: trade in same block prohibited
# amountTakerWants is amount of shares the taker wants to fill
# picks orders off the book
# @return fxp
def trade(tradeID, amountTakerWants):
    refund()
    if(MUTEX.getMutex()):
        throw()
    MUTEX.setMutex()

    tradeInfo = array(2)
    tradeInfo[0] = orderID
    tradeInfo[1] = amountTakerWants
    tradeHash = sha3(tradeInfo, items = 2)
    if(TRADES.checkHash(tradeHash, msg.sender) == -1):
        MUTEX.unsetMutex()
        logArrayReturn([-1])
    # Get trade
    trade = array(TRADE_FIELDS)
    trade = TRADES.getTrade(tradeID, outitems = TRADE_FIELDS)
    if(!trade[0]):
        MUTEX.unsetMutex()
        logArrayReturn([0])
    type = trade[1]
    market = trade[2]
    creator = INFO.getCreator(market)
    amount = trade[3]
    price = trade[4]
    owner = trade[5]
    outcome = trade[7]
    moneyEscrowed = trade[8]
    sharesEscrowed = trade[9]
    checkTradePreconditions()
    branch = MARKETS.getBranch(market)
        
    cumulativeScale = MARKETS.getCumulativeScale(market)

    # Fill buy order
    if(type == BID):
        fillBid()
    elif(type == ASK):
        fillAsk()
    else:
        throw()

    # Log price, fill amount, type and timestamp
    MARKETS.setPrice(market, outcome, price)
    MUTEX.unsetMutex()
    logArrayReturn([SUCCESS, fxpMaxValue, fxpMaxAmount])

macro checkTradePreconditions():
    if(owner == msg.sender):
        MUTEX.unsetMutex()
        logArrayReturn([-3])
    # Make sure the trade has been mined, obvious HFT prevention
    if(block.number <= trade[6]):
        MUTEX.unsetMutex()
        logArrayReturn([TRADE_SAME_BLOCK_PROHIBITED])


# Filling a bid [aka selling shares]
# Scenarios:
    # Asker has max - price and expects complete set minus the one theyre selling
    # Or asker has shares and expects to be paid price - min for them
    # Bidder owns all shares except the one theyre buying and has escrowed them and wants to pay price - min for the share and then sell the complete set for range thus getting max - price at the end
    # Or bidder has escrowed price - min for their shares
macro fillBid():
    sumOfFills = 0
    # all in shares including the money here
    askerSharesFilled = 0
    askerMoneyFilled = 0
    bidderSharesFilled = 0
    bidderMoneyFilled = 0
    
    if(sharesEscrowed):
        fill = min(sharesEscrowed, amountTakerWants)
        sharesEscrowed -= fill
        amountTakerWants -= fill
        sumOfFills += fill
        bidderSharesFilled = fill
        sendSharesEscrowedByBidderBackToBidder(fill amount)

    if(amountTakerWants && moneyEscrowed):
        fill = min(moneyEscrowed/(price - min), amountTakerWants)
        moneyEscrowed -= fill * (price - min)
        amountTakerWants -= fill
        sumOfFills += fill
        bidderMoneyFilled = fill

    remainderToFill = sumOfFills

    # Get available balance of shares
    balance = MARKETS.getParticipantSharesPurchased(market, msg.sender, outcome)
    
    if(balance <= 0 or amountTakerWants <= 0):
        MUTEX.unsetMutex()
        logArrayReturn([INSUFFICIENT_BALANCE])
    # Calculate value
    value = safeFxpMul(sumOfFills, price)
    # must trade at least 0.00000001 in value
    if(value < MIN_TRADE_VALUE):
        MUTEX.unsetMutex()
        throw()
    # Update trade amount or remove
    if(sumOfFills < amount):
        TRADES.fillTrade(tradeIDs[t], sumOfFills, money, shares)
    else:
        removeTrade(tradeIDs[t], market)
    # Update balances
    MARKETS.modifyParticipantShares(market, msg.sender, outcome, -fill, 1)
    MARKETS.modifyParticipantShares(market, owner, outcome, fill, 0)
    # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
    
    if(msg.sender owns shares of outcome):
        fill = min(sharesOwned, remainderToFill)
        askerSharesFilled = fill
        remainderToFill -= fill

    if(remainderToFill):
        issueAskerCompleteSetsForRemainderAmountAndDontChargeYet()
        askerMoneyFilled = remainderToFill
        remainderToFill -= remainderToFill

    paySender = INFO.getWallet(market).transfer(msg.sender, value)
    if(!paySender):
        throw()
    # Update fxpMaxAmount
    fxpMaxAmount -= fill
    # Log transaction [ASK b/c it's filling a bid so from trader's perspective they're asking]
    log(type = logPrice, market, msg.sender, owner, ASK, price, fill, block.timestamp, tradeIDs[t], outcome)
    
    sendBidderSharesFromAsker(amount of sumOfFills)
    sellBidderCompleteSetsUsingMinAndGiveMoneyToBidder(sharesOwnedPerOutcome)
    transfer((price - min) * bidderSharesFilled) to market from bidder since market hasnt been paid yet after complete sets selling
    transfer((price - min) * sumOfFills) from the market to the asker.
    transfer(range * askerMoneyFilled) to the market from asker for the amount of shares in askerMoneyFilled
    Sell the askers complete sets using min(shares per outcome they own).



# Filling an ask [aka buying shares]
# Scenarios:
    # Asker either escrowed max - price and expects complete set minus the one they're selling
    # Or asker had shares and escrowed them and expects to be paid price - min for them
    # Bidder owns all shares except the one they're buying and will pay price - min for the shares they're buying
    # Or bidder will pay price - min for their shares
macro fillAsk():
    sumOfFills = 0
    # all in shares including the money here
    askerSharesFilled = 0
    askerMoneyFilled = 0
    bidderSharesFilled = 0
    bidderMoneyFilled = 0

    if(sharesEscrowed):
        fill = min(sharesEscrowed, amountTakerWants)
        sharesEscrowed -= fill
        amountTakerWants -= fill
        sumOfFills += fill
        askerSharesFilled = fill

    if(amountTakerWants && moneyEscrowed):
        fill = min(moneyEscrowed/(max - price), amountTakerWants)
        moneyEscrowed -= fill * (max - price)
        amountTakerWants -= fill
        sumOfFills += fill
        askerMoneyFilled = fill
        issueAskerCompleteSetsMinusOutcomeSellingInFillAmountAndDontChargeBecauseAlreadyPaid()

    remainderToFill = sumOfFills

    balance = INFO.getCurrency(market).balanceOf(msg.sender)
    # Determine fill amount
    
    # Calculate value
    value = safeFxpMul(sumOfFills, price)
    # must trade at least 0.00000001 in value
    if(value < MIN_TRADE_VALUE):
        MUTEX.unsetMutex()
        throw()
    
    # Update trade amount or remove filled trade
    if(fill < amount):
        TRADES.fillTrade(tradeIDs[t], fill)
    else:
        removeTrade(tradeIDs[t], market)
    # Update balances [user asking has already gotten rid of shares in escrow, just need to add them to the buyer]
    MARKETS.modifyParticipantShares(market, msg.sender, outcome, fill, 1)

    # Transfer cash from user to person who has ask order
    payMaker = INFO.getCurrency(market).transferFrom(msg.sender, owner, valueToSpend)
    if(!payMaker):
        throw()
                
    if(msg.sender owns shares of all outcomes besides the one theyre buying):
        fill = min(sharesOwned, remainderToFill)
        bidderSharesFilled = fill
        remainderToFill -= fill

    if(remainderToFill):
        bidderMoneyFilled = remainderToFill
        remainderToFill -= remainderToFill

    # Update fxpMaxValue
    fxpMaxValue -= valueToSpend
    # Log transaction [BID b/c it's filling an ask so from trader's perspective they're bidding]
    log(type = logPrice, market, msg.sender, owner, BID, price, fill, block.timestamp, tradeIDs[t], outcome)
    
    sendBidderSumOfFillsSharesByJustCreatingThemAndGivingThemToThem()
    sellBidderCompleteSetsUsingMin(sharesOwnedPerOutcome)
    transfer((price - min) * (bidderSharesFilled + bidderMoneyFilled)) to market from bidder since market hasnt been paid yet
    transfer((price - min) * askerSharesFilled) from the market to the asker, dont need to send for askerMoneyFilled because asker only escrowed max - price and thus has "already been paid" for those shares
    Sell the askers complete sets using min(shares per outcome they now own).

