# This software (Augur) allows buying and selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
# 
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
# 
#    This program is distributed in the hope that it will be useful, #    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
# 
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

### Allows users to take orders off the book and short sell

import branches as BRANCHES
import info as INFO
import markets as MARKETS
import trades as TRADES
import expiringEvents as EXPEVENTS
extern subcurrency: [allowance:[int256,int256]:int256, approve:[int256,int256]:int256, balance:[]:int256, balanceOf:[int256]:int256, transfer:[int256,int256]:int256, transferFrom:[int256,int256,int256]:int256]
inset('../data_api/refund.se')

event logPrice(market:indexed, sender:indexed, owner:indexed, type, price, amount, timestamp, tradeid, outcome)

macro ONEPOINTFIVE: 27670116110564327424

# Trade types
macro BID: 1
macro ASK: 2
# Field counts
macro TRADE_FIELDS: 8
# Boolean success/failure
macro SUCCESS: 1
# Error codes
macro INSUFFICIENT_BALANCE: 10
macro TRADE_SAME_BLOCK_PROHIBITED: 22

# calculates trading fee percentage
# 4*fee*price*(1-price/range)/range keeps fees lower at the edges
macro feePercent($marketFee, $price, $cumScale):
    4 * $marketFee * $price * (ONE - $price * 2 ** 64 / $cumScale) / ($cumScale * ONE)

# removes a trade from the book
macro removeTrade($tradeID, $market):
    TRADES.removeTrade($tradeID)
    MARKETS.removeTradeFromMarket($market, $tradeID)

# 
# Trade [allows a user to pick up/fill orders off the book]
# 
# Errors:
    # -1: trade doesn't exist
    # -2: bad trade hash
    # -4: must buy at least .00000001 in
    # -5: can't pick up your own trade
    # 10: insufficient balance
    # 22: trade in same block prohibited
# max value is max money to spend to buy [including fees] filling ask orders
# max amount is max shares to sell filling bid orders
# 500k gas cost
# picks orders off the book
def trade(fxpMaxValue, fxpMaxAmount, tradeIDs:arr):
    refund()
    i = 0
    trades = 0
    while(i < len(tradeIDs)):
        trades += tradeIDs[i]
        i += 1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = fxpMaxAmount
    tradeInfo[2] = fxpMaxValue
    tradeHash = sha3(tradeInfo, items = 3)
    if(TRADES.checkHash(tradeHash, msg.sender) == -1):
        return([-2]: arr)
    # Try to fulfill each trade passed
    t = 0
    while(t < len(tradeIDs)):
        # Get trade
        trade = array(TRADE_FIELDS)
        trade = TRADES.getTrade(tradeIDs[t], outitems = TRADE_FIELDS)
        if(!trade):
            return([0]: arr)
        # Get market
        type = trade[1]
        market = trade[2]
        creator = INFO.getCreator(market)
        amount = trade[3]
        price = trade[4]
        owner = trade[5]
        outcome = trade[7]
        fill = 0
        if(owner == msg.sender):
            return([-5]: arr)
        # Make sure the trade has been mined, obvious HFT prevention
        if(block.number <= trade[6]):
            return([TRADE_SAME_BLOCK_PROHIBITED]: arr)
        branch = MARKETS.getBranch(market)
        fee = feePercent(MARKETS.getTradingFee(market), price, MARKETS.getCumScale(market))

        # Fill buy order
        if(type == BID):
            # Get available balance of shares
            balance = MARKETS.getParticipantSharesPurchased(market, msg.sender, outcome)
            if(balance > 0 and fxpMaxAmount > 0):
                makerFeeRate = MARKETS.getMakerFees(market)
                # Determine fill amount
                fill = min(amount, min(balance, fxpMaxAmount))
                # Calculate value
                value = (fill * price) / ONE
                # must trade at least 0.00000001 in value
                if(value < 184467440738):
                    return([-4]: arr)
                # Update trade amount or remove
                if(fill < amount):
                    TRADES.fillTrade(tradeIDs[t], fill)
                else:
                    removeTrade(tradeIDs[t], market)
                # Update balances
                MARKETS.modifyParticipantShares(market, msg.sender, outcome, -fill, 1)
                MARKETS.modifyParticipantShares(market, owner, outcome, fill, 0)
                # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
                fee = value * fee / ONE
                branchFees = (THREE_FOURTHS + (ONE_HALF - makerFeeRate) / 2) * fee / ONE
                creatorFees = (ONE_FOURTH + (ONE_HALF - makerFeeRate) / 2) * fee / ONE
                
                # 75% to branch + .5% more to branch per maker fee 1% decrease
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                # also pay sender for the shares they're selling
                if(!INFO.getWallet(market).transfer(msg.sender, value - (branchFees + creatorFees)) or !INFO.getWallet(market).transfer(BRANCHES.getWallet(branch, INFO.getCurrency(market)), branchFees) or !INFO.getWallet(market).transfer(creator, creatorFees)):
                    throw()

                # other party [maker] pays their part of the fee here too [they previously escrowed it in the market]
                fee = fee * makerFeeRate / ONE
                if(!INFO.getWallet(market).transfer(creator, fee / 2) or !INFO.getWallet(market).transfer(BRANCHES.getWallet(branch, INFO.getCurrency(market)), fee / 2)):
                    throw()

                # needed to keep track of how many fees a market has raised
                # only count branch fees here
                MARKETS.addFees(market, fee / 2 + branchFees)
                # Update fxpMaxAmount
                fxpMaxAmount -= fill
                # Log transaction [ASK b/c it's filling a bid so from trader's perspective they're asking]
                log(type = logPrice, market, msg.sender, owner, ASK, price, fill, block.timestamp, tradeIDs[t], outcome)
            else:
                return([INSUFFICIENT_BALANCE]: arr)
        elif(type == ASK):
            balance = INFO.getCurrency(market).balanceOf(msg.sender)
            makerFeeRate = MARKETS.getMakerFees(market)
            takerFee = (ONEPOINTFIVE - makerFeeRate) * fee / ONE
            totalTradeCost = amount * price * (takerFee + ONE) / ONE ** 2
            # trade value to spend is equal to min(moneyUserOwns, moneyUserWantsToSpend, valueOfTradeThatIsUnfilledIncludingFees)
            valueToSpend = min(totalTradeCost, min(fxpMaxValue, balance))
            # Determine fill amount
            fill = valueToSpend * ONE / price * ONE / (takerFee + ONE)
            tradeValueExcludingFees = fill * price / ONE
            if(tradeValueExcludingFees >= 184467440738):
                # Update trade amount or remove filled trade
                if(fill < amount):
                    TRADES.fillTrade(tradeIDs[t], fill)
                else:
                    removeTrade(tradeIDs[t], market)
                # Update balances [user asking has already gotten rid of shares in escrow, just need to add them to the buyer]
                MARKETS.modifyParticipantShares(market, msg.sender, outcome, fill, 1)

                branchFees = (THREE_FOURTHS + (ONE_HALF - makerFeeRate) / 2) * tradeValueExcludingFees / ONE * fee / ONE
                creatorFees = (ONE_FOURTH + (ONE_HALF - makerFeeRate) / 2) * tradeValueExcludingFees / ONE * fee / ONE
                
                # Transfer cash from user to person who has ask order and pay fee to branch and market creator
                # 75% to branch + .5% more to branch per maker fee 1% decrease
                # 25% to creator + .5% more to creator per 1% decrease in maker fees
                if(!INFO.getCurrency(market).transferFrom(msg.sender, owner, valueToSpend - (branchFees + creatorFees)) or !INFO.getCurrency(market).transferFrom(msg.sender, BRANCHES.getWallet(branch, INFO.getCurrency(market)), branchFees) or !INFO.getCurrency(market).transferFrom(msg.sender, creator, creatorFees)):
                    throw()
                
                # other party [maker] pay their part of the fee here too
                makerFee = tradeValueExcludingFees * makerFeeRate / ONE * fee / ONE
                if(!INFO.getWallet(market).transfer(creator, makerFee / 2) or !INFO.getWallet(market).transfer(BRANCHES.getWallet(branch, INFO.getCurrency(market)), makerFee / 2)):
                    throw()

                # only count branch fees here
                MARKETS.addFees(market, makerFee / 2 + branchFees)
                # Update fxpMaxValue
                fxpMaxValue -= valueToSpend
                # Log transaction [BID b/c it's filling an ask so from trader's perspective they're bidding]
                log(type = logPrice, market, msg.sender, owner, BID, price, fill, block.timestamp, tradeIDs[t], outcome)
            else:
                return([INSUFFICIENT_BALANCE]: arr)
        else:
            throw()

        # Log price, fill amount, type and timestamp
        MARKETS.setPrice(market, outcome, price)
        # Next trade
        t += 1
    return([SUCCESS, fxpMaxValue, fxpMaxAmount]: arr)

# Allows a user to "short" by buying n complete sets and selling n shares of the unwanted outcome to a bid on the book in one tx
# Example:
    # buyer gives up say 20
    # complete set cost is say 100
    # fee is say 2
    # market should lose 20 from buyer's escrowed money
    # market should gain 100 from complete set
    # person short selling should give the market 80 [complete set cost less shares sold]
    # plus fees
        # 1 should go to branch
        # 1 should go to creator
# Errors:
    # -1: trade doesn't exist
    # -2: invalid trade hash/commitment
    # -3: must be a bid, not an ask
    # -4: market is already resolved
    # -5: can't pickup your own trade
    # -7: not a large enough trade
def shortSell(buyerTradeIDs: arr, fxpMaxAmount):
    refund()
    i = 0
    trades = 0
    while(i < len(buyerTradeIDs)):
        trades += buyerTradeIDs[i]
        i += 1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = fxpMaxAmount
    tradeInfo[2] = 0
    tradeHash = sha3(tradeInfo, items = 3)
    if(TRADES.checkHash(tradeHash, msg.sender) == -1):
        return([-2]: arr)
    # Try to fulfill each trade passed
    t = 0
    while(t < len(buyerTradeIDs)):
        # Get trade
        trade = array(TRADE_FIELDS)
        trade = TRADES.getTrade(buyerTradeIDs[t], outitems = TRADE_FIELDS)
        if(!trade):
            return([-1]: arr)
        # Get market
        type = trade[1]
        if(type != BID):
            return([-3]: arr)
        market = trade[2]
        branch = MARKETS.getBranch(market)
        if(MARKETS.getOneWinningOutcome(market, 0)):
            return([-4]: arr)
        origAmount = trade[3]
        price = trade[4]
        owner = trade[5]
        outcome = trade[7]
        if(owner == msg.sender):
            return([-5]: arr)
        # Make sure the trade has been mined, obvious HFT prevention
        if(block.number <= trade[6]):
            return([TRADE_SAME_BLOCK_PROHIBITED]: arr)
    
        # calculate cost
        creator = INFO.getCreator(market)
        tradingFee = MARKETS.getTradingFee(market)
        cumScale = MARKETS.getCumScale(market)
        amount = min(origAmount, fxpMaxAmount)
        if(amount < 0):
            return([INSUFFICIENT_BALANCE]: arr)
        fee = amount * price * feePercent(tradingFee, price, cumScale) / ONE ** 2
        makerFeeRate = MARKETS.getMakerFees(market)
        branchFees = (THREE_FOURTHS + (ONE_HALF - makerFeeRate) / 2) * fee / ONE
        creatorFees = (ONE_FOURTH + (ONE_HALF - makerFeeRate) / 2) * fee / ONE
        takerFeesTotal = branchFees + creatorFees
        cost = amount * cumScale / ONE - (amount * price / ONE - takerFeesTotal)
        if(INFO.getCurrency(market).balanceOf(msg.sender) < cost):
            return([INSUFFICIENT_BALANCE]: arr)
        if(amount * price / ONE < 184467440738):
            return([-7]: arr)
    
        numOutcomes = MARKETS.getMarketNumOutcomes(market)
    
        i = 1
        # send shares of the event to user address, buying complete sets
        while(i <= numOutcomes):
            MARKETS.modifyShares(market, i, amount)
            MARKETS.modifyParticipantShares(market, msg.sender, i, amount, 0)
            i += 1
        if(BRANCHES.getVotePeriod(branch) < MARKETS.getTradingPeriod(market)):
            MARKETS.modifySharesValue(market, amount * cumScale / ONE)
            EXPEVENTS.adjustPeriodShareValueOutstanding(branch, MARKETS.getTradingPeriod(market), amount * cumScale / ONE)
        # send money from user acc. to market address/account
        # cost for shares
        if(!INFO.getCurrency(market).transferFrom(msg.sender, market, cost - takerFeesTotal)):
            throw()

        # Fill buy order [short selling the outcome user doesn't want]
        # Determine fill amount
        fill = amount
        # Update trade amount or remove
        if(fill < origAmount):
            TRADES.fillTrade(buyerTradeIDs[t], fill)
        else:
            removeTrade(buyerTradeIDs[t], market)
        # Update balances
        MARKETS.modifyParticipantShares(market, msg.sender, outcome, -fill, 1)
        MARKETS.modifyParticipantShares(market, owner, outcome, fill, 0)
        # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]
        # 75% to branch + .5% more to branch per maker fee 1% decrease
        if(!INFO.getCurrency(market).transferFrom(msg.sender, branch, branchFees)):
            throw()
        # 25% to creator + .5% more to creator per 1% decrease in maker fees
        if(!INFO.getCurrency(market).transferFrom(msg.sender, creator, creatorFees)):
            throw()

        # other party [maker] pay their part of the fee here too
        fee = fee * makerFeeRate / ONE
        
        if(!INFO.getWallet(market).transfer(creator, fee / 2) or !INFO.getWallet(market).transfer(BRANCHES.getWallet(branch, INFO.getCurrency(market)), fee / 2)):
            throw()
    
        # only count branch fees here
        MARKETS.addFees(market, fee / 2 + branchFees)
    
        fxpMaxAmount -= fill
        # Log transaction [ASK b/c it's filling a bid so from trader's perspective they're asking]
        log(type = logPrice, market, msg.sender, owner, ASK, price, fill, block.timestamp, buyerTradeIDs[t], outcome)
        MARKETS.setPrice(market, outcome, price)
        t += 1
    return([SUCCESS, fxpMaxAmount, fill, price]: arr)
