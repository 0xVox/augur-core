# This software (Augur) allows buying and selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful, #    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

macro Controller: 0xC001D00D
extern Controller: [lookup:[int256]:int256, checkWhitelist:[int256]:int256]

BRANCHES = Controller.lookup('branches')
extern branches: [addCurrency:[int256,int256,int256,int256]:int256, addMarketToBranch:[int256,int256]:int256, disableCurrency:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getBranchesStartingAt:[int256]:int256[], getCreationDate:[int256]:int256, getBranchCurrency:[int256,int256]:int256, getCurrencyActive:[int256,int256]:int256, getCurrencyByContract:[int256,int256]:int256, getCurrencyRate:[int256,int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getForkTime:[int256]:int256, getInitialBalance:[int256,int256,int256]:int256, getMarketIDsInBranch:[int256,int256,int256]:int256[], getMinTradingFee:[int256]:int256, getMostRecentChild:[int256]:int256, getNumBranches:[]:int256, getNumCurrencies:[int256]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, getBranchWallet:[int256,int256]:int256, incrementPeriod:[int256]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256,int256,int256,int256]:int256, reactivateCurrency:[int256,int256]:int256, removeLastCurrency:[int256]:int256, replaceCurrency:[int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256,int256]:int256, setMostRecentChild:[int256,int256]:int256, updateCurrencyRate:[int256,int256,int256,int256]:int256, updateNumCurrencies:[int256,int256]:_]

MARKETS = Controller.lookup('markets')
extern markets: [addFees:[int256,int256]:int256, addOrder:[int256,int256]:int256, addToMarketsHash:[int256,int256]:int256, getBondsMan:[int256]:int256, getBranch:[int256]:int256, getCumulativeScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getGasSubsidy:[int256]:int256, getLastExpDate:[int256]:int256, getLastOrder:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketShareContracts:[int256]:int256[], getMarketsHash:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOrderIDs:[int256]:int256[], getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPrevID:[int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalOrders:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256,int256[]]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, removeOrderFromMarket:[int256,int256]:int256, returnTags:[int256]:int256[], setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]

EVENTS = Controller.lookup('events')
extern events: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, addReportersPaidSoFar:[int256]:int256, getBond:[int256]:int256, getChallenged:[int256]:int256, getCreationTime:[int256]:int256, getEarlyResolutionBond:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventPushedUp:[int256]:int256, getEventResolution:[int256]:bytes, getExpiration:[int256]:int256, getExtraBond:[int256]:int256, getFirstPreliminaryOutcome:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForkResolveAddress:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getMode:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportersPaidSoFar:[int256]:int256, getReportingThreshold:[int256]:int256, getResolutionAddress:[int256]:int256, getResolutionLength:[int256]:int256, getResolveBondPoster:[int256]:int256, getUncaughtOutcome:[int256]:int256, getEventInfo:[int256]:int256[], initializeEvent:[int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setChallenged:[int256]:int256, setCreationTime:[int256]:int256, setEarlyResolutionBond:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setExtraBond:[int256,int256]:int256, setFirstPreliminaryOutcome:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setMode:[int256,int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256]

ORDERS = Controller.lookup('orders')
extern orders: [checkHash:[int256,int256]:int256, commitOrder:[int256]:int256, fillOrder:[int256,int256,int256,int256]:int256, getAmount:[int256]:int256, getBestAsk:[int256,int256]:int256, getBestBid:[int256,int256]:int256, getID:[int256]:int256, getOrder:[int256]:int256[], getOrderOwner:[int256]:int256, getPrice:[int256]:int256, makeOrderHash:[int256,int256,int256]:int256, removeOrder:[int256]:int256, saveOrder:[int256,int256,int256,int256,int256,int256,int256,int256,int256]:int256]

INFO = Controller.lookup('info')
extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getCurrency:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, getWallet:[int256]:int256, setCurrencyAndWallet:[int256,int256,int256]:int256, setInfo:[int256,bytes,int256,int256,int256,int256]:int256]

MUTEX = Controller.lookup('mutex')
extern mutex: [getMutex:[]:int256, setMutex:[]:int256, unsetMutex:[]:int256]


### This allows you to place orders on the book and cancel them

# Warning: subcurrencies/tokens are untrusted contracts
extern subcurrency: [allowance:[address,address]:uint256, approve:[address,uint256]:uint256, balanceOf:[address]:uint256, decimals:[]:uint256, name:[]:uint256, symbol:[]:uint256, totalSupply:[]:uint256, transfer:[address,uint256]:uint256, transferFrom:[address,address,uint256]:uint256]
inset('../data_api/refund.se')
inset('logReturn.se')
inset('../data_api/float.se')

event logAddTx(market:indexed, sender:indexed, type, fxpPrice, fxpAmount, outcome, orderID, moneyEscrowed, sharesEscrowed)
event logCancel(market:indexed, sender:indexed, fxpPrice, fxpAmount, orderID, outcome, type, money, shares)
event bidAndAskLogReturn(returnValue)

# Order types
macro BID: 1
macro ASK: 2
# Field counts
macro ORDER_FIELDS: 10
# Boolean success/failure
macro FAILURE: 0
macro SUCCESS: 1

macro MIN_ORDER_VALUE: 10000000000000000
macro MAX_ORDER_VALUE: 1569275433846670190958947355801916604025L

#
# Buy / Sell actions: puts orders on the book
# Errors:
    #  0: market doesn't exist
    # -1: fxpAmount/fxpPrice bad
    # -2: oracle only branch
#
# costs 532k gas
# price is always in 10**18 fxp, amount is in the market's currency # of decimals, e.g. for 9 10**9 is 1 share [so buy 10**9 complete sets and it'll cost you 1 full unit of that currency or buy 10**9 at a fxpPrice of 10**18 it'll cost you 1 full unit of the currency]
# smallest order value is 0.00000001
def placeOrder(type, fxpAmount, fxpPrice, market, outcome):
    refund()
    if(MUTEX.getMutex()):
        throw()
    MUTEX.setMutex()

    saveOrder(type, fxpAmount, fxpPrice, market, outcome, msg.sender)
    MUTEX.unsetMutex()
    logReturn(bidAndAskLogReturn, FAILURE)

#
# Cancellation: cancels an order, if a bid refunds money, if an ask returns shares
# @returns 1 if success, 0 if failure
#
# 200k gas
def cancel(orderID):
    refund()
    if(MUTEX.getMutex()):
        throw()
    MUTEX.setMutex()

    # user can cancel anytime
    # Get order
    fetchOrderCancelInfo()
    # Check the owner
    if(msg.sender != owner):
        MUTEX.unsetMutex()
        logReturn(bidAndAskLogReturn, FAILURE)

    # Clear the order first
    removeOrder(orderID, market)
    refundOrder()
    # Log cancellation
    log(type = logCancel, market, msg.sender, fxpPrice, fxpAmount, orderID, outcome, type, moneyEscrowed, sharesEscrowed)
    MUTEX.unsetMutex()
    logReturn(bidAndAskLogReturn, SUCCESS)

macro saveOrder($type, $fxpAmount, $fxpPrice, $market, $outcome, $sender):
    $cumulativeScale = MARKETS.getCumulativeScale(market)
    $branch = MARKETS.getBranch(market)
    checkOrderPreconditions()

    $moneyEscrowed = 0
    $sharesEscrowed = 0
    $initialAmount = $fxpAmount

    if($type == ASK):
        placeAsk()
    if($type == BID):
        placeBid()
    else:
        throw()

    order = [$type, $market, $initialAmount, $fxpPrice, $sender, block.number, $outcome, $moneyEscrowed, $sharesEscrowed]
    orderID = sha3(order, items = 9)
    if(ORDERS.getID(orderID)):
        throw()
    ORDERS.saveOrder(orderID, $type, $market, $initialAmount, $fxpPrice, $sender, $outcome, $moneyEscrowed, $sharesEscrowed)
    # Update market
    MARKETS.addOrder($market, orderID)

    log(type = logAddTx, $market, $sender, $type, $fxpPrice, $initialAmount, $outcome, orderID, $moneyEscrowed, $sharesEscrowed)
    MUTEX.unsetMutex()
    logReturn(bidAndAskLogReturn, orderID)

macro refundOrder():
    # Issue refunds
    if(type == BID):
        # Return to user sharesEscrowed that weren't filled yet for all outcomes except the order outcome
        if(sharesEscrowed):
            i = 1
            while i < MARKETS.getNumOutcomes($market):
                if(i != outcome):
                    MARKETS.modifyParticipantShares($market, msg.sender, $outcome, sharesEscrowed, 0)
                i += 1
    elif(type == ASK):
        # shares refund if has shares escrowed for this outcome
        if(sharesEscrowed):
            MARKETS.modifyParticipantShares(market, msg.sender, outcome, sharesEscrowed, 0)
    else:
        throw()
    # Return to user moneyEscrowed that wasn't filled yet
    if(moneyEscrowed):
        refunded = INFO.getWallet(market).transfer(msg.sender, moneyEscrowed)
        if(!refunded):
            throw()

macro removeOrder($orderID, $market):
    ORDERS.removeOrder($orderID)
    MARKETS.removeOrderFromMarket($market, $orderID)

macro fetchOrderCancelInfo():
    order = array(ORDER_FIELDS)
    order = ORDERS.getOrder(orderID, outitems = ORDER_FIELDS)
    if(!order[0]):
        MUTEX.unsetMutex()
        return(0)
    type = order[1]
    market = order[2]
    fxpAmount = order[3]
    fxpPrice = order[4]
    owner = order[5]
    outcome = order[7]
    moneyEscrowed = order[8]
    sharesEscrowed = order[9]

macro checkOrderPreconditions():
    if(!$branch):
        MUTEX.unsetMutex()
        return(0)
    if(BRANCHES.getOracleOnly($branch)):
        MUTEX.unsetMutex()
        return(-2)

macro placeAsk():
    # Check if there are any "crossed orders" (i.e., bid orders
    # at a price greater than or equal to the sell price).
    bestBidID = ORDERS.getBestBid($market, $outcome)
    bestBidPrice = ORDERS.getPrice(bestBidID)
    if bestBidID != 0 and $fxpPrice <= bestBidPrice and ORDERS.getAmount(bestBidID) >= safeFxpDiv(MIN_ORDER_VALUE, bestBidPrice):
        logReturn(bidAndAsk_logReturn, -5)

    # Take shares in escrow if user has shares
    sharesHeld = MARKETS.getParticipantSharesPurchased($market, msg.sender, $outcome)
    if(sharesHeld):
        $minValue = 0
        if(EVENTS.getNumOutcomes(MARKETS.getMarketEvent($market, 0)) > 2):
            $minValue = ONE
        else:
            $minValue = EVENTS.getMinValue(MARKETS.getMarketEvent($market, 0))
        price = $fxpPrice - $minValue
        cost = safeFxpMul($fxpAmount, price)
        if(price > cumulativeScale or cost < MIN_ORDER_VALUE or cost >= MAX_ORDER_VALUE):
            MUTEX.unsetMutex()
            return(-1)
        fill = min(sharesHeld, $fxpAmount)
        $fxpAmount -= fill
        $sharesEscrowed += fill
        MARKETS.modifyParticipantShares($market, msg.sender, $outcome, -fill, 0)

    # Take max minus price they want to sell at for the remainder of the amount that wasn't able to be used up above
    if($fxpAmount):
        $maxValue = 0
        if(EVENTS.getNumOutcomes(MARKETS.getMarketEvent($market, 0)) > 2):
            $maxValue = ONE
        else:
            $maxValue = EVENTS.getMaxValue(MARKETS.getMarketEvent($market, 0))
        costPerShareShorting = $maxValue - $fxpPrice
        orderCost = safeFxpMul($fxpAmount, costPerShareShorting)
        if(costPerShareShorting > cumulativeScale or orderCost < MIN_ORDER_VALUE or orderCost >= MAX_ORDER_VALUE):
            MUTEX.unsetMutex()
            return(-1)
        $moneyEscrowed += orderCost
        $paidOrderCost = INFO.getCurrency($market).transferFrom($sender, INFO.getWallet($market), orderCost)
        if(!paidOrderCost):
            throw()

macro placeBid():
    # Check if there are any "crossed orders" (i.e., ask orders
    # at a price less than or equal to the buy price).
    bestAskID = ORDERS.getBestAsk($market, $outcome)
    bestAskPrice = ORDERS.getPrice(bestAskID)
    if bestAskID != 0 and $fxpPrice >= bestAskPrice and ORDERS.getAmount(bestAskID) >= safeFxpDiv(MIN_ORDER_VALUE, bestAskPrice):
        logReturn(bidAndAsk_logReturn, -5)

    # If user owns n minus the one outcome we're buying escrow no money but escrow their shares in all the other outcomes.
    MAX_INT = 57896044618658097711785492504343953926634992332820282019728792003956564819967L
    sharesHeld = MAX_INT
    i = 1
    while i < MARKETS.getMarketNumOutcomes($market):
        if(i != $outcome):
            sharesHeld = min(MARKETS.getParticipantSharesPurchased($market, msg.sender, i), sharesHeld)
        i += 1
    if(sharesHeld):
        $minValue = 0
        if(EVENTS.getNumOutcomes(MARKETS.getMarketEvent($market, 0)) > 2):
            $minValue = ONE
        else:
            $minValue = EVENTS.getMinValue(MARKETS.getMarketEvent($market, 0))
        price = $fxpPrice - $minValue
        cost = safeFxpMul($fxpAmount, price)
        if(price > cumulativeScale or cost < MIN_ORDER_VALUE or cost >= MAX_ORDER_VALUE):
            MUTEX.unsetMutex()
            return(-1)
        fill = min(sharesHeld, $fxpAmount)
        $fxpAmount -= fill
        $sharesEscrowed += fill
        i = 1
        while i < MARKETS.getNumOutcomes($market):
            if(i != $outcome):
                MARKETS.modifyParticipantShares($market, msg.sender, i, -fill, 0)
            i += 1

    # Take money in escrow for price - min for the remainder of amount that wasn't able to be used up above. Make sure price - min isn't more than range
    if($fxpAmount):
        $minValue = 0
        if(EVENTS.getNumOutcomes(MARKETS.getMarketEvent($market, 0)) > 2):
            $minValue = ONE
        else:
            $minValue = EVENTS.getMinValue(MARKETS.getMarketEvent($market, 0))
        price = $fxpPrice - $minValue
        cost = safeFxpMul($fxpAmount, price)
        $moneyEscrowed += cost
        if(price > cumulativeScale or cost < MIN_ORDER_VALUE or cost >= MAX_ORDER_VALUE):
            MUTEX.unsetMutex()
            return(-1)
        $paidOrderCost = INFO.getCurrency($market).transferFrom($sender, INFO.getWallet($market), cost)
        if(!$paidOrderCost):
            throw()
