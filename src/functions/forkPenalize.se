import info as INFO
import cash as CASH
import branches as BRANCHES
import reporting as REPORTING
import events as EVENTS
import markets as MARKETS
import backstops as BACKSTOPS
import sendReputation as SENDREP
import roundTwo as ROUNDTWO
import expiringEvents as EXPEVENTS
import createBranch as CREATEBRANCH
inset('refund.se')

# rbcr is done as a normal event where everyone reports on it
# only called on the fork not the parent, normal penalization except the values are forkOutcome and forkEthicality as opposed to anything else
# some rep from this goes to bond poster, original / last period report is actually what a user reported on the parent for the round 2 bond vote, they lose rep as well as people this time who report wrong
# branch is fork
def penalizeOnForkedEvent(branch, event):
    if(EVENTS.getForked(event)==0):
        return(-1)
    # means event / fork isn't resolved
    if(EVENTS.getForkedDone(event)==0):
        return(-2)
    repBalance = REPORTING.getRepBalance(branch, msg.sender)
    lastPeriod = BRANCHES.getVotePeriod(branch)-1
    if(!self.branch[branch].penalized[lastPeriod][msg.sender].notEnoughReportsPenalized):
        return(-3)
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
        return(-2)
    if(EVENTS.getOriginalExpiration(event)!=EVENTS.getExpiration(event) && MARKETS.getPushedForward(market)):
        if(lastPeriod==EVENTS.getOriginalExpiration(event)/BRANCHES.getPeriodLength(branch)):
            return(-1)

    newRep = 0
    newAfterRep = 0
    smoothedRep = 0
    totalRepDifference = 0
    outcome = catch(EVENTS.getForkOutcome(event))
    reportValue = EXPEVENTS.getReport(branch, lastPeriod, event, msg.sender)
    lastPenalizationPeriod = lastPeriod - 1
    oldReport = EXPEVENTS.getReport(BRANCHES.getParent(branch), lastPenalizationPeriod, msg.sender)
    p = self.proportionCorrectForkEvent(event)
    if(scalar(event) or categorical(event)):
        outcome = EVENTS.getForkOutcome(event)
    oldRep = EXPEVENTS.getBeforeRep(branch, lastPeriod, msg.sender)

    # Do the first rbcr based on first report and final outcome if reported first time
    if(oldReport && !self.branch[branch].penalized[lastPeriod][msg.sender].event[event] && outcome!=0):
        oldEthics = EXPEVENTS.getEthicReport(BRANCHES.getParent(branch), lastPenalizationPeriod, event, msg.sender)
        # wrong
        #184467440737095520 == 0.01 in fxp
        if(oldReport > outcome+184467440737095520 or oldReport < outcome-184467440737095520):
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                diff = oldReport - outcome
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*p - ONE)/ONE
        # right
        else:
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                diff = oldReport - outcome
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
        #smoothedRep = oldRep*.8 + newRep*.2
        smoothedRep = oldRep * 14757395258967642112/ONE + newRep * 3689348814741910528/ONE
        repChange = smoothedRep - oldRep
        newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender) + repChange
        EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        totalRepDifference = repChange
        # for ethicality if diff. appeal then pay back the fork bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively
        if(oldEthics != ethic_catch(EVENTS.getEthical(event)) && totalRepDifference >=0):
            totalRepDifference = -184467440737095520*repBalance / ONE
        if(repBalance + totalRepDifference <= 0):
            totalRepDifference = -1*repBalance
        # reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, rest goes to branch as usual later in the process
        if(self.bondPaid[event] < self.bondAmount[branch]*2 && totalRepDifference < 0):
            # done instead of sending to redistrib. pool
            REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), totalRepDifference)
            # sends that rep to the bonded challenger
            REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, self.forking[event].bondPoster), -totalRepDifference)
            self.bondPaid[event] += -1*totalRepDifference
    
    # Do the second (for each user) based on second report and final outcome
    if(reportValue && !self.branch[branch].penalized[lastPeriod][msg.sender].event[event] && outcome!=0):
        ethics = EXPEVENTS.getEthicReport(branch, lastPeriod, event, msg.sender)
        # wrong
        #184467440737095520 == 0.01 in fxp
        if(reportValue > outcome+184467440737095520 or reportValue < outcome-184467440737095520):
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                diff = reportValue - outcome
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*p - ONE)/ONE
        # right
        else:
            if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
                diff = reportValue - outcome    
                p = -(abs(diff)/2) + ONE
            newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
        #smoothedRep = oldRep*.8 + newRep*.2
        smoothedRep = oldRep * 14757395258967642112/ONE + newRep * 3689348814741910528/ONE
        repChange = smoothedRep - oldRep
        newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender) + repChange
        EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
        totalRepDifference = repChange
        # for ethicality if diff. appeal then pay back the fork bond from people who reported the wrong ethicality, but don't take rep beyond that and max at 20% of their rep respectively
        if(ethics != ethic_catch(EVENTS.getEthical(event)) && totalRepDifference >=0):
            totalRepDifference = -184467440737095520*repBalance / ONE
        if(repBalance + repChange <= 0):
            totalRepDifference = -1*repBalance
        if(self.bondPaid[event] < self.bondAmount[branch]*2 && totalRepDifference < 0):
            # done instead of sending to redistrib. pool
            REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), totalRepDifference)
            # sends that rep to the bonded challenger
            REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, self.forking[event].bondPoster), -totalRepDifference)
            self.bondPaid[event] += -1*totalRepDifference
        
        self.branch[branch].penalized[lastPeriod][msg.sender].event[event] = 1
        self.branch[branch].penalized[lastPeriod][msg.sender].num += 1
        if(EXPEVENTS.getNumReportsActual(branch, lastPeriod, msg.sender)==self.branch[branch].penalized[lastPeriod][msg.sender].num):
            if(newAfterRep <= 0):
                newAfterRep = 0
                EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
            self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod
            self.branch[branch].denominator[lastPeriod] += newAfterRep
            totalRepDifference = newAfterRep - oldRep
            if(repBalance + totalRepDifference <= 0):
                totalRepDifference = -1*repBalance
            if(totalRepDifference<0):
                # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), totalRepDifference)
                # sends that rep to the branch
                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), -totalRepDifference)
    return(1)

def proportionCorrectForkEvent(event):
    refund()
    p = 0
    outcome = catch(EVENTS.getForkOutcome(event))
    if(outcome!=0):
        # binary
        if(EVENTS.getNumOutcomes(event)==2 and EVENTS.getMaxValue(event)==TWO and EVENTS.getMinValue(event)==ONE):
            # subtract 1 to get it from 0 to 1
            avgOutcome = EVENTS.getForkOutcome(event) - ONE
            # say we have outcome of 0, avg is .4, what is p?
            # p is .6 or 60%
            if(outcome == ONE):
                p = ONE - avgOutcome
            # say we have outcome of 1, avg is .8, what is p (proportion correct)?
            # p is .8 or 80%
            if(outcome == 2 * ONE):
                p = avgOutcome
            if(outcome == 3 * ONEHALF):
                return(0)
        return(p)
    else:
        return(0)

macro scalar($event):
    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)
        
macro binary($event):
    (EVENTS.getNumOutcomes($event)==2 and EVENTS.getMaxValue($event)==TWO and EVENTS.getMinValue($event)==ONE)
        
macro categorical($event):
    (EVENTS.getNumOutcomes($event)>2)
    
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro abs($a):
    if($a<0):
        $a = -$a
    $a
    
# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD