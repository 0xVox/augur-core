# This software (Augur) allows buying and selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful, #    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

extern subcurrency: [allowance:[int256,int256]:int256, approve:[int256,int256]:int256, balance:[]:int256, balanceOf:[int256]:int256, ]:[int256,int256]:int256, transferFrom:[int256,int256,int256]:int256, changeTokens:[int256, int256]:int256, modifySupply:[int256]:int256]
inset('refund.se')
#todo remove redundant data

# Markets' index is the market, markets stores data about markets [which are able to be traded on] in augur
    # Events is a 0 indexed array of events in the market in the format of
        # [1, event, event, 2, event, 3, event, event, event]
        # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
    # Sharespurchased keeps track of the number of shares purchased for each outcome
        # sharesPurchased states starts at 1 - (same for participants[].shares[] array)
    # Participants is an array of participants, their addresses as keys and the shares in each outcome they've purchased of an event as the values
        # e.g. participants[addr].shares[1]
    # currentParticipant is the number of participants [traders] in the market
    # cumulativeScale == range of the market for scalars
    # numOutcomes is the number of outcomes in a market [up to 8 for now]
    # a binary outcome state 1 is no, 2 is true, 0 if not done, 1.5 if indeterminate
    # fxpTradingFee is a percent in fixedPoint and the base trading fee for a market
    # tradingPeriod is which eventExpPeriod market expires in
    # pushing forward is whether a market has been pushed forward to attempt early resolution
    # bondsman is the person/address who/that posted the early resolution bond
    # originalPeriod is the original period the market's event would resolve in
    # tradeIDs stores trades for a given market
    # lastTrade is the last trade that happened in a given market
    # totalTrades is the total number of trades in a give market
    # tags are the subject tags / categories / keywords for a given market
    # extraInfo is any extra info that didn't fit well in the regular description
    # sharesValue is the value of the shares traded in a given market
    # gasSubsidy is paid by the creator to pay for closing the market [closing is just setting the winning outcomes and allowing people to withdraw funds if they own winning shares]
    # fees is total fxpAmount of fees a market has paid to a branch [the reporters]
    # lastExpDate is when the market's last event expires
    # prices keeps track of the latest traded fxpPrice for a given outcome in a market
    # shareContracts stores the erc-20 token contract address for each outcome in the market
data Markets[](events[], lenEvents, sharesPurchased[], participants[](shares[]), winningOutcomes[], cumulativeScale, numOutcomes, tradingPeriod, fxpTradingFee, branch, volume, pushingForward, bondsMan, originalPeriod, tradeIDs[](id, nextID, prevID), lastTrade, totalTrades, tag1, tag2, tag3, extraInfo[], extraInfoLen, sharesValue, gasSubsidy, fees, lastExpDate, prices[], shareContracts[])

# takes branch as param, composite hash of all markets in the system
data marketsHash[]

def getMarketsHash(branch):
    callstackCheck()
    return(self.marketsHash[branch])

def addToMarketsHash(branch, newHash):
    callstackCheck()
    x = array(2)
    x[0] = self.marketsHash[branch]
    x[1] = newHash
    self.marketsHash[branch] = sha3(x, items = 2)
    return(1)

def addFees(market, fxpAmount):
    callstackCheck()
    self.Markets[market].fees += fxpAmount
    return(1)

def setPrice(market, outcome, fxpPrice):
    callstackCheck()
    self.Markets[market].prices[outcome] = fxpPrice
    return(1)

# refund closing cost for a market
def refundClosing(market, to):
    callstackCheck()
    subsidy = self.Markets[market].gasSubsidy
    self.Markets[market].gasSubsidy -= subsidy
    if(!send(to, subsidy)):
        throw()
    return(1)

def getLastExpDate(market):
    callstackCheck()
    return(self.Markets[market].lastExpDate)

# @return fxp
def getLastOutcomePrice(market, outcome):
    callstackCheck()
    return(self.Markets[market].prices[outcome])

# @return fxp
def getFees(market):
    callstackCheck()
    return(self.Markets[market].fees)

def getgasSubsidy(market):
    callstackCheck()
    return(self.Markets[market].gasSubsidy)

# @return fxp
def getSharesValue(market):
    callstackCheck()
    return(self.Markets[market].sharesValue)

def returnTags(market):
    callstackCheck()
    tags = array(3)
    tags[0] = self.Markets[market].tag1
    tags[1] = self.Markets[market].tag2
    tags[2] = self.Markets[market].tag3
    return(tags: arr)

# @return fxp
def getTotalSharesPurchased(market):
    callstackCheck()
    total = 0
    n = self.Markets[market].numOutcomes
    i = 1
    while(i <= n):
        total += self.Markets[market].sharesPurchased[i]
        i += 1
    return(total)

def getMarketEvent(market, index):
    callstackCheck()
    return(self.Markets[market].events[index])

def getMarketEvents(market):
    callstackCheck()
    return(load(self.Markets[market].events[0], items = self.Markets[market].lenEvents): arr)
    
def getMarketShareContracts(market):
    callstackCheck()
    return(load(self.Markets[market].shareContracts[0], items = self.Markets[market].numOutcomes): arr)

# @return fxp
def getSharesPurchased(market, outcome):
    callstackCheck()
    return(self.Markets[market].sharesPurchased[outcome])

def getExtraInfo(market):
    callstackCheck()
    length = self.Markets[market].extraInfoLen
    return(load(self.Markets[market].extraInfo[0], chars = length): str)

# @return fxp
def getVolume(market):
    callstackCheck()
    return(self.Markets[market].volume)

# @return fxp
def getParticipantSharesPurchased(market, trader, outcome):
    callstackCheck()
    return(self.Markets[market].shareContracts[outcome].balanceOf(trader))

def getNumEvents(market):
    callstackCheck()
    return(self.Markets[market].lenEvents)

# @return fxp
def getCumulativeScale(market):
    callstackCheck()
    return(self.Markets[market].cumulativeScale)

def getMarketNumOutcomes(market):
    callstackCheck()
    return(self.Markets[market].numOutcomes)

def getTradingPeriod(market):
    callstackCheck()
    return(self.Markets[market].tradingPeriod)

def getOriginalTradingPeriod(market):
    callstackCheck()
    return(self.Markets[market].originalPeriod)

def setTradingPeriod(market, period):
    callstackCheck()
    self.Markets[market].tradingPeriod = period
    return(1)

def getTradingFee(market):
    callstackCheck()
    return(self.Markets[market].fxpTradingFee)

def getBranch(market):
    callstackCheck()
    return(self.Markets[market].branch)

macro market($market):
    self.Markets[$market]

macro fxpcumulativeScale($market):
    market($market).cumulativeScale

macro numOutcomes($market):
    market($market).numOutcomes

macro sharesPurchased($market):
    market($market).sharesPurchased

# check that msg.sender is one of our function contracts
def initializeMarket(market, events: arr, tradingPeriod, fxpTradingFee, branch, tag1, tag2, tag3, fxpcumulativeScale, numOutcomes, extraInfo: str, gasSubsidy, fxpCreationFee, lastExpDate, shareContracts: arr):
    callstackCheck()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # add event list to the market
    save(self.Markets[market].events[0], events, items = len(events))
    save(self.Markets[market].shareContracts[0], shareContracts, items = numOutcomes)
    self.Markets[market].lenEvents = len(events)
    save(self.Markets[market].extraInfo[0], extraInfo, chars = len(extraInfo))
    self.Markets[market].extraInfoLen = len(extraInfo)
    self.Markets[market].tradingPeriod = tradingPeriod
    self.Markets[market].originalPeriod = tradingPeriod
    self.Markets[market].fxpTradingFee = fxpTradingFee
    self.Markets[market].branch = branch
    self.Markets[market].cumulativeScale = fxpcumulativeScale
    self.Markets[market].numOutcomes = numOutcomes
    self.Markets[market].tag1 = tag1
    self.Markets[market].tag2 = tag2
    self.Markets[market].gasSubsidy = gasSubsidy
    self.Markets[market].tag3 = tag3
    self.Markets[market].fees = fxpCreationFee
    self.Markets[market].lastExpDate = lastExpDate
    self.addToMarketsHash(branch, market)
    return(1)

def modifyShares(market, outcome, fxpAmount):
    callstackCheck()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    sharesPurchased(market)[outcome] += fxpAmount
    self.Markets[market].shareContracts[outcome].modifySupply(fxpAmount)
    return(1)

def modifySharesValue(market, fxpAmount):
    callstackCheck()
    self.Markets[market].sharesValue += fxpAmount
    return(1)

def modifyParticipantShares(market, trader, outcome, fxpAmount, actualTrade):
    callstackCheck()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Markets[market].shareContracts[outcome].changeTokens(trader, fxpAmount)
    if(actualTrade):
        if(fxpAmount < 0):
            fxpAmount = fxpAmount * -1
        self.Markets[market].volume += fxpAmount
    return(1)

def addTrade(market, tradeID):
    callstackCheck()
    self.Markets[market].tradeIDs[lastID].nextID = tradeID
    self.Markets[market].tradeIDs[tradeID].prevID = self.Markets[market].lastTrade
    self.Markets[market].tradeIDs[tradeID].id = tradeID
    self.Markets[market].lastTrade = tradeID
    self.Markets[market].totalTrades += 1
    return(1)

def removeTradeFromMarket(marketID, tradeID):
    callstackCheck()
    prevID = self.Markets[marketID].tradeIDs[tradeID].prevID
    nextID = self.Markets[marketID].tradeIDs[tradeID].nextID
    # if the trade had a previous and next trade it connects them directly, remove this tradeID from the sequence/middle
    if(prevID and nextID):
        self.Markets[marketID].tradeIDs[prevID].nextID = nextID
        self.Markets[marketID].tradeIDs[nextID].prevID = prevID
    # if it's the most recent trade, update the previous trade to be the most recent one
    elif(prevID):
        self.Markets[marketID].lastTrade = prevID
        self.Markets[marketID].tradeIDs[prevID].nextID = 0
    
    # if the trade had a trade following it, 0 out that slot
    if(nextID):
        self.Markets[marketID].tradeIDs[tradeID].nextID = 0
    # if the trade had a trade before it, 0 out that slot
    if(prevID):
        self.Markets[marketID].tradeIDs[tradeID].prevID = 0
    self.Markets[marketID].tradeIDs[tradeID].id = 0
    self.Markets[marketID].totalTrades -= 1
    return(1)

def getTradeIDs(marketID):
    callstackCheck()
    tradesCount = self.Markets[marketID].totalTrades
    tradeID = self.Markets[marketID].lastTrade
    tradeIDs = array(tradesCount)
    i = 0
    while(i < tradesCount):
        tradeIDs[i] = self.Markets[marketID].tradeIDs[tradeID].id
        tradeID = self.Markets[marketID].tradeIDs[tradeID].prevID
        i += 1

    if(tradeIDs):
        return(tradeIDs: arr)
    return([FAILURE]: arr)

def setWinningOutcomes(market, outcomes: arr):
    callstackCheck()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # largest # of winning outcomes is 8
    save(self.Markets[market].winningOutcomes[0], outcomes, items = len(outcomes))
    return(1)

def getWinningOutcomes(market):
    callstackCheck()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good, if not, log
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # largest # of winning outcomes is 8
    return(load(self.Markets[market].winningOutcomes[0], items = 8): arr)

def getOneWinningOutcome(market, num):
    # whitelist
    callstackCheck()
    return(self.Markets[market].winningOutcomes[num])

def setTradingFee(market, fee):
    callstackCheck()
    self.Markets[market].fxpTradingFee = fee
    return(fee)

def setPushedForward(market, bool, sender):
    callstackCheck()
    self.Markets[market].pushingForward = bool
    self.Markets[market].bondsMan = sender
    return(1)

def getPushedForward(market):
    callstackCheck()
    return(self.Markets[market].pushingForward)

def getBondsMan(market):
    callstackCheck()
    return(self.Markets[market].bondsMan)

def getLastTrade(market):
    callstackCheck()
    return(self.Markets[market].lastTrade)

def getPrevID(market, trade):
    callstackCheck()
    return(self.Markets[market].tradeIDs[trade].prevID)

def getTotalTrades(marketID):
    callstackCheck()
    return(self.Markets[marketID].totalTrades)

def getSender():
    callstackCheck()
    return(msg.sender)
