def init():
    description = text("Root branch")
    save(self.Info[1010101].description[0], description, chars=len(description))
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Info[1010101].descriptionLength = len(description)
    self.Reporting[1010101].repIDtoIndex[msg.sender] = 0
    self.Reporting[1010101].reputation[0].repValue = 0
    self.Reporting[1010101].reputation[0].reporterID = msg.sender
    self.Reporting[1010101].numberReporters = 2
    self.Reporting[1010101].repIDtoIndex[1010101] = 1
    self.Reporting[1010101].reputation[1].repValue = 0
    self.Reporting[1010101].reputation[1].reporterID = 1010101
    self.branch[1010101].baseReportersLastPeriod = 2*3
    self.Branches[1010101].currentVotePeriod = (block.timestamp / 15) - 1
    self.Branches[1010101].periodLength = 15 # 2 hours
    # .5%
    self.Branches[1010101].minTradingFee = 92233720368547760 
    self.branchListCount = 1
    self.branchList[0] = 1010101
    # since only have to report on half this targets 3
    self.Branches[1010101].baseReporters = 2*3
    # test initial funds
    self.cashcoinBalances[msg.sender] = 100000*ONE

inset('refund.se')

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](description[2048], descriptionLength, creator, creationFee)


def getDescription(ID):
    refund()
    length=self.Info[ID].descriptionLength
    return(load(self.Info[ID].description[0], chars=length): str)

def getDescriptionLength(ID):
    refund()
    return(self.Info[ID].descriptionLength)

def getCreator(ID):
    refund()
    return(self.Info[ID].creator)

def getCreationFee(ID):
    refund()
    return(self.Info[ID].creationFee)

# @return 1 if success, 0 if creator already exists
def setInfo(ID, description: str, creator, fee):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    # check that msg.sender is one of our function contracts
    if(self.Info[ID].creator == 0):
        save(self.Info[ID].description[0], description, chars=len(description))
        self.Info[ID].descriptionLength = len(description)
        self.Info[ID].creationFee = fee
        self.Info[ID].creator = creator
        return(1)
    else:
        return(0)
        
### Helper functions [only needed for tester, on chain in a separate file]:
macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)

macro categorical($event):
    (self.getNumOutcomes($event)>2)

macro abs($a):
    if($a<0):
        $a = -$a
    $a

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE
inset('refund.se')

# Storage of all data associated with reporters
    # Reporting index is the branchID
    # Reporters index is the rep. address
    # We 0 index reputation so can walk thru for consensus - todo / wrong don't need 0 indexing anymore
    # RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
    # total rep is all the rep in augur
    # active rep is the amount which is actually active
    # fork is the child branch of a parent which forked
    # dormant rep stores dormant rep values
data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep, dormantRep[](repValue, reporterID), activeRep, fork)

data whitelists[](addresses[], taken)


def checkWhitelist(address):
    refund()
    return(self.whitelists[msg.sender].addresses[address])

def getActiveRep(branch):
    return(self.Reporting[branch].activeRep)
    
def adjustActiveRep(branch, amount):
    self.Reporting[branch].activeRep += amount
    return(1)

def setFork(branch):
    self.Reporting[branch].fork = branch
    return(1)
    
def getFork(branch):
    return(self.Reporting[branch].fork)

def checkContractWhitelist(contract, address):
    refund()
    return(self.whitelists[contract].addresses[address])

def setWhitelist(contract, addresses:arr):
    refund()
    if self.whitelists[contract].taken:
        return(text("ERROR: you have to vote to change a whitelist"):str)
    else:
        self.whitelists[contract].taken = 1
        i = 0
        l = len(addresses)
        while i <l:
            address = addresses[i]
            self.whitelists[contract].addresses[addresses] = 1
            i += 1
        return(text("SUCCESS"):str)

# @return reputation value
def getRepByIndex(branch, repIndex):
    refund()
    return(self.Reporting[branch].reputation[repIndex].repValue)

# @return reputation value
def getRepBalance(branch, address):
    refund()
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].reputation[repIndex].repValue)

def getDormantRepByIndex(branch, repIndex):
    refund()
    return(self.Reporting[branch].dormantRep[repIndex].repValue)

# @return reputation value
# getDormantRepBalance
def balanceOf(branch, address):
    refund()
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].dormantRep[repIndex].repValue)
    
# return total supply of dormant rep
def totalSupply(branch):
    return((self.Reporting[branch].totalRep - self.Reporting[branch].activeRep))

def getReporterID(branch, index):
    refund()
    return(self.Reporting[branch].reputation[index].reporterID)

def getTotalRep(branch):
    refund()
    return(self.Reporting[branch].totalRep)

# will return 0s for array values after it's looped through all the ones you
# have an actual balance in
def getReputation(address):
    refund()
    branchListCount = self.getNumBranches()
    if(address):
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    else:
        address = msg.sender
        branches = array(2*branchListCount)
        branchList = array(branchListCount)
        branchList = self.getBranches(outitems=branchListCount)
        i = 0
        b = 0
        while i < branchListCount:
            branch = branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    return(branches: arr)

def getNumberReporters(branch):
    refund()
    return(self.Reporting[branch].numberReporters)

def repIDToIndex(branch, repID):
    refund()
    return(self.Reporting[branch].repIDtoIndex[repID])

# check that msg.sender is one of our function contracts
def setInitialReporters(parent, branchID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # add branch as a "reporter"
    self.Reporting[branchID].numberReporters = 1
    self.Reporting[branchID].repIDtoIndex[branchID] = 0
    self.Reporting[branchID].reputation[0].repValue = 0
    self.Reporting[branchID].reputation[0].reporterID = branchID
    return(1)

def addReporter(branch, sender, amount, dormant, repToBonderOrBranch):
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    refund()
    reporterIndex = self.Reporting[branch].numberReporters
    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex
    self.Reporting[branch].reputation[reporterIndex].repValue = amount
    self.Reporting[branch].reputation[reporterIndex].reporterID = sender
    self.Reporting[branch].dormantRep[reporterIndex].reporterID = sender
    self.Reporting[branch].dormantRep[reporterIndex].repValue = dormant
    self.Reporting[branch].activeRep += amount + repToBonderOrBranch
    self.Reporting[branch].totalRep += amount + dormant + repToBonderOrBranch
    self.Reporting[branch].numberReporters += 1
    return(1)

def addRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    if(safeToAdd(self.Reporting[branch].reputation[index].repValue, value)):
        self.Reporting[branch].reputation[index].repValue += value
        return(1)
    else:
        return(0)

def subtractRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    if(safeToSubtract(self.Reporting[branch].reputation[index].repValue, value)):
        self.Reporting[branch].reputation[index].repValue -= value
        return(1)
    else:
        return(0)

def setRep(branch, index, newRep):
    refund()
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    oldRep = self.Reporting[branch].reputation[index].repValue
    self.Reporting[branch].reputation[index].repValue = newRep
    self.Reporting[branch].activeRep += newRep - oldRep
    self.Reporting[branch].totalRep += newRep - oldRep
    return(1)

def addDormantRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue += value
    return(1)

def subtractDormantRep(branch, index, value):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Reporting[branch].dormantRep[index].repValue -= value
    return(1)

# check that msg.sender is one of our function contracts
# Sets the initial distribution of rep
def setSaleDistribution(addresses: arr, balances: arr, branchID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    i = 0
    while i < len(addresses):
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].repValue = balances[i]
        self.Reporting[branchID].dormantRep[self.Reporting[branchID].numberReporters].reporterID = addresses[i]
        self.Reporting[branchID].repIDtoIndex[addresses[i]] = self.Reporting[branchID].numberReporters
        self.Reporting[branchID].numberReporters += 1
        i+=1
    return(1)

# safe adders idea pulled from piper merriam's btcrelay audit
macro safeToAdd($a, $b):
    (($a + $b) >= $a)

macro safeToSubtract($a, $b):
    ($b <= $a)
macro fx_floor_log2($x):
    with $y = $x / 0x10000000000000000:
        with $lo = 0:
            with $hi = 191:
                with $mid = ($hi + $lo)/2:
                    while (($lo + 1) != $hi):
                        if $y < 2**$mid:
                            $hi = $mid
                        else:
                            $lo = $mid
                        $mid = ($hi + $lo)/2
                    $lo

macro fx_log2_small($x):
    with $result = -0x48A49EAD9B2CD16BE:
        with $temp = $x:
            $result += 0x124DC64B2741E5F083*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x36A569D528A96FF419*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x880785B1DE09970584*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x10AF33C52EB996E92A6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x19FD6E8AC1305DD6D3F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x2086485A91622AE7378*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x210382DF5A3175686B4*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1B58D71F02D9DA4F7B6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1288E14C2FB8C4C1595*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0xA44C5BBEB599D5AB38*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A0E619C630B69BC17*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1AE8CAEA63CF2593A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x7C3EF5A5BFC21BA1F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x1BD202FA82B683802*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x4A90858A0731AD74*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result -= 0x8CB3CD4376E76EF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA6B8F8E68CD877*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result - 0x5D5316875D9E3*$temp / 0x10000000000000000

macro fx_log2($x):
    with $y = fx_floor_log2($x):
        with $z = $x / 2**$y:
            $y * 0x10000000000000000 + fx_log2_small($z)

macro fx_log($x):
    fx_log2($x) * 0x10000000000000000 / 0x171547652B82FE177

macro fx_exp2_small($x):
    with $result = 0x10000000000000000:
        with $temp = $x:
            $result += 0xB17217F7D1CF79AC*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x3D7F7BFF058B1D56*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xE35846B82505F32*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x276556DF749D7C6*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x5761FF9E294A6F*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xA184897C5558D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0xFFE5FE24386C*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x162C023B2A1D*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1B5250C02BF*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E4D3F1A83*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1E87B8E21*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x1C768AA3*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result += 0x164F0A9*$temp / 0x10000000000000000
            $temp = $temp*$x / 0x10000000000000000
            $result + 0x1B08D3*$temp / 0x10000000000000000

macro fx_exp2($x):
    with $y = $x / 0x10000000000000000:
        with $z = $x % 0x10000000000000000:
            fx_exp2_small($z) * 2**$y

macro fx_exp($x):
    fx_exp2($x * 0x10000000000000000 / 0xB17217F7D1CF79AC)

# Calculates the exponential function given a fixed point [base 2^64] number, so e^x
def fx_exp(x):
    return(fx_exp(x))

# Calculates the natural log function given a fixed point [base 2^64] number, so ln(x)
def fx_log(x):
    return(fx_log(x))
inset('refund.se')

# Keeps track of data for round two backstop [where everyone reports on something] using event as the index
    # final is whether an event is final
    # bondReturned is whether the bond principle has been returned
    # bondPaid is how much on top of the bond principle has been paid to the bond poster
    # refund is subsidy to pay for round 2 event resolution function call
    # bondPoster is the account which posted the bond
    # original ethicality, outcome, and voteperiod specify the first round of consensus values for ethicality, outcome, and voteperiod, respectively
    # roundTwo states whether an event is a round two event
data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, originalEthicality, final, bondPoster, bondReturned, bondPaid, refund)

# Keeps track of data for the forking backstop [wherein the network is forked into two sets of rep] using event as the index
    # moved is used for stating whether an event has been moved to the winning fork
    # bondPaid is how much on top of the bond principle has been paid to the bond poster
    # bondAmount is the amount of the bond
    # bondPoster is the account which posted the bond
    # forkedOverEthicality states whether the event was forked due to controversy of ethicality
    # originalBranch is the branch the event was originally on
data forking[](bondPoster, bondAmount, forkedOverEthicality, bondPaid, originalBranch, moved)

# Given a branch and a forkPeriod it states which fork the winner was
data resolved[][]

def setRoundTwoRefund(event, amt):
    self.roundTwo[event].refund = amt
    return(1)
    
def doRoundTwoRefund(sender, event):
    send(sender, self.roundTwo[event].refund)
    return(1)

def setForkBondPoster(event, poster):
    self.forking[event].bondPoster = poster
    return(1)

def getForkBondPoster(event):
    return(self.forking[event].bondPoster)

def setForkedOverEthicality(event):
    self.forking[event].forkedOverEthicality = 1
    return(1)

def getForkedOverEthicality(event):
    return(self.forking[event].forkedOverEthicality)
    
def adjForkBondPaid(event, amount):
    self.forking[event].bondPaid += amount
    return(1)

def getForkBondPaid(event):
    return(self.forking[event].bondPaid)

# sets bond amount for a fork bond
def setBondAmount(event, amount):
    self.forking[event].bondAmount = amount
    return(1)

# gets bond amount for a fork bond
def getBondAmount(event):
    return(self.forking[event].bondAmount)

def setOriginalBranch(event, branch):
    self.forking[event].originalBranch = branch
    return(1)

def getOriginalBranch(event):
    return(self.forking[event].originalBranch)
    
def setMoved(event):
    self.forking[event].moved = 1
    return(1)

def getMoved(event):
    return(self.forking[event].moved)
    
def setResolved(branch, forkPeriod, winner):
    self.resolved[branch][forkPeriod] = winner
    return(1)

def getResolved(branch, forkPeriod):
    return(self.resolved[branch][forkPeriod])

# gets how much of round 2 bond has been paid back
def getBondPaid(event):
    return(self.roundTwo[event].bondPaid)

# increases how much of round 2 bond has been paid back
def increaseBondPaid(event, amount):
    self.roundTwo[event].bondPaid += amount
    return(1)

# whether a round 2 bond's principle has been returned
def getBondReturned(event):
    return(self.roundTwo[event].bondReturned)
    
def setBondReturned(event):
    self.roundTwo[event].bondReturned = 1
    return(1)

def getRoundTwo(event):
    refund()
    return(self.roundTwo[event].roundTwo)
    
def setRoundTwo(event, roundTwo):
    self.roundTwo[event].roundTwo = roundTwo
    return(1)
    
def getBondPoster(event):
    refund()
    return(self.roundTwo[event].bondPoster)

def setBondPoster(event, bondPoster):
    self.roundTwo[event].bondPoster = bondPoster
    return(1)

# whether a round 2 event is final
def getFinal(event):
    refund()
    return(self.roundTwo[event].final)

def setFinal(event):
    self.roundTwo[event].final = 1
    return(1)
    
def getOriginalOutcome(event):
    refund()
    return(self.roundTwo[event].originalOutcome)

def setOriginalOutcome(event, originalOutcome):
    self.roundTwo[event].originalOutcome = originalOutcome
    return(1)

def getOriginalEthicality(event):
    refund()
    return(self.roundTwo[event].originalEthicality)
    
def setOriginalEthicality(event, ethicality):
    self.roundTwo[event].originalEthicality = ethicality
    return(1)

def getOriginalVotePeriod(event):
    refund()
    return(self.roundTwo[event].originalVotePeriod)

def setOriginalVotePeriod(event, period):
    self.roundTwo[event].originalVotePeriod = period
    return(1)
macro sendRedistributedRepToBranch():
    if(newAfterRep <= 0):
        newAfterRep = 0
        self.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)
    self.setPenalizedUpTo(branch, msg.sender, lastPeriod)
    self.increaseDenominator(branch, lastPeriod, newAfterRep)
    totalRepDifference = newAfterRep - oldRep
    if(repBalance + totalRepDifference <= 0):
        totalRepDifference = -1*repBalance
    if(totalRepDifference < 0):
        # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]
        self.addRep(branch, self.repIDToIndex(branch, msg.sender), totalRepDifference)
        # sends that rep to the branch
        self.addRep(branch, self.repIDToIndex(branch, branch), -totalRepDifference)
inset('refund.se')

### This contract keeps track of data associated with reporting periods and the events + reports in them

# This keeps track of info in a period for the events in that period, it takes a branch and votePeriod as params, respectively
    # Events is 0 indexed and stores the events in a period [this allows the client to loop through and detect which events a given user should report on]
    # eventIDToIndex returns an event id for a given index in events
    # requiredEvents states whether a given event is required to be reported on or not [a round2 backstop or a fork event are both required]
    # subsidy is money for paying back a user for calculating the targeted num of reports for an event
    # eventWeight is number of reports on an event in a round 1 event, total rep reported on it in a backstop 1 or fork event
    # repEvent is the amount of rep that has reported on an event
    # lesserReportNum is the number of reports an event should have [the lesser of how many it can afford from fees and how many it should have due to outstanding share value]
    # numberEvents is the total number of events in a given reporting period
    # roundTwoNumEvents is the number of round 2 events in a given reporting period
    # numReqEvents is the number of events that are required to be reported on in a given reporting period
    # numberRemoved is the number of events that no longer have to be reported on in this period [a good example is an event that was resolved early successfully]
    # numEventsToReportOn is the number of events available for reporting on [not including required events] * base number of reporters per event [this is multiplied by a user's periodRepWeight to figure out how many events they should be reporting on in a given period]
    # shareValue is the value of all the outstanding shares from markets that have events expiring in this period 
data periodEventInfo[][](events[], eventIDToIndex[], requiredEvents[], subsidy[], eventWeight[], lesserReportNum[], numberEvents, roundTwoNumEvents, numReqEvents, numberRemoved, numEventsToReportOn, shareValue)

# This keeps track of info in a period for the reporters, it takes a branch and votePeriod as params, respectively
    # Before rep is the amount of active rep a user has before any penalizations for reporting incorrectly
    # After rep is the amount of active rep a user has after all the modifications to their rep at the end of a period [it's initially equal to the before rep]
    # Period dormant rep is how much rep a user has dormant at the start of a period
    # Report hash stores the hash of a report&salt a user submitted for a given report [takes reporter, event as params]
    # Salty encrypted hash stores an encrypted concatenation of the salt and a report: it allows users to easily migrate across devices [takes reporter, event as params]
    # Report is the report a reporter submitted for a given event [takes reporter, event as params]
    # Ethics is the ethicality a reporter submitted for a given event [takes reporter, event as params]
    # numReportsSubmitted is the number of a reports a reporter has submitted for this period
    # periodRepWeight is a weighting used to calculate how many events a reporter should report on in a given period
data reporterPeriodInfo[][](beforeRep[], afterRep[], periodDormantRep[], reportHash[][], saltyEncryptedHash[][], report[][], ethics[][], numReportsSubmitted[], periodRepWeight[])

# This takes a period and event as params (e.g self.modeItems[period][event]) and stores mode data for categorical & scalar event reports
    # reportValue takes a possible reported value [say .72 in fixed point] as a key and the value is how many reports that event has, or in the case of a backstop, how much rep has reported on that event
    # currentMode keeps track of the current mode report for an event or which reportValue key has the highest value of reports/rep reported on it
    # currentModeItems is how many reports or rep reported the current mode has, which is used in determining whether there's a new mode
data modeItems[][](reportValue[], currentMode, currentModeItems)

def getSaltyEncryptedHash(branch, period, reporter, event):
    refund()
    return(self.reporterPeriodInfo[branch][period].saltyEncryptedHash[reporter][event])

def setSaltyEncryptedHash(branch, period, reporter, saltyEncryptedHash, event):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.reporterPeriodInfo[branch][period].saltyEncryptedHash[reporter][event] = saltyEncryptedHash
    return(1)
    
# todo fix sec.
def refundCost(to, value):
    send(to, value)
    return(1)

def getSubsidy(branch, period, event):
    return(self.periodEventInfo[branch][period].subsidy[event])

def getPeriodRepWeight(branch, votePeriod, sender):
    return(self.reporterPeriodInfo[branch][votePeriod].periodRepWeight[sender])

def setPeriodRepWeight(branch, votePeriod, sender, value):
    self.reporterPeriodInfo[branch][votePeriod].periodRepWeight[sender] = value
    return(1)

def getReportHash(branch, period, reporter, event):
    refund()
    return(self.reporterPeriodInfo[branch][period].reportHash[reporter][event])

def setEthicReport(branch, period, event, ethics, sender):
    self.reporterPeriodInfo[branch][period].ethics[sender][event] = ethics
    return(1)

def setReport(branch, period, event, report, sender):
    self.reporterPeriodInfo[branch][period].report[sender][event] = report
    return(1)

def setBeforeRep(branch, period, rep, sender):
    self.reporterPeriodInfo[branch][period].beforeRep[sender] = rep
    return(rep)

def setAfterRep(branch, period, rep, sender):
    self.reporterPeriodInfo[branch][period].afterRep[sender] = rep
    return(rep)

def setPeriodDormantRep(branch, period, rep, sender):
    self.reporterPeriodInfo[branch][period].periodDormantRep[sender] = rep
    return(rep)

def getLesserReportNum(branch, period, event):
    return(self.periodEventInfo[branch][period].lesserReportNum[event])

def getCurrentModeItems(period, event):
    return(self.modeItems[period][event].currentModeItems)

def getCurrentMode(period, event):
    return(self.modeItems[period][event].currentMode)
    
# returns weight of a report value for the mode
def getWeightOfReport(period, event, report):
    return(self.modeItems[period][event].reportValue[report])

def getEthicReport(branch, period, event, sender):
    return(self.reporterPeriodInfo[branch][period].ethics[sender][event])

def getReport(branch, period, event, sender):
    #if(whitelist):
    return(self.reporterPeriodInfo[branch][period].report[sender][event])

def getBeforeRep(branch, period, sender):
    return(self.reporterPeriodInfo[branch][period].beforeRep[sender])

def getAfterRep(branch, period, sender):
    return(self.reporterPeriodInfo[branch][period].afterRep[sender])
    
def getPeriodDormantRep(branch, period, sender):
    return(self.reporterPeriodInfo[branch][period].periodDormantRep[sender])

def getNumReportsSubmitted(branch, votePeriod, sender):
    return(self.reporterPeriodInfo[branch][votePeriod].numReportsSubmitted[sender])

def getEventWeight(branch, votePeriod, eventID):
    return(self.periodEventInfo[branch][votePeriod].eventWeight[eventID])

def getNumRoundTwo(branch, period):
    refund()
    return(self.periodEventInfo[branch][period].roundTwoNumEvents)

def addRoundTwo(branch, period):
    refund()
    self.periodEventInfo[branch][period].roundTwoNumEvents += 1
    return(1)

def getRequired(event, period, branch):
    return(self.periodEventInfo[branch][period].requiredEvents[event])
    
def getNumRequired(branch, period):
    return(self.periodEventInfo[branch][period].numReqEvents)
    
# Return 0 means already required
def setEventRequired(branch, period, event):
    if(self.periodEventInfo[branch][period].requiredEvents[event]==0):
        self.periodEventInfo[branch][period].requiredEvents[event] = 1
        self.periodEventInfo[branch][period].numReqEvents += 1
        return(1)
    else:
        return(0)

# With this function you can get the eventIDs and report on outcomes
# @return all events in a branch and expiration period
def getEvents(branch, period):
    refund()
    numEvents = self.periodEventInfo[branch][period].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.periodEventInfo[branch][period].events[i]
        i += 1
    return(events: arr)
    
def getEventsRange(branch, period, start, end):
    refund()
    numEvents = end-start
    events = array(numEvents)
    i = start
    index = 0
    while i < end:
        events[index] = self.periodEventInfo[branch][period].events[i]
        index += 1
        i += 1
    return(events: arr)
    
def getEventIndex(branch, period, eventID):
    refund()
    return(self.periodEventInfo[branch][period].eventIDToIndex[eventID])

# gets number of available events to report on, not counting required events
# -1: voting not started
def setNumEventsToReportOn(branch):
    # whitelist to only makeReports
    period = self.getVotePeriod(branch)
    self.periodEventInfo[branch][period].numEventsToReportOn = (self.periodEventInfo[branch][period].numberEvents - self.periodEventInfo[branch][period].numReqEvents - self.periodEventInfo[branch][period].numberRemoved)*self.getBaseReporters(branch)
    return(1)

# gets number of available events to report on, not counting required events
def getNumEventsToReportOn(branch, period):
    refund()
    return(self.periodEventInfo[branch][period].numEventsToReportOn)

def getShareValue(branch, expIndex):
    refund()
    return(self.periodEventInfo[branch][expIndex].shareValue)

def getNumberEvents(branch, period):
    refund()
    return(self.periodEventInfo[branch][period].numberEvents)

def getEvent(branch, period, eventIndex):
    refund()
    return(self.periodEventInfo[branch][period].events[eventIndex])

# check that msg.sender is one of our function contracts
def addEvent(branch, futurePeriod, eventID, subsidy):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.periodEventInfo[branch][futurePeriod].events[self.periodEventInfo[branch][futurePeriod].numberEvents] = eventID
    self.periodEventInfo[branch][futurePeriod].eventIDToIndex[eventID] = self.periodEventInfo[branch][futurePeriod].numberEvents
    self.periodEventInfo[branch][futurePeriod].numberEvents += 1
    self.periodEventInfo[branch][futurePeriod].subsidy[eventID] += subsidy
    return(1)

def deleteEvent(branch, period, event):
    i = self.periodEventInfo[branch][period].eventIDToIndex[event]
    self.periodEventInfo[branch][period].events[i] = 0
    self.periodEventInfo[branch][period].eventIDToIndex[event] = 0
    return(1)

def removeEvent(branch, period):
    refund()
    self.periodEventInfo[branch][period].numberRemoved += 1
    return(1)

def getNumRemoved(branch, period):
    refund()
    return(self.periodEventInfo[branch][period].numberRemoved)

def adjustPeriodShareValueOutstanding(branch, expIndex, amount):
    refund()
    self.periodEventInfo[branch][expIndex].shareValue += amount
    return(1)

def setReportHash(branch, period, reporter, reportHash, event):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.reporterPeriodInfo[branch][period].reportHash[reporter][event] = reportHash
    return(1)

# called in case an event doesn't get reported on at all in a period
def moveEvent(branch, event):
    if(self.getVotePeriod(branch) > self.getExpiration(event)/self.getPeriodLength(branch) && !self.getUncaughtOutcome(event)):
        # add to next expiration period
        self.addEvent(branch, block.timestamp/self.getPeriodLength(branch), event)
        self.setExpiration(event, block.timestamp)
        return(1)
    else:
        return(0)

def addToWeightOfReport(period, event, report, amount):
    self.modeItems[period][event].reportValue[report] += amount
    return(1)

def setCurrentMode(period, event, mode):
    self.modeItems[period][event].currentMode = mode
    return(1)

# basically setting current mode's weight
def setCurrentModeItems(period, event, modeReport):
    self.modeItems[period][event].currentModeItems = self.modeItems[period][event].reportValue[modeReport]
    return(1)

def setEventWeight(branch, votePeriod, eventID, num):
    self.periodEventInfo[branch][votePeriod].eventWeight[eventID] = num
    return(1)

def countReportAsSubmitted(branch, votePeriod, eventID, sender, weight):
    self.periodEventInfo[branch][votePeriod].eventWeight[eventID] += weight
    self.reporterPeriodInfo[branch][votePeriod].numReportsSubmitted[sender] += 1
    return(1)

def setLesserReportNum(branch, period, event, num):
    self.periodEventInfo[branch][period].lesserReportNum[event] = num
    return(1)

macro proportionCorrect(event, forkEvent):
    refund()
    p = 0
    if(forkEvent):
        uncaught = self.getForkOutcome(event)
        outcome = catch(uncaught)
        # subtract 1 to get it from 0 to 1
        avgOutcome = uncaught - ONE
    else:
        uncaught = self.getUncaughtOutcome(event)        
        outcome = catch(uncaught)
        # subtract 1 to get it from 0 to 1
        avgOutcome = uncaught - ONE
        return(0)
    # binary
    if(self.getNumOutcomes(event)==2 and self.getMaxValue(event)==TWO and self.getMinValue(event)==ONE):
        # say we have outcome of 0, avg is .4, what is p?
            # p is .6 or 60%
        if(outcome == ONE):
            p = ONE - avgOutcome
        # say we have outcome of 1, avg is .8, what is p (proportion correct)?
            # p is .8 or 80%
        elif(outcome == 2 * ONE):
            p = avgOutcome
        # unneeded but nice to know that in indeterminate case it'll return 0
        #elif(outcome == 3 * ONEHALF):
        #    return(0)
    p

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro binary($event):
    (self.getNumOutcomes($event)==2 and self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)

macro categorical($event):
    (self.getNumOutcomes($event)>2)

macro abs($a):
    if($a<0):
        $a = -$a
    $a

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE
inset('refund.se')

# Storage for branch data
# branch takes a branchID
    # penalized takes for a given period a user / address reported for a certain event and num of events they reported on in that period in total
    # penalizedUpTo is the latest period a user has done the penalization for
    # fees collected states whether for a given period a user collected fees
    # rep collected states whether for a given period a user collected rep
    # base reporters last period is the minimum number of reporters for the last period
data branch[](period[](denominator, penalized[](event[], num, notEnoughReportsPenalized), feesCollected[], feeFirst, periodBalance), penalizedUpTo[], baseReportersLastPeriod)

# refunds keeps track of subsidies for various consensus function calls paid for by the market creator or bonders
data refunds[]

# Keeps track of whether a reporter has been penalized for collusion while reporting
data slashed[][](reporter[])


def getSlashed(branch, votePeriod, reporter):
    return(self.slashed[branch][votePeriod].reporter[reporter])
    
def setSlashed(branch, votePeriod, reporter):
    self.slashed[branch][votePeriod].reporter[reporter] = 1
    return(1)

def setRefund(refunder, amt):
    self.refunds[refunder] = amt
    return(1)
    
def doRefund(sender, refunder):
    send(sender, self.refunds[refunder])
    return(1)

def getBaseReportersLastPeriod(branch):
    return(self.branch[branch].baseReportersLastPeriod)

def setBaseReportersLastPeriod(branch, amount):
    self.branch[branch].baseReportersLastPeriod = amount
    return(1)

# get whether the first fee has been claimed by a reporter yet
def getFeeFirst(branch, period):
    return(self.branch[branch].period[period].feeFirst)

def setFeeFirst(branch, period, val):
    self.branch[branch].period[period].feeFirst = val
    return(1)

def getPeriodBalance(branch, period):
    return(self.branch[branch].period[period].periodBalance)

def setPeriodBalance(branch, period, balance):
    self.branch[branch].period[period].periodBalance = balance

def getPenalizedUpTo(branch, sender):
    return(self.branch[branch].penalizedUpTo[sender])

def setPenalizedUpTo(branch, sender, period):
    self.branch[branch].penalizedUpTo[sender] = period
    return(1)

def getDenominator(branch, period):
    return(self.branch[branch].period[period].denominator)

def increaseDenominator(branch, period, amount):
    self.branch[branch].period[period].denominator += amount
    return(1)
    
def decreaseDenominator(branch, period, amount):
    self.branch[branch].period[period].denominator -= amount
    return(1)

def getFeesCollected(branch, address, period):
    return(self.branch[branch].period[period].feesCollected[address])

def setFeesCollected(branch, address, period):
    self.branch[branch].period[period].feesCollected[address] = 1
    return(1)
    
def getPenalized(branch, period, sender, event):
    return(self.branch[branch].period[period].penalized[sender].event[event])

def setPenalized(branch, period, sender, event):
    self.branch[branch].period[period].penalized[sender].event[event] = 1
    return(1)

def getPenalizedNum(branch, period, sender):
    return(self.branch[branch].period[period].penalized[sender].num)    

def increasePenalizedNum(branch, period, sender, amount):
    self.branch[branch].period[period].penalized[sender].num += amount
    return(1)

def setNotEnoughPenalized(branch, address, period):
    self.branch[branch].period[period].penalized[address].notEnoughReportsPenalized = 1
    return(1)
    
def getNotEnoughPenalized(branch, address, period):
    return(self.branch[branch].period[period].penalized[address].notEnoughReportsPenalized)
    
def getRepRedistributionDone(branch, reporter):
    refund()
    return(repRedistributionDone(branch, reporter))

macro repRedistributionDone($branch, $reporter):
    lastPeriodPenalized = self.branch[$branch].penalizedUpTo[$reporter]
    lastPeriod = self.getVotePeriod($branch)-1
    if(lastPeriod==lastPeriodPenalized):
        1
    else:
        0
inset('refund.se')

# Branches keeps track of data associated with branches in augur
# Branches' index is the hash of the branch (aka branchID)
# currentVotePeriod is the current index in eventsExpDates and tells us which bucket of events are up to be
# voted on in the current vote period (should always be 1 behind block.timestamp/periodlength or current EventsExpDates index)
# currentExpPeriod = (block.timestamp / self.Branches[branch].periodLength)
# currentExpPeriod - 1 is what's up for reporting at any given time
# periodLength is the length in seconds of the branch's reporting period
# parentPeriod is the period the parent was in when the branch was created [useful for claiming rep after a fork]
# baseReporters the number of reporters which report on a market at a minimum
# forkPeriod is the period a branch was last forked over
# eventForkedOver is the event a branch was last forked over
# parent is the parent branch of the given branch
# How to set minimum reporting fee guidelines for reporters, abs. minimum should be calc. as follows:
    #Volume per period * .5 * fee * ev/ebit * 6 >= rep market cap
    #Say ev/ebit or valuation is 15, so:
    #45 * fee * volume per period = rep market cap
    #Want:
        #Rep market cap >> outstanding shares value at all times
# min can be no lower than ~0.0000001 or so otherwise can run into underflow isues
data Branches[](currentVotePeriod, periodLength, markets[], numMarkets, minTradingFee, balance[], creationDate, oracleOnly, parentPeriod, baseReporters, forkPeriod, eventForkedOver, parent)

# first param is the branch, second param is the subcurrency contract
data cash[][]

# keeps track of a list of all branches
data branchList[]
data branchListCount


# call once after uploading (externed method not allowed in init)
def initDefaultBranch():
    refund()
    return(self.initiateOwner(1010101))

# event a branch was most recently forked over
def getEventForkedOver(branch):
    return(self.Branches[branch].eventForkedOver)

def setEventForkedOver(branch, event):
    self.Branches[branch].eventForkedOver = event
    return(1)

def getBaseReporters(branch):
    refund()
    return(self.Branches[branch].baseReporters)
    
def setBaseReporters(branch, num):
    refund()
    self.Branches[branch].baseReporters = num
    return(1)

def getOracleOnly(branch):
    refund()
    return(self.Branches[branch].oracleOnly)

def getVotePeriod(branch):
    refund()
    return(self.Branches[branch].currentVotePeriod)

def getPeriodLength(branch):
    refund()
    return(self.Branches[branch].periodLength)

# branch cash balance at start of period
def setInitialBalance(branch, period, balance):
    refund()
    self.Branches[branch].balance[period] = balance
    return(balance)

def getInitialBalance(branch, period):
    refund()
    return(self.Branches[branch].balance[period])

# @return all markets in a branch
def getMarketsInBranch(branch):
    refund()
    numMarkets = self.Branches[branch].numMarkets
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[i]
        i += 1
    return(markets: arr)
   
   
def getParent(branch):
    return(self.Branches[branch].parent)

# @return all markets in a branch
def getSomeMarketsInBranch(branch, initial, last):
    refund()
    numMarkets = last - initial
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[initial+i]
        i += 1
    return(markets: arr)

def getNumMarketsBranch(branch):
    refund()
    return(self.Branches[branch].numMarkets)

def getMinTradingFee(branch):
    refund()
    return(self.Branches[branch].minTradingFee)

# @return all branches
def getBranches():
    refund()
    b = 0
    numBranches = self.branchListCount
    branches = array(numBranches)
    while b < numBranches:
        branches[b] = self.branchList[b]
        b += 1
    return(branches: arr)

def getNumBranches():
    refund()
    return(self.branchListCount)

def getBranchByNum(branchNumber):
    refund()
    return(self.branchList[branchNumber])

def getCreationDate(ID):
    refund()
    return(self.Branches[ID].creationDate)

# check that msg.sender is one of our function contracts
def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod, parent):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    if(self.Branches[ID].periodLength==0):
        self.Branches[ID].currentVotePeriod = currentVotePeriod
        self.Branches[ID].periodLength = periodLength
        self.Branches[ID].minTradingFee = minTradingFee
        self.branchList[self.branchListCount] = ID
        self.branchListCount += 1
        self.Branches[ID].creationDate = block.timestamp
        self.Branches[ID].parentPeriod = parentPeriod
        self.Branches[ID].oracleOnly = oracleOnly
        self.Branches[ID].parent = parent
        self.Branches[ID].baseReporters = self.Branches[parent].baseReporters
        self.initiateOwner(ID)
        return(1)
    else:
        return(0)

def getParentPeriod(branch):
    refund()
    return(self.Branches[branch].parentPeriod)

def incrementPeriod(branch):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    self.Branches[branch].currentVotePeriod += 1
    return(1)

# check that msg.sender is one of our function contracts
def addMarketToBranch(branch, market):
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    refund()
    numMarkets = self.Branches[branch].numMarkets
    self.Branches[branch].markets[numMarkets] = market
    self.Branches[branch].numMarkets += 1
    return(1)
    
def setForkPeriod(branch):
    self.Branches[branch].forkPeriod = self.Branches[branch].currentVotePeriod
    return(1)
    
# gets the period in which a branch was most recently forked
def getForkPeriod(branch):
    return(self.Branches[branch].forkPeriod)
macro refund():
    if(msg.value > 0):
        send(msg.sender, msg.value)

macro ONE: 2^64

macro WEITOETH: 10^18

macro THREEFOURTHS: 13835058055282163712

macro ONEFOURTH: 2**62

macro ONEHALF: 2**63

macro TWO: 2**65

macro TWENTYFOURHR: 86400

macro throw():
    i = 0
    while(1):
        i += 1
    i
inset('refund.se')

# Markets' index is the marketID, markets stores data about markets [which are able to be traded on] in augur
    # Events is a 0 indexed array of events in the market in the format of
        # [1, event, event, 2, event, 3, event, event, event]
        # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
    # Sharespurchased keeps track of the number of shares purchased for each outcome
        # sharesPurchased states starts at 1 - (same for participants[].shares[] array)
    # Participants is an array of participants, their addresses as keys and the shares in each outcome they've purchased of an event as the values
        # e.g. participants[addr].shares[1]
    # currentParticipant is the number of participants [traders] in the market
    # cumulativeScale == range of the market for scalars
    # numOutcomes is the number of outcomes in a market [up to 8 for now]
    # a binary outcome state 1 is no, 2 is true, 0 if not done, 1.5 if indeterminate
    # tradingFee is a percent in fixedPoint and the base trading fee for a market: takers pay 100%-150% of this, makers pay 0-50% of this
    # tradingPeriod is which eventExpPeriod market expires in
    # pushing forward is whether a market has been pushed forward to attempt early resolution
    # bondsman is the person/address who/that posted the early resolution bond
    # originalPeriod is the original period the market's event would resolve in
    # trade_ids stores trades for a given market
    # last_trade is the last trade that happened in a given market
    # total_trades is the total number of trades in a give market
    # tags are the subject tags / categories / keywords for a given market
    # makerFees - from 0-50% - amount of fee that the maker orders pay
    # extraInfo is any extra info that didn't fit well in the regular description
    # sharesValue is the value of the shares traded in a given market
    # gasSubsidy is paid by the creator to pay for closing the market [closing is just setting the winning outcomes and allowing people to withdraw funds if they own winning shares]
    # fees is total amount of fees a market has paid to a branch [the reporters]
    # lastExpDate is when the market's last event expires
    # prices keeps track of the latest traded price for a given outcome in a market
data Markets[](events[], lenEvents, sharesPurchased[], participants[](shares[]), winningOutcomes[], cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch, volume, pushingForward, bondsMan, originalPeriod, trade_ids[](id, next_id, prev_id), last_trade, total_trades, tag1, tag2, tag3, makerFees, extraInfo[], extraInfoLen, sharesValue, gasSubsidy, fees, creationTime, lastExpDate, prices[])

# takes branch as param, composite hash of all markets in the system
data marketsHash[]

def getMarketsHash(branch):
    return(self.marketsHash[branch])

def addToMarketsHash(branch, newHash):
    x = array(2)
    x[0] = self.marketsHash[branch]
    x[1] = newHash
    self.marketsHash[branch] = sha3(x, items=2)
    return(1)

def addFees(market, amount):
    self.Markets[market].fees += amount
    return(1)

def setPrice(market, outcome, price):
    self.Markets[market].prices[outcome] = price
    return(1)

# refund closing cost for a market
def refundClosing(market, to):
    subsidy = self.Markets[market].gasSubsidy
    self.Markets[market].gasSubsidy -= subsidy
    send(subsidy, to)
    return(1)

def getLastExpDate(market):
    return(self.Markets[market].lastExpDate)

def getLastOutcomePrice(market, outcome):
    return(self.Markets[market].prices[outcome])

def getFees(market):
    return(self.Markets[market].fees)

def getMakerFees(market):
    return(self.Markets[market].makerFees)

def getgasSubsidy(market):
    return(self.Markets[market].gasSubsidy)

def getSharesValue(market):
    return(self.Markets[market].sharesValue)

def returnTags(market):
    tags = array(3)
    tags[0] = self.Markets[market].tag1
    tags[1] = self.Markets[market].tag2
    tags[2] = self.Markets[market].tag3
    return(tags: arr)

def getTotalSharesPurchased(market):
    refund()
    total = 0
    n = self.Markets[market].numOutcomes
    i = 1
    while i <= n:
      total += self.Markets[market].sharesPurchased[i]
      i += 1
    return(total)

def getMarketEvent(market, index):
    refund()
    return(self.Markets[market].events[index])

def getCreationTime(market):
    return(self.Markets[market].creationTime)

def getMarketEvents(market):
    refund()
    return(load(self.Markets[market].events[0], items=self.Markets[market].lenEvents): arr)

def getSharesPurchased(market, outcome):
    refund()
    return(self.Markets[market].sharesPurchased[outcome])

def getExtraInfo(market):
    refund()
    length=self.Markets[market].extraInfoLen
    return(load(self.Markets[market].extraInfo[0], chars=length): str)

def getVolume(market):
    refund()
    return(self.Markets[market].volume)

def getParticipantSharesPurchased(market, trader, outcome):
    refund()
    return(self.Markets[market].participants[trader].shares[outcome])

def getNumEvents(market):
    refund()
    return(self.Markets[market].lenEvents)

def getCumScale(market):
    refund()
    return(self.Markets[market].cumulativeScale)

def getMarketNumOutcomes(market):
    refund()
    return(self.Markets[market].numOutcomes)

def getTradingPeriod(market):
    refund()
    return(self.Markets[market].tradingPeriod)

def getOriginalTradingPeriod(market):
    refund()
    return(self.Markets[market].originalPeriod)

def setTradingPeriod(market, period):
    refund()
    self.Markets[market].tradingPeriod = period
    return(1)

def getTradingFee(market):
    refund()
    return(self.Markets[market].tradingFee)

def getBranchID(market):
    refund()
    return(self.Markets[market].branch)

macro market($marketID):
    self.Markets[$marketID]

macro cumScale($marketID):
    market($marketID).cumulativeScale

macro numOutcomes($marketID):
    market($marketID).numOutcomes

macro sharesPurchased($marketID):
    market($marketID).sharesPurchased

# check that msg.sender is one of our function contracts
def initializeMarket(marketID, events: arr, tradingPeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumScale, numOutcomes, extraInfo: str, gasSubsidy, creationFee, lastExpDate):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # add event list to the market
    save(self.Markets[marketID].events[0], events, items=len(events))
    self.Markets[marketID].lenEvents = len(events)
    save(self.Markets[marketID].extraInfo[0], extraInfo, chars=len(extraInfo))
    self.Markets[marketID].extraInfoLen = len(extraInfo)
    self.Markets[marketID].tradingPeriod = tradingPeriod
    self.Markets[marketID].originalPeriod = tradingPeriod
    self.Markets[marketID].tradingFee = tradingFee
    self.Markets[marketID].branch = branch
    self.Markets[marketID].cumulativeScale = cumScale
    self.Markets[marketID].numOutcomes = numOutcomes
    self.Markets[marketID].tag1 = tag1
    self.Markets[marketID].tag2 = tag2
    self.Markets[marketID].gasSubsidy = gasSubsidy
    self.Markets[marketID].tag3 = tag3
    self.Markets[marketID].makerFees = makerFees
    self.Markets[marketID].fees = creationFee
    self.Markets[marketID].creationTime = block.timestamp
    self.Markets[marketID].lastExpDate = lastExpDate
    return(1)

def modifyShares(marketID, outcome, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    sharesPurchased(marketID)[outcome] += amount
    return(1)
    
def modifySharesValue(marketID, amount):
    self.Markets[marketID].sharesValue += amount
    return(1)

def modifyParticipantShares(marketID, trader, outcome, amount, cancel):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.Markets[marketID].participants[trader].shares[outcome] += amount
    if(amount<0):
        amount = amount*-1
    if(cancel):
        amount = -1*amount
    self.Markets[marketID].volume += amount
    return(1)   

def setWinningOutcomes(market, outcomes: arr):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # largest # of winning outcomes is 8
    save(self.Markets[market].winningOutcomes[0], outcomes, items=len(outcomes))
    return(1)

def getWinningOutcomes(market):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good, if not, log
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    # largest # of winning outcomes is 8
    return(load(self.Markets[market].winningOutcomes[0], items=8): arr)
    
def getOneWinningOutcome(market, num):
    refund()
    # whitelist
    return(self.Markets[market].winningOutcomes[num])

def setTradingFee(market, fee):
    refund()
    self.Markets[market].tradingFee = fee
    return(fee)

def setPushedForward(market, bool, sender):
    refund()
    self.Markets[market].pushingForward = bool
    self.Markets[market].bondsMan = sender
    return(1)

def getPushedForward(market):
    refund()
    return(self.Markets[market].pushingForward)

def getBondsMan(market):
    refund()
    return(self.Markets[market].bondsMan)

def getLastTrade(market):
    refund()
    return(self.Markets[market].last_trade)
    
def addTrade(market, trade_id, last_id):
    refund()
    self.Markets[market].trade_ids[last_id].next_id = trade_id
    self.Markets[market].trade_ids[trade_id].prev_id = last_id
    self.Markets[market].trade_ids[trade_id].id = trade_id
    self.Markets[market].last_trade = trade_id
    self.Markets[market].total_trades += 1
    return(1)
    
def remove_trade_from_market(market_id, trade_id):
    refund()
    prev_id = self.Markets[market_id].trade_ids[trade_id].prev_id
    next_id = self.Markets[market_id].trade_ids[trade_id].next_id
    if prev_id and next_id:
        self.Markets[market_id].trade_ids[prev_id].next_id = next_id
        self.Markets[market_id].trade_ids[next_id].prev_id = prev_id
    elif prev_id:
        self.Markets[market_id].last_trade = prev_id
        self.Markets[market_id].trade_ids[prev_id].next_id = 0

    if next_id:
        self.Markets[market_id].trade_ids[trade_id].next_id = 0
    if prev_id:
        self.Markets[market_id].trade_ids[trade_id].prev_id = 0
    self.Markets[market_id].trade_ids[trade_id].id = 0
    self.Markets[market_id].total_trades -= 1
    return(1)

def get_trade_ids(market_id):
    refund()
    trades_count = self.Markets[market_id].total_trades
    trade_id = self.Markets[market_id].last_trade
    trade_ids = array(trades_count)

    i = 0
    while i < trades_count:
        trade_ids[i] = self.Markets[market_id].trade_ids[trade_id].id
        trade_id = self.Markets[market_id].trade_ids[trade_id].prev_id
        i += 1

    if trade_ids:
        return(trade_ids:arr)
    return([FAILURE]:arr)
    
def get_total_trades(market_id):
    refund()
    return(self.Markets[market_id].total_trades)

def getSender():
    return(msg.sender)

inset('refund.se')

macro TRADE_FIELDS: 8
macro EVENTS_FIELDS: 6
macro OUTCOMES_FIELDS: 2
macro WINNING_OUTCOMES_FIELDS: 8
macro BASE_FIELDS: 17

def getOrderBook(marketID):
    refund()
    numTrades = self.get_total_trades(marketID)
    trades = self.get_trade_ids(marketID, outitems=numTrades)
    orderBook = array(TRADE_FIELDS*numTrades)
    i = 0
    while i < numTrades:
        tradeInfo = self.get_trade(trades[i], outitems=TRADE_FIELDS)
        j = 0
        while j < 8:
            orderBook[8*i + j] = tradeInfo[j]
            j += 1
        i += 1
    return(orderBook:arr)

def getMarketInfo(marketID):
    refund()
    index = BASE_FIELDS
    descriptionLength = self.getDescriptionLength(marketID)
    numEvents = self.getNumEvents(marketID)
    numOutcomes = self.getMarketNumOutcomes(marketID)
    marketInfo = array(BASE_FIELDS + numEvents*EVENTS_FIELDS + numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1)
    marketInfo[0] = marketID
    # marketInfo[1] = self.getCurrentParticipantNumber(marketID)
    marketInfo[2] = self.getMakerFees(marketID)
    # marketInfo[3] = self.getParticipantNumber(marketID, msg.sender)
    marketInfo[4] = numOutcomes
    marketInfo[5] = self.getTradingPeriod(marketID)
    marketInfo[6] = self.getTradingFee(marketID)
    marketInfo[7] = self.getBranchID(marketID)
    marketInfo[8] = numEvents
    marketInfo[9] = self.getCumScale(marketID)
    marketInfo[10] = self.getCreationTime(marketID)
    marketInfo[11] = self.getVolume(marketID)
    marketInfo[12] = self.getCreationFee(marketID)
    marketInfo[13] = self.getCreator(marketID)
    tags = slice(self.returnTags(marketID, outitems=3), items=0, items=3)
    marketInfo[14] = tags[0]
    marketInfo[15] = tags[1]
    marketInfo[16] = tags[2]

    # gather event(s) info:
    # [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]
    events = slice(self.getMarketEvents(marketID, outitems=numEvents), items=0, items=numEvents)
    i = 0
    while i < numEvents:
        eventInfo = self.getEventInfo(events[i], outitems=EVENTS_FIELDS)
        marketInfo[index + i*EVENTS_FIELDS] = events[i]
        j = 1
        while j < EVENTS_FIELDS:
            marketInfo[index + i*EVENTS_FIELDS + j] = eventInfo[j]
            j += 1
        i += 1
    index += numEvents*EVENTS_FIELDS

    # gather outcomes info: [sharesPurchased, price], winningOutcomes
    # (price of outcome = last trade)
    numTrades = self.get_total_trades(marketID)
    trades = self.get_trade_ids(marketID, outitems=numTrades)
    k = 0
    while k < numOutcomes:
        marketInfo[index + k*OUTCOMES_FIELDS] = self.getSharesPurchased(marketID, k + 1)
        i = 0
        marketInfo[index + k*OUTCOMES_FIELDS + 1] = self.getLastOutcomePrice(market, k + 1)
        k += 1
    index += numOutcomes*OUTCOMES_FIELDS
    winningOutcomes = slice(self.getWinningOutcomes(marketID, outitems=8), items=0, items=8)
    k = 0
    while k < WINNING_OUTCOMES_FIELDS:
        marketInfo[index + k] = winningOutcomes[k]
        k += 1
    index += WINNING_OUTCOMES_FIELDS

    # append description character codes
    marketInfo[index] = descriptionLength
    index += 1
    description = self.getDescription(marketID, outchars=descriptionLength)
    c = 0
    while c < descriptionLength:
        marketInfo[index + c] = getch(description, c)
        c += 1
    return(marketInfo: arr)

def batchGetMarketInfo(marketIDs: arr):
    refund()
    numMarkets = len(marketIDs)
    totalLength = 0
    marketInfoLength = array(numMarkets)
    i = 0
    while i < numMarkets:
        marketID = marketIDs[i]
        descriptionLength = self.getDescriptionLength(marketID)
        numEvents = self.getNumEvents(marketID)
        numOutcomes = self.getMarketNumOutcomes(marketID)
        marketInfoLength[i] = BASE_FIELDS + numEvents*EVENTS_FIELDS + numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 2
        totalLength += marketInfoLength[i]
        i += 1
    marketsInfo = array(totalLength)
    index = 0
    i = 0
    while i < numMarkets:
        marketInfo = self.getMarketInfo(marketIDs[i], outitems=marketInfoLength[i] - 1)
        marketsInfo[index] = marketInfoLength[i]
        j = 0
        while j < marketInfoLength[i] - 1:
            marketsInfo[index + j + 1] = marketInfo[j]
            j += 1
        index += marketInfoLength[i]
        i += 1
    return(marketsInfo: arr)

def getMarketsInfo(branch, offset, numMarketsToLoad):
    refund()
    numMarkets = self.getNumMarketsBranch(branch)
    if numMarketsToLoad == 0:
        numMarketsToLoad = numMarkets
    marketIDs = slice(self.getMarketsInBranch(branch, outitems=numMarkets), items=0, items=numMarkets)
    totalLen = numMarketsToLoad*11
    m = 0
    while m < numMarketsToLoad:
        totalLen += self.getDescriptionLength(marketIDs[m + offset])
        m += 1
    marketsInfo = array(totalLen + 1)
    m = 0
    c = 1
    totalMarkets = min(numMarketsToLoad, numMarkets)
    marketsInfo[0] = totalMarkets
    while m < totalMarkets:
        marketID = marketIDs[m + offset]
        descriptionLength = self.getDescriptionLength(marketID)
        marketsInfo[c] = 11 + descriptionLength
        marketsInfo[c + 1] = marketID
        marketsInfo[c + 2] = self.getTradingPeriod(marketID)
        marketsInfo[c + 3] = self.getTradingFee(marketID)
        marketsInfo[c + 4] = self.getCreationTime(marketID)
        marketsInfo[c + 5] = self.getVolume(marketID)
        tags = slice(self.returnTags(marketID, outitems=3), items=0, items=3)
        marketsInfo[c + 6] = tags[0]
        marketsInfo[c + 7] = tags[1]
        marketsInfo[c + 8] = tags[2]
        marketsInfo[c + 9] = self.getLastExpDate(marketID)
        marketsInfo[c + 10] = self.getMakerFees(marketID)
        description = self.getDescription(marketIDs[m + offset], outchars=descriptionLength)
        c += 11
        d = 0
        while d < descriptionLength:
            marketsInfo[c] = getch(description, d)
            c += 1
            d += 1
        m += 1
    return(marketsInfo: arr)

inset('refund.se')

# Keeps track of data about events in augur
# Events' index is the eventID
# so max-min/numOutcomes is interval between outcomes (useful for ui for categoricals, e.g. 1 is >50, 2 is >100, etc.)
# markets keeps track of the markets associated with an event
# threshold is the min "random" sha threshold for reporting on an event used in the scenario where no one reports on an event
# mode is the mode reported value for a given event [only on categorical / scalar events]
# uncaughtOutcome is the average reported value for a binary event
# ethical is the ethicality for a given event
# originalExp is original expiry date in the case an event was pushed back and the expiration date gets changed - both are in epoch time
# pushedUp states that an event was pushed forward to attempt early resolution
# rejected states that a pushed forward market's event [so one that attempted to resolve before it was expired] got rejected and shouldn't have actually been pushed forward
    # rejectedPeriod is the period such an event was pushed forward to and failed to be resolved in
# bond is the indeterminate bond that's taken away if an event is reported on as indeterminate
# forked is whether an event was the event a branch was forked over
# forkOver is whether the event that was forked over is resolved
# forkOutcome is the outcome of an event that was forked over
# forkEthicality is the ethicality of an event that was forked over
# resolutionSource is a string with the recommended source for resolving a market
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes, markets[], numMarkets, threshold, mode, uncaughtOutcome, ethical, originalExp, rejected, rejectedPeriod, bond, forked, forkOver, forkOutcome, forkEthicality, resolutionSource[], resolutionSourceLength, pushedUp, reportersPaidSoFarForEvent)

# Keeps track of number of events created in the past 24 hours
data past24Hours[]

def getReportersPaidSoFar(event):
    return(self.Events[event].reportersPaidSoFarForEvent)

def addReportersPaidSoFar(event):
    self.Events[event].reportersPaidSoFarForEvent += 1
    return(1)

def getEventPushedUp(event):
    return(self.Events[event].pushedUp)
    
def setEventPushedUp(event, val):
    self.Events[event].pushedUp = val
    return(1)

def getForkOutcome(event):
    return(self.Events[event].forkOutcome)

def setForkOutcome(event, value):
    self.Events[event].forkOutcome = value
    return(1)
    
def getForkEthicality(event):
    return(self.Events[event].forkEthicality)

def setForkEthicality(event, value):
    self.Events[event].forkEthicality = value
    return(1)

def getForked(event):
    return(self.Events[event].forked)

def setForked(event):
    self.Events[event].forked = 1
    return(1)
    
def setForkDone(event):
    self.Events[event].forkOver = 1
    return(1)
    
def getForkedDone(event):
    return(self.Events[event].forkOver)

def getEventResolution(event):
    resLen = self.Events[event].resolutionSourceLength
    return(load(self.Events[event].resolutionSource[0], chars=resLen): str)

def getEventInfo(event):
    refund()
    eventinfo = array(7)
    eventinfo[0] = self.Events[event].branch
    eventinfo[1] = self.Events[event].expirationDate 
    eventinfo[2] = self.Events[event].outcome
    eventinfo[3] = self.Events[event].minValue
    eventinfo[4] = self.Events[event].maxValue
    eventinfo[5] = self.Events[event].numOutcomes
    eventinfo[6] = self.Events[event].bond
    return(eventinfo: arr)
    
def getResolution(event):
    refund()
    length=self.Events[event].resolutionSourceLength
    return(load(self.Events[event].resolutionSource[0], chars=length): str)

def getPast24(period):
    refund()
    return(self.past24Hours[period])

def addPast24(period):
    refund()
    self.past24Hours[period] += 1
    return(1)

def getEventBranch(event):
    refund()
    return(self.Events[event].branch)

def getExpiration(event):
    refund()
    return(self.Events[event].expirationDate)

def getOriginalExpiration(event):
    refund()
    return(self.Events[event].originalExp)
    
def setOriginalExpiration(event, date):
    self.Events[event].originalExp = date
    return(1)

def setExpiration(event, date):
    refund()
    self.Events[event].expirationDate = date
    return(1)

def setBranch(event, branch):
    self.Events[event].branch = branch
    return(1)

def getOutcome(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].outcome)

def getEthics(event):
    refund()
    return(self.Events[event].ethical)

def setEthics(event, ethicality):
    refund()
    self.Events[event].ethical = ethicality
    return(ethicality)

def getEthical(event):
    refund()
    return(self.Events[event].ethical)

def getMinValue(event):
    refund()
    return(self.Events[event].minValue)

def getMaxValue(event):
    refund()
    return(self.Events[event].maxValue)

def getNumOutcomes(event):
    refund()
    return(self.Events[event].numOutcomes)

def setUncaughtOutcome(event, outcome):
    refund()
    self.Events[event].uncaughtOutcome = outcome
    return(1)

def getUncaughtOutcome(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].uncaughtOutcome)

def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes, resolution: str):
    refund()
    # check that msg.sender is one of our function contracts
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    if(self.Events[ID].expirationDate==0):
        self.Events[ID].branch = branch
        self.Events[ID].expirationDate = expirationDate
        self.Events[ID].originalExp = expirationDate
        self.Events[ID].minValue = minValue
        self.Events[ID].maxValue = maxValue
        self.Events[ID].numOutcomes = numOutcomes
        save(self.Events[ID].resolutionSource[0], resolution, chars=len(resolution))
        return(1)
    else:
        return(0)

def setBond(event, bond):
    refund()
    self.Events[event].bond = bond
    return(1)

def addMarket(event, marketID):
    refund()
    self.Events[event].markets[self.Events[event].numMarkets] = marketID
    self.Events[event].numMarkets += 1
    return(1)

def getBranch(event):
    return(self.Events[event].branch)

def getBond(event):
    refund()
    return(self.Events[event].bond)

def getMarkets(event):
    refund()
    i = 0
    markets = array(self.Events[event].numMarkets)
    while i < self.Events[event].numMarkets:
        markets[i] = self.Events[event].markets[i]
        i += 1
    return(markets: arr)
    
def getMarket(event, marketIndex):
    refund()
    return(self.Events[event].markets[marketIndex])

def getNumMarkets(event):
    refund()
    return(self.Events[event].numMarkets)

def setOutcome(ID, outcome):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.Events[ID].outcome = outcome
    return(1)

def getReportingThreshold(event):
    refund()
    return(self.Events[event].threshold)
    
def setThreshold(event, threshold):
    # do whitelist
    self.Events[event].threshold = threshold
    return(1)

def getMode(event):
    refund()
    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good
    return(self.Events[event].mode)

def setMode(event, mode):
    refund()
    self.Events[event].mode = mode
    return(1)

def setRejected(event, period):
    refund()
    self.Events[event].rejected = 1
    self.Events[event].rejectedPeriod = period
    return(1)

def getRejected(event):
    refund()
    return(self.Events[event].rejected)

def getRejectedPeriod(event):
    refund()
    return(self.Events[event].rejectedPeriod)
macro calculateRepChange($report, $maxPenalty):
    # wrong
    #184467440737095520 == 0.01 in fxp
    if($report > outcome+POINTZEROONE or $report < outcome-POINTZEROONE):
        if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
            diff = $report - outcome
            p = -(abs(diff)/2) + ONE
        newRep = oldRep*(2*p - ONE)/ONE
    # right
    else:
        if(scalar(event) or categorical(event) or outcome==3*ONEHALF):
            diff = $report - outcome
            p = -(abs(diff)/2) + ONE
        newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE
    # (1-k) * old rep + k * new rep where k = maxPenalty [max of 1] / (number of events you reported on last period) for penalization and pen. rate for backstop 1
    if(numReportedOn<10):
        repChange = oldRep * (ONE - $maxPenalty/10)/ONE + newRep*($maxPenalty/10)/ONE - oldRep
    else:
        repChange = oldRep * (ONE - $maxPenalty/numReportedOn)/ONE + newRep*($maxPenalty/numReportedOn)/ONE - oldRep
inset('refund.se')

### Storage of all data associated with trades

# reporterID is index
data tradeCommits[](hash, block)
# tradeID is index
data trades[](id, type, market, amount, price, owner, block, outcome)

def makeTradeHash(max_value, max_amount, trade_ids: arr):
    refund()
    i = 0
    trades = 0
    while i < len(trade_ids):
        trades += trade_ids[i]
        i+=1
    tradeInfo = array(3)
    tradeInfo[0] = trades
    tradeInfo[1] = max_amount
    tradeInfo[2] = max_value
    tradeHash = sha3(tradeInfo, items=3)
    return(tradeHash)

def commitTrade(hash):
    refund()
    self.tradeCommits[msg.sender].hash = hash
    self.tradeCommits[msg.sender].block = block.number
    return(1)

def zeroHash():
    refund()
    self.tradeCommits[msg.sender].hash = 0
    return(1)

def checkHash(tradeHash, sender):
    refund()
    if(self.tradeCommits[sender].hash != tradeHash || block.number <= self.tradeCommits[sender].block):
        return(-1)
    else:
        return(1)
        
def getID(tradeID):
    refund()
    return(self.trades[tradeID].id)
    
def saveTrade(trade_id, type, market, amount, price, sender, outcome):
    refund()
    self.trades[trade_id].id = trade_id
    self.trades[trade_id].type = type
    self.trades[trade_id].market = market
    self.trades[trade_id].amount = amount
    self.trades[trade_id].price = price
    self.trades[trade_id].owner = sender
    self.trades[trade_id].block = block.number
    self.trades[trade_id].outcome = outcome
    return(1)

def get_trade(id):
    refund()
    trade = array(8)
    trade[0] = self.trades[id].id
    trade[1] = self.trades[id].type
    trade[2] = self.trades[id].market
    trade[3] = self.trades[id].amount
    trade[4] = self.trades[id].price
    trade[5] = self.trades[id].owner
    trade[6] = self.trades[id].block
    trade[7] = self.trades[id].outcome
    if trade:
        return(trade:arr)
    return([0]:arr)    

def get_amount(id):
    refund()
    return(self.trades[id].amount)
    
def get_price(id):
    refund()
    return(self.trades[id].price)

def update_trade(id, price):
    refund()
    self.trades[id].price = price
    self.trades[id].block = block.number

def remove_trade(id):
    refund()
    self.trades[id].id = 0
    self.trades[id].type = 0
    self.trades[id].market = 0
    self.trades[id].amount = 0
    self.trades[id].price = 0
    self.trades[id].owner = 0
    self.trades[id].block = 0
    self.trades[id].outcome = 0
    return(1)
    
def fill_trade(trade_id, fill):
    refund()
    self.trades[trade_id].amount -= fill
    return(1)
inset('refund.se')

# address -> value map of "cash [a made up subcurrency/token for testing"
data cashcoinBalances[]

# address -> address mapping of a cash address to the address that owns it
data owners[]


# @return: cash balance of address
def balance(address):
    refund()
    return(self.cashcoinBalances[address])

# A random market could have a balance, and when that account was created/first used in the subcurrency, it'd have whatever contract that created it be the owner, so for example...
# needs to be called when making a market, branch, etc. or a new cash user acc.
def initiateOwner(account):
    refund()
    if(self.owners[account]==0 and self.cashcoinBalances[account]==0):
        self.owners[account] = msg.sender
        return(1)
    else:
        return(0)

# Sends cash from a user to a receiver
# @return value of cash sent; fail is 0
def sendFrom(recver, value, from):
    refund()
    if(self.owners[msg.sender]==0 && from==msg.sender):
        self.owners[msg.sender] = msg.sender
    # sendFrom would check if the sender had an owner, if it did, then it'd check and see if the msg.sender was the owner.
    # it's not owned by a regular account nor a contract owned account (i.e. a market's hash from markets.)
    if(from!=tx.origin and msg.sender!=self.owners[from] and msg.sender!=from):
        return(0)
    #if(self.owners[recver]==0):
    #    return(0)
    senderBalance = self.cashcoinBalances[from]
    if(senderBalance >= value && value > 0):
        self.cashcoinBalances[from] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# make sure only coming from specific contracts
def subtractCash(ID, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    #if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):
    #    return(0)
    self.cashcoinBalances[ID] -= amount
    return(1)

def addCash(ID, amount):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #    return(-1)
    self.cashcoinBalances[ID] += amount
    return(1)

def setCash(address, balance):
    refund()
    #if !self.whitelist.check(msg.sender):
    #    return(-1)
    self.cashcoinBalances[address] = balance
    return(1)

def depositEther():
    self.cashcoinBalances[msg.sender] += msg.value * ONE / WEITOETH
    return msg.value

def withdrawEther(to, value):
    if(value < 0):
        return(-1)
    if self.cashcoinBalances[msg.sender] >= value * ONE / WEITOETH:
        self.cashcoinBalances[msg.sender] -= value * ONE / WEITOETH
        send(to, value)
        return 1
    else:
        return 0
inset('refund.se')
inset('eventHelpers.se')

macro POINTSEVEN: 12912720851596685312
macro POINTZEROONE: 184467440737095520

# Error -1: Hey, you're not broke!
def cashFaucet():
    refund()
    if self.balance(msg.sender) > 5*ONE:
        return(-1)
    self.setCash(msg.sender, 10000*ONE)
    return(1)

def reputationFaucet(branch):
    refund()
    if self.repIDToIndex(branch, tx.origin) != 0 or self.getReporterID(branch, 0) == tx.origin:
        index = self.repIDToIndex(branch, tx.origin)
    else:
        index = self.getNumberReporters(branch)
        self.addReporter(branch, tx.origin, 0, 0, 0)
    self.setRep(branch, index, 47*ONE)
    self.setPenalizedUpTo(branch, tx.origin, (self.getVotePeriod(branch)-1))
    return(1)

inset('refund.se')

# first param is the market, second param is the subcurrency contract
data cash[][]

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF

macro CATCH_TOLERANCE: ONE / 10


# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

# If ethicality value <.5 it's 0, otherwise it's ethical
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE


macro scalar($event):
    ((self.getMaxValue($event)!=TWO || self.getMinValue($event)!=ONE) && self.getNumOutcomes($event)==2)

macro binary($event):
    (self.getNumOutcomes($event)==2 and ONE*self.getMaxValue($event)==TWO and self.getMinValue($event)==ONE)

macro categorical($event):
    (self.getNumOutcomes($event)>2)
inset('refund.se')
inset('eventHelpers.se')
inset('redistributeRep.se')
inset('proportionCorrect.se')
inset('repChange.se')

#event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)

macro POINTZEROONE: 184467440737095520
macro POINTEIGHT: 14757395258967642112
macro POINTTWO: 3689348814741910528
macro POINTFOUR: 7378697629483821056
macro MINBOND: 200*ONE

# Penalizes a reporter for reporting wrongly on a round 2 reporting / backstop 1 event
# So we want to do the rep redistribution for both period 1 and period 2 at this time
# essentially penalizeWrong for backstop 1 [where everyone reports on a given event]
# in a fork this is called on the original branch and event is reported on again on new branch
# Errors:
    #  0: event isn't eligible/up for round two penalization
    # -1: already past first half of new period and needed to penalize before then
    # -2: round two resolve wasn't successful
    # -3: in fork period only thing that rep redistribution is done on is the round 2 event in the original branch via round 2 penalize
    # -4: already done for all events in this period
    # -5: needed to collect fees last period which sets the before/after rep
# force event to be resolved first if it can be
# roundTwoResolve needs to be called for any event here before can be penalized if it's a backstop 1 event, a la close market for other events before being penalized
# todo go over penalty amounts like .2 for ethicality seems too high
def penalizeRoundTwoWrong(branch, event):
    refund()
    lastPeriod = self.getVotePeriod(branch)-1
    lastPenalizationPeriod = lastPeriod - 1
    periodLength = self.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    newRep = 0
    newAfterRep = self.getAfterRep(branch, lastPeriod, msg.sender)
    repBalance = self.getRepBalance(branch, msg.sender)
    oldRep = self.getBeforeRep(branch, lastPeriod, msg.sender)
    forkEvent = self.getEventForkedOver(branch)
    uncaught = self.getUncaughtOutcome(event)
    outcome = catch(uncaught)
    if(scalar(event) or categorical(event)):
        outcome = uncaught
    reportValue = self.getReport(branch, lastPeriod, event, msg.sender)
    oldReport = self.getReport(branch,lastPenalizationPeriod,event,msg.sender)
    ethics = self.getEthicReport(branch, lastPeriod, event, msg.sender)
    oldEthics = self.getEthicReport(branch, lastPenalizationPeriod, event, msg.sender)
    averageAdjudicationCost = self.getInitialBalance(branch, lastPeriod)/self.getNumberEvents(branch, lastPeriod)
    bond = averageAdjudicationCost + self.getSharesValue(market)*(POINTZEROONE + self.getTradingFee(market)/2) / 2**64
    bond = min(bond, MINBOND)
    ethical = self.getEthical(event)
    p = proportionCorrect(event, 0)
    # makes sure we're actually still able to report on the last vote period and that we're in 1st half of current period
    if(residual > periodLength/2 or (block.timestamp / periodLength - 2)!=lastPeriod):
        return(-1)
    # if no outcome / event not resolved yet, resolve it [as long as it wasn't an event that was pushed fwd and got rejected and thus hasn't actually resolved yet]
    elif(!self.getOutcome(event)):
        if(self.roundTwoResolve(branch, event, self.getEventIndex(branch, lastPeriod, event), msg.sender)==0):
            return(-2)
    elif(self.getForkPeriod(branch) == lastPeriod && event!=forkEvent):
        return(-3)
    elif(self.getPenalizedUpTo(branch, msg.sender)==lastPeriod):
        return(-4)
    elif(!self.getFeesCollected(branch, msg.sender, lastPeriod)):
        return(-5)
    # if overruled / different outcome after reporting on again
    overruled = 0
    if(scalar(event) or categorical(event)):
        if((self.getOriginalOutcome(event) != self.getUncaughtOutcome(event) or self.getOriginalEthicality(event)!=ethic_catch(ethical))):
            overruled = 1
    elif((self.getOriginalOutcome(event) != catch(uncaught) or self.getOriginalEthicality(event)!=ethic_catch(ethical))):
        overruled = 1
        
    numReportedOn = self.getNumReportsSubmitted(branch, lastPeriod, msg.sender)
    repChange = 0
    # penalization on a round 2 event if not already penalized, it has outcome, and user reported on it
    # if it's penalizing in the period it was pushed back to we can do the penalization, should do it for both the first and second period
    if(self.getRoundTwo(event) && (self.getFinal(event) or event==forkEvent) && !self.getPenalized(branch, lastPeriod, msg.sender, event) && (reportValue or oldReport)):
        # Do the first rep redistribution based on first report and final outcome if reported first time
        if(oldReport && outcome!=0):
            calculateRepChange(oldReport, POINTFOUR)
            handleEthicsAndBondRepRedistribution(POINTFOUR, oldEthics, numReportedOn)
        # Do the second (for each user) based on second report and final outcome
        if(reportValue && outcome!=0):
            calculateRepChange(reportValue, POINTTWO)
            handleEthicsAndBondRepRedistribution(POINTTWO, ethics, numReportedOn)
        self.setPenalized(branch, lastPeriod, msg.sender, event)
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)
    else:
        return(0)
    # if a fork event in original branch, only event needed to report on in this period is that one [b/c the original branch resolves it as a regular round 2 event, fork reports again]
    if(event==forkEvent):
        self.increasePenalizedNum(branch, lastPeriod, msg.sender, (numReportedOn - 1))
    return(1)