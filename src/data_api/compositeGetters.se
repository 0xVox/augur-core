# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

macro Controller: 0xC001D00D
extern Controller: [lookup:[int256]:int256, checkWhitelist:[int256]:int256]

INFO = Controller.lookup('info')
extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getCurrency:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, getWallet:[int256]:int256, setCurrencyAndWallet:[int256,int256,int256]:int256, setInfo:[int256,bytes,int256,int256,int256,int256]:int256]

EVENTS = Controller.lookup('events')
extern events: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, addReportersPaidSoFar:[int256]:int256, getBond:[int256]:int256, getChallenged:[int256]:int256, getCreationTime:[int256]:int256, getEarlyResolutionBond:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventPushedUp:[int256]:int256, getEventResolution:[int256]:bytes, getExpiration:[int256]:int256, getExtraBond:[int256]:int256, getFirstPreliminaryOutcome:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForkResolveAddress:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getMode:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportersPaidSoFar:[int256]:int256, getReportingThreshold:[int256]:int256, getResolutionAddress:[int256]:int256, getResolutionLength:[int256]:int256, getResolveBondPoster:[int256]:int256, getUncaughtOutcome:[int256]:int256, geteventInfo:[int256]:int256[], initializeEvent:[int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setChallenged:[int256]:int256, setCreationTime:[int256]:int256, setEarlyResolutionBond:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setExtraBond:[int256,int256]:int256, setFirstPreliminaryOutcome:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setMode:[int256,int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256]

BRANCHES = Controller.lookup('branches')
extern branches: [addCurrency:[int256,int256,int256,int256]:int256, addMarketToBranch:[int256,int256]:int256, disableCurrency:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getBranchesStartingAt:[int256]:int256[], getCreationDate:[int256]:int256, getCurrency:[int256,int256]:int256, getCurrencyActive:[int256,int256]:int256, getCurrencyByContract:[int256,int256]:int256, getCurrencyRate:[int256,int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getForkTime:[int256]:int256, getInitialBalance:[int256,int256,int256]:int256, getMarketIDsInBranch:[int256,int256,int256]:int256[], getMinTradingFee:[int256]:int256, getMostRecentChild:[int256]:int256, getNumBranches:[]:int256, getNumCurrencies:[int256]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, getWallet:[int256,int256]:int256, incrementPeriod:[int256]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256,int256,int256,int256]:int256, reactivateCurrency:[int256,int256]:int256, removeLastCurrency:[int256]:int256, replaceCurrency:[int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256,int256]:int256, setMostRecentChild:[int256,int256]:int256, updateCurrencyRate:[int256,int256,int256,int256]:int256, updateNumCurrencies:[int256,int256]:_]

ORDERS = Controller.lookup('orders')
extern orders: [checkHash:[int256,int256]:int256, commitOrder:[int256]:int256, fillOrder:[int256,int256,int256,int256]:int256, getAmount:[int256]:int256, getBestAsk:[int256,int256]:int256, getBestBid:[int256,int256]:int256, getID:[int256]:int256, getOrder:[int256]:int256[], getPrice:[int256]:int256, makeOrderHash:[int256,int256,int256]:int256, removeOrder:[int256]:int256, saveOrder:[int256,int256,int256,int256,int256,int256,int256,int256,int256]:int256]

MARKETS = Controller.lookup('markets')
extern markets: [addFees:[int256,int256]:int256, addOrder:[int256,int256]:int256, addToMarketsHash:[int256,int256]:int256, getBondsMan:[int256]:int256, getBranch:[int256]:int256, getCumulativeScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getGasSubsidy:[int256]:int256, getLastExpDate:[int256]:int256, getLastOrder:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketShareContracts:[int256]:int256[], getMarketsHash:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOrderIDs:[int256]:int256[], getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPrevID:[int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalOrders:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256,int256[]]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, removeOrderFromMarket:[int256,int256]:int256, returnTags:[int256]:int256[], setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]

EXPEVENTS = Controller.lookup('expiringEvents')
extern expiringEvents: [addEvent:[int256,int256,int256,int256,int256,int256,int256]:int256, addReportToReportsSubmitted:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodFeeValue:[int256,int256,int256]:int256, countReportAsSubmitted:[int256,int256,int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getActiveReporters:[int256,int256,int256,int256]:int256[], getAfterFork:[int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256,int256]:int256, getEventWeight:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getFeeValue:[int256,int256]:int256, getLesserReportNum:[int256,int256,int256]:int256, getNumActiveReporters:[int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsSubmitted:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepWeight:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportsCommitted:[int256,int256,int256]:int256, getRequired:[int256,int256,int256]:int256, getSaltyEncryptedHash:[int256,int256,int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setEventWeight:[int256,int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepWeight:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setSaltyEncryptedHash:[int256,int256,int256,int256,int256]:int256]

PROPORTION = Controller.lookup('proportionCorrect')
extern proportionCorrect: []


inset('refund.se')

macro ORDER_FIELDS: 10
macro EVENTS_FIELDS: 7
macro OUTCOMES_FIELDS: 3
macro BASE_FIELDS: 15
macro BASE_CACHE_FIELDS: 10

def getOrderBook(marketID, offset, numOrdersToLoad):
    refund()
    numOrders = MARKETS.getTotalOrders(marketID)
    if offset > numOrders:
        return([]: arr)
    if numOrdersToLoad == 0:
        numOrdersToLoad = numOrders
    totalOrders = min(numOrdersToLoad, numOrders - offset)
    orders = slice(MARKETS.getOrderIDs(marketID, outitems=numOrders), items=offset, items=offset+numOrdersToLoad)
    orderBook = array(ORDER_FIELDS*totalOrders)
    numAvailableOrders = 0
    i = 0
    while i < totalOrders:
        orderInfo = ORDERS.getOrder(orders[i], outitems=ORDER_FIELDS)
        if orderInfo[0] != 0:
            j = 0
            while j < 8:
                orderBook[8*numAvailableOrders + j] = orderInfo[j]
                j += 1
            numAvailableOrders += 1
        i += 1
    return(slice(orderBook, items=0, items=ORDER_FIELDS*numAvailableOrders): arr)

def getAccountOrderBook(marketID, account):
    refund()
    numOrders = MARKETS.getTotalOrders(marketID)
    orders = MARKETS.getOrderIDs(marketID, outitems=numOrders)
    orderBook = array(ORDER_FIELDS*numOrders)
    numAccountOrders = 0
    i = 0
    while i < numOrders:
        owner = ORDERS.getOrderOwner(orders[i])
        if owner == account:
            orderInfo = ORDERS.getOrder(orders[i], outitems=ORDER_FIELDS)
            if orderInfo[0] != 0:
                j = 0
                while j < 8:
                    orderBook[8*numAccountOrders + j] = orderInfo[j]
                    j += 1
                numAccountOrders += 1
        i += 1
    return(slice(orderBook, items=0, items=ORDER_FIELDS*numAccountOrders): arr)

def getMarketInfo(marketID, account):
    refund()
    index = BASE_FIELDS
    eventID = MARKETS.getMarketEvent(marketID, 0)
    descriptionLength = INFO.getDescriptionLength(eventID)
    resolutionLength = EVENTS.getResolutionLength(eventID)
    extraInfoLength = MARKETS.getExtraInfoLength(marketID)
    numOutcomes = MARKETS.getMarketNumOutcomes(marketID)
    marketInfo = array(BASE_FIELDS + EVENTS_FIELDS + numOutcomes*OUTCOMES_FIELDS + descriptionLength + resolutionLength + extraInfoLength + 3)
    marketInfo[0] = marketID
    marketInfo[1] = MARKETS.getMakerFees(marketID)
    marketInfo[2] = numOutcomes
    marketInfo[3] = MARKETS.getTradingPeriod(marketID)
    marketInfo[4] = MARKETS.getTradingFee(marketID)
    marketInfo[5] = MARKETS.getBranchID(marketID)
    marketInfo[6] = MARKETS.getCumScale(marketID)
    marketInfo[7] = MARKETS.getCreationTime(marketID)
    marketInfo[8] = MARKETS.getCreationBlock(marketID)
    marketInfo[9] = MARKETS.getVolume(marketID)
    marketInfo[10] = INFO.getCreationFee(marketID)
    marketInfo[11] = INFO.getCreator(marketID)
    tags = MARKETS.returnTags(marketID, outitems=3)
    marketInfo[12] = tags[0]
    marketInfo[13] = tags[1]
    marketInfo[14] = tags[2]

    # gather event(s) info:
    # [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]
    eventInfo = EVENTS.getEventInfo(eventID, outitems=EVENTS_FIELDS - 2)
    marketInfo[index] = eventID
    j = 1
    while j < EVENTS_FIELDS - 2:
        marketInfo[index + j] = eventInfo[j]
        j += 1
    marketInfo[index + EVENTS_FIELDS - 2] = EVENTS.getEthical(eventID)
    marketInfo[index + EVENTS_FIELDS - 1] = PROPORTION.proportionCorrect(eventID)
    index += EVENTS_FIELDS

    # gather outcomes info: [sharesPurchased, price]
    # (price of outcome = last trade)
    k = 0
    while k < numOutcomes:
        marketInfo[index + k*OUTCOMES_FIELDS] = MARKETS.getSharesPurchased(marketID, k + 1)
        marketInfo[index + k*OUTCOMES_FIELDS + 1] = MARKETS.getLastOutcomePrice(marketID, k + 1)
        if account != 0:
            marketInfo[index + k*OUTCOMES_FIELDS + 2] = MARKETS.getParticipantSharesPurchased(marketID, account, k + 1)
        k += 1
    index += numOutcomes*OUTCOMES_FIELDS

    # append description character codes
    marketInfo[index] = descriptionLength
    index += 1
    description = INFO.getDescription(eventID, outchars=descriptionLength)
    c = 0
    while c < descriptionLength:
        marketInfo[index + c] = getch(description, c)
        c += 1
    index += descriptionLength

    # append resolution character codes
    marketInfo[index] = resolutionLength
    index += 1
    resolution = EVENTS.getResolution(eventID, outchars=resolutionLength)
    c = 0
    while c < resolutionLength:
        marketInfo[index + c] = getch(resolution, c)
        c += 1
    index += resolutionLength

    # append extraInfo character codes
    marketInfo[index] = extraInfoLength
    index += 1
    extraInfo = MARKETS.getExtraInfo(marketID, outchars=extraInfoLength)
    c = 0
    while c < extraInfoLength:
        marketInfo[index + c] = getch(extraInfo, c)
        c += 1

    return(marketInfo: arr)

def batchGetMarketInfo(marketIDs: arr, account):
    refund()
    numMarkets = len(marketIDs)
    totalLength = 0
    marketInfoLength = array(numMarkets)
    i = 0
    while i < numMarkets:
        marketID = marketIDs[i]
        eventID = MARKETS.getMarketEvent(marketID, 0)
        descriptionLength = INFO.getDescriptionLength(eventID)
        resolutionLength = EVENTS.getResolutionLength(eventID)
        extraInfoLength = MARKETS.getExtraInfoLength(marketID)
        numOutcomes = MARKETS.getMarketNumOutcomes(marketID)
        marketInfoLength[i] = BASE_FIELDS + EVENTS_FIELDS + numOutcomes*OUTCOMES_FIELDS + descriptionLength + resolutionLength + extraInfoLength + 4
        totalLength += marketInfoLength[i]
        i += 1
    marketsInfo = array(totalLength)
    index = 0
    i = 0
    while i < numMarkets:
        marketInfo = self.getMarketInfo(marketIDs[i], account, outitems=marketInfoLength[i] - 1)
        marketsInfo[index] = marketInfoLength[i]
        j = 0
        while j < marketInfoLength[i] - 1:
            marketsInfo[index + j + 1] = marketInfo[j]
            j += 1
        index += marketInfoLength[i]
        i += 1
    return(marketsInfo: arr)

# - if both volumeMin and volumeMax are specified, then
#   only include markets in the half-open interval: (volumeMin, volumeMax]
# - if volumeMax = -1 then there is no upper limit
def getMarketsInfo(branch, offset, numMarketsToLoad, volumeMin, volumeMax):
    refund()
    numMarkets = BRANCHES.getNumMarketsBranch(branch)
    if offset > numMarkets:
        return([]: arr)
    if numMarketsToLoad == 0:
        numMarketsToLoad = numMarkets
    totalMarkets = min(numMarketsToLoad, numMarkets - offset)
    marketIDs = BRANCHES.getSomeMarketsInBranch(branch, offset, offset + totalMarkets, outitems=totalMarkets)

    if volumeMin < volumeMax or volumeMax == -1:
        numThresholdedMarkets = 0
        thresholdedMarketIDs = array(numMarkets)
        m = 0
        while m < totalMarkets:
            marketID = marketIDs[m]
            volume = MARKETS.getVolume(marketID)
            if volume > volumeMin and (volumeMax == -1 or volume <= volumeMax):
                thresholdedMarketIDs[numThresholdedMarkets] = marketID
                numThresholdedMarkets += 1
                if numThresholdedMarkets == totalMarkets:
                    m = totalMarkets - 1
            m += 1
        totalMarkets = min(numThresholdedMarkets, totalMarkets)
        marketIDs = slice(thresholdedMarketIDs, items=0, items=numThresholdedMarkets)

    descriptionLengths = array(totalMarkets)
    totalLen = totalMarkets*16
    m = 0
    while m < totalMarkets:
        eventID = MARKETS.getMarketEvent(marketIDs[m], 0)
        descriptionLengths[m] = INFO.getDescriptionLength(eventID)
        totalLen += descriptionLengths[m]
        m += 1
    marketsInfo = array(totalLen + 1)
    marketsInfo[0] = totalMarkets

    # get basic market info for each market
    m = 0
    c = 1
    while m < totalMarkets:
        marketID = marketIDs[m]
        descriptionLength = descriptionLengths[m]
        marketsInfo[c] = 16 + descriptionLength
        marketsInfo[c + 1] = marketID
        marketsInfo[c + 2] = MARKETS.getTradingPeriod(marketID)
        marketsInfo[c + 3] = MARKETS.getTradingFee(marketID)
        marketsInfo[c + 4] = MARKETS.getCreationTime(marketID)
        marketsInfo[c + 5] = MARKETS.getVolume(marketID)
        tags = MARKETS.returnTags(marketID, outitems=3)
        marketsInfo[c + 6] = tags[0]
        marketsInfo[c + 7] = tags[1]
        marketsInfo[c + 8] = tags[2]
        marketsInfo[c + 9] = MARKETS.getLastExpDate(marketID)
        marketsInfo[c + 10] = MARKETS.getMakerFees(marketID)
        eventID = MARKETS.getMarketEvent(marketID, 0)
        marketsInfo[c + 11] = eventID
        marketsInfo[c + 12] = EVENTS.getMinValue(eventID)
        marketsInfo[c + 13] = EVENTS.getMaxValue(eventID)
        marketsInfo[c + 14] = EVENTS.getNumOutcomes(eventID)
        marketsInfo[c + 15] = EVENTS.getOutcome(eventID)
        description = INFO.getDescription(eventID, outchars=descriptionLength)
        c += 16
        d = 0
        while d < descriptionLength:
            marketsInfo[c] = getch(description, d)
            c += 1
            d += 1
        m += 1
    return(marketsInfo: arr)

def getMarketCreatorFeesCollected(market):
    return((MARKETS.getFees(market) - INFO.getCreationFee(market))/2)

def getEventsWithSubmittedReport(branch, period, reporter):
    numEvents = EXPEVENTS.getNumberEvents(branch, period)
    events = array(numEvents)
    n = 0
    i = 0
    while(i < numEvents):
        eventID = EXPEVENTS.getEvent(branch, period, i)
        if(EXPEVENTS.getReport(branch, period, eventID, reporter) != 0):
            events[n] = eventID
            n += 1
        i += 1
    return(slice(events, items=0, items=n): arr)

def getPositionInMarket(market, account):
    numOutcomes = MARKETS.getMarketNumOutcomes(market)
    position = array(numOutcomes)
    i = 0
    while i < numOutcomes:
        position[i] = MARKETS.getParticipantSharesPurchased(market, account, i + 1)
        i += 1
    return(position: arr)

def getMarketsCreatedByMarketCreator(branch, creator, initial, last):
    if(last < initial):
        throw()
    markets = array(last - initial)
    marketsByCreator = array(last - initial)
    markets = BRANCHES.getSomeMarketsInBranch(branch, initial, last, outitems = (last - initial))
    i = 0
    n = 0
    while i < len(markets):
        if(INFO.getCreator(markets[i]) == creator):
            marketsByCreator[n] = markets[i]
            n += 1
        i += 1
    marketsByCreator = slice(marketsByCreator, items = 0, items = n)
    return(marketsByCreator: arr)
