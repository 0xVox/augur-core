# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have receive a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import events as EVENTS
import makeReports as MAKEREPORTS
import cash as CASH
inset('refund.se')

# [branchID][votingPeriod]
# reporthash is [reporterID] = hash
data EventsExpDates[][](numberEvents, numberRemoved, events[], numEventsToReportOn, reportHash[][], shareValue, roundTwoNumEvents)

data EventIDToIndex[][]

data branches[](beforeRep[][], afterRep[][], periodDormantRep[][], ethics[][](event[]), report[][](event[]), numReportsEvent[][], numReportsExpectedEvent[][], numReportsActual[][], reportedPeriod[][], repEvent[][])

data requiredEvents[]

# branch, period as params
data numReqEvents[][]

data mode_items[][](report_value[], current_mode, current_mode_items)

def getCurrentModeItems(period, event):
    return(self.mode_items[period][event].current_mode_items)

def getCurrentMode(period, event):
    return(self.mode_items[period][event].current_mode)
    
# returns weight of a report value for the mode
def getWeightOfReport(period, event, report):
    return(self.mode_items[period][event].report_value[report])

def getRepEvent(branch, votePeriod, event):
    return(self.branches[branch].repEvent[votePeriod][event])

def getReportedPeriod(branch, period, reporter):
    return(self.branches[branch].reportedPeriod[period][reporter])

def getEthicReport(branch, period, event):
    return(self.branches[branch].ethics[period][tx.origin].event[event])

def getNumReportsExpectedEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsExpectedEvent[votePeriod][eventID])

def getNumReportsEvent(branch, votePeriod, eventID):
    return(self.branches[branch].numReportsEvent[votePeriod][eventID])

def getReport(branch, period, event):
    #if(whitelist):
    return(self.branches[branch].report[period][tx.origin].event[event])

def getBeforeRep(branch, period):
    return(self.branches[branch].beforeRep[period][tx.origin])

def getAfterRep(branch, period):
    return(self.branches[branch].afterRep[period][tx.origin])
    
def getPeriodDormantRep(branch, period):
    return(self.branches[branch].periodDormantRep[period][tx.origin])

def getNumReportsActual(branch, votePeriod):
    return(self.branches[branch].numReportsActual[tx.origin][votePeriod])

def getNumRoundTwo(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].roundTwoNumEvents)

def addRoundTwo(branch, period):
    refund()
    self.EventsExpDates[branch][period].roundTwoNumEvents += 1
    return(1)

def getRequired(event):
    return(self.requiredEvents[event])
    
def getNumRequired(branch, period):
    return(self.numReqEvents[branch][period])
    
# Return 0 means already required
def setEventRequired(branch, period, event):
    if(self.requiredEvents[event]==0):
        self.requiredEvents[event] = 1
        self.numReqEvents[branch][period] += 1
        return(1)
    else:
        return(0)

# With this function you can get the eventIDs and report on outcomes
# @return all events in a branch and expiration period
def getEvents(branch, expDateIndex):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        i += 1
    return(events: arr)
    
def getEventsToReportOn(branch, expDateIndex):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents*2)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        reportingThreshold = MAKEREPORTS.calculateReportingThreshold(branch, events[i], expDateIndex)
        x = array(1)
        x[0] = tx.origin + events[i]
        shaHash = sha3(x, items=1)/ONE
        if((shaHash < reportingThreshold || shaHash<EVENTS.getReportingThreshold(events[i]) || self.getRequired(events[i])) && !EVENTS.getOutcome(events[i])):
            events[i+1] = 1
        else:
            events[i+1] = 0
        i += 2
    return(events: arr)
    
def getEventsRange(branch, expDateIndex, start, end):
    refund()
    numEvents = end-start
    events = array(numEvents)
    i = start
    index = 0
    while i < end:
        events[index] = self.EventsExpDates[branch][expDateIndex].events[i]
        index += 1
        i += 1
    return(events: arr)
    
def getEventIndex(period, eventID):
    refund()
    return(self.EventIDToIndex[period][eventID])

# we should probably make this bonded too
# -1: voting not started
def setNumEventsToReportOn(branch):
    refund()
    # after voting has started
    expDateIndex = BRANCHES.getVotePeriod(branch)
    self.EventsExpDates[branch][expDateIndex].numEventsToReportOn = (self.EventsExpDates[branch][expDateIndex].numberEvents - self.numReqEvents[branch][expDateIndex] - self.EventsExpDates[branch][expDateIndex].numberRemoved)*BRANCHES.getBaseReporters(branch)
    return(1)

def getNumEventsToReportOn(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numEventsToReportOn)

def getShareValue(branch, expIndex):
    refund()
    return(self.EventsExpDates[branch][expIndex].shareValue)

def getNumberEvents(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numberEvents)

def getEvent(branch, expDateIndex, eventIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].events[eventIndex])

def getReportHash(branch, expDateIndex, reporter, event):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event])

# check that msg.sender is one of our function contracts
def addEvent(branch, futurePeriod, eventID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID
    self.EventIDToIndex[futurePeriod][eventID] = self.EventsExpDates[branch][futurePeriod].numberEvents
    self.EventsExpDates[branch][futurePeriod].numberEvents += 1
    return(1)

def removeEvent(branch, period):
    refund()
    self.EventsExpDates[branch][period].numberRemoved += 1
    return(1)

def getNumRemoved(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].numberRemoved)

def adjustPeriodShareValueOutstanding(branch, expIndex, amount):
    refund()
    self.EventsExpDates[branch][expIndex].shareValue += amount
    return(1)

def setReportHash(branch, expDateIndex, reporter, reportHash, event):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event] = reportHash
    return(1)

# called in case an event doesn't get reported on at all in a period
def moveEvent(branch, event):
    if(BRANCHES.getVotePeriod(branch) > EVENTS.getExpiration(event)/BRANCHES.getPeriodLength(branch) && !EVENTS.getUncaughtOutcome(event)):
        # add to next expiration period
        self.addEvent(branch, block.timestamp/BRANCHES.getPeriodLength(branch), event)
        EVENTS.setExpiration(event, block.timestamp)
        return(1)
    else:
        return(0)
        
def addToWeightOfReport(period, event, report, amount):
    self.mode_items[period][event].report_value[report] += amount
    return(1)
    
def setCurrentMode(period, event, mode):
    self.mode_items[period][event].current_mode = mode
    return(1)
    
# basically setting current mode's weight
def setCurrentModeItems(period, event, modeReport):
    self.mode_items[period][event].current_mode = self.mode_items[period][event].report_value[modeReport]
    return(1)

def addRepEvent(branch, votePeriod, event, amount):
    self.branches[branch].repEvent[votePeriod][event] += amount
    return(1)
    
def setReportedPeriod(branch, period, reporter):
    self.branches[branch].reportedPeriod[period][reporter] = 1
    return(1)

def setEthicReport(branch, period, event, ethics):
    self.branches[branch].ethics[period][tx.origin].event[event] = ethics
    return(1)

def setNumReportsExpectedEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] = num
    return(1)

def setNumReportsEvent(branch, votePeriod, eventID, num):
    self.branches[branch].numReportsEvent[votePeriod][eventID] = num
    return(1)
    
def addReportToEvent(branch, votePeriod, eventID):
    self.branches[branch].numReportsEvent[votePeriod][eventID] += 1
    return(1)

def addReportExpected(branch, votePeriod, eventID):
    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] += 1
    return(1)

def setReport(branch, period, event, report):
    self.branches[branch].report[period][tx.origin].event[event] = report
    return(1)

def setBeforeRep(branch, period, rep):
    self.branches[branch].beforeRep[period][tx.origin] = rep
    return(rep)

def setAfterRep(branch, period, rep):
    self.branches[branch].afterRep[period][tx.origin] = rep
    return(rep)

def setPeriodDormantRep(branch, period, rep):
    self.branches[branch].periodDormantRep[period][tx.origin] = rep
    return(rep)