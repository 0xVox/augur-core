# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have receive a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

import branches as BRANCHES
import events as EVENTS
import makeReports as MAKEREPORTS
import cash as CASH
inset('refund.se')

# [branchID][votingPeriod]
# reporthash is [reporterID] = hash
data EventsExpDates[][](numberEvents, numberRemoved, events[], totalRepReported, numEventsToReportOn, reportHash[][], shareValue, roundTwoNumEvents)

data EventIDToIndex[][]

def getNumRoundTwo(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].roundTwoNumEvents)
    
def addRoundTwo(branch, period):
    refund()
    self.EventsExpDates[branch][period].roundTwoNumEvents += 1
    return(1)

# With this function you can get the eventIDs and report on outcomes
# @return all events in a branch and expiration period
def getEvents(branch, expDateIndex):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        i += 1
    return(events: arr)
    
def getEventsToReportOn(branch, expDateIndex):
    refund()
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents*2)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
    	reportingThreshold = MAKEREPORTS.calculateReportingThreshold(branch, events[i], expDateIndex)
    	x = array(1)
    	x[0] = tx.origin + events[i]
    	shaHash = sha3(x, items=1)/2**64
    	if(shaHash < reportingThreshold || shaHash<EVENTS.getReportingThreshold(events[i]) || MAKEREPORTS.getRequired(events[i])):
    	    events[i+1] = 1
    	else:
    	    events[i+1] = 0
        i += 2
    return(events: arr)
    
def getEventsRange(branch, expDateIndex, start, end):
    refund()
    numEvents = end-start
    events = array(numEvents)
    i = start
    index = 0
    while i < end:
        events[index] = self.EventsExpDates[branch][expDateIndex].events[i]
        index += 1
        i += 1
    return(events: arr)
    
def getEventIndex(period, eventID):
    refund()
    return(self.EventIDToIndex[period][eventID])

# we should probably make this bonded too
# -1: voting not started
def setNumEventsToReportOn(branch, expDateIndex):
    refund()
    # after voting has started
    if(expDateIndex==BRANCHES.getVotePeriod(branch)):
        # todo fix circular dependency
        numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents - MAKEREPORTS.getNumRequired(branch, expDateIndex)
        numberToReportOnEstimate = (numEvents-self.EventsExpDates[branch][expDateIndex].numberRemoved)*BRANCHES.getBaseReporters(branch)
        self.EventsExpDates[branch][expDateIndex].numEventsToReportOn = numberToReportOnEstimate
        return(1)
    else:
        return(-1)

def getNumEventsToReportOn(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numEventsToReportOn)

def getShareValue(branch, expIndex):
    refund()
    return(self.EventsExpDates[branch][expIndex].shareValue)

def getNumberEvents(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].numberEvents)

def getEvent(branch, expDateIndex, eventIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].events[eventIndex])

def getTotalRepReported(branch, expDateIndex):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].totalRepReported)

def getReportHash(branch, expDateIndex, reporter, event):
    refund()
    return(self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event])

# check that msg.sender is one of our function contracts
def addEvent(branch, futurePeriod, eventID):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID
    self.EventIDToIndex[futurePeriod][eventID] = self.EventsExpDates[branch][futurePeriod].numberEvents
    self.EventsExpDates[branch][futurePeriod].numberEvents += 1
    return(1)

def removeEvent(branch, period):
    refund()
    self.EventsExpDates[branch][period].numberRemoved += 1
    return(1)

def getNumRemoved(branch, period):
    refund()
    return(self.EventsExpDates[branch][period].numberRemoved)

def setTotalRepReported(branch, expDateIndex, repReported):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][expDateIndex].totalRepReported = repReported
    return(1)

def adjustPeriodShareValueOutstanding(branch, expIndex, amount):
    refund()
    self.EventsExpDates[branch][expIndex].shareValue += amount
    return(1)

def setReportHash(branch, expDateIndex, reporter, reportHash, event):
    refund()
    #if(!self.whitelist.check(msg.sender)):
    #	return(-1)
    self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event] = reportHash
    return(1)

# called in case an event doesn't get reported on at all in a period
def moveEvent(branch, event):
    if(BRANCHES.getVotePeriod(branch) > EVENTS.getExpiration(event)/BRANCHES.getPeriodLength(branch) && !EVENTS.getUncaughtOutcome(event)):
        # add to next expiration period
        self.addEvent(branch, block.timestamp/BRANCHES.getPeriodLength(branch), event)
        EVENTS.setExpiration(event, block.timestamp)
        return(1)
    else:
        return(0)