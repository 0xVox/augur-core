### Deals with whether a reporter can report on a given event

macro Controller: 0xC001D00D
extern Controller: [lookup:[int256]:int256, checkWhitelist:[int256]:int256]

BRANCHES = Controller.lookup('branches')
extern branches: [addCurrency:[int256,int256,int256,int256]:int256, addMarketToBranch:[int256,int256]:int256, disableCurrency:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getBranchesStartingAt:[int256]:int256[], getCreationDate:[int256]:int256, getBranchCurrency:[int256,int256]:int256, getCurrencyActive:[int256,int256]:int256, getCurrencyByContract:[int256,int256]:int256, getCurrencyRate:[int256,int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getForkTime:[int256]:int256, getInitialBalance:[int256,int256,int256]:int256, getMarketIDsInBranch:[int256,int256,int256]:int256[], getMinTradingFee:[int256]:int256, getMostRecentChild:[int256]:int256, getNumBranches:[]:int256, getNumCurrencies:[int256]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, getBranchWallet:[int256,int256]:int256, incrementPeriod:[int256]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256,int256,int256,int256]:int256, reactivateCurrency:[int256,int256]:int256, removeLastCurrency:[int256]:int256, replaceCurrency:[int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256,int256]:int256, setMostRecentChild:[int256,int256]:int256, updateCurrencyRate:[int256,int256,int256,int256]:int256, updateNumCurrencies:[int256,int256]:_]

CONSENSUS = Controller.lookup('consensusData')
extern consensusData.se: [decreaseDenominator:[int256,int256,int256]:int256, doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepCollected:[int256,int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:int256, setRefund:[int256,int256]:int256, setRepCollected:[int256,int256,int256]:int256, setSlashed:[int256,int256,int256]:int256]

EVENTS = Controller.lookup('events')
extern events: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, addReportersPaidSoFar:[int256]:int256, getBond:[int256]:int256, getChallenged:[int256]:int256, getCreationTime:[int256]:int256, getEarlyResolutionBond:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventPushedUp:[int256]:int256, getEventResolution:[int256]:bytes, getExpiration:[int256]:int256, getExtraBond:[int256]:int256, getFirstPreliminaryOutcome:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForkResolveAddress:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getMode:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportersPaidSoFar:[int256]:int256, getReportingThreshold:[int256]:int256, getResolutionAddress:[int256]:int256, getResolutionLength:[int256]:int256, getResolveBondPoster:[int256]:int256, getUncaughtOutcome:[int256]:int256, getEventInfo:[int256]:int256[], initializeEvent:[int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setChallenged:[int256]:int256, setCreationTime:[int256]:int256, setEarlyResolutionBond:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setExtraBond:[int256,int256]:int256, setFirstPreliminaryOutcome:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setMode:[int256,int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256]

EXPEVENTS = Controller.lookup('expiringEvents')
extern expiringEvents: [addEvent:[int256,int256,int256,int256,int256,int256,int256]:int256, addReportToReportsSubmitted:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodFeeValue:[int256,int256,int256]:int256, countReportAsSubmitted:[int256,int256,int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getActiveReporters:[int256,int256,int256,int256]:int256[], getAfterFork:[int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256,int256]:int256, getEventWeight:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getFeeValue:[int256,int256]:int256, getLesserReportNum:[int256,int256,int256]:int256, getNumActiveReporters:[int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsSubmitted:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepWeight:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportsCommitted:[int256,int256,int256]:int256, getRequired:[int256,int256,int256]:int256, getSaltyEncryptedHash:[int256,int256,int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setEventWeight:[int256,int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepWeight:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setSaltyEncryptedHash:[int256,int256,int256,int256,int256]:int256]

FXP = Controller.lookup('fxpFunctions')
extern fxpFunctions: [fxExp:[int256]:int256, fxLog:[int256]:int256]

REPORTING = Controller.lookup('reporting')
extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOfReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, claimInitialRep:[]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReportedOnNonFinalRoundTwoEvent:[int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256]:int256, setRep:[int256,int256,int256]:int256, setReportedOnNonFinalRoundTwoEvent:[int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]

MAKEREPORTS = Controller.lookup('makeReports')
extern makeReports: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, makeHash:[int256,int256,int256,int256,int256]:int256, submitReport:[int256,int256,int256,int256]:_, submitReportHash:[int256,int256,int256]:_, validateReport:[int256,int256,int256,int256,int256,int256,int256]:int256]


# fix circular dependency ^
inset('refund.se')
inset('float.se')
inset('../functions/eventHelpers.se')

macro ONE_POINT_TWO: 1200000000000000000

macro POINT_ZERO_ONE: 10000000000000000

macro MAX_THRESHOLD: 10 ** 54

macro MIN_EVENTS_FOR_WHALE_TO_REPORT_ON: 30

# Calculates what a reporter should have to get below as a target to report on any given event
# eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2))
    # exp(1.2*ln(repbal)) / exp(1.2*ln(totalrep)) is == (reporterList[n]/totalRep)**1.2
    # a**b=exp(b*ln(a))=e**(b*ln(a)).
# whitelist
# @return fxp
def calculateReportingThreshold(branch, event, period, sender):
    repConstant = EXPEVENTS.getPeriodRepWeight(branch, period, sender)
    if(!repConstant):
        calculateAndSetRepConstant()
    # 1 is 10**54 here, lesserreportnum, repconstant, and one are all base 10**18
    reportingThreshold = EXPEVENTS.getLesserReportNum(branch, period, event) * repConstant * ONE
    if(reportingThreshold > MAX_THRESHOLD):
        reportingThreshold = MAX_THRESHOLD
    return(reportingThreshold)

# Gets events a reporter should report on
# start is the event index we want to start fetching events to report on from
def getEventsToReportOn(branch, period, sender, start, end):
    if(end == 0):
        end = EXPEVENTS.getNumberEvents(branch, period)
    events = array(numEvents)
    i = 0
    numEventsToReportOn = 0
    while i < end:
        thisEvent = EXPEVENTS.getEvent(branch, period, start + i)
        if thisEvent != 0:
            # calculate report target for event here if not done for purposes of computing this
            if(!EXPEVENTS.getLesserReportNum(branch, period, thisEvent)):
                MAKEREPORTS.calculateReportTargetForEvent(branch, thisEvent, period, msg.sender)
            reportingThreshold = self.calculateReportingThreshold(branch, thisEvent, period, sender)
            hash = sha3([sender, thisEvent], items = 2)
            shaHash = abs(hash) / ONE * 2
            shaHash = shaHash / 57896044618658097711785L * ONE
            notResolvedYet = !EVENTS.getOutcome(thisEvent)
            ableToReportOn = (shaHash < reportingThreshold or EXPEVENTS.getRequired(thisEvent, period, branch)) and notResolvedYet and !eventCreatedPriorToFork(thisEvent)
            if(ableToReportOn):
                events[numEventsToReportOn] = thisEvent
                numEventsToReportOn += 1
        i += 1
    return(slice(events, items = 0, items = numEventsToReportOn): arr)

# Gets whether a reporter is able to report on a given event or not
# Returns 1 if able
# Errors: 0 if not
# whitelist
def getEventCanReportOn(branch, period, reporter, event):
    if(!EXPEVENTS.getLesserReportNum(branch, period, event)):
        MAKEREPORTS.calculateReportTargetForEvent(branch, event, period, reporter)
    reportingThreshold = self.calculateReportingThreshold(branch, event, period, reporter)

    # do abs then mult by 2 to ensure it's positive and between 0 and 1
    hash = sha3([reporter, event], items = 2)
    shaHash = (abs(hash) / ONE) * 2
    shaHash = shaHash / 57896044618658097711785L * ONE
    wasAbleToReportOn = (shaHash < reportingThreshold or EXPEVENTS.getRequired(event, period, branch)) and !eventCreatedPriorToFork(event)
    if(!wasAbleToReportOn):
        return(0)
    return(1)

# In the rare possibility that less than 3 reporters get randomly selected to report on a market in a given period, on the last day, we can change the sha3 threshold, UI calls this.
# Returns 1 if the event's reporting threshold has been set
# Errors: 0 if the event can't be reported on
def setReportingThreshold(event):
    # first check is if event expDate is in the current vote period and second is if blockNum is near expiration of commit period (within 24 hr.)
    # final check is if no reports [commits] on event
    # so if in 24 hr we'd be in the next half of the vote period, we're within 24 hr of the end of this half
    branch = EVENTS.getEventBranch(event)
    periodLength = BRANCHES.getPeriodLength(branch)
    currentVotePeriod = BRANCHES.getVotePeriod(branch)
    inCurrentVotePeriod = (currentVotePeriod == EVENTS.getExpiration(event) / periodLength)
    reportsCommitted = EXPEVENTS.getReportsCommitted(branch, currentVotePeriod, event)
    periodHalfEndsInLessThanADay = ((block.timestamp + TWENTY_FOUR_HR) % periodLength) > (periodLength / 2)
    if(!inCurrentVotePeriod or !periodHalfEndsInLessThanADay or reportsCommitted >= 3 or eventCreatedPriorToFork(event)):
        return(0)
    EVENTS.setThreshold(event, MAX_THRESHOLD)
    return(1)

macro calculateAndSetRepConstant():
    repConstant = FXP.fxExp(ONE_POINT_TWO * FXP.fxLog(REPORTING.getRepBalance(branch, sender)) / ONE) * ONE / FXP.fxExp(ONE_POINT_TWO * FXP.fxLog(REPORTING.getActiveRep(branch)) / ONE)
    numEventsAvailableToReportOn = EXPEVENTS.getNumEventsToReportOn(branch, period)
    expectedEventsForReporter = repConstant * numEventsAvailableToReportOn
    # this includes required events
    eventsInPeriod = EXPEVENTS.getNumberEvents(branch, period) - EXPEVENTS.getNumRemoved(branch, period)
    numRequiredEvents = EXPEVENTS.getNumRequired(branch, period)
    # ensures low number of events with highly concentrated rep edge case still get reported on
    if(repFraction >= POINT_ZERO_ONE):
        minimum = min(MIN_EVENTS_FOR_WHALE_TO_REPORT_ON - numRequiredEvents, eventsInPeriod - numRequiredEvents)
        if(expectedEventsForReporter / ONE < minimum):
            expectedEventsForReporter = minimum * ONE
            repConstant = expectedEventsForReporter / numEventsAvailableToReportOn
    EXPEVENTS.setPeriodRepWeight(branch, period, sender, repConstant)

macro abs($a):
    if($a < 0):
        $a = -$a
    $a

# simply a helper function / useful to know
# @return fxp
def calculateNumberOfEventsAReporterHasToReportOnAtMinimum(branch, reporter, period):
    originalRep = EXPEVENTS.getBeforeRep(branch, period, reporter)
    # this includes the baseReporters * numEventsAvailable
    numEventsAvailableToReportOn = EXPEVENTS.getNumEventsToReportOn(branch, period)
    # events a user should be reporting on
    # eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2))
    # a**b=exp(b*ln(a))=e**(b*ln(a)).
    repConstant = FXP.fxExp(ONE_POINT_TWO * FXP.fxLog(originalRep) / ONE) * ONE / FXP.fxExp(ONE_POINT_TWO * FXP.fxLog(REPORTING.getActiveRep(branch)) / ONE)
    numRequiredEvents = EXPEVENTS.getNumRequired(branch, period)
    forkPeriod = BRANCHES.getForkPeriod(branch)
    period = BRANCHES.getVotePeriod(branch)
    forkScenario = period == (forkPeriod + 1) or period == (forkPeriod + 2)
    expectedEventsForReporterIncludingRequired = 0
    if(forkScenario):
        expectedEventsForReporterIncludingRequired = repConstant * numEventsAvailableToReportOn
    else:
        expectedEventsForReporterIncludingRequired = repConstant * numEventsAvailableToReportOn + numRequiredEvents * ONE
    dealWithWhaleReporters()
    return(expectedEventsForReporterIncludingRequired / 2)

macro dealWithWhaleReporters():
    eventsInPeriod = safeSub(EXPEVENTS.getNumberEvents(branch, lastPeriod), EXPEVENTS.getNumRemoved(branch, lastPeriod))
    reporterIsAWhale = repConstant >= POINT_ZERO_ONE
    if(reporterIsAWhale and forkScenario):
        minimum = safeAdd(MIN_EVENTS_FOR_WHALE, numEventsAvailableToReportOn)
        if(expectedEventsForReporterIncludingRequired / ONE < minimum):
            expectedEventsForReporterIncludingRequired = minimum * ONE
    elif(reporterIsAWhale and forkScenario):
        minimum = min(safeAdd(MIN_EVENTS_FOR_WHALE, numRequiredEvents), eventsInPeriod)
        if(expectedEventsForReporterIncludingRequired / ONE < minimum):
            expectedEventsForReporterIncludingRequired = minimum * ONE
    baseReporters = CONSENSUS.getBaseReportersLastPeriod(branch)
    total = safeMul(repConstant, baseReporters)
    # if total is too high [>1] then expectedEventsForReporterIncludingRequired will estimate a higher number than reality, so need to correct for this below
    # correction for if people have more than x [4.6% of at 40 min reporters] rep in one account - they report on everything (hence incentive to divy rep into mult. accounts and not pool) i.e. if((exp(ln(rep%)*1.2)+0.001)*baseReporters > 1)
    if(total > ONE and forkScenario):
        expectedEventsForReporterIncludingRequired = safeMul(safeDiv(numEventsAvailableToReportOn, baseReporters), ONE)
    elif(total > ONE):
        expectedEventsForReporterIncludingRequired = safeAdd(safeMul(safeDiv(numEventsAvailableToReportOn, baseReporters), ONE), safeMul(numRequiredEvents, ONE))

# If anyone w/ 1 rep or more in active rep could've reported in a period but didn't enough they need to be penalized.
# Loop through the list of all active reporters in a period and branch and check their expected minimum number of events to report on, if they've reported on less than this then find an example event they could've reported on but didn't, then return those addresses and events
def findLazyReportersAndLeechers(branch, votePeriod, reporterStart, reporterEnd, eventStart, eventEnd):
    if(reporterEnd == 0):
        reporterEnd = EXPEVENTS.getNumActiveReporters(branch, votePeriod)
    numberReportersChecking = (reporterEnd - reporterStart)
    activeReporters = array(numberReportersChecking)
    activeReporters = EXPEVENTS.getActiveReporters(branch, votePeriod, reporterStart, reporterEnd, outitems = numberReportersChecking)
    lazyReportersAndExampleEventsTheyCouldveReportedOn = array(numberReportersChecking * 2)
    reporterIndex = 0
    leecherIndex = 0
    while(reporterIndex < numberReportersChecking):
        reporter = activeReporters[reporterIndex]
        if(EXPEVENTS.getNumReportsSubmitted(branch, votePeriod, reporter) < self.calculateNumberOfEventsAReporterHasToReportOnAtMinimum(branch, reporter, votePeriod)):
            if(eventEnd == 0):
                eventEnd = EXPEVENTS.getNumberEvents(branch, votePeriod)
            numberEventsChecking = eventEnd - eventStart
            events = array(numberEventsChecking)
            events = EXPEVENTS.getEventsRange(branch, votePeriod, eventStart, eventEnd, outitems = numberEventsChecking)
            eventIndex = 0
            while(eventIndex < numberEventsChecking):
                if(self.getEventCanReportOn(branch, votePeriod, reporter, events[eventIndex])):
                    lazyReportersAndExampleEventsTheyCouldveReportedOn[leecherIndex] = reporter
                    lazyReportersAndExampleEventsTheyCouldveReportedOn[leecherIndex+1] = events[e]
                    leecherIndex += 2
                    eventIndex = numberEventsChecking
                else:
                    eventIndex += 1
        reporterIndex += 1
    return(slice(lazyReportersAndExampleEventsTheyCouldveReportedOn, items=0, items=leecherIndex): arr)
