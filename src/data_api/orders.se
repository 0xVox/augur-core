# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

MARKETS = self.controller.lookup('markets')
extern markets: [addFees:[int256,int256]:int256, addOrder:[int256,int256]:int256, addToMarketsHash:[int256,int256]:int256, getBondsMan:[int256]:int256, getBranch:[int256]:int256, getCumulativeScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getGasSubsidy:[int256]:int256, getLastExpDate:[int256]:int256, getLastOrder:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getMarketEvent:[int256]:int256, getMarketNumOutcomes:[int256]:int256, getMarketResolved:[int256]:int256, getMarketShareContracts:[int256]:int256[], getMarketsHash:[int256]:int256, getOrderIDs:[int256]:int256[], getOriginalTradingPeriod:[int256]:int256, getOutcomeShareContract:[int256,int256]:int256, getOutcomeShareWallet:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPrevID:[int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:uint256, getSharesValue:[int256]:int256, getTags:[int256]:int256[], getTopic:[int256]:int256, getTotalOrders:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, initializeMarket:[int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256,int256[],int256[]]:int256, modifyMarketVolume:[int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, removeOrderFromMarket:[int256,int256]:int256, setController:[address]:int256, setMarketResolved:[int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, suicideFunds:[address]:_]

inset('../macros/safeMath.sem')
inset('../macros/refund.sem')

### Storage of all data associated with orders

# traderID is index
data orderCommits[](hash, block)
# orderID is index
data orders[](id, type, market, fxpAmount, fxpPrice, owner, block, outcome, fxpSharesEscrowed, fxpMoneyEscrowed)

data controller

event CancelOrder(market: indexed, sender: indexed, fxpPrice, fxpAmount, orderID, outcome, type, cashRefund, sharesRefund, timestamp)
event CompleteSets(sender: indexed, market: indexed, type: indexed, fxpAmount, numOutcomes, fxpFee, timestamp)
event MakeOrder(market: indexed, sender: indexed, type, fxpPrice, fxpAmount, outcome, orderID, fxpMoneyEscrowed, fxpSharesEscrowed, timestamp, tradeGroupID)
event TakeAskOrder(market: address: indexed, sender: address: indexed, owner: address: indexed, type: uint256, fxpPrice, fxpAmount: uint256, timestamp: uint256, orderID: address, outcome: uint256, fxpAskerSharesFilled: uint256, fxpAskerMoneyFilled: uint256, fxpBidderMoneyFilled: uint256, fxpFee: uint256)
event TakeBidOrder(market: address: indexed, sender: address: indexed, owner: address: indexed, type: uint256, fxpPrice, fxpAmount: uint256, timestamp: uint256, orderID: address, outcome: uint256, fxpAskerSharesFilled: uint256, fxpAskerMoneyFilled: uint256, fxpBidderSharesFilled: uint256, fxpBidderMoneyFilled: uint256, fxpFee: uint256)

# Trade types
macro BID: 1
macro ASK: 2

def init():
    self.controller = 0x0

def makeOrderHash(market, outcome, direction):
    refund()
    orderInfo = array(4)
    orderInfo[0] = market
    orderInfo[1] = outcome
    orderInfo[2] = direction
    orderInfo[3] = msg.sender
    orderHash = ripemd160(orderInfo, items=4)
    return(orderHash)

def commitOrder(hash):
    refund()
    self.orderCommits[msg.sender].hash = hash
    self.orderCommits[msg.sender].block = block.number
    return(1)

def checkHash(orderHash, sender):
    if(self.orderCommits[sender].hash != orderHash or block.number <= self.orderCommits[sender].block):
        ~invalid()
    else:
        return(1)

def saveOrder(orderID, type, market, fxpAmount, fxpPrice, sender, outcome, fxpMoneyEscrowed, fxpSharesEscrowed, tradeGroupID):
    self.controller.assertIsWhitelisted(msg.sender)
    if(outcome > MARKETS.getMarketNumOutcomes(market)):
        ~invalid()
    self.orders[orderID].id = orderID
    self.orders[orderID].type = type
    self.orders[orderID].market = market
    self.orders[orderID].fxpAmount = fxpAmount
    self.orders[orderID].fxpPrice = fxpPrice
    self.orders[orderID].owner = sender
    self.orders[orderID].block = block.number
    self.orders[orderID].outcome = outcome
    self.orders[orderID].fxpMoneyEscrowed = fxpMoneyEscrowed
    self.orders[orderID].fxpSharesEscrowed = fxpSharesEscrowed
    log(type = MakeOrder, market, sender, type, fxpPrice, fxpAmount, outcome, orderID, fxpMoneyEscrowed, fxpSharesEscrowed, block.timestamp, tradeGroupID)
    return(1)

def getOrder(id):
    order = array(10)
    order[0] = self.orders[id].id
    order[1] = self.orders[id].type
    order[2] = self.orders[id].market
    order[3] = self.orders[id].fxpAmount
    order[4] = self.orders[id].fxpPrice
    order[5] = self.orders[id].owner
    order[6] = self.orders[id].block
    order[7] = self.orders[id].outcome
    order[8] = self.orders[id].fxpMoneyEscrowed
    order[9] = self.orders[id].fxpSharesEscrowed
    if(order):
        return(order: arr)
    return([0]: arr)

def removeOrder(id):
    self.controller.assertIsWhitelisted(msg.sender)
    self.orders[id].id = 0
    self.orders[id].type = 0
    self.orders[id].market = 0
    self.orders[id].fxpAmount = 0
    self.orders[id].fxpPrice = 0
    self.orders[id].owner = 0
    self.orders[id].block = 0
    self.orders[id].outcome = 0
    self.orders[id].fxpMoneyEscrowed = 0
    self.orders[id].fxpSharesEscrowed = 0
    return(1)

def fillOrder(orderID, fill, money, shares):
    self.controller.assertIsWhitelisted(msg.sender)
    if(fill > self.orders[orderID].fxpAmount or money > self.orders[orderID].fxpMoneyEscrowed or shares > self.orders[orderID].fxpSharesEscrowed):
        ~invalid()
    self.orders[orderID].fxpAmount -= fill
    self.orders[orderID].fxpMoneyEscrowed -= money
    self.orders[orderID].fxpSharesEscrowed -= shares
    return(1)

def takeBidOrderLog(market: address, sender: address, owner: address, fxpPrice, fxpSumOfFills: uint256, orderID: address, outcome: uint256, fxpAskerSharesFilled: uint256, fxpAskerMoneyFilled: uint256, fxpBidderSharesFilled: uint256, fxpBidderMoneyFilled: uint256, fxpFee: uint256):
    # Log transaction [ASK b/c it's filling a bid so from trader's perspective they're asking]
    log(type=TakeBidOrder, market, sender, owner, ASK, fxpPrice, fxpSumOfFills, block.timestamp, orderID, outcome, fxpAskerSharesFilled, fxpAskerMoneyFilled, fxpBidderSharesFilled, fxpBidderMoneyFilled, fxpFee)
    return(1)

def takeAskOrderLog(market: address, sender: address, owner: address, fxpPrice, fxpSumOfFills: uint256, orderID: address, outcome: uint256, fxpAskerSharesFilled: uint256, fxpAskerMoneyFilled: uint256, fxpBidderMoneyFilled: uint256, fxpFee: uint256):
    # Log transaction [BID b/c it's filling an ask so from trader's perspective they're bidding]
    log(type=TakeAskOrder, market, sender, owner, BID, fxpPrice, fxpSumOfFills, block.timestamp, orderID, outcome, fxpAskerSharesFilled, fxpAskerMoneyFilled, fxpBidderMoneyFilled, fxpFee)
    return(1)

def completeSetsLog(sender, market, type, fxpAmount, numOutcomes, fee):
    log(type = CompleteSets, sender, market, type, fxpAmount, numOutcomes, fee, block.timestamp)
    return(1)

def cancelOrderLog(market, sender, fxpPrice, fxpAmount, orderID, outcome, type, fxpMoneyEscrowed, fxpSharesEscrowed):
    log(type = CancelOrder, market, sender, fxpPrice, fxpAmount, orderID, outcome, type, fxpMoneyEscrowed, fxpSharesEscrowed, block.timestamp)
    return(1)

# @return fxp
def getAmount(id):
    return(self.orders[id].fxpAmount)

def getID(orderID):
    return(self.orders[orderID].id)

# @return fxp
def getPrice(id):
    return(self.orders[id].fxpPrice)

def getOrderOwner(id):
    return(self.orders[id].owner)

def getType(id):
    return(self.orders[id].type)

def setController(newController: address):
    if(msg.sender != self.controller):
        ~invalid()
    self.controller = newController
    return(1)

def suicideFunds(to: address):
    if(msg.sender != self.controller):
        ~invalid()
    suicide(to)