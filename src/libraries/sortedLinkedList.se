data comparor
data collection[](exists, prev, next)
data count
data head
data tail
data owner
data initialized

inset('../macros/require.sem')

extern comparisonProviderInterface: [compare:[int256, int256]:int256]

def init():
    self.owner = msg.sender

def any():
    require(msg.sender == self.owner or msg.sender == self)

def initialize(comparor: address):
    require(not self.initialized)
    self.initialized = 1
    self.comparor = comparor
    return(1)

def add(item: int256, hints: arr):
    if (self.contains(item)):
        self.remove(item)

    # If this is the only node it is the head / tail and we can early out
    if (self.count == 0):
        self.head = item
        self.tail = item
        self.collection[item].exists = 1
        self.count += 1
        return(1)

    # By default we begin the insertion search at the head
    nodeValue = self.head

    # If hints are provided (and valid) we will use the first still present value to begin the search
    hintIndex = 0
    while(hintIndex < len(hints) and nodeValue == self.head):
        hint = hints[hintIndex]
        if (self.contains(hint) and self.comparor.compare(hint, item) == 1):
            nodeValue = hint
        hintIndex += 1

    # Do traversal to find the insertion point
    while(self.hasPrev(nodeValue) and self.comparor.compare(nodeValue, item) >= 0):
        nodeValue = self.getPrev(nodeValue)
    
    # Actually insert the node
    # if the node we stop on is greater than or equal to this item we insert before it 
    if (self.comparor.compare(nodeValue, item) >= 0):
        if (self.hasPrev(nodeValue)):
            self.collection[self.getPrev(nodeValue)].next = item
            self.collection[item].prev = self.getPrev(nodeValue)
        self.collection[nodeValue].prev = item
        self.collection[item].next = nodeValue
    # otherwise we insert after the node
    else:
        if (self.hasNext(nodeValue)):
            self.collection[self.getNext(nodeValue)].prev = item
            self.collection[item].next = self.getNext(nodeValue)
        self.collection[nodeValue].next = item
        self.collection[item].prev = nodeValue
    
    # Do basic inclusion in the actual set
    self.collection[item].exists = 1
    self.count += 1

    # set head and tail if needed
    if (!self.hasNext(item)):
        self.head = item
    if (!self.hasPrev(item)):
        self.tail = item

    self.assertInvariants()
    return(1)

def remove(item: int256):
    if (!self.contains(item)):
        return(0)

    hasPrev = self.hasPrev(item)
    hasNext = self.hasNext(item)

    if (hasPrev):
        if (hasNext):
            self.collection[self.collection[item].prev].next = self.getNext(item)
        else:
            self.head = self.getPrev(item)

    if (hasNext):
        if (hasPrev):
            self.collection[self.collection[item].next].prev = self.getPrev(item)
        else:
            self.tail = self.getNext(item)

    self.collection[item].exists = 0

    self.count -= 1
    self.assertInvariants()
    return(1)

def getHead():
    require(self.count > 0)
    return(self.head)

def getTail():
    require(self.count > 0)
    return(self.tail)

def getNext(item: int256):
    require(self.contains(item))
    require(self.hasNext(item))
    return(self.collection[item].next)

def getPrev(item: int256):
    require(self.contains(item))
    require(self.hasPrev(item))
    return(self.collection[item].prev)

def hasNext(item: int256):
    require(self.contains(item))
    return(self.collection[self.collection[item].next].exists)

def hasPrev(item: int256):
    require(self.contains(item))
    return(self.collection[self.collection[item].prev].exists)

def contains(item: int256):
    return(self.collection[item].exists)

def count():
    return(self.count)

def isEmpty():
    return(self.count == 0)

def assertInvariants():
    if (not self.head):
        require(self.tail)
        require(self.count)

    if (not self.tail):
        require(self.head)
        require(self.count)

    if (not self.count):
        require(self.head)
        require(self.tail)
