# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]
BRANCHES = create('../data_api/branches.se')
extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]
CASH = create('../data_api/cash.se')
extern refund.se: [addFees:[int256,int256]:int256, addToMarketsHash:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsHash:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]
MARKETS = create('../data_api/markets.se')
extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]
EVENTS = create('../data_api/events.se')
extern closeMarketOne: [oneOutcome:[int256,int256,int256,int256,int256]:int256]
CLOSEONE = create('../functions/closeMarketOne.se')
extern closeMarketTwo: [twoOutcomes:[int256,int256[],int256,int256]:int256]
CLOSETWO = create('../functions/closeMarketTwo.se')
extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256]
BACKSTOPS = create('../data_api/backstops.se')
extern eventResolution: [determineWinningOutcomes:[int256]:int256[], resolveBinary:[int256,int256,int256,int256]:int256, resolveCategoricalOrScalar:[int256,int256,int256,int256,int256,int256]:int256]
RESOLVE = create('../functions/eventResolution.se')
inset('refund.se')
inset('logReturn.se')

event closeMarket_logReturn(returnValue)

# first param is the market, second param is the subcurrency contract
data cash[][]

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF

macro CATCH_TOLERANCE: ONE / 10


# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

# If ethicality value <.5 it's 0, otherwise it's ethical
macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

# Loop through events in the market, get their outcomes && use those to determine the winning outcomes and resolve a market!
# @return 0 if fail/trading not over yet/event not expired or closed already, if success 1
# Error messages otherwise
    # -1: Market has no cash anyway / already closed
    # -2: 0 outcome / not reported on yet
    # -3: not final round 2 event
    # -4: market isn't in branch
    # -5: Event forked and not final yet
    # -6: bonded pushed forward market not ready to be resolved
    # -7: already resolved
# if market's events have moved due to a fork branch param passed should be the new fork [todo check to make sure it handles the wrong branch param properly here]
def closeMarket(branch, market, sender):
    refund()
    numberEvents = MARKETS.getNumEvents(market)
    tradingPeriod = MARKETS.getTradingPeriod(market)
    period = BRANCHES.getVotePeriod(branch)
    event = MARKETS.getMarketEvent(market, 0)
    if(CASH.balance(market)<=0):
        logReturn(closeMarket_logReturn, -1)
    if(EVENTS.getUncaughtOutcome(event)==0):
        logReturn(closeMarket_logReturn, -2)
    if(BACKSTOPS.getRoundTwo(event) && !BACKSTOPS.getFinal(event)):
        logReturn(closeMarket_logReturn, -3)
    if(MARKETS.getBranchID(market)!=branch):
        logReturn(closeMarket_logReturn, -4)
    # checks whether any events not already resolved
    resolved = 1
    # what if we forked or round 2 won't it be resolved and thus market never gets resolved todo
    if(EVENTS.getOutcome(event)==0 && EVENTS.getmode(event)==0):
        resolved = 0
    if((period > tradingPeriod) && !resolved):
        # look at through event in the market, get its outcomes, resolve it && use those to determine the winning outcomes for a given market!
        votingPeriodEvent = EVENTS.getExpiration(event)/BRANCHES.getPeriodLength(branch)
        fxpOutcome = EVENTS.getOutcome(event)
        resolution = 1
        forkPeriod = BRANCHES.getForkPeriod(EVENTS.getEventBranch(event))
        currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)
        if((EVENTS.getForked(event) && !EVENTS.getForkedDone(event)) or (currentPeriod <= (forkPeriod+1))):
            logReturn(closeMarket_logReturn, -5)
        if(binary(event) && fxpOutcome==0):
            resolution = RESOLVE.resolveBinary(event, market, branch, votingPeriodEvent)
        elif(scalar(event) && EVENTS.getmode(event)==0):
            resolution = RESOLVE.resolveCategoricalOrScalar(EVENTS.getMinValue(event), EVENTS.getMaxValue(event), event, market, branch, votingPeriodEvent)
        elif(categorical(event) && EVENTS.getmode(event)==0):
            resolution = RESOLVE.resolveCategoricalOrScalar(ONE, ONE*EVENTS.getNumOutcomes(event), event, market, branch, votingPeriodEvent)
        if(resolution==-6):
            logReturn(closeMarket_logReturn, -6)
        winningOutcomes = array(8)
        winningOutcomes = RESOLVE.determineWinningOutcomes(event, outitems=8)
        MARKETS.setWinningOutcomes(market, winningOutcomes)
        # refunds closing cost
        MARKETS.refundClosing(market, sender)
        logReturn(closeMarket_logReturn, 1)
    else:
        logReturn(closeMarket_logReturn, 0)

# Claim trading profits/value per share after a market is resolved
# @returns 1 if successful
# Errors:
    # 0: market not resolved
    # -1: trader doesn't exist
    # -8: invalid branch
def claimProceeds(branch, market):
    refund()
    if(MARKETS.getBranchID(market)!=branch):
        return(-8)
    tradingPeriod = MARKETS.getTradingPeriod(market)
    period = BRANCHES.getVotePeriod(branch)
    event = MARKETS.getMarketEvent(market, 0)
    resolved = 1
    if(EVENTS.getOutcome(event)==0 && EVENTS.getmode(event)==0):
        resolved = 0
    # as long as it's resolved money can be collected
    if((period > tradingPeriod || reportingDone) && resolved):
        winningOutcomes = array(8)
        winningOutcomes = MARKET.getWinningOutcomes(market, outitems=8)
        outcome = 0
        # market not resolved
        if(winningOutcomes[0]==0):
            return(0)
        if(winningOutcomes[1]==0):
            ethical = ethic_catch(EVENTS.getEthical(event))
            # unethical or .5 categorical 1d market is resolved with all outcomes having equal values
            if(categorical(event) && (EVENTS.getmode(event)==ONEHALF or !ethical)):
                outcome = CLOSEONE.oneOutcome(market, winningOutcomes[0], msg.sender, 1, EVENTS.getNumOutcomes(event))
            # resolves a regular binary market
            else:
                outcome = CLOSEONE.oneOutcome(market, winningOutcomes[0], msg.sender, 0, 0)
        # resolves a scalar market
        elif(winningOutcomes[1]):
            outcome = CLOSETWO.twoOutcomes(market, winningOutcomes, event, msg.sender)
        return(outcome)
    else:
        return(0)

macro scalar($event):
    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)

macro binary($event):
    (EVENTS.getNumOutcomes($event)==2 and EVENTS.getMaxValue($event)==TWO and EVENTS.getMinValue($event)==ONE)

macro categorical($event):
    (EVENTS.getNumOutcomes($event)>2)