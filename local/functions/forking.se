extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]
INFO = create('../data_api/info.se')
extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]
CASH = create('../data_api/cash.se')
extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]
BRANCHES = create('../data_api/branches.se')
extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]
REPORTING = create('../data_api/reporting.se')
extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]
EVENTS = create('../data_api/events.se')
extern refund.se: [addFees:[int256,int256]:int256, addToMarketsHash:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsHash:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]
MARKETS = create('../data_api/markets.se')
extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256]
BACKSTOPS = create('../data_api/backstops.se')
extern sendReputation: [allowance:[int256,int256]:int256, approve:[int256,int256,int256]:int256, convertToActiveRep:[int256,int256]:int256, convertToDormantRep:[int256,int256]:int256, sendReputation:[int256,int256,int256]:int256, transfer:[int256,int256,int256]:int256, transferFrom:[int256,int256,int256,int256]:int256]
SENDREP = create('../functions/sendReputation.se')
extern roundTwo: [resolve:[int256,int256]:int256, roundTwoPostBond:[int256,int256,int256,int256]:int256, roundTwoResolve:[int256,int256,int256,int256]:int256]
ROUNDTWO = create('../functions/roundTwo.se')
extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256]
EXPEVENTS = create('../data_api/expiringEvents.se')
extern createBranch: [createSubbranch:[bytes,int256,int256,int256,int256]:int256]
CREATEBRANCH = create('../functions/createBranch.se')
extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256]
CONSENSUSDATA = create('../data_api/consensusData.se')
inset('refund.se')

macro POINTZEROONE: 10000000000000000

# UI has to handle function calls for these

#Notes:
    #Anyone can pay some amount significantly greater than the bond amount to force a branching event, splitting rep into two classes.
    #In one class the reported outcome for whatever event was the cause of dispute is said to be right, and rep is redistributed accordingly.
    #In the other class/branch, the event is readjudicated and remove the outcome on the pre fork branch and rep is redistributed as normal, except people who said the original outcome in the original fork lose rep.
    # Note: Whichever outcome was truly the correct one would determine which branch had rep that actually held value.  This would be akin to a Bitcoin hard fork scenario.  The winning fork, of course, would be the one with the most voluminous markets, which would be determined by the fork that represented reality, which would have a higher market cap.  Markets go to the most popular fork by default after 2 months.

# Period where we forked, at the end of it
    # don't penalize for this period / anything that happened here should be considered to not have happened - done
    # let period be incremented as normal - done
    # no rep redistribution on this period besides for event forked over on original. parent but don't actually resolve the event until later per below - done
    # fork users get a free pass for not reporting on this period - done
# Period after fork where we need to do nothing while waiting for fork to resolve
    # free pass for not reporting during this period in og branch - done, UI needs to call penalizeWrong with a 0 as event param or todo do this contract side after doing penalize wrong
    # no reporting or rep redistribution in this period except for on fork branch we re-report on the forked market and that's it, so no free pass on fork for that one event - done
# Period after fork is resolved
    # markets can't be moved until now - done
    # all markets have early exp disabled until this point - done
    # each event which should've resolved in the past 2 periods and this one is pushed up into this period and voted on in period after this - done
        # stays in parent if it wins, otherwise goes to new fork - done
    # each event resolving further in the future is pushed into the respective period on whichever fork wins - done
# todo if already moved once don't allow again after another fork
def move_event(event):
    forkPeriod = BRANCHES.getForkPeriod(EVENTS.getEventBranch(event))
    branch = EVENTS.getEventBranch(event)
    eventForkedOver = BRANCHES.getEventForkedOver(branch)
    expPeriod = EVENTS.getExpiration(event)/BRANCHES.getPeriodLength(branch)
    eventIndex = EXPEVENTS.getEventIndex(expPeriod, event)
    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)
    if(forkPeriod && currentPeriod == (forkPeriod+2) && !EVENTS.getOutcome(event) && !BACKSTOPS.getMoved(event)):
        winner = BACKSTOPS.getResolved(branch, forkPeriod)
        if(winner==0):
            winner = self.resolve_fork(branch)
        BACKSTOPS.setMoved(event)
        if(event == eventForkedOver):
            return(1)
        elif(winner == EVENTS.getEventBranch(event)):
            # set outcomes to 0
            EVENTS.setOutcome(event, 0)
            EVENTS.setmode(event, 0)
            EVENTS.setEthics(event, 0)
            EVENTS.setUncaughtOutcome(event, 0)
            # return bond if it's a round 2 event and make it not one anymore
            ROUNDTWO.roundTwoResolve(branch, event, eventIndex)

            # leave event here
            # if should've resolved in past periods
            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1)):
                # push it into next [this] period
                EXPEVENTS.addEvent(branch, currentPeriod, eventID)
                EVENTS.setExpiration(event, block.timestamp)
            # otherwise it's set to expire in the period it would've expired in as normal, no changes needed
        else:
            EVENTS.setBranch(event, winner)
            # set outcomes to 0
            EVENTS.setOutcome(event, 0)
            EVENTS.setmode(event, 0)
            EVENTS.setEthics(event, 0)
            EVENTS.setUncaughtOutcome(event, 0)
            # return bond if it's a round 2 event and make it not one anymore
            ROUNDTWO.roundTwoResolve(branch, event, eventIndex)

            # move event to fork
            # and place it into the next reporting period w/ outcomes to 0
            if(expPeriod == forkPeriod or expPeriod == (forkPeriod+1)):
                # push it into next [this] period
                EXPEVENTS.addEvent(branch, currentPeriod, eventID)
                EVENTS.setExpiration(event, block.timestamp)
            else:
                # push into period it wouldve expired in
                EXPEVENTS.addEvent(branch, expPeriod, eventID)
                # expiration time doesnt need to change
    else:
        return(0)

# parent branch is branch here
# todo fork use address picked in market creation to resolve it and have a default fork resolve option
def resolve_fork(branch):
    # do whitelist
    forkPeriod = BRANCHES.getForkPeriod(EVENTS.getEventBranch(event))
    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)
    origCap = self.exchangeRate(branch)
    fork = REPORTING.getFork(branch)
    forkCap = self.exchangeRate(fork)
    if(origcap >= forkCap):
        winner = branch
        BACKSTOPS.setResolved(branch, forkPeriod, winner)
        return(winner)
    else:
        winner = fork
        BACKSTOPS.setResolved(branch, forkPeriod, winner)
        return(winner)

# Resolve fork method that gets exchange rate
def exchangeRate(branch):
    # get rep exchange rate from etherex for (branch)
    #return(exchangeRate)
    # for testing we'll just rng the exchange rate :)
    return(sha3(branch))

# In the last 48 hours during period where a round 2 was pushed back to, can be made to fork instead of just round 2, so round 2 bond poster gets bond back
# bond is 1% of rep
def fork(event, branch, forkedOverEthicality):
    forkPeriod = BRANCHES.getForkPeriod(branch)
    currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)
    # no fork for 1 period after a fork
    if(forkPeriod == currentPeriod or currentPeriod == (forkPeriod+1) or currentPeriod == (forkPeriod+2)):
        return(-3)
    if(!EVENTS.getRoundTwo(event) || EVENTS.getFinal(event) || EVENTS.getForked(event)):
        return(-1)
    if(EVENTS.getBranch(event)!=branch):
        return(0)
    # todo find actual gas cost for resolution here and charge that
    if(msg.value < 200000*tx.gasprice):
        return(0)
    send(CONSENSUSDATA, msg.value)
    CONSENSUSDATA.setRefund(event, msg.value)
    # if pushed forward event don't allow
    if(EVENTS.getOriginalExpiration(event)!=EVENTS.getExpiration(event)):
        return(-4)
    # if in last 48 hr of period
    if(block.timestamp/BRANCHES.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/BRANCHES.getPeriodLength(branch)) && EVENTS.getUncaughtOutcome(event)!=0 && !EVENTS.getForked(event)):
        bond = POINTZEROONE*REPORTING.getTotalRep(branch)/ONE
        BACKSTOPS.setBondAmount(event, bond)
        # lose fork bond in branch 1
        # results same as roundtwobond, let it resolve as that on original network
        if(SENDREP.sendReputation(branch, event, bond)==0):
            return(-2)
        # on branch 2 fork bond isn't lost
        # on fork bond isn't lost, gets paid up to 2x from "liars"
        # make the fork
        newBranch = CREATEBRANCH.createSubbranch(text("fork"), BRANCHES.getPeriodLength(branch), branch, BRANCHES.getMinTradingFee(branch), 0)
        REPORTING.setFork(newBranch)
        period = BRANCHES.getVotePeriod(newBranch)
        EXPEVENTS.setEventRequired(newBranch, period+1, event)
        EXPEVENTS.addEvent(newBranch, period+1, event)
        EVENTS.setExpiration(event, block.timestamp)
        BACKSTOPS.setOriginalBranch(event, branch)
        BACKSTOPS.setForkBondPoster(event, msg.sender)
        EVENTS.setForked(event)
        BACKSTOPS.setFinal(event)
        BRANCHES.setForkPeriod(branch)
        BRANCHES.setForkPeriod(newBranch)
        BRANCHES.setEventForkedOver(newBranch, event)
        BRANCHES.setEventForkedOver(branch, event)
        if(forkedOverEthicality):
            BACKSTOPS.setForkedOverEthicality(event)
        # return round 2 bond on orig. branch
        market = EVENTS.getMarket(event, 0)
        avgAdjCost = BRANCHES.getInitialBalance(branch, period-1)/EXPEVENTS.getNumberEvents(branch, period-1)
        bond = avgAdjCost + MARKETS.getSharesValue(market)*(POINTZEROONE + MARKETS.getTradingFee(market)/2) / ONE
        bond = min(bond, 200*ONE)
        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, event), bond)
        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getBondPoster(event)), bond)
        BACKSTOPS.setBondReturned(event)
    else:
        return(0)


# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
# branch is orig. branch
def resolveForkedEvent(branch, event):
    refund()
    bond = 100*ONE
    votedOnAgain = 0
    # checks for orig. branch
    if(EVENTS.getBranch(event)!=branch or BRANCHES.getEventForkedOver(branch)!=event):
        return(0)
    if(BRANCHES.getVotePeriod(branch) > (EVENTS.getExpiration(event) / BRANCHES.getPeriodLength(branch))):
        votedOnAgain = 1
    if(!EVENTS.getForked(event)):
        return(-1)
    if(self.resolveForkEvent(branch, event)):
        EVENTS.setForkDone(event)
        CONSENSUSDATA.doRefund(msg.sender, event)
        return(1)
    # fork not done yet
    else:
        return(0)

# once winning fork decided this sets fork done and sets the event outcome to the forkoutcome + ethicality if the fork won, or to the resolved round 2 outcome + ethicality if the original parent won
def resolveForkEvent(branch, event):
    refund()
    # whitelist
    bond = EVENTS.getBond(event)
    winner = BACKSTOPS.getResolved(branch, BRANCHES.getForkPeriod(branch))
    if(!winner):
        return(-5)
    # binary
    if(binary(event)):
        fxpOutcome = 0
        ethical = 0
        # original parent won
        if(winner==branch):
            fxpOutcome = catch(EVENTS.getUncaughtOutcome(event))
            ethical = ethic_catch(EVENTS.getEthical(event))
        # fork won
        else:
            fxpOutcome = catch(EVENTS.getForkOutcome(event))
            ethical = ethic_catch(EVENTS.getForkEthicality(event))
        EVENTS.setOutcome(event, fxpOutcome)
        EVENTS.setEthics(event, ethical)
        if(fxpOutcome==3*ONEHALF || !ethical):
            # give event bond money to reporters
            CASH.subtractCash(event, bond)
            CASH.addCash(branch, bond)
            # not ethical is same as .5 outcome
            fxpOutcome = 3*ONEHALF
            EVENTS.setOutcome(event, fxpOutcome)
        else:
            # return bond
            CASH.subtractCash(event, bond)
            CASH.addCash(INFO.getCreator(event), bond)
        return(1)
    # scalar
    elif(scalar(event) or categorical(event)):
        mode = 0
        ethical = 0
        # original parent won
        if(winner==branch):
            mode = EVENTS.getUncaughtOutcome(event)
            ethical = ethic_catch(EVENTS.getEthical(event))
        # fork won
        else:
            mode = EVENTS.getForkOutcome(event)
            ethical = ethic_catch(EVENTS.getForkEthicality(event))
        EVENTS.setmode(event, mode)
        EVENTS.setEthics(event, ethical)
        scaled_max = EVENTS.getMaxValue(event)
        scaled_min = EVENTS.getMinValue(event)
        if(categorical(event)):
            scaled_min = ONE
            scaled_max = ONE*EVENTS.getNumOutcomes(event)
        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min
        ethicOutcome = ONEHALF * (scaled_max - scaled_min)/ONE + scaled_min
        EVENTS.setOutcome(event, fxpOutcome)
        if(mode==ONEHALF || !ethical):
            # give event bond money to reporters
            CASH.subtractCash(event, bond)
            CASH.addCash(branch, bond)
            # not ethical is same as .5 outcome
            EVENTS.setOutcome(event, ethicOutcome)
        else:
            # return bond
            CASH.subtractCash(event, bond)
            CASH.addCash(INFO.getCreator(event), bond)
        return(1)
    # (should never be reached)
    else:
        return(0)

macro scalar($event):
    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)

macro binary($event):
    (EVENTS.getNumOutcomes($event)==2 and EVENTS.getMaxValue($event)==TWO and EVENTS.getMinValue($event)==ONE)

macro categorical($event):
    (EVENTS.getNumOutcomes($event)>2)

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro abs($a):
    if($a<0):
        $a = -$a
    $a

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD