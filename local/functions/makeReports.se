# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]
BRANCHES = create('../data_api/branches.se')
extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256]
EXPEVENTS = create('../data_api/expiringEvents.se')
extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]
CASH = create('../data_api/cash.se')
extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getResolutionLength:[int256]:int256, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]
EVENTS = create('../data_api/events.se')
extern refund.se: [addFees:[int256,int256]:int256, addToMarketsHash:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationTime:[int256]:int256, getCumScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getLastExpDate:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsHash:[int256]:int256, getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setMakerFees:[int256,int256]:int256, setPrice:[int256,int256,int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]
MARKETS = create('../data_api/markets.se')
extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]
REPORTING = create('../data_api/reporting.se')
extern refund.se: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256]
BACKSTOPS = create('../data_api/backstops.se')
extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256]
CONSENSUS = create('../data_api/consensusData.se')
extern collectFees: [collectFees:[int256,int256]:int256]
COLLECTFEES = create('../functions/collectFees.se')
extern penalizationCatchup: [penalizationCatchup:[int256,int256]:int256]
CATCHUP = create('../functions/penalizationCatchup.se')
extern reportingThreshold: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getEventCanReportOn:[int256,int256,int256,int256]:int256, getEventsToReportOn:[int256,int256,int256,int256]:int256[], setReportingThreshold:[int256]:int256]
THRESHOLD = create('../functions/reportingThreshold.se')
inset('refund.se')
inset('logReturn.se')

event makeReports_logReturn(returnValue)

macro MAX_THRESHOLD: 10^54

def makeHash(salt, report, eventID, sender):
    hashInfo = array(4)
    hashInfo[0] = sender
    hashInfo[1] = salt
    hashInfo[2] = report
    hashInfo[3] = eventID
    reportHash = sha3(hashInfo, chars=32*len(hashInfo))
    return(reportHash)

# Allows a user to submit the hash of their report / commit
# Error: 0: not caught up on rep redistributions
# Error -1: invalid event
# Error -2: not in first half of period [commit part]
def submitReportHash(event, reportHash, encryptedReport, encryptedSalt):
    branch = EVENTS.getBranch(event)
    votePeriod = BRANCHES.getVotePeriod(branch)

    # makes sure a user is up to date on penalizations
    lastPeriodPenalized = CONSENSUS.getPenalizedUpTo(branch, msg.sender)
    lastPeriod = BRANCHES.getVotePeriod(branch)-1
    delta = lastPeriod - lastPeriodPenalized
    if(delta > 1):
        if(CATCHUP.penalizationCatchup(branch, msg.sender)!=1):
            return(0)
    if(!CONSENSUS.getRepRedistributionDone(branch, msg.sender)):
        return(0)

    # if first report of period, num events not set
    if(EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)==0):
        EXPEVENTS.setNumEventsToReportOn(branch)
        # set amount of fees to be distributed in this period from the branch
        BRANCHES.setInitialBalance(branch, votePeriod, CASH.balance(branch))
    eventIndex = EXPEVENTS.getEventIndex(votePeriod, event)
    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)
    if(eventIndex==0 && (eventID==0 || event!=eventID)):
        return(-1)
    reportingThreshold = 0

    # check if this is a backstop event
    if(EXPEVENTS.getRequired(event) || EVENTS.getReportingThreshold(event)):
        reportingThreshold = MAX_THRESHOLD
    else:
        if(EXPEVENTS.getLesserReportNum(branch, votePeriod, event)==0):
            THRESHOLD.calculateReportTargetForEvent(branch, event, votePeriod, msg.sender)
        reportingThreshold = THRESHOLD.calculateReportingThreshold(branch, event, votePeriod, msg.sender)

    # do abs then mult by 2 to ensure pos. and between 0 and 1
    shaHash = sha3(msg.sender + event)
    # max value 10^54: 2^256 / 10^54 = 115792089237316195423570.985...
    shaHash = abs(shaHash) / 115792089237316195423571
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual <= periodLength/2 && shaHash <= reportingThreshold):
        EXPEVENTS.setReportHash(branch, votePeriod, msg.sender, reportHash, event)
        EXPEVENTS.setEncryptedReport(branch, votePeriod, msg.sender, encryptedReport, encryptedSalt, event)
        return(1)
    return(-2)

# Submits / reveals a report for a period
# @return 1 if success
# Error messages
    # 0: reporter doesn't exist or has <1 rep
    # -1: has already reported
    # -2: not in second half of period [reveal part]
    # -3: hash doesn't match
    # -4: bad report
    # -5: invalid event
    # -6: already resolved
    # -7: <48 hr left in period, too late to report, able to put up readj. bonds though
    # -8: fees couldn't be collected
def submitReport(event, salt, report, ethics):
    branch = EVENTS.getBranch(event)
    balance = REPORTING.getRepBalance(branch, msg.sender)
    votePeriod = BRANCHES.getVotePeriod(branch)
    if(balance<ONE):
        logReturn(makeReports_logReturn, 0)
    if(EXPEVENTS.getReport(branch, votePeriod, event, msg.sender)):
        logReturn(makeReports_logReturn, -1)
    eventIndex = EXPEVENTS.getEventIndex(votePeriod, event)
    # makes sure event is in the given branch and vote period
    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)
    if(eventIndex==0 && (eventID==0 || event!=eventID)):
        logReturn(makeReports_logReturn, -5)
    elif(EVENTS.getOutcome(event)!=0):
        logReturn(makeReports_logReturn, -6)
    periodLength = BRANCHES.getPeriodLength(branch)
    # ensures user has collected fees for last reporting period
    if(!CONSENSUS.getFeesCollected(branch, msg.sender, votePeriod-1)):
        if(COLLECTFEES.collectFees(branch, msg.sender)<1):
            logReturn(makeReports_logReturn, -8)
    # commented out for testing
    #if(block.timestamp/periodLength!=((block.timestamp + 2*TWENTYFOURHR)/periodLength)):
    #    logReturn(makeReports_logReturn, -7)
    residual = block.timestamp % periodLength
    if(residual > periodLength/2):
        realHash = EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, event)
        if(self.makeHash(salt, report, eventID, msg.sender)!=realHash || realHash==0):
            # logReturn(makeReports_logReturn, -3)
            checkRepHash = self.makeHash(salt, report, eventID, msg.sender)
            logReturn(makeReports_logReturn, checkRepHash)
        forkedOverEthicality = BACKSTOPS.getForkedOverEthicality(event)
        forkedOverThisEvent = 0
        if(BRANCHES.getEventForkedOver(branch) == event):
            forkedOverThisEvent = 1
        roundTwo = BACKSTOPS.getRoundTwo(event)
        report = self.validateReport(event, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance)
        if(report == -4):
            logReturn(makeReports_logReturn, -4)
        EXPEVENTS.setReport(branch, votePeriod, eventID, report, msg.sender)
        # set ethics value for event
        ethics = ethics
        if(ethics!=ONE and ethics!=0):
            ethics = ONE
        # set ethicality for forked event
        if(forkedOverThisEvent):
            # fork remove ethicality option if was forked over ethicality, other ethicality choice is the ethicality
            if(forkedOverEthicality):
                oldEthical = ethic_catch(EVENTS.getEthical(event))
                if(oldEthical == ONE):
                    ethics = 0
                else:
                    ethics = ONE
            EXPEVENTS.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
            ethics = (EVENTS.getForkEthicality(event)*EXPEVENTS.getRepEvent(branch, votePeriod, event) + ethics*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, event) + balance)
            EVENTS.setForkEthicality(event, ethics)
        # set ethicality for a regular event
        else:
            EXPEVENTS.setEthicReport(branch, votePeriod, event, ethics, msg.sender)
            # weight by rep
            if(roundTwo):
                ethics = (EVENTS.getEthics(event)*EXPEVENTS.getRepEvent(branch, votePeriod, event) + ethics*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, event) + balance)
            # just a simple avg.
            else:
                ethics = (EVENTS.getEthics(event)*EXPEVENTS.getNumReportsEvent(branch, votePeriod, event) + ethics) / (EXPEVENTS.getNumReportsEvent(branch, votePeriod, event) + 1)
            EVENTS.setEthics(eventID, ethics)
        EXPEVENTS.addReportToEvent(branch, votePeriod, eventID, msg.sender)
        # round 2 and fork events are weighted by rep
        if(roundTwo or forkedOverThisEvent):
            EXPEVENTS.addRepEvent(branch, votePeriod, event, EXPEVENTS.getBeforeRep(branch, votePeriod, msg.sender))
        reportsNum = EXPEVENTS.getLesserReportNum(branch, votePeriod, event)
        paidBack = EXPEVENTS.getReportersPaidSoFar(branch, event)
        diff = reportsNum - paidBack
        # used to pay reporters after reporting for their gas costs
        if(diff >= 1):
            EXPEVENTS.addReportersPaidSoFar(branch, event)
            CASH.subtractCash(branch, 3500000*tx.gasprice)
            CASH.addCash(msg.sender, 3500000*tx.gasprice)
        logReturn(makeReports_logReturn, 1)
    logReturn(makeReports_logReturn, -2)

# validates and submits report
# weights reports by rep if round 2 and fork
# Returns -4 if report is invalid
    # isn't between 1 and 2 if binary
    # if same report as original outcome / ethicality if a forked event not forked over ethicality it's also invalid b/c this option was removed as a poss. answer
def validateReport(eventID, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance):
    outcome = 0
    # binary
    if(EVENTS.getNumOutcomes(eventID)==2 and EVENTS.getMaxValue(eventID)==TWO && EVENTS.getMinValue(eventID)==ONE):
        if(report>2*ONE or report<ONE or report==0):
            return(-4)
        # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
        elif(forkedOverThisEvent):
            # in case of fork remove the original outcome as a possible response if didn't fork over ethics
            if(!forkedOverEthicality && report == catch(EVENTS.getUncaughtOutcome(eventID))):
                return(-4)
            outcome = (EVENTS.getForkOutcome(eventID)*EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + report*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + balance)
            EVENTS.setForkOutcome(eventID, outcome)
        else:
            if(roundTwo):
                outcome = (EVENTS.getUncaughtOutcome(eventID)*EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + report*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + balance)
            else:
                outcome = (EVENTS.getUncaughtOutcome(eventID)*EXPEVENTS.getNumReportsEvent(branch, votePeriod, eventID) + report) / (EXPEVENTS.getNumReportsEvent(branch, votePeriod, eventID) + 1)
            EVENTS.setUncaughtOutcome(eventID, outcome)
    # scalar or categorical
    else:
        if(report > ONE):
            report = ONE
        elif(report<=0):
            # 1 is the new 0 [1/10**18 is basically 0 but able to be differentiated from no report of 0]
            report = 1
        if(forkedOverThisEvent):
            # in case of fork remove the original outcome as a possible response if didn't fork over ethics
            if(!forkedOverEthicality && report == EVENTS.getUncaughtOutcome(eventID)):
                return(-4)
            # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
            EXPEVENTS.addToWeightOfReport(votePeriod, eventID, report, balance)
            if(EXPEVENTS.getWeightOfReport(votePeriod, eventID, report) > EXPEVENTS.getCurrentModeItems(votePeriod, eventID)):
                EXPEVENTS.setCurrentMode(votePeriod, eventID, report)
                EXPEVENTS.setCurrentModeItems(votePeriod, eventID, report)
            outcome = EXPEVENTS.getCurrentMode(votePeriod, eventID)
            EVENTS.setForkOutcome(eventID, outcome)
        else:
            if(roundTwo):
                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
                EXPEVENTS.addToWeightOfReport(votePeriod, eventID, report, balance)
                if(EXPEVENTS.getWeightOfReport(votePeriod, eventID, report) > EXPEVENTS.getCurrentModeItems(votePeriod, eventID)):
                    EXPEVENTS.setCurrentMode(votePeriod, eventID, report)
                    EXPEVENTS.setCurrentModeItems(votePeriod, eventID, report)
                outcome = EXPEVENTS.getCurrentMode(votePeriod, eventID)
            else:
                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)
                EXPEVENTS.addToWeightOfReport(votePeriod, eventID, report, 1)
                if(EXPEVENTS.getWeightOfReport(votePeriod, eventID, report) > EXPEVENTS.getCurrentModeItems(votePeriod, eventID)):
                    EXPEVENTS.setCurrentMode(votePeriod, eventID, report)
                    EXPEVENTS.setCurrentModeItems(votePeriod, eventID, report)
                outcome = EXPEVENTS.getCurrentMode(votePeriod, eventID)
            EVENTS.setUncaughtOutcome(eventID, outcome)
    return(report)

macro YES: TWO
macro NO: ONE
macro BAD: 3 * ONEHALF
macro CATCH_TOLERANCE: ONE / 10

# Bins values to 1, 1.5, 2
macro catch($x):
    if($x < (BAD - CATCH_TOLERANCE)):
        NO
    elif($x > (BAD + CATCH_TOLERANCE)):
        YES
    else:
        BAD

macro ethic_catch($x):
    if($x < ONEHALF):
        0
    else:
        ONE

macro abs($a):
    if($a<0):
        $a = -$a
    $a