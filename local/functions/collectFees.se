extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]
CASH = create('../data_api/cash.se')
extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]
BRANCHES = create('../data_api/branches.se')
extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256,int256]:int256, addReportersPaidSoFar:[int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEncryptedReport:[int256,int256,int256,int256]:int256[], getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportersPaidSoFar:[int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEncryptedReport:[int256,int256,int256,int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256]
EXPEVENTS = create('../data_api/expiringEvents.se')
extern consensusData: [doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:_, setRefund:[int256,int256]:int256, setSlashed:[int256,int256,int256]:int256]
CONSENSUS = create('../data_api/consensusData.se')
extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]
REPORTING = create('../data_api/reporting.se')
inset('refund.se')

# Allows a user to collect both redistributed rep and trading fees earned at the end of a period
# Errors:
    # -1: rep redistribution/rewards/penalizations in consensus not done yet
    # -2: needs to be second half of reporting period to claim rep [1st half is when redistribution is done]
        # after this window, any unclaimed rep is pushed to the next period's redistrib. pool via the first make report submission
# 2 means no errors but didnt report
def collectFees(branch, sender):
    refund()
    periodLength = BRANCHES.getPeriodLength(branch)
    residual = block.timestamp % periodLength
    if(residual <= periodLength/2):
        return(-2)
    if(!CONSENSUS.getRepRedistributionDone(branch, sender)):
        # need to call penalize for all events and penalize for too lazy to report or catchup if necessary
        return(-1)
    votePeriod = BRANCHES.getVotePeriod(branch)
    lastPeriod = votePeriod - 1
    newRep = EXPEVENTS.getAfterRep(branch, lastPeriod, sender)
    # need 1 rep to claim fees
    if(!CONSENSUS.getFeesCollected(branch, sender, lastPeriod) && newRep>ONE):
        denominator = CONSENSUS.getDenominator(branch, lastPeriod)
        # sets the amount of rep available for redistribution in the next period
        if(!CONSENSUS.getFeeFirst(branch, lastPeriod)):
            CONSENSUS.setFeeFirst(branch, lastPeriod, 1)
            CONSENSUS.setPeriodBalance(branch, lastPeriod, REPORTING.getRepBalance(branch, branch))
        gainedRep = newRep * CONSENSUS.getPeriodBalance(branch, lastPeriod) / denominator
        #if(lostRep) newRep should be == EXPEVENTS.getAfterRep(branch, period, sender) + gainedRep
        #if(gainedRep) newRep should be == EXPEVENTS.getBeforeRep(branch, period, sender) + gainedRep
        # give a reporter their portion of redistributed rep
        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, sender), gainedRep)
        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, branch), gainedRep)
        cash = BRANCHES.getInitialBalance(branch, lastPeriod) * newRep / denominator
        # give a reporter their portion of the trading fees
        CASH.addCash(sender, cash)
        CASH.subtractCash(branch, cash)
        CONSENSUS.setFeesCollected(branch, sender, lastPeriod)
        # return not reported enough bond if not enough penalized is 0 or BRANCHES.getForkPeriod(branch)+1 == lastPeriod during collect fees
        # todo first period this won't have been paid?
        if(CONSENSUS.getNotEnoughPenalized(branch, msg.sender, lastPeriod)==0 or BRANCHES.getForkPeriod(branch)+1 == lastPeriod):
            CONSENSUS.doRefund(msg.sender, msg.sender)
        # need to pay not reporting bond
        if(msg.value <= 500000*tx.gasprice):
            throw()
        balance = REPORTING.getRepBalance(branch, msg.sender)
        dormantRep = REPORTING.balanceOf(branch, msg.sender)
        # Record rep for next report period before any redistributions
        # todo what if in first period these before/after/etc haven't been set?
        EXPEVENTS.setBeforeRep(branch, votePeriod, balance, msg.sender)
        EXPEVENTS.setAfterRep(branch, votePeriod, balance, msg.sender)
        EXPEVENTS.setPeriodDormantRep(branch, votePeriod, dormantRep, msg.sender)
        CONSENSUS.setRefund(msg.sender, msg.value)
        send(CONSENSUS, msg.value)
        return(1)
    # shouldn't be reached / if so no effect
    elif(!CONSENSUS.getFeesCollected(branch, sender, lastPeriod)):
        CONSENSUS.setFeesCollected(branch, sender, lastPeriod)
        return(2)