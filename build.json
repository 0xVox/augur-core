{
    "accounts": {
        "address": "0x4fc79e76158c6f347195a4a5564893e0f55f0ebf", 
        "code": [
            "# accounts indexed with sha256(handle)", 
            "data accounts[](privateKey, iv, salt, mac, uuid)", 
            "", 
            "# Register a new account.", 
            "# @param {int} handle sha256 digest of the user's handle/username", 
            "# @param {int} privateKey Encrypted private key (256-bit)", 
            "# @param {int} iv AES initialization vector (128-bit)", 
            "# @param {int} salt Key derivation salt (256-bit)", 
            "# @param {int} mac Message authentication code (256-bit)", 
            "# @param {int} uuid Hex-encoded v4 UUID bytearray (128-bit)", 
            "# @return int 0 if failed, 1 if successful", 
            "def register(handle, privateKey, iv, salt, mac, uuid):", 
            "    if self.accounts[handle].privateKey != 0:", 
            "        return(0)", 
            "    self.accounts[handle].privateKey = privateKey", 
            "    self.accounts[handle].iv = iv", 
            "    self.accounts[handle].salt = salt", 
            "    self.accounts[handle].mac = mac", 
            "    self.accounts[handle].uuid = uuid", 
            "    return(1)", 
            "", 
            "# Retrieve an existing account.", 
            "# @param {int} handle sha256 digest of the user's handle/username", 
            "# @return array(5) [privateKey, iv, salt, mac, uuid] (0s if account not found)", 
            "def getAccount(handle):", 
            "    privateKey = self.accounts[handle].privateKey", 
            "    iv = self.accounts[handle].iv", 
            "    salt = self.accounts[handle].salt", 
            "    mac = self.accounts[handle].mac", 
            "    uuid = self.accounts[handle].uuid", 
            "    if privateKey == 0 or iv == 0 or salt == 0 or mac == 0 or uuid == 0:", 
            "        return([0, 0, 0, 0, 0]: arr)", 
            "    return([privateKey, iv, salt, mac, uuid]: arr)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "handle", 
                        "type": "int256"
                    }
                ], 
                "name": "getAccount(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "handle", 
                        "type": "int256"
                    }, 
                    {
                        "name": "privateKey", 
                        "type": "int256"
                    }, 
                    {
                        "name": "iv", 
                        "type": "int256"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "mac", 
                        "type": "int256"
                    }, 
                    {
                        "name": "uuid", 
                        "type": "int256"
                    }
                ], 
                "name": "register(int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern accounts: [getAccount:[int256]:int256[], register:[int256,int256,int256,int256,int256,int256]:int256]"
    }, 
    "adjust": {
        "address": "0x360f45231a8f6f192dece487e30b51e8f9fca081", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Jack Peterson (jack@augur.net).", 
            "", 
            "# Minimum value of array", 
            "macro minimum($a):", 
            "    with $min = $a[0]:", 
            "        with $i = 1:", 
            "            with $len = len($a):", 
            "                while $i < $len:", 
            "                    if $a[$i] < $min:", 
            "                        $min = $a[$i]", 
            "                    $i += 1", 
            "                $min", 
            "", 
            "def reputation_delta(scores:arr, num_reports, num_events):", 
            "    # Which of the two possible 'new' reputation vectors had more in common", 
            "    # with the original 'old' reputation?", 
            "    # set1: [0, num_reports - 1]", 
            "    # set2: [num_reports, 2*num_reports - 1]", 
            "    with two_num_reports = 2*num_reports:", 
            "        with sets = array(two_num_reports):", 
            "            with set1_compare = abs(minimum(scores)):", 
            "                with set2_compare = maximum(scores):", 
            "                    with i = 0:", 
            "                        while i < num_reports:", 
            "                            sets[i] = scores[i] + set1_compare", 
            "                            i += 1", 
            "                        while i < two_num_reports:", 
            "                            sets[i] = scores[i - num_reports] - set2_compare", 
            "                            i += 1", 
            "                        return(sets: arr)", 
            "", 
            "def weighted_delta(set1:arr, set2:arr, reputation:arr, reports:arr, num_reports, num_events):", 
            "    with i = 0:", 
            "        while i < num_reports:", 
            "            reputation[i] = fixed_divide(reputation[i], TOTAL_REPUTATION)", 
            "            i += 1", 
            "    with three_num_events = 3*num_events:", 
            "        with wsets = array(three_num_events):", 
            "            with wset1 = normalize(set1):", 
            "                with wset2 = normalize(set2):", 
            "                    with i = 0:", 
            "                        with two_num_events = 2*num_events:", 
            "                            while i < num_events:", 
            "                                with k = 0:", 
            "                                    while k < num_reports:", 
            "                                        with pos = k*num_events + i:", 
            "                                            wsets[i] += fixed_multiply(reputation[k], reports[pos])", 
            "                                            wsets[i + num_events] += fixed_multiply(wset1[k], reports[pos])", 
            "                                            wsets[i + two_num_events] += fixed_multiply(wset2[k], reports[pos])", 
            "                                        k += 1", 
            "                                i += 1", 
            "                            return(wsets: arr)", 
            "", 
            "def select_scores(old:arr, new1:arr, new2:arr, set1:arr, set2:arr, scores:arr, num_reports, num_events):", 
            "    # Difference in sum of squared errors. If > 0, then new1 had higher", 
            "    # errors (use new2); conversely if < 0, then use new1.", 
            "    with sse1 = 0:", 
            "        with sse2 = 0:", 
            "            with i = 0:", 
            "                while i < num_events:", 
            "                    sse1 += fixed_multiply(new1[i] - old[i], new1[i] - old[i])", 
            "                    sse2 += fixed_multiply(new2[i] - old[i], new2[i] - old[i])", 
            "                    i += 1", 
            "            with ref_ind = sse1 - sse2:", 
            "                with adjusted_scores = array(num_reports):", 
            "                    if ref_ind <= 0:", 
            "                        adjusted_scores = set1", 
            "                    else:", 
            "                        adjusted_scores = set2", 
            "                    return(adjusted_scores: arr)", 
            "", 
            "inset('../../macros/constants.sm')", 
            "inset('../../macros/fixed.sm')", 
            "inset('../../macros/arrays.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "scores", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "reputation_delta(int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "old", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "new1", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "new2", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "set1", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "set2", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "scores", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "select_scores(int256[],int256[],int256[],int256[],int256[],int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "set1", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "set2", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "reputation", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "reports", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "weighted_delta(int256[],int256[],int256[],int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern adjust: [reputation_delta:[int256[],int256,int256]:int256[], select_scores:[int256[],int256[],int256[],int256[],int256[],int256[],int256,int256]:int256[], weighted_delta:[int256[],int256[],int256[],int256[],int256,int256]:int256[]]"
    }, 
    "branches": {
        "address": "0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "# CurrentVotePeriod is the current index in eventsExpDates", 
            "# Branches' index is the hash of the branch (aka branchID)", 
            "# currentVotePeriod is a nonce that tells us which bucket of events up to be", 
            "# voted on in the current vote period (should always be 1 behind block.number/periodlength or current EventsExpDates index)", 
            "# period parameter for reporting", 
            "# currentExpPeriod = (block.number / self.Branches[branch].periodLength)", 
            "# currentExpPeriod - 1 is what's up for reporting at any given time", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REP = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "", 
            "data Branches[](currentVotePeriod, periodLength, step, substep, markets[], numMarkets, minTradingFee)", 
            "", 
            "data branchList[]", 
            "", 
            "data branchListCount", 
            "", 
            "def init():", 
            "    self.Branches[1010101].currentVotePeriod = (block.number / 1800) - 1", 
            "    self.Branches[1010101].periodLength = 1800", 
            "    self.Branches[1010101].minTradingFee = 2^57", 
            "    self.branchListCount = 1", 
            "    self.branchList[0] = 1010101", 
            "", 
            "def getVotePeriod(branch):", 
            "\treturn(self.Branches[branch].currentVotePeriod)", 
            "", 
            "def getPeriodLength(branch):", 
            "\treturn(self.Branches[branch].periodLength)", 
            "", 
            "def getStep(branch):", 
            "\treturn(self.Branches[branch].step)", 
            "", 
            "# @return all markets in a branch", 
            "def getMarkets(branch):", 
            "    numMarkets = self.Branches[branch].numMarkets", 
            "    markets = array(numMarkets)", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        markets[i] = self.Branches[branch].markets[i]", 
            "        i += 1", 
            "    return(markets: arr)", 
            "", 
            "def getNumMarkets(branch):", 
            "\treturn(self.Branches[branch].numMarkets)", 
            "", 
            "def getMinTradingFee(branch):", 
            "\treturn(self.Branches[branch].minTradingFee)", 
            "", 
            "# @return all branches", 
            "def getBranches():", 
            "    b = 0", 
            "    numBranches = self.branchListCount", 
            "    branches = array(numBranches)", 
            "    while b < numBranches:", 
            "        branches[b] = self.branchList[b]", 
            "        b += 1", 
            "    return(branches: arr)", 
            "", 
            "def getNumBranches():", 
            "\treturn(self.branchListCount)", 
            "", 
            "def getBranch(branchNumber):", 
            "\treturn(self.branchList[branchNumber])", 
            "", 
            "# will return 0s for array values after it's looped through all the ones you", 
            "# have an actual balance in", 
            "def getReputation(address):", 
            "    branchListCount = self.branchListCount", 
            "    if(address):", 
            "        branches = array(2*branchListCount)", 
            "        branchList = array(branchListCount)", 
            "        branchList = self.getBranches(outitems=branchListCount)", 
            "        i = 0", 
            "        b = 0", 
            "        while i < branchListCount:", 
            "            branch = branchList[i]", 
            "            balance = REP.getRepBalance(branch, address)", 
            "            if(balance!=0):", 
            "                branches[b] = branch", 
            "                branches[b+1] = balance", 
            "                b += 2", 
            "            i += 1", 
            "    else:", 
            "        address = tx.origin", 
            "        branches = array(2*branchListCount)", 
            "        branchList = array(branchListCount)", 
            "        branchList = self.getBranches(outitems=branchListCount)", 
            "        i = 0", 
            "        b = 0", 
            "        while i < branchListCount:", 
            "            branch = branchList[i]", 
            "            balance = REP.getRepBalance(branch, address)", 
            "            if(balance!=0):", 
            "                branches[b] = branch", 
            "                branches[b+1] = balance", 
            "                b += 2", 
            "            i += 1", 
            "    return(branches: arr)", 
            "", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tif(self.Branches[ID].periodLength==0):", 
            "\t\tself.Branches[ID].currentVotePeriod = currentVotePeriod", 
            "\t\tself.Branches[ID].periodLength = periodLength", 
            "\t\tself.Branches[ID].minTradingFee = minTradingFee", 
            "\t\tself.branchList[self.branchListCount] = ID", 
            "\t\tself.branchListCount += 1", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def incrementStep(branch):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.Branches[branch].step += 1", 
            "\treturn(1)", 
            "", 
            "def setStep(branch, step):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.Branches[branch].step = step", 
            "\treturn(1)", 
            "", 
            "def incrementPeriod(branch):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.Branches[branch].currentVotePeriod += 1", 
            "\treturn(1)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def addMarket(branch, market):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tnumMarkets = self.Branches[branch].numMarkets", 
            "\tself.Branches[branch].markets[numMarkets] = market", 
            "\tself.Branches[branch].numMarkets += 1", 
            "\treturn(1)", 
            "", 
            "def getSubstep(branch):", 
            "\treturn(self.Branches[branch].substep)", 
            "", 
            "def incrementSubstep(branch):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Branches[branch].substep += 1", 
            "    return(1)", 
            "", 
            "def setSubstep(branch, substep):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Branches[branch].substep = substep", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "addMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branchNumber", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "getBranches()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarkets(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getMinTradingFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "getNumBranches()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumMarkets(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getReputation(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getStep(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getSubstep(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getVotePeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "incrementPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "incrementStep(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "incrementSubstep(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "currentVotePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "periodLength", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minTradingFee", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeBranch(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "step", 
                        "type": "int256"
                    }
                ], 
                "name": "setStep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "substep", 
                        "type": "int256"
                    }
                ], 
                "name": "setSubstep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]"
    }, 
    "buy&sellShares": {
        "address": "0x222be5d1b153b7f04189b2f591166665a885aaf5", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPEVENTS = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x3c5062d58be6ce59534e8a2d10f1d533c1a0206e", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256]", 
            "FXP = 0x1fa4745bcd612d19c698aad79c9ceee079cf65b6", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getSharesPurchased:[int256,int256]:int256, getSimulatedBuy:[int256,int256,int256]:_, getSimulatedSell:[int256,int256,int256]:_, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x44a270caf86e229f188b340994fa8671ae94450a", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "", 
            "data nonces[]", 
            "", 
            "event updatePrice(user:indexed, market:indexed, outcome:indexed, price, cost)", 
            "", 
            "", 
            "# amount of shares should be fixed point", 
            "# @return return price + fee to buy shares", 
            "# Error messages otherwise", 
            "    # -1: invalid outcome or trading closed", 
            "    # -2: entered a -amt of shares", 
            "    # -3: not enough money / limit order too low", 
            "    # -4: bad nonce/hash", 
            "def buyShares(branch, market, outcome, amount, nonce, limit):", 
            "    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)", 
            "    # if we have 3-4 cycles in a row of events getting pushed back market would already be closed even though", 
            "    # events up to be decided on for a while yet never decided", 
            "    # technically this is a stalled branch and market should be open", 
            "    # if(currentPeriod >= currentVotePeriod +3) we're stalled", 
            "    #the question is though --- are these events part of the set that were stalled?", 
            "    #if above && the event outcomes aren't determined (0), then yes", 
            "    #then set a stalled boolean", 
            "", 
            "    #if !good_pow():", 
            "    #    return(-4)", 
            "    inc_nonce()", 
            "    stalled = 0", 
            "    currentPeriod = block.number / BRANCHES.getPeriodLength(branch)", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    numEvents = MARKETS.getNumEvents(market)", 
            "    events = MARKETS.getMarketEvents(market, outitems=numEvents)", 
            "    if(currentPeriod >= (currentVotePeriod+3)):", 
            "        c = 0", 
            "        while c < numEvents:", 
            "            if(EVENTS.getOutcome(events[c])==0):", 
            "                c += 1", 
            "            else:", 
            "                return(-1)", 
            "        stalled = 1", 
            "    if (outcome==0 || (currentVotePeriod>=MARKETS.getTradingPeriod(market) && !stalled) || MARKETS.getBranchID(market) != branch):", 
            "        return(-1)", 
            "    # lmsr cost calcs", 
            "    oldCost = MARKETS.lsLmsr(market)", 
            "    MARKETS.modifyShares(market, outcome, amount)", 
            "    newCost = MARKETS.lsLmsr(market)", 
            "    if newCost <= oldCost:", 
            "        MARKETS.modifyShares(market, outcome, -amount)", 
            "        return(0)", 
            "    price = (newCost - oldCost)", 
            "", 
            "    if(CASH.balance(tx.origin) < price*(MARKETS.getTradingFee(market) + 2^64)/2^64 or (limit!=0 and (price*2^64/amount)>limit)):", 
            "        MARKETS.modifyShares(market, outcome, -amount)", 
            "        return(-3)", 
            "", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "", 
            "    # if participant doesn't exist in market, add them", 
            "    if(tx.origin != MARKETS.getParticipantID(market, participantNumber)):", 
            "        participantNumber = MARKETS.addParticipant(market, tx.origin)", 
            "", 
            "    MARKETS.modifyParticipantShares(market, participantNumber, outcome, amount)", 
            "    # send shares of the event to user address", 
            "    # if user doesn't have enough money, revert", 
            "    # send money from user acc. to market address/account", 
            "    # cost for shares", 
            "    CASH.send(market, price)", 
            "    # half of fees to market creator", 
            "    fee = MARKETS.getTradingFee(market)*price/2^64", 
            "    CASH.send(INFO.getCreator(market), fee/2)", 
            "    # other half go to branch", 
            "    CASH.send(branch, fee/2)", 
            "    # log new price & avg price paid/share", 
            "    log(type=updatePrice, tx.origin, market, outcome, MARKETS.price(market, outcome), -price*2^64/amount)", 
            "    return(price+fee)", 
            "", 
            "# amount is amount of shares to sell", 
            "# instead of inputting particip. num could just loop through array if dont have it", 
            "# @return error msg if fail, returns amount you get paid if success", 
            "# Error messages otherwise", 
            "    # -1: invalid outcome, trading closed, or you haven't traded in this market", 
            "    # -2: entered a -amt of shares", 
            "    # -3: you own no shares / limit price too high", 
            "def sellShares(branch, market, outcome, amount, nonce, limit):", 
            "    #if !good_pow():", 
            "    #    return(-4)", 
            "    inc_nonce()", 
            "    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    stalled = 0", 
            "    currentPeriod = block.number / BRANCHES.getPeriodLength(branch)", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    numEvents = MARKETS.getNumEvents(market)", 
            "    events = MARKETS.getMarketEvents(market, outitems=numEvents)", 
            "    if((currentPeriod + 3) >= currentVotePeriod):", 
            "        c = 0", 
            "        while c < numEvents:", 
            "            if(EVENTS.getOutcome(events[c])==0):", 
            "                c += 1", 
            "            else:", 
            "                return(-1)", 
            "        stalled = 1", 
            "    if (MARKETS.getParticipantID(market, participantNumber) != tx.origin || outcome==0 || (currentVotePeriod>=MARKETS.getTradingPeriod(market) && !stalled) || MARKETS.getBranchID(market) != branch):", 
            "        return(-1)", 
            "    # lmsr cost calcs", 
            "    oldCost = MARKETS.lsLmsr(market)", 
            "    MARKETS.modifyShares(market, outcome, -amount)", 
            "    newCost = MARKETS.lsLmsr(market)", 
            "    if oldCost <= newCost:", 
            "        MARKETS.modifyShares(market, outcome, amount)", 
            "        return(-2)", 
            "    # these prices are in fixed point", 
            "    price = oldCost - newCost", 
            "    # remove shares from the user's account", 
            "    # if user actually doesn't have the shares, revert", 
            "    if (MARKETS.getParticipantSharesPurchased(market, participantNumber, outcome) < amount or (price*2^64/amount)<limit):", 
            "        MARKETS.modifyShares(market, outcome, amount)", 
            "        return(-3)", 
            "    else:", 
            "        # send bitcoin from the market to the user acc.", 
            "        CASH.subtractCash(market, price)", 
            "        fee = MARKETS.getTradingFee(market)*price/2^64", 
            "        # half of fees go to market creator", 
            "        CASH.addCash(INFO.getCreator(market), fee/2)", 
            "        # half go to branch", 
            "        CASH.addCash(branch, fee/2)", 
            "        price -= fee", 
            "        CASH.addCash(tx.origin, price)", 
            "        MARKETS.modifyParticipantShares(market, participantNumber, outcome, -amount)", 
            "        # log new price and avg. price sold / share", 
            "        log(type=updatePrice, tx.origin, market, outcome, MARKETS.price(market, outcome), price*2^64/amount)", 
            "        return(price)", 
            "", 
            "macro good_pow():", 
            "    with $data = array(4):", 
            "        $data[0] = branch", 
            "        $data[1] = market", 
            "        $data[2] = tx.origin", 
            "        $data[3] = self.nonces[tx.origin]", 
            "        with $firstHash = sha3($data, chars=4*32):", 
            "            with $data2 = array(2):", 
            "                $data2[0] = $firstHash", 
            "                $data2[1] = nonce", 
            "                lt(sha3($data2, chars=2*32), 2^254/10000)", 
            "", 
            "macro inc_nonce():", 
            "    self.nonces[tx.origin] += 1", 
            "", 
            "def getNonce(ID):", 
            "    return(self.nonces[ID])"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "nonce", 
                        "type": "int256"
                    }, 
                    {
                        "name": "limit", 
                        "type": "int256"
                    }
                ], 
                "name": "buyShares(int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getNonce(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "nonce", 
                        "type": "int256"
                    }, 
                    {
                        "name": "limit", 
                        "type": "int256"
                    }
                ], 
                "name": "sellShares(int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "user", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "cost", 
                        "type": "int256"
                    }
                ], 
                "name": "updatePrice(int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern buy&sellShares: [buyShares:[int256,int256,int256,int256,int256,int256]:int256, getNonce:[int256]:int256, sellShares:[int256,int256,int256,int256,int256,int256]:int256]"
    }, 
    "cash": {
        "address": "0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "data cashcoinBalances[]", 
            "", 
            "def init():", 
            "    # test initial funds", 
            "    self.cashcoinBalances[tx.origin] = 100000*2^64", 
            "", 
            "# @return: cash balance of address", 
            "def balance(address):", 
            "    return(self.cashcoinBalances[address])", 
            "", 
            "# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)", 
            "# so cashcoin fees could just go to root branch, or we could not have fees besides", 
            "# gas fee to do a send transaction", 
            "# @return: value sent, 0 if fails", 
            "def send(recver, value):", 
            "    sender = tx.origin", 
            "    senderBalance = self.cashcoinBalances[sender]", 
            "    if(senderBalance >= value):", 
            "        self.cashcoinBalances[sender] -= value", 
            "        self.cashcoinBalances[recver] += value", 
            "        return(value)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# @return value of cash sent; fail is 0", 
            "def sendFrom(recver, value, from):", 
            "    if(from!=tx.origin):", 
            "        return(0)", 
            "    senderBalance = self.cashcoinBalances[from]", 
            "    if(senderBalance >= value):", 
            "        self.cashcoinBalances[from] -= value", 
            "        self.cashcoinBalances[recver] += value", 
            "        return(value)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# make sure only coming from specific contracts", 
            "def subtractCash(ID, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.cashcoinBalances[ID] -= amount", 
            "    return(1)", 
            "", 
            "def addCash(ID, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.cashcoinBalances[ID] += amount", 
            "    return(1)", 
            "", 
            "def setCash(address, balance):", 
            "    #if !self.whitelist.check(msg.sender):", 
            "    #    return(-1)", 
            "    self.cashcoinBalances[address] = balance", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "addCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "balance(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "send(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }, 
                    {
                        "name": "from", 
                        "type": "int256"
                    }
                ], 
                "name": "sendFrom(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "setCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]"
    }, 
    "center": {
        "address": "0x8a0cf0b390a9acbaed8abe1df64e4a1eb7fde454", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Jack Peterson (jack@augur.net).", 
            "", 
            "def center(reports_filled:arr, reputation:arr, scaled:arr, scaled_max:arr, scaled_min:arr, max_iterations, max_components):", 
            "    with num_reports = len(reputation):", 
            "        with flatsize = len(reports_filled):", 
            "            with num_events = flatsize / num_reports:", 
            "                # calculate weighted centered data matrix", 
            "                with weighted_means = array(num_events):", 
            "                    with total_weight = 0:", 
            "                        with i = 0:", 
            "                            while i < num_reports:", 
            "                                with j = 0:", 
            "                                    while j < num_events:", 
            "                                        weighted_means[j] += reputation[i] * reports_filled[i * num_events + j]", 
            "                                        j += 1", 
            "                                total_weight += reputation[i]", 
            "                                i += 1", 
            "                            with j = 0:", 
            "                                while j < num_events:", 
            "                                    weighted_means[j] /= total_weight", 
            "                                    j += 1", 
            "                            # weighted centered data (wcd): [0, flatsize-1]", 
            "                            # loading_vector [1 0 0 . . . 0]: [flatsize, flatsize + num_events]", 
            "                            with lflatsize = flatsize + num_events + 2:", 
            "                                with wcd = array(lflatsize):", 
            "                                    with i = 0:", 
            "                                        while i < flatsize:", 
            "                                            # 0 if num_reports = 1", 
            "                                            wcd[i] = reports_filled[i] - weighted_means[i % num_events]", 
            "                                            i += 1", 
            "                                        wcd[i] = ONE", 
            "                                        wcd[lflatsize - 2] = max_iterations", 
            "                                        if max_components < num_events:", 
            "                                            wcd[lflatsize - 1] = max_components", 
            "                                        else:", 
            "                                            wcd[lflatsize - 1] = num_events", 
            "                                        return(wcd: arr)", 
            "", 
            "def tokenize(reputation:arr, num_reports):", 
            "    with tokens = array(num_reports):", 
            "        with i = 0:", 
            "            while i < num_reports:", 
            "                tokens[i] = reputation[i] * COINS", 
            "                i += 1", 
            "            return(tokens: arr)", 
            "", 
            "# First row of the covariance matrix", 
            "def covariance(wcd:arr, tokens:arr, num_reports, num_events):", 
            "    with cov = array(num_events):", 
            "        with wcd_x_tokens = array(num_reports):", 
            "            with i = 0:", 
            "                while i < num_reports:", 
            "                    wcd_x_tokens[i] = fixed_multiply(wcd[i*num_events], tokens[i])", 
            "                    i += 1", 
            "            with alltokens = sum(tokens):", 
            "                with i = 0:", 
            "                    while i < num_events:", 
            "                        with j = 0:", 
            "                            while j < num_reports:", 
            "                                cov[i] += fixed_multiply(wcd_x_tokens[j], wcd[j*num_events + i])", 
            "                                j += 1", 
            "                        cov[i] = fixed_divide(cov[i], alltokens - ONE)", 
            "                        i += 1", 
            "                    return(cov: arr)", 
            "", 
            "inset('../../macros/constants.sm')", 
            "inset('../../macros/fixed.sm')", 
            "inset('../../macros/arrays.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "reports_filled", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "reputation", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "scaled", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "scaled_max", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "scaled_min", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "max_iterations", 
                        "type": "int256"
                    }, 
                    {
                        "name": "max_components", 
                        "type": "int256"
                    }
                ], 
                "name": "center(int256[],int256[],int256[],int256[],int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "wcd", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "tokens", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "covariance(int256[],int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "reputation", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }
                ], 
                "name": "tokenize(int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern center: [center:[int256[],int256[],int256[],int256[],int256[],int256,int256]:int256[], covariance:[int256[],int256[],int256,int256]:int256[], tokenize:[int256[],int256]:int256[]]"
    }, 
    "checkQuorum": {
        "address": "0x7a38967fab965444182e48fca12d63c62ceb3d96", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPEVENTS = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "", 
            "# extern branches.se: [addMarket:ii:i, getBranch:i:i, getBranches:_:a, getMarkets:i:a, getMinTradingFee:i:i, getNumBranches:_:i, getNumMarkets:i:i, getPeriodLength:i:i, getStep:i:i, getVotePeriod:i:i, incrementPeriod:i:i, incrementStep:i:i, initializeBranch:iiii:i, setStep:ii:i, setSubstep:ii:i]", 
            "# BRANCHES = 0x13dc5836cd5638d0b81a1ba8377a7852d41b5bbe", 
            "", 
            "# extern expiringEvents.se: [addEvent:iii:i, getAdjPrinComp:ii:a, getEvent:iii:i, getEvents:ii:a, getLoadingVector:ii:a, getNewOne:ii:a, getNewTwo:ii:a, getNumberEvents:ii:i, getOutcomesFinal:ii:a, getReport:iiii:i, getReportHash:iii:i, getReporterBallot:iii:a, getReportsFilled:ii:a, getReportsMask:ii:a, getScores:ii:a, getSetOne:ii:a, getSetTwo:ii:a, getSmoothRep:ii:a, getTotalRepReported:ii:i, getVSize:ii:i, getWeightedCenteredData:ii:a, makeBallot:ii:a, moveEventsToCurrentPeriod:iii:i, returnOld:ii:a, setAdjPrinComp:iia:i, setLoadingVector:iia:i, setNewOne:iia:i, setNewTwo:iia:i, setOld:iia:i, setOutcomesFinal:iia:i, setReportHash:iiii:i, setReporterBallot:iiiai:i, setReportsFilled:iia:i, setReportsMask:iia:i, setScores:iia:i, setSetOne:iia:i, setSetTwo:iia:i, setSmoothRep:iia:i, setTotalRepReported:iii:i, setVSize:iii:i, setWeightedCenteredData:iia:i]", 
            "# EXPEVENTS = 0x61d90fd4c1c3502646153003ec4d5c177de0fb58", 
            "", 
            "# returns whether a quorem has a matured event", 
            "# if there aren't enough events in a vote period eventsexpdate, push them to the current period and increment the vote period", 
            "# @return 0 if fail, 1 if success", 
            "def checkQuorum(branch):", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    currentPeriod = (block.number / BRANCHES.getPeriodLength(branch))", 
            "    # provided the currentPeriod is >=2 periods past the things we're going to rbcr on", 
            "    # we can then conclude it has matured && people have had time to vote", 
            "    matured = 0", 
            "    enoughEvents = 0", 
            "    enoughUpcoming = 0", 
            "    if (currentPeriod >= (currentVotePeriod+2)):", 
            "        matured = 1", 
            "", 
            "    # min future decisions at stake - 200 - else branch stalls (do same thing we do if min ballot/event size isn't met,", 
            "    # push events into current period and hopefully more people will create decisions so it can actually be voted on, else repeat)", 
            "    # should 0 out stuff in if statement here", 
            "    upcomingDecisions = 0", 
            "    b = currentVotePeriod", 
            "    while b < (currentVotePeriod+100):", 
            "        upcomingDecisions += EXPEVENTS.getNumberEvents(branch, b)", 
            "        b += 1", 
            "", 
            "    # normally < 30 and < 500 respectively, lowered for testing", 
            "    if ((EXPEVENTS.getNumberEvents(branch, currentVotePeriod) < 5 || upcomingDecisions < 10) && matured):", 
            "        BRANCHES.incrementPeriod(branch)", 
            "        BRANCHES.setStep(branch, 0)", 
            "        BRANCHES.setSubstep(branch, 0)", 
            "        currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "        EXPEVENTS.moveEventsToCurrentPeriod(branch, currentVotePeriod, currentPeriod)", 
            "    else:", 
            "        if(EXPEVENTS.getTotalRepReported(branch, currentVotePeriod)==0 && matured):", 
            "            BRANCHES.incrementPeriod(branch)", 
            "            BRANCHES.setStep(branch, 0)", 
            "            BRANCHES.setSubstep(branch, 0)", 
            "            currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "            EXPEVENTS.moveEventsToCurrentPeriod(branch, currentVotePeriod, currentPeriod)", 
            "            enoughEvents = 0", 
            "            enoughUpcoming = 0", 
            "        else:", 
            "            enoughEvents = 1", 
            "            enoughUpcoming = 1", 
            "", 
            "    if(matured && enoughEvents && enoughUpcoming):", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "        # return([currentPeriod, currentVotePeriod, matured, EXPEVENTS.getNumberEvents(branch, currentVotePeriod), upcomingDecisions]:arr)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "checkQuorum(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern checkQuorum: [checkQuorum:[int256]:int256]"
    }, 
    "closeMarket": {
        "address": "0xdb45fd72e0f88393c872c0387ad7a4c9e9df4296", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x3c5062d58be6ce59534e8a2d10f1d533c1a0206e", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getSharesPurchased:[int256,int256]:int256, getSimulatedBuy:[int256,int256,int256]:_, getSimulatedSell:[int256,int256,int256]:_, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x44a270caf86e229f188b340994fa8671ae94450a", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "extern closeMarketOne: [oneOutcome:[int256,int256]:int256]", 
            "CLOSEONE = 0x9e049aef53bf7d56caa398b6437218ebc548b9c7", 
            "extern closeMarketTwo: [twoOutcomes:[int256,int256[],int256[]]:int256]", 
            "CLOSETWO = 0xf9ed008f6b3b5ec95fce763f3c738c32db17c2e0", 
            "extern closeMarketFour: [fourOutcomes:[int256,int256[],int256[]]:int256]", 
            "CLOSEFOUR = 0x1d6c3999f23692326cf590addb050b482cdf79ba", 
            "extern closeMarketEight: [eightOutcomes:[int256,int256[],int256[]]:int256]", 
            "CLOSEEIGHT = 0xe327c3128520eeacfb1da6091149344a34457f99", 
            "", 
            "# loop through events in the market, get their outcomes && use those to determine the winning events!", 
            "# distribute coins among winning events", 
            "# when multidimen fancy payouts we report on the events separately per usual, but combine them to determine winning state of a fancy market && then payout that state", 
            "# @return 0 if fail, if success 1", 
            "# Error messages otherwise", 
            "    # -1: Market has no cash anyway", 
            "    # -2: 0 outcome", 
            "    # -3: Outcome indeterminable", 
            "def closeMarket(branch, market):", 
            "    if(CASH.balance(market)<=0):", 
            "        return(-1)", 
            "    numberEvents = MARKETS.getNumEvents(market)", 
            "    tradingPeriod = MARKETS.getTradingPeriod(market)", 
            "    # check if any events in the market were pushed back and that market has expired", 
            "    # (as long as the latest expiring event wasn't pushed back, we know they all got reported on)", 
            "    # if it *was* pushed back, we'll just get an outcome of 0, return 0 until the event is actually reported on, then we can resolve the market", 
            "    if(BRANCHES.getVotePeriod(branch) > tradingPeriod):", 
            "        # loop through events in the market, get their outcomes && use those to determine the winning events!", 
            "        n = 0", 
            "        # (max poss. winning outcomes is 8 outcomes total all scalar multidimensional)", 
            "        winningOutcomes = array(8)", 
            "        events = array(3)", 
            "        events = MARKETS.getMarketEvents(market, outitems=3)", 
            "        while n < numberEvents:", 
            "            fxpOutcome = EVENTS.getOutcome(events[n])", 
            "            if(fxpOutcome==0):", 
            "                return(-2)", 
            "            outcome = fxpOutcome/2^64", 
            "            # makes sure it's not a scalar", 
            "            if(fxpOutcome==3*2^63 && numberEvents==1 && !(EVENTS.getMaxValue(events[n])!=1 && EVENTS.getNumOutcomes(events[n])==2)):", 
            "                # return all the $$$ - (@ 50 cents a share)", 
            "                i = 0", 
            "                currentParticipant = MARKETS.getCurrentParticipantNumber(market)", 
            "                while i < currentParticipant:", 
            "                    sharesOwnedOne = MARKETS.getParticipantSharesPurchased(market, i, 1)", 
            "                    sharesOwnedTwo = MARKETS.getParticipantSharesPurchased(market, i, 2)", 
            "                    participant = MARKETS.getParticipantID(market, i)", 
            "                    CASH.subtractCash(market, sharesOwnedOne*2^63 / 2^64)", 
            "                    CASH.addCash(participant, sharesOwnedOne*2^63 / 2^64)", 
            "                    CASH.subtractCash(market, sharesOwnedTwo*2^63 / 2^64)", 
            "                    CASH.addCash(participant, sharesOwnedTwo*2^63 / 2^64)", 
            "                    i += 1", 
            "", 
            "                # give back initial liquidity and ls-lmsr alpha fees (or as much of it/profits are left)", 
            "                # refund left over initial liquidity in market - half to market creator, other half to voters", 
            "                # rest of money available in market + the additional trading fees divy up amongst reporters and market creator", 
            "                initialLiquidity = INFO.getCreationFee(market)", 
            "                # split up excess profits & liquidity", 
            "                marketCash = CASH.balance(market)", 
            "                CASH.addCash(branch, marketCash/2)", 
            "                CASH.addCash(INFO.getCreator(market), marketCash / 2)", 
            "                CASH.subtractCash(market, marketCash)", 
            "", 
            "                winningOutcomes[0] = 1", 
            "                winningOutcomes[1] = 2", 
            "                MARKETS.setWinningOutcomes(market, winningOutcomes)", 
            "                return(-3)", 
            "            elif(fxpOutcome==0):", 
            "                return(-2)", 
            "            if(n==0):", 
            "                #scalar or .5", 
            "                if((EVENTS.getMaxValue(events[n])!=1 && EVENTS.getNumOutcomes(events[n])==2) || fxpOutcome==3*2^63):", 
            "                    winningOutcomes[0] = 1", 
            "                    winningOutcomes[1] = 2", 
            "                # anything besides scalar or .5", 
            "                else:", 
            "                    winningOutcomes[0] += outcome", 
            "            elif(n==1):", 
            "                if((EVENTS.getMaxValue(events[n])!=1 && EVENTS.getNumOutcomes(events[n])==2) || fxpOutcome==3*2^63):", 
            "                    # scalar, scalar", 
            "                    if(winningOutcomes[1]):", 
            "                        winningOutcomes[2] = 3", 
            "                        winningOutcomes[3] = 4", 
            "                    # nonscalar, scalar", 
            "                    else:", 
            "                      # winningOutcomes[0] = winningOutcomes[0]", 
            "                        winningOutcomes[1] = winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-1])", 
            "                # scalar, nonscalar", 
            "                elif(winningOutcomes[1]):", 
            "                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "                    winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "                # nonscalar, nonscalar", 
            "                else:", 
            "                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "            elif(n==2):", 
            "                if((EVENTS.getMaxValue(events[n])!=1 && EVENTS.getNumOutcomes(events[n])==2) || fxpOutcome==3*2^63):", 
            "                    #scalar, scalar, scalar", 
            "                    if(winningOutcomes[3]):", 
            "                        winningOutcomes[4] = 5", 
            "                        winningOutcomes[5] = 6", 
            "                        winningOutcomes[6] = 7", 
            "                        winningOutcomes[7] = 8", 
            "                    #scalar, nonscalar, scalar", 
            "                    #nonscalar, scalar, scalar", 
            "                    elif(winningOutcomes[1]):", 
            "                      # winningOutcomes[0] = winningOutcomes[0]", 
            "                      # winningOutcomes[1] = winningOutcomes[1]", 
            "                        winningOutcomes[2] += winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "                        winningOutcomes[3] += winningOutcomes[1] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "                    #nonscalar, nonscalar, scalar", 
            "                    elif(winningOutcomes[1]==0):", 
            "                      # winningOutcomes[0] = winningOutcomes[0]", 
            "                        winningOutcomes[1] += winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "                else:", 
            "                    #scalar, scalar, nonscalar", 
            "                    if(winningOutcomes[3]):", 
            "                        winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                        winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                        winningOutcomes[2] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                        winningOutcomes[3] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    #scalar, nonscalar, nonscalar", 
            "                    #nonscalar, scalar, nonscalar", 
            "                    elif(winningOutcomes[1]):", 
            "                        winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                        winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    #nonscalar, nonscalar, nonscalar", 
            "                    else:", 
            "                        winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "            n+=1", 
            "", 
            "        pricePerShare1 = 0", 
            "        pricePerShare2 = 0", 
            "        pricePerShare3 = 0", 
            "        pricePerShare4 = 0", 
            "        pricePerShare5 = 0", 
            "        pricePerShare6 = 0", 
            "        pricePerShare7 = 0", 
            "        pricePerShare8 = 0", 
            "", 
            "        if(winningOutcomes[1]==0):", 
            "            CLOSEONE.oneOutcome(market, winningOutcomes[0])", 
            "", 
            "        elif(winningOutcomes[7]):", 
            "            CLOSEEIGHT.eightOutcomes(market, winningOutcomes, events)", 
            "", 
            "        elif(winningOutcomes[3]):", 
            "            CLOSEFOUR.fourOutcomes(market, winningOutcomes, events)", 
            "", 
            "        elif(winningOutcomes[1]):", 
            "            CLOSETWO.twoOutcomes(market, winningOutcomes, events)", 
            "", 
            "        # give back initial liquidity and ls-lmsr alpha fees (or as much of it/profits are left)", 
            "        # refund left over initial liquidity in market - half to market creator, other half to voters", 
            "        # *unless* it's a scaled decision, refund all initial liquidity left over to market creator", 
            "        # rest of money available in market + the additional trading fees divy up amongst reporters and market creator", 
            "        initialLiquidity = INFO.getCreationFee(market)", 
            "        creator = INFO.getCreator(market)", 
            "        marketCash = CASH.balance(market)", 
            "        # some scalar involved", 
            "        if(winningOutcomes[1]):", 
            "            if(CASH.balance(market) > initialLiquidity):", 
            "                # pay back liquidity, split up excess profits", 
            "                CASH.addCash(creator, initialLiquidity)", 
            "                CASH.subtractCash(market, initialLiquidity)", 
            "                marketCash -= initialLiquidity", 
            "                CASH.addCash(branch, marketCash/2)", 
            "                CASH.addCash(creator, marketCash/2)", 
            "                CASH.subtractCash(market, marketCash)", 
            "            # send whatever's left of the initial liquidity to the creator", 
            "            else:", 
            "                CASH.addCash(creator, marketCash)", 
            "                CASH.subtractCash(market, marketCash)", 
            "", 
            "        # no scalars", 
            "        else:", 
            "            # split up excess profits & liquidity", 
            "            CASH.addCash(branch, marketCash/2)", 
            "            CASH.addCash(creator, marketCash/2)", 
            "            CASH.subtractCash(market, marketCash)", 
            "", 
            "        MARKETS.setWinningOutcomes(market, winningOutcomes)", 
            "        return(1)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "closeMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarket: [closeMarket:[int256,int256]:int256]"
    }, 
    "closeMarketEight": {
        "address": "0xe327c3128520eeacfb1da6091149344a34457f99", 
        "code": [
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getSharesPurchased:[int256,int256]:int256, getSimulatedBuy:[int256,int256,int256]:_, getSimulatedSell:[int256,int256,int256]:_, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x44a270caf86e229f188b340994fa8671ae94450a", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "", 
            "# eight winning outcomes", 
            "def eightOutcomes(market, winningOutcome: arr, events: arr):", 
            "    outcomeOne = EVENTS.getOutcome(events[0])", 
            "    minValueOne = EVENTS.getMinValue(events[0])", 
            "    maxValueOne = EVENTS.getMaxValue(events[0])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[1])", 
            "    minValueTwo = EVENTS.getMinValue(events[1])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[1])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "    outcomeThree = EVENTS.getOutcome(events[2])", 
            "    minValueThree = EVENTS.getMinValue(events[2])", 
            "    maxValueThree = EVENTS.getMaxValue(events[0])", 
            "    if(outcomeThree>maxValueThree):", 
            "        outcomeThree = maxValueThree", 
            "    elif(outcomeThree<minValueThree):", 
            "        outcomeThree = minValueThree", 
            "", 
            "    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)", 
            "    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)", 
            "    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent", 
            "    outcomeThreeHighSidePercent = 2^64*(outcomeThree - 2^64*minValueThree) / (2^64*maxValueThree - 2^64*minValueThree)", 
            "    outcomeThreeLowSidePercent = 2^64 - outcomeThreeHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high", 
            "    pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)", 
            "    pricePerShare5 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare6 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare7 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "    pricePerShare8 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)", 
            "", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    i = 0", 
            "    currentParticipant = MARKETS.getCurrentParticipantNumber(market)", 
            "    while i < currentParticipant:", 
            "        # for each winning outcome do...", 
            "        sharesOwned = array(8)", 
            "        while(winningOutcome[n]!=0):", 
            "            sharesOwned[n] = MARKETS.getParticipantSharesPurchased(market, i, winningOutcome[n])", 
            "            n+=1", 
            "        participant = MARKETS.getParticipantID(market, i)", 
            "        CASH.subtractCash(market, sharesOwned[0]*pricePerShare1/2^64)", 
            "        CASH.addCash(participant, sharesOwned[0]*pricePerShare1/2^64)", 
            "        CASH.subtractCash(market, sharesOwned[1]*pricePerShare2/2^64)", 
            "        CASH.addCash(participant, sharesOwned[1]*pricePerShare2/2^64)", 
            "        CASH.subtractCash(market, sharesOwned[2]*pricePerShare3/2^64)", 
            "        CASH.addCash(participant, sharesOwned[2]*pricePerShare3/2^64)", 
            "        CASH.subtractCash(market, sharesOwned[3]*pricePerShare4/2^64)", 
            "        CASH.addCash(participant, sharesOwned[3]*pricePerShare4/2^64)", 
            "        CASH.subtractCash(market, sharesOwned[4]*pricePerShare5/2^64)", 
            "        CASH.addCash(participant, sharesOwned[4]*pricePerShare5/2^64)", 
            "        CASH.subtractCash(market, sharesOwned[5]*pricePerShare6/2^64)", 
            "        CASH.addCash(participant, sharesOwned[5]*pricePerShare6/2^64)", 
            "        CASH.subtractCash(market, sharesOwned[6]*pricePerShare7/2^64)", 
            "        CASH.addCash(participant, sharesOwned[6]*pricePerShare7/2^64)", 
            "        CASH.subtractCash(market, sharesOwned[7]*pricePerShare8/2^64)", 
            "        CASH.addCash(participant, sharesOwned[7]*pricePerShare8/2^64)", 
            "        i+=1", 
            "", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "eightOutcomes(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketEight: [eightOutcomes:[int256,int256[],int256[]]:int256]"
    }, 
    "closeMarketFour": {
        "address": "0x1d6c3999f23692326cf590addb050b482cdf79ba", 
        "code": [
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getSharesPurchased:[int256,int256]:int256, getSimulatedBuy:[int256,int256,int256]:_, getSimulatedSell:[int256,int256,int256]:_, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x44a270caf86e229f188b340994fa8671ae94450a", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "", 
            "# four winning outcomes", 
            "def fourOutcomes(market, winningOutcome: arr, events: arr):", 
            "    # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high", 
            "    scalarOne = -1", 
            "    scalarTwo = -1", 
            "    if((EVENTS.getMaxValue(events[0])!=1 && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*2^63):", 
            "        scalarOne = 0", 
            "    if((EVENTS.getMaxValue(events[1])!=1 && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*2^63):", 
            "        if(scalarOne == -1):", 
            "            scalarOne = 1", 
            "        else:", 
            "            scalarTwo = 1", 
            "    elif((EVENTS.getMaxValue(events[2])!=1 && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*2^63):", 
            "        scalarTwo = 2", 
            "    outcomeOne = EVENTS.getOutcome(events[scalarOne])", 
            "    minValueOne = EVENTS.getMinValue(events[scalarOne])", 
            "    maxValueOne = EVENTS.getMaxValue(events[scalarOne])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[scalarTwo])", 
            "    minValueTwo = EVENTS.getMinValue(events[scalarTwo])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[scalarTwo])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "", 
            "    outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)", 
            "    outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)", 
            "    outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # share four goes with the high-high side", 
            "    pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / 2^64", 
            "    # share three goes with the low-high side", 
            "    pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / 2^64", 
            "    # share two goes with the high-low side", 
            "    pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / 2^64", 
            "    # share one goes with the low-low", 
            "    # both fixed point so div by 2^64 to keep in fixed point", 
            "    pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / 2^64", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    i = 0", 
            "    currentParticipant = MARKETS.getCurrentParticipantNumber(market)", 
            "    while i < currentParticipant:", 
            "        # for each winning outcome do...", 
            "        n = 0", 
            "        while(winningOutcome[n]!=0):", 
            "            sharesOwned = MARKETS.getParticipantSharesPurchased(market, i, winningOutcome[n])", 
            "            participant = MARKETS.getParticipantID(market, i)", 
            "            # low-low", 
            "            if(n==0):", 
            "                CASH.subtractCash(market, sharesOwned*pricePerShare1/2^64)", 
            "                CASH.addCash(participant, sharesOwned*pricePerShare1/2^64)", 
            "            # high-low", 
            "            elif(n==1):", 
            "                CASH.subtractCash(market, sharesOwned*pricePerShare2/2^64)", 
            "                CASH.addCash(participant, sharesOwned*pricePerShare2/2^64)", 
            "            # low-high", 
            "            elif(n==2):", 
            "                CASH.subtractCash(market, sharesOwned*pricePerShare3/2^64)", 
            "                CASH.addCash(participant, sharesOwned*pricePerShare3/2^64)", 
            "            # high-high", 
            "            elif(n==3):", 
            "                CASH.subtractCash(market, sharesOwned*pricePerShare4/2^64)", 
            "                CASH.addCash(participant, sharesOwned*pricePerShare4/2^64)", 
            "            n+=1", 
            "        i+=1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "fourOutcomes(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketFour: [fourOutcomes:[int256,int256[],int256[]]:int256]"
    }, 
    "closeMarketOne": {
        "address": "0x9e049aef53bf7d56caa398b6437218ebc548b9c7", 
        "code": [
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getSharesPurchased:[int256,int256]:int256, getSimulatedBuy:[int256,int256,int256]:_, getSimulatedSell:[int256,int256,int256]:_, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x44a270caf86e229f188b340994fa8671ae94450a", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "", 
            "# mutex result non scalar not .5", 
            "# one winning outcome", 
            "def oneOutcome(market, winningOutcome):", 
            "    pricePerShare1 = 2^64", 
            "", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    i = 0", 
            "    particpantNumber = MARKETS.getCurrentParticipantNumber(market)", 
            "    while i < particpantNumber:", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, i, winningOutcome)", 
            "        participant = MARKETS.getParticipantID(market, i)", 
            "        CASH.subtractCash(market, sharesOwned*pricePerShare1/2^64)", 
            "        CASH.addCash(participant, sharesOwned*pricePerShare1/2^64)", 
            "        i += 1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256"
                    }
                ], 
                "name": "oneOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketOne: [oneOutcome:[int256,int256]:int256]"
    }, 
    "closeMarketTwo": {
        "address": "0xf9ed008f6b3b5ec95fce763f3c738c32db17c2e0", 
        "code": [
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getSharesPurchased:[int256,int256]:int256, getSimulatedBuy:[int256,int256,int256]:_, getSimulatedSell:[int256,int256,int256]:_, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x44a270caf86e229f188b340994fa8671ae94450a", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "", 
            "# # of winningOutcomes is 2", 
            "def twoOutcomes(market, winningOutcome: arr, events: arr):", 
            "    # look for the scalar", 
            "    scalar = 0", 
            "    if((EVENTS.getMaxValue(events[0])!=1 && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*2^63):", 
            "        scalar = 0", 
            "    elif((EVENTS.getMaxValue(events[1])!=1 && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*2^63):", 
            "        scalar = 1", 
            "    elif((EVENTS.getMaxValue(events[2])!=1 && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*2^63):", 
            "        scalar = 2", 
            "    outcome = EVENTS.getOutcome(events[scalar])", 
            "    minValue = EVENTS.getMinValue(events[scalar])", 
            "    maxValue = EVENTS.getMaxValue(events[scalar])", 
            "    if(outcome>maxValue):", 
            "        outcome = maxValue", 
            "    elif(outcome<minValue):", 
            "        outcome = minValue", 
            "    # price is in fixed point", 
            "    # share two goes with the high side", 
            "    pricePerShare2 = 2^64*(outcome - 2^64*minValue) / (2^64*maxValue - 2^64*minValue)", 
            "    #share one goes with the low side of the calc", 
            "    pricePerShare1 = 2^64 - pricePerShare1", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    i = 0", 
            "    currentParticipant = MARKETS.getCurrentParticipantNumber(market)", 
            "    while i < currentParticipant:", 
            "        # for each winning outcome do...", 
            "        n = 0", 
            "        while(winningOutcome[n]!=0):", 
            "            sharesOwned = MARKETS.getParticipantSharesPurchased(market, i, winningOutcome[n])", 
            "            participant = MARKETS.getParticipantID(market, i)", 
            "            # low side", 
            "            if(n==0):", 
            "                CASH.subtractCash(market, sharesOwned*pricePerShare1/2^64)", 
            "                CASH.addCash(participant, sharesOwned*pricePerShare1/2^64)", 
            "            # high side (of the scalar part)", 
            "            elif(n==1):", 
            "                CASH.subtractCash(market, sharesOwned*pricePerShare2/2^64)", 
            "                CASH.addCash(participant, sharesOwned*pricePerShare2/2^64)", 
            "            n+=1", 
            "        i += 1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "twoOutcomes(int256,int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketTwo: [twoOutcomes:[int256,int256[],int256[]]:int256]"
    }, 
    "createBranch": {
        "address": "0x7bf8e4f9e3183867f2ad8c8e61d7b4df3a9204a8", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPEVENTS = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x3c5062d58be6ce59534e8a2d10f1d533c1a0206e", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "", 
            "# period length is given in blocks", 
            "# description format is branchName:description", 
            "# is there some way we can include the description bytes in the sha256 hash?", 
            "# @return branchID if success", 
            "# error messages otherwise", 
            "    # -1: bad input or parent doesn't exist", 
            "    # -2: no money for creation fee or branch already exists", 
            "def createSubbranch(description:str, periodLength, parent, tradingFee):", 
            "    if(periodLength<=0 || !BRANCHES.getPeriodLength(parent) || description==0):", 
            "        return(-1)", 
            "", 
            "    if(tradingFee>2^62):", 
            "        return(-1)", 
            "    #upcomingDecisions = 0", 
            "    #a = (block.number / BRANCHES.getPeriodLength(parent))", 
            "    #b = a", 
            "    #while b < (a+100):", 
            "    #    upcomingDecisions += EXPEVENTS.getNumberEvents(parent, a)", 
            "    #    b += 1", 
            "    # turned off for testing", 
            "    #if(upcomingDecisions < 500):", 
            "    #    return(0)", 
            "", 
            "    branchInfo = string(7*32+len(description))", 
            "    branchInfo[0] = BRANCH                                      #typecode", 
            "    branchInfo[1] = tx.origin                                   #creator address", 
            "    branchInfo[2] = 47*2^64                                     #creation fee", 
            "    branchInfo[3] = periodLength                                #length of voting cycle", 
            "    branchInfo[4] = block.number                                #current block number", 
            "    branchInfo[5] = parent                                      #branchID of parent branch", 
            "    branchInfo[6] = tradingFee", 
            "    mcopy(branchInfo+ 7*32, description, len(description))", 
            "    # people can check that these characteristics hash to the ID if they want", 
            "    # people can hand a friend their new branch hash && characteristics && say, \"don't trust me? check\"", 
            "    branchID = sha256(branchInfo, chars=len(branchInfo))", 
            "    currentVotePeriod = (block.number / periodLength) - 1", 
            "    BRANCHES.initializeBranch(branchID, currentVotePeriod, periodLength, tradingFee)", 
            "    if(INFO.getCreator(parent) && CASH.send(parent, 47*2^64) && INFO.setInfo(branchID, description, tx.origin, 47*2^64) && REPORTING.setInitialReporters(parent, branchID)):", 
            "        return(branchID)", 
            "    else:", 
            "        return(-2)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "periodLength", 
                        "type": "int256"
                    }, 
                    {
                        "name": "parent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }
                ], 
                "name": "createSubbranch(bytes,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createBranch: [createSubbranch:[bytes,int256,int256,int256]:int256]"
    }, 
    "createEvent": {
        "address": "0xf21d1dc93739dddb2ff15db191d7922fe8a4e196", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPEVENTS = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x3c5062d58be6ce59534e8a2d10f1d533c1a0206e", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "", 
            "# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0", 
            "# to 11.0 would be 11 outcomes (if incremented by 0.1)", 
            "# need to make sure these values are ok", 
            "# @return eventID if success", 
            "# error messages otherwise", 
            "    # -2: min > max", 
            "    # -1: we're either already past that date, branch doesn't exist, or description is bad", 
            "    # 0: not enough money to pay fees or event already exists", 
            "def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes):", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    if(minValue > maxValue):", 
            "        return(-2)", 
            "    if periodLength && description != 0 && expDate > block.number:", 
            "        eventinfo = string(8*32 + len(description))", 
            "        eventinfo[0] = EVENT                                        #typecode", 
            "        eventinfo[1] = branch                                       #branchID", 
            "        eventinfo[2] = expDate                                      #expiration date", 
            "        eventinfo[3] = tx.origin                                    #creator address", 
            "        eventinfo[4] = 42*2^64                                      #creation fee", 
            "        eventinfo[5] = minValue                                     #minimum outcome value", 
            "        eventinfo[6] = maxValue                                     #maximum outcome value", 
            "        eventinfo[7] = numOutcomes                                  #number of outcomes", 
            "        mcopy(eventinfo + 8*32, description, len(description))", 
            "        eventID = sha256(eventinfo, chars=len(eventinfo))", 
            "    else:", 
            "        return(-1)", 
            "", 
            "    # fee to ask a question rises if voter participation (rep reported) falls, if it's really high, the fee is lowered (participationFactor is a fixedpoint number)", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    participationFactor = (EXPEVENTS.getTotalRepReported(branch, currentVotePeriod-2) * 2^64) / EXPEVENTS.getTotalRepReported(branch, currentVotePeriod-1)", 
            "    if participationFactor == 0:", 
            "        participationFactor = 1", 
            "", 
            "    # send fee and bond", 
            "    if CASH.balance(tx.origin) >= (42*2^64 + participationFactor*45):", 
            "        if !INFO.getCreator(eventID) && !EVENTS.getEventBranch(eventID) && CASH.send(eventID, 42*2^64) && CASH.send(branch, participationFactor*45):", 
            "            # see which future period it expires in && put the event in that bin", 
            "            # event voting periods - expDate / periodLength gives you the voting period #", 
            "            futurePeriod = expDate / periodLength", 
            "            if INFO.setInfo(eventID, description, tx.origin, participationFactor*45) && EVENTS.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes) && EXPEVENTS.addEvent(branch, futurePeriod, eventID):", 
            "                return(eventID)", 
            "            else:", 
            "                return(0)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "expDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }
                ], 
                "name": "createEvent(int256,bytes,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createEvent: [createEvent:[int256,bytes,int256,int256,int256,int256]:int256]"
    }, 
    "createMarket": {
        "address": "0x344b7273d6ba3ae6464de981e3f8f21de20eb429", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x3c5062d58be6ce59534e8a2d10f1d533c1a0206e", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256]", 
            "FXP = 0x1fa4745bcd612d19c698aad79c9ceee079cf65b6", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getSharesPurchased:[int256,int256]:int256, getSimulatedBuy:[int256,int256,int256]:_, getSimulatedSell:[int256,int256,int256]:_, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x44a270caf86e229f188b340994fa8671ae94450a", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "", 
            "event creationBlock(market:indexed)", 
            "", 
            "# alpha is a fixedpoint number / calc. it in UI", 
            "# z is the optimal initial vector for each outcome", 
            "# z = liquidity / (1+(alpha*n*ln(n)))", 
            "# initialLiquidity is initial number of cash in each outcome you want to buy/initialize/set", 
            "# tradingFee is a percent in fixedPoint", 
            "# same for these values", 
            "# @return marketID if success", 
            "# error messages otherwise:", 
            "#   -1: bad input or parent doesn't exist", 
            "#   -2: too many events", 
            "#   -3: too many outcomes", 
            "#   -4: not enough money or market already exists", 
            "", 
            "def createMarket(branch, description:str, alpha, initialLiquidity, tradingFee, events:arr):", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    if(periodLength==0 or len(description)==0 or initialLiquidity==0 or alpha <= 2^57 or tradingFee < BRANCHES.getMinTradingFee(branch)):", 
            "        return(-1)", 
            "    if(tradingFee > 2^61):", 
            "        return(-1)", 
            "    event = events[0]", 
            "", 
            "    # check that events have same exp. dates && branch", 
            "    i = 0", 
            "    eventNum = len(events)", 
            "", 
            "    # only supports 3 dimensional markets atm", 
            "    if(eventNum > 3):", 
            "        return(-2)", 
            "", 
            "    numOutcomes = 0", 
            "    eventsConcat = 0", 
            "    cumulativeScale = 0", 
            "    tradingPeriod = 0", 
            "    while i < eventNum:", 
            "        event = events[i]", 
            "        expirationDate = EVENTS.getExpiration(event)", 
            "        if(expirationDate > tradingPeriod):", 
            "            tradingPeriod = expirationDate", 
            "        eventsConcat += event", 
            "        if (EVENTS.getEventBranch(event) != branch || !INFO.getCreator(event)):", 
            "            return(-1)", 
            "", 
            "        # scalars", 
            "        maxValue = EVENTS.getMaxValue(event)", 
            "        if(maxValue!=1 && EVENTS.getNumOutcomes(event)==2):", 
            "            # is a valid scalar", 
            "            cumulativeScale += maxValue - EVENTS.getMinValue(event)", 
            "        eventNumOutcomes = EVENTS.getNumOutcomes(event)", 
            "        if(i==0):", 
            "            numOutcomes += eventNumOutcomes", 
            "        else:", 
            "            numOutcomes *= eventNumOutcomes", 
            "        i += 1", 
            "    if(numOutcomes > 200):", 
            "        return(-3)", 
            "    if(cumulativeScale==0):", 
            "        cumulativeScale = 1", 
            "    tradingPeriod = (tradingPeriod / periodLength)", 
            "", 
            "    # formation of marketID (hash)", 
            "    marketinfo = string(11*32 + len(description))", 
            "    marketinfo[0] = MARKET", 
            "    marketinfo[1] = tx.origin", 
            "    marketinfo[2] = initialLiquidity", 
            "    marketinfo[3] = branch", 
            "    marketinfo[4] = eventsConcat", 
            "    marketinfo[5] = len(events)", 
            "    marketinfo[6] = cumulativeScale", 
            "    marketinfo[7] = alpha", 
            "    marketinfo[8] = numOutcomes", 
            "    marketinfo[9] = tradingPeriod", 
            "    marketinfo[10] = tradingFee", 
            "    mcopy(marketinfo + 11*32, description, chars=len(description))", 
            "    marketID = sha256(marketinfo, chars=len(marketinfo))", 
            "    log(type=creationBlock, marketID)", 
            "", 
            "    # pay numOutcomes fee", 
            "    # if it's already been created return 0", 
            "    if(!CASH.send(branch, numOutcomes*2^63) || INFO.getCreator(marketID) || MARKETS.getMarketNumOutcomes(marketID)):", 
            "        return(-4)", 
            "", 
            "    # buy some of all outcomes", 
            "    # ls-lmsr needs at least a very small initial liquidity", 
            "    y = 1", 
            "    z = initialLiquidity * 2**64 / (2**64 + alpha*cumulativeScale*FXP.fx_log(initialLiquidity)/2**64)", 
            "    MARKETS.initialLiquiditySetup(marketID, alpha, cumulativeScale, numOutcomes)", 
            "    while y <= numOutcomes:", 
            "        MARKETS.modifyShares(marketID, y, z)", 
            "        y += 1", 
            "", 
            "    if(INFO.setInfo(marketID, description, tx.origin, initialLiquidity) && BRANCHES.addMarket(branch, marketID) && MARKETS.initializeMarket(marketID, events, tradingPeriod, tradingFee, branch) && CASH.send(marketID, initialLiquidity)):", 
            "        return(marketID)", 
            "", 
            "    # revert shares bought and other variables", 
            "    else:", 
            "        v = 1", 
            "        while v <= numOutcomes:", 
            "            MARKETS.modifyShares(marketID, v, -z)", 
            "            v += 1", 
            "        MARKETS.initialLiquiditySetup(marketID, 0, 0, 0)", 
            "        return(-4)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "alpha", 
                        "type": "int256"
                    }, 
                    {
                        "name": "initialLiquidity", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }
                ], 
                "name": "createMarket(int256,bytes,int256,int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "creationBlock(int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern createMarket: [createMarket:[int256,bytes,int256,int256,int256,int256[]]:int256]"
    }, 
    "dispatch": {
        "address": "0x4b22c2f46045f8eb791e9c31b3d17dc41ea33cb4", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Joey Krug (joey@augur.net) or", 
            "# Jack Peterson (jack@augur.net).", 
            "", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPIRING = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "extern checkQuorum: [checkQuorum:[int256]:int256]", 
            "QUORUM = 0x7a38967fab965444182e48fca12d63c62ceb3d96", 
            "extern redeem_interpolate: [interpolate:[int256,int256,int256,int256,int256]:int256, read_ballots:[int256,int256,int256,int256,int256]:int256]", 
            "REDEEM_INTERPOLATE = 0x9194647074999cc5792164fdebd1f653aa99397c", 
            "extern redeem_center: [center:[int256,int256,int256,int256,int256]:int256, covariance:[int256,int256,int256,int256,int256]:int256]", 
            "REDEEM_CENTER = 0x608fa0fbee213d5ca2032fc30b50c16bc852b7da", 
            "extern redeem_score: [blank:[int256,int256,int256,int256,int256]:int256, deflate:[int256,int256,int256,int256,int256]:int256, latent:[int256,int256,int256,int256,int256]:int256, loadings:[int256,int256,int256,int256,int256]:int256, score:[int256,int256,int256,int256,int256]:int256]", 
            "REDEEM_SCORE = 0x652b9c2095f2e244b7ca144237ff6b2ff2f32d67", 
            "extern redeem_adjust: [reputation_delta:[int256,int256,int256,int256,int256]:int256, select_scores:[int256,int256,int256,int256,int256]:int256, weighted_delta:[int256,int256,int256,int256,int256]:int256]", 
            "REDEEM_ADJUST = 0xb5c5b32e285ba059cd5c79560885ac6448ecfc36", 
            "extern redeem_resolve: [resolve:[int256,int256,int256,int256,int256]:int256, smooth:[int256,int256,int256,int256,int256]:int256]", 
            "REDEEM_RESOLVE = 0x7368ad231be18e0c6859e6ec776c3c8e2857b747", 
            "extern redeem_payout: [payout:[int256,int256,int256,int256,int256]:int256]", 
            "REDEEM_PAYOUT = 0xa4f49043cabb4c514eb8d7425932b982dd65c74c", 
            "", 
            "# - 50% of fees already distributed to market creators", 
            "#   all remaining fees go to reporters", 
            "# - what if not enough consensus or not enough events expiring upcoming", 
            "# @return next step or loop index (see below), for final call return new voting period", 
            "def dispatch(branch):", 
            "    if !BRANCHES.getStep(branch) and !QUORUM.checkQuorum(branch):", 
            "        return(-1)", 
            "    with period = BRANCHES.getVotePeriod(branch):", 
            "        with num_events = EXPIRING.getNumberEvents(branch, period):", 
            "            with num_reports = REPORTING.getNumberReporters(branch):", 
            "                with flatsize = num_events * num_reports:", 
            "                    with step = BRANCHES.getStep(branch):", 
            "                        if step == 10:", 
            "                            REDEEM_PAYOUT.payout(branch, period, num_events, num_reports, flatsize)", 
            "                            BRANCHES.setStep(branch, 0) # reset step", 
            "                            BRANCHES.incrementPeriod(branch)", 
            "                            return(period + 1)", 
            "                        elif step == 0:", 
            "                            EXPIRING.setTotalReputation(branch, period, REPORTING.getTotalRep(branch))", 
            "                            REDEEM_INTERPOLATE.read_ballots(branch, period, num_events, num_reports, flatsize)", 
            "                        elif step == 1:", 
            "                            REDEEM_INTERPOLATE.interpolate(branch, period, num_events, num_reports, flatsize)", 
            "                        elif step == 2:", 
            "                            REDEEM_CENTER.center(branch, period, num_events, num_reports, flatsize)", 
            "                        elif step == 3:", 
            "                            REDEEM_CENTER.covariance(branch, period, num_events, num_reports, flatsize)", 
            "", 
            "                        # loop MAX_COMPONENTS", 
            "                        elif step == 4:", 
            "                            with substep = BRANCHES.getSubstep(branch):", 
            "                                if substep == 0:", 
            "                                    REDEEM_SCORE.blank(branch, period, num_events, num_reports, flatsize)", 
            "                                    BRANCHES.incrementSubstep(branch)", 
            "                                    return(step)", 
            "", 
            "                                # loop MAX_ITERATIONS", 
            "                                elif substep == 1:", 
            "                                    if REDEEM_SCORE.loadings(branch, period, num_events, num_reports, flatsize) == 0:", 
            "                                        BRANCHES.incrementSubstep(branch)", 
            "                                    return(step)", 
            "", 
            "                                elif substep == 2:", 
            "                                    REDEEM_SCORE.latent(branch, period, num_events, num_reports, flatsize)", 
            "                                    BRANCHES.incrementSubstep(branch)", 
            "                                    return(step)", 
            "                                elif substep == 3:", 
            "                                    REDEEM_SCORE.deflate(branch, period, num_events, num_reports, flatsize)", 
            "                                    BRANCHES.incrementSubstep(branch)", 
            "                                    return(step)", 
            "                                else:", 
            "                                    with more = REDEEM_SCORE.score(branch, period, num_events, num_reports, flatsize):", 
            "                                        BRANCHES.setSubstep(branch, 0)", 
            "                                        if more == 1:", 
            "                                            return(step)", 
            "                                        else:", 
            "                                            BRANCHES.incrementStep(branch)", 
            "                                            return(step + 1)", 
            "", 
            "                        elif step == 5:", 
            "                            REDEEM_ADJUST.reputation_delta(branch, period, num_events, num_reports, flatsize)", 
            "                        elif step == 6:", 
            "                            REDEEM_ADJUST.weighted_delta(branch, period, num_events, num_reports, flatsize)", 
            "                        elif step == 7:", 
            "                            REDEEM_ADJUST.select_scores(branch, period, num_events, num_reports, flatsize)", 
            "                        elif step == 8:", 
            "                            REDEEM_RESOLVE.smooth(branch, period, num_events, num_reports, flatsize)", 
            "                        elif step == 9:", 
            "                            REDEEM_RESOLVE.resolve(branch, period, num_events, num_reports, flatsize)", 
            "                        BRANCHES.incrementStep(branch)", 
            "                        return(step + 1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "dispatch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern dispatch: [dispatch:[int256]:int256]"
    }, 
    "events": {
        "address": "0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "# Events' index is the eventID", 
            "# a binary outcome has 0 for min && 1 for max value, but consensus will return 2^64 and 2^65 respectively", 
            "# so for voting 1 and 2 in fxp. need to be given for binaries, not 0 & 1", 
            "# S&P 500 scalar would be say 0 && 4700, respectively", 
            "# categorical markets have fixed point min and max", 
            " # so max-min/numOutcomes is interval between outcomes (useful for ui, e.g. 1 is >50, 2 is >100, etc.)", 
            "# need outcomes returned as 1*2^64, 2*2^64, etc... indeterminate as 3*2^63", 
            "data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes)", 
            "", 
            "def getEventInfo(event):", 
            "    info = array(6)", 
            "    info[0] = self.Events[event].branch", 
            "    info[1] = self.Events[event].expirationDate", 
            "    info[2] = self.Events[event].outcome", 
            "    info[3] = self.Events[event].minValue", 
            "    info[4] = self.Events[event].maxValue", 
            "    info[5] = self.Events[event].numOutcomes", 
            "    return(info: arr)", 
            "", 
            "def getEventBranch(event):", 
            "\treturn(self.Events[event].branch)", 
            "", 
            "def getExpiration(event):", 
            "\treturn(self.Events[event].expirationDate)", 
            "", 
            "def getOutcome(event):", 
            "\treturn(self.Events[event].outcome)", 
            "", 
            "def getMinValue(event):", 
            "\treturn(self.Events[event].minValue)", 
            "", 
            "def getMaxValue(event):", 
            "\treturn(self.Events[event].maxValue)", 
            "", 
            "def getNumOutcomes(event):", 
            "\treturn(self.Events[event].numOutcomes)", 
            "", 
            "def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes):", 
            "\t# check that msg.sender is one of our function contracts", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tif(self.Events[ID].expirationDate==0):", 
            "\t\tself.Events[ID].branch = branch", 
            "\t\tself.Events[ID].expirationDate = expirationDate", 
            "\t\tself.Events[ID].minValue = minValue", 
            "\t\tself.Events[ID].maxValue = maxValue", 
            "\t\tself.Events[ID].numOutcomes = numOutcomes", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)", 
            "", 
            "def setOutcome(ID, outcome):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.Events[ID].outcome = outcome", 
            "\treturn(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventInfo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getExpiration(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMaxValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMinValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expirationDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeEvent(int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]"
    }, 
    "expiringEvents": {
        "address": "0x27f07adb9921e7f69462e3e285d43c6c25768058", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "", 
            "# [branchID][votingPeriod]", 
            "# v_size = numReports * numEvents", 
            "# reportsFilled, reportsMask, weightedCenteredData, loadingVector, scores, set1, set2, old,", 
            "# new1, new2, adjPrinComp, smoothRep, outcomesFinal, consensusReward is all consensus data", 
            "# reporters is [reporterID][eventNum]", 
            "# reporthash is [reporterID] = hash", 
            "data EventsExpDates[][](numberEvents, events[], totalRepReported, totalReputation, reporters[][], reportHash[], vSize, reportsFilled[], reportsMask[], weightedCenteredData[], covarianceMatrixRow[], deflated[], loadingVector[], latent, scores[], set1[], set2[], old[], new1[], new2[], adjPrinComp[], smoothRep[], outcomesFinal[], reporterPayouts[])", 
            "", 
            "# atm voters who do vote are req. to vote on all things in their respective ballots (even if just a 0 / no vote)", 
            "# ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[w/eVotingPeriodShouldBe].numberEvents", 
            "# w/ this function you can get the eventIDs and report on outcomes", 
            " # make sure in this function to check that the report value is not >maxvalue or <minvalue for the event", 
            "# ui will want to alert users of any hey we're behind but atm you should really be voting on this voting period situation (anything meeting the req. of vote if we were caught up)", 
            "# @returns a ballot of events (UI needs to vote w/ a ballot of reports in this order per corresponding event)", 
            "# @return all events in a branch and expiration period", 
            "def getEvents(branch, expDateIndex):", 
            "    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents", 
            "    events = array(numEvents)", 
            "    i = 0", 
            "    while i < numEvents:", 
            "        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]", 
            "        i += 1", 
            "    return(events: arr)", 
            "", 
            "def getNumberEvents(branch, expDateIndex):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].numberEvents)", 
            "", 
            "def getEvent(branch, expDateIndex, eventIndex):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].events[eventIndex])", 
            "", 
            "def getTotalReputation(branch, expDateIndex):", 
            "    return(self.EventsExpDates[branch][expDateIndex].totalReputation)", 
            "", 
            "def getTotalRepReported(branch, expDateIndex):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].totalRepReported)", 
            "", 
            "def getReporterBallot(branch, expDateIndex, reporterID):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].reporters[reporterID][0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)", 
            "", 
            "def getReport(branch, expDateIndex, reporter, reportNum):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].reporters[reporter][reportNum])", 
            "", 
            "def getReportHash(branch, expDateIndex, reporter):", 
            "\treturn(self.EventsExpDates[branch][expDateIndex].reportHash[reporter])", 
            "", 
            "def getVSize(branch, expDateIndex):", 
            "    return(self.EventsExpDates[branch][expDateIndex].vSize)", 
            "", 
            "def getReportsFilled(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].reportsFilled[0], chars=32*self.EventsExpDates[branch][expDateIndex].vSize): arr)", 
            "", 
            "def getReportsMask(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].reportsMask[0], chars=32*self.EventsExpDates[branch][expDateIndex].vSize): arr)", 
            "", 
            "def getWeightedCenteredData(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].weightedCenteredData[0], chars=32*self.EventsExpDates[branch][expDateIndex].vSize): arr)", 
            "", 
            "def getCovarianceMatrixRow(branch, expDateIndex):", 
            "    return(load(self.EventsExpDates[branch][expDateIndex].covarianceMatrixRow[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)", 
            "", 
            "def getDeflated(branch, expDateIndex):", 
            "    return(load(self.EventsExpDates[branch][expDateIndex].deflated[0], chars=32*self.EventsExpDates[branch][expDateIndex].vSize): arr)", 
            "", 
            "def getLoadingVector(branch, expDateIndex):", 
            "    return(load(self.EventsExpDates[branch][expDateIndex].loadingVector[0], chars=32*(self.EventsExpDates[branch][expDateIndex].numberEvents+2)): arr)", 
            "", 
            "def getLatent(branch, expDateIndex):", 
            "    return(self.EventsExpDates[branch][expDateIndex].latent)", 
            "", 
            "def getScores(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].scores[0], chars=32*(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)", 
            "", 
            "def getSetOne(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].set1[0], chars=32*(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)", 
            "", 
            "def getSetTwo(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].set2[0], chars=32*(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)", 
            "", 
            "def returnOld(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].old[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)", 
            "", 
            "def getNewOne(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].new1[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)", 
            "", 
            "def getNewTwo(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].new2[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)", 
            "", 
            "def getAdjPrinComp(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].adjPrinComp[0], chars=32*(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)", 
            "", 
            "def getSmoothRep(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].smoothRep[0], chars=32*(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)", 
            "", 
            "def getOutcomesFinal(branch, expDateIndex):", 
            "\treturn(load(self.EventsExpDates[branch][expDateIndex].outcomesFinal[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)", 
            "", 
            "def getReporterPayouts(branch, expDateIndex):", 
            "    return(load(self.EventsExpDates[branch][expDateIndex].reporterPayouts[0], chars=32*self.EventsExpDates[branch][expDateIndex].numberEvents): arr)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def addEvent(branch, futurePeriod, eventID):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID", 
            "\tself.EventsExpDates[branch][futurePeriod].numberEvents += 1", 
            "\treturn(1)", 
            "", 
            "def setTotalRepReported(branch, expDateIndex, repReported):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.EventsExpDates[branch][expDateIndex].totalRepReported = repReported", 
            "\treturn(1)", 
            "", 
            "def setTotalReputation(branch, expDateIndex, totalReputation):", 
            "    self.EventsExpDates[branch][expDateIndex].totalReputation = totalReputation", 
            "    return(1)", 
            "", 
            "def setReporterBallot(branch, expDateIndex, reporterID, report: arr, reputation):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].reporters[reporterID][0], report, chars=32*len(report))", 
            "\tself.EventsExpDates[branch][expDateIndex].totalRepReported += reputation", 
            "\treturn(1)", 
            "", 
            "def setVSize(branch, expDateIndex, vSize):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.EventsExpDates[branch][expDateIndex].vSize = vSize", 
            "\treturn(1)", 
            "", 
            "def setReportsFilled(branch, expDateIndex, reportsFilled: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].reportsFilled[0], reportsFilled, chars=32*len(reportsFilled))", 
            "\treturn(1)", 
            "", 
            "def setReportsMask(branch, expDateIndex, reportsMask: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].reportsMask[0], reportsMask, chars=32*len(reportsMask))", 
            "\treturn(1)", 
            "", 
            "def setWeightedCenteredData(branch, expDateIndex, weightedCenteredData: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].weightedCenteredData[0], weightedCenteredData, chars=32*len(weightedCenteredData))", 
            "\treturn(1)", 
            "", 
            "def setCovarianceMatrixRow(branch, expDateIndex, covarianceMatrixRow: arr):", 
            "    #if !self.whitelist.check(msg.sender):", 
            "     #   return(-1)", 
            "    save(self.EventsExpDates[branch][expDateIndex].covarianceMatrixRow[0], covarianceMatrixRow, chars=32*len(covarianceMatrixRow))", 
            "    return(1)", 
            "", 
            "def setDeflated(branch, expDateIndex, deflated: arr):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    save(self.EventsExpDates[branch][expDateIndex].deflated[0], deflated, chars=32*len(deflated))", 
            "    return(1)", 
            "", 
            "def setLoadingVector(branch, expDateIndex, loadingVector: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].loadingVector[0], loadingVector, chars=32*len(loadingVector))", 
            "\treturn(1)", 
            "", 
            "def setLatent(branch, expDateIndex, latent):", 
            "    #if !self.whitelist.check(msg.sender):", 
            "    #   return(-1)", 
            "    self.EventsExpDates[branch][expDateIndex].latent = latent", 
            "    return(1)", 
            "", 
            "def setScores(branch, expDateIndex, scores: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].scores[0], scores, chars=32*len(scores))", 
            "\treturn(1)", 
            "", 
            "def setSetOne(branch, expDateIndex, setOne: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].set1[0], setOne, chars=32*len(setOne))", 
            "\treturn(1)", 
            "", 
            "def setSetTwo(branch, expDateIndex, setTwo: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].set2[0], setTwo, chars=32*len(setTwo))", 
            "\treturn(1)", 
            "", 
            "def setOld(branch, expDateIndex, setOld: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].old[0], setOld, chars=32*len(setOld))", 
            "\treturn(1)", 
            "", 
            "def setNewOne(branch, expDateIndex, newOne: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].new1[0], newOne, chars=32*len(newOne))", 
            "\treturn(1)", 
            "", 
            "def setNewTwo(branch, expDateIndex, newTwo: arr):", 
            "\t# if(!self.whitelist.check(msg.sender)):", 
            "\t# \treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].new2[0], newTwo, chars=32*len(newTwo))", 
            "\treturn(1)", 
            "", 
            "def setAdjPrinComp(branch, expDateIndex, adjPrinComp: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].adjPrinComp[0], adjPrinComp, chars=32*len(adjPrinComp))", 
            "\treturn(1)", 
            "", 
            "def setSmoothRep(branch, expDateIndex, smoothRep: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].smoothRep[0], smoothRep, chars=32*len(smoothRep))", 
            "\treturn(1)", 
            "", 
            "def setOutcomesFinal(branch, expDateIndex, outcomesFinal: arr):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tsave(self.EventsExpDates[branch][expDateIndex].outcomesFinal[0], outcomesFinal, chars=32*len(outcomesFinal))", 
            "\treturn(1)", 
            "", 
            "def setReporterPayouts(branch, expDateIndex, reporterPayouts: arr):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #   return(-1)", 
            "    save(self.EventsExpDates[branch][expDateIndex].reporterPayouts[0], reporterPayouts, chars=32*len(reporterPayouts))", 
            "    return(1)", 
            "", 
            "def setReportHash(branch, expDateIndex, reporter, reportHash):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\tself.EventsExpDates[branch][expDateIndex].reportHash[reporter] = reportHash", 
            "\treturn(1)", 
            "", 
            "def moveEventsToCurrentPeriod(branch, currentVotePeriod, currentPeriod):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    x = 0", 
            "    while(x < self.EventsExpDates[branch][currentVotePeriod-1].numberEvents):", 
            "        self.EventsExpDates[branch][currentPeriod].events[self.EventsExpDates[branch][currentPeriod].numberEvents] = self.EventsExpDates[branch][currentVotePeriod-1].events[x]", 
            "        self.EventsExpDates[branch][currentPeriod].numberEvents += 1", 
            "        # sub and set old period event to 0 poss.?", 
            "        x += 1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "futurePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "addEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getAdjPrinComp(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getCovarianceMatrixRow(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getDeflated(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getLatent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getLoadingVector(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getNewOne(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getNewTwo(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumberEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getOutcomesFinal(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportNum", 
                        "type": "int256"
                    }
                ], 
                "name": "getReport(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportHash(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporterID", 
                        "type": "int256"
                    }
                ], 
                "name": "getReporterBallot(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getReporterPayouts(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportsFilled(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportsMask(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getScores(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getSetOne(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getSetTwo(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getSmoothRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalRepReported(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalReputation(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getVSize(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getWeightedCenteredData(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "currentVotePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "currentPeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "moveEventsToCurrentPeriod(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "returnOld(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "adjPrinComp", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setAdjPrinComp(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "covarianceMatrixRow", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setCovarianceMatrixRow(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "deflated", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setDeflated(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "latent", 
                        "type": "int256"
                    }
                ], 
                "name": "setLatent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "loadingVector", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setLoadingVector(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "newOne", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setNewOne(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "newTwo", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setNewTwo(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "setOld", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setOld(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcomesFinal", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setOutcomesFinal(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportHash", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportHash(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporterID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "reputation", 
                        "type": "int256"
                    }
                ], 
                "name": "setReporterBallot(int256,int256,int256,int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporterPayouts", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setReporterPayouts(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportsFilled", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setReportsFilled(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportsMask", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setReportsMask(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "scores", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setScores(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "setOne", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setSetOne(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "setTwo", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setSetTwo(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "smoothRep", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setSmoothRep(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repReported", 
                        "type": "int256"
                    }
                ], 
                "name": "setTotalRepReported(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "totalReputation", 
                        "type": "int256"
                    }
                ], 
                "name": "setTotalReputation(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "vSize", 
                        "type": "int256"
                    }
                ], 
                "name": "setVSize(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "weightedCenteredData", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setWeightedCenteredData(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]"
    }, 
    "faucets": {
        "address": "0x1f7a7eb8bdf2690bd815c24a16f3301706005f42", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact jack@augur.net or joey@augur.net.", 
            "", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "", 
            "# Error -1: Hey, you're not broke!", 
            "def cashFaucet():", 
            "    if CASH.balance(tx.origin) > fix(5):", 
            "        return(-1)", 
            "    CASH.setCash(tx.origin, fix(10000))", 
            "    return(1)", 
            "", 
            "def reputationFaucet(branch):", 
            "    if REPORTING.repIDToIndex(branch, tx.origin) != 0 or REPORTING.getReporterID(branch, 0) == tx.origin:", 
            "        index = REPORTING.repIDToIndex(branch, tx.origin)", 
            "    else:", 
            "        index = REPORTING.getNumberReporters(branch)", 
            "        REPORTING.addReporter(branch, tx.origin)", 
            "    REPORTING.setRep(branch, index, fix(47))", 
            "    return(1)", 
            "", 
            "inset(\"../../macros/fixed.sm\")"
        ], 
        "fullsig": [
            {
                "inputs": [], 
                "name": "cashFaucet()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "reputationFaucet(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern faucets: [cashFaucet:[]:int256, reputationFaucet:[int256]:int256]"
    }, 
    "fxpFunctions": {
        "address": "0x1fa4745bcd612d19c698aad79c9ceee079cf65b6", 
        "code": [
            "macro fx_floor_log2($x):", 
            "    with $y = $x / 0x10000000000000000:", 
            "        with $lo = 0:", 
            "            with $hi = 191:", 
            "                with $mid = ($hi + $lo)/2:", 
            "                    while (($lo + 1) != $hi):", 
            "                        if $y < 2**$mid:", 
            "                            $hi = $mid", 
            "                        else:", 
            "                            $lo = $mid", 
            "                        $mid = ($hi + $lo)/2", 
            "                    $lo", 
            "", 
            "macro fx_log2_small($x):", 
            "    with $result = -0x48A49EAD9B2CD16BE:", 
            "        with $temp = $x:", 
            "            $result += 0x124DC64B2741E5F083*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x36A569D528A96FF419*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x880785B1DE09970584*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x10AF33C52EB996E92A6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x19FD6E8AC1305DD6D3F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x2086485A91622AE7378*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x210382DF5A3175686B4*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1B58D71F02D9DA4F7B6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1288E14C2FB8C4C1595*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0xA44C5BBEB599D5AB38*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x4A0E619C630B69BC17*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1AE8CAEA63CF2593A9*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x7C3EF5A5BFC21BA1F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1BD202FA82B683802*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x4A90858A0731AD74*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x8CB3CD4376E76EF*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xA6B8F8E68CD877*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result - 0x5D5316875D9E3*$temp / 0x10000000000000000", 
            "", 
            "macro fx_log2($x):", 
            "    with $y = fx_floor_log2($x):", 
            "        with $z = $x / 2**$y:", 
            "            $y * 0x10000000000000000 + fx_log2_small($z)", 
            "", 
            "macro fx_log($x):", 
            "    fx_log2($x) * 0x10000000000000000 / 0x171547652B82FE177", 
            "", 
            "macro fx_exp2_small($x):", 
            "    with $result = 0x10000000000000000:", 
            "        with $temp = $x:", 
            "            $result += 0xB17217F7D1CF79AC*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x3D7F7BFF058B1D56*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xE35846B82505F32*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x276556DF749D7C6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x5761FF9E294A6F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xA184897C5558D*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xFFE5FE24386C*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x162C023B2A1D*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1B5250C02BF*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1E4D3F1A83*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1E87B8E21*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1C768AA3*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x164F0A9*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result + 0x1B08D3*$temp / 0x10000000000000000", 
            "", 
            "macro fx_exp2($x):", 
            "    with $y = $x / 0x10000000000000000:", 
            "        with $z = $x % 0x10000000000000000:", 
            "            fx_exp2_small($z) * 2**$y", 
            "", 
            "macro fx_exp($x):", 
            "    fx_exp2($x * 0x10000000000000000 / 0xB17217F7D1CF79AC)", 
            "", 
            "def fx_exp(x):", 
            "\treturn(fx_exp(x))", 
            "", 
            "def fx_log(x):", 
            "\treturn(fx_log(x))"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "fx_exp(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "fx_log(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256]"
    }, 
    "info": {
        "address": "0x3c5062d58be6ce59534e8a2d10f1d533c1a0206e", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "", 
            "# Every entity in our contract has similar metadata.", 
            "# Instead of putting it in each entity, we put all the", 
            "# metadata here.", 
            "# Info's index is the hash of the item we're getting info on", 
            "data Info[](description[2048], descriptionLength, creator, creationFee)", 
            "", 
            "def init():", 
            "    description = text(\"Root branch\")", 
            "    save(self.Info[1010101].description[0], description, chars=len(description))", 
            "    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826", 
            "    self.Info[1010101].creationFee = 10", 
            "    self.Info[1010101].descriptionLength = len(description)", 
            "", 
            "def getDescription(ID):", 
            "\tlength=self.Info[ID].descriptionLength", 
            "\treturn(load(self.Info[ID].description[0], chars=length): str)", 
            "", 
            "def getDescriptionLength(ID):", 
            "\treturn(self.Info[ID].descriptionLength)", 
            "", 
            "def getCreator(ID):", 
            "\treturn(self.Info[ID].creator)", 
            "", 
            "def getCreationFee(ID):", 
            "\treturn(self.Info[ID].creationFee)", 
            "", 
            "# @return 1 if success, 0 if creator already exists", 
            "def setInfo(ID, description: str, creator, fee):", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\t# check that msg.sender is one of our function contracts", 
            "\tif(self.Info[ID].creator == 0):", 
            "\t\tsave(self.Info[ID].description[0], description, chars=len(description))", 
            "\t\tself.Info[ID].descriptionLength = len(description)", 
            "\t\tself.Info[ID].creationFee = fee", 
            "\t\tself.Info[ID].creator = creator", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreator(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getDescription(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getDescriptionLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "creator", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fee", 
                        "type": "int256"
                    }
                ], 
                "name": "setInfo(int256,bytes,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]"
    }, 
    "ipfs": {
        "address": "0x0dc961533e26dccb673ccbaa93d8e8fd96b41765", 
        "code": [
            "data hashes[]", 
            "", 
            "def setHash(name, hash):", 
            "    self.hashes[name] = hash", 
            "    return(1)", 
            "", 
            "def getHash(name):", 
            "    return(self.hashes[name])"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "name", 
                        "type": "int256"
                    }
                ], 
                "name": "getHash(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "name", 
                        "type": "int256"
                    }, 
                    {
                        "name": "hash", 
                        "type": "int256"
                    }
                ], 
                "name": "setHash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern ipfs: [getHash:[int256]:int256, setHash:[int256,int256]:int256]"
    }, 
    "makeReports": {
        "address": "0x66be17e5b82a1080dae93bbd65935516182ca20c", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPEVENTS = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x3c5062d58be6ce59534e8a2d10f1d533c1a0206e", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "", 
            "# a no vote is -2^64, a yes vote is 2^64 && a can't determine vote is 3*2^63 (a empty ballot is 0)", 
            "# atm voters who do vote are req. to vote on all things in their respective ballots (rest just auto .5 them)", 
            "# ui should handle this by filling in things you didn't vote on automatically & ask to be sure you didn't want to vote on them", 
            "# UI makeBallot function does this", 
            "    # ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[votePeriod].numberEvents", 
            "    # && loop through the events[] array fr2om 0 to numberEvents -1 for the votes list / order", 
            "# people could report something like 16027*2^64 for a scalar", 
            "# if people get behind on voting (e.g the redeem tx isn't called <1 period after it can be called)", 
            "    # voteperiod is an optional parameter only used in the scenario that we get behind on voting periods", 
            "    # so people will need to vote on periods that are upcoming even if our currentVotePeriod is a bit behind (e.g. if current expperiod is 7 you should vote on stuff from voteperiod 6 (and then upon period 8 you can't vote anymore))", 
            "# @return 1 if success", 
            "# Error messages otherwise", 
            "    # -1: report isn't long enough", 
            "    # -2: reporter (you) doesn't (don't) exist, or voting period over or hasn't starred yet", 
            "    # -3: hash doesn't match", 
            "    # -4: no rep", 
            "def report(branch, report:arr, votePeriod, salt):", 
            "    # make sure the branch exists", 
            "    repIndex = REPORTING.repIDToIndex(branch, tx.origin)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    if(residual > periodLength/2):", 
            "        # submit salt and votes", 
            "        # need report length to be same as number of items in the current eventexpdates voting period events!", 
            "        if(len(report)!=EXPEVENTS.getNumberEvents(branch, votePeriod)):", 
            "            return(-1)", 
            "        if(REPORTING.getRepBalance(branch, tx.origin)==0):", 
            "            return(-4)", 
            "", 
            "        realHash = EXPEVENTS.getReportHash(branch, votePeriod, tx.origin)", 
            "        hashInfo = array(len(report) + 2)", 
            "        hashInfo[0] = tx.origin", 
            "        hashInfo[1] = salt", 
            "        i = 2", 
            "        while i < (len(report) + 2):", 
            "            hashInfo[i] = report[i-2]", 
            "            i += 1", 
            "        reportHash = sha256(hashInfo, chars=32*len(hashInfo))", 
            "        if(reportHash!=realHash):", 
            "            (return(-3))", 
            "", 
            "        # if currentExpPeriod is more than 2 periods past the current vote period", 
            "        # then there can be no more voting for that voting period", 
            "        # (reasoning being: >=1 period past means all the events in that period have expired)", 
            "        # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)", 
            "        # currently requires events to expire to vote", 
            "        currentExpPeriod = (block.number / periodLength)", 
            "        if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):", 
            "            return(-2)", 
            "", 
            "        reputation = REPORTING.getRepBalance(branch, tx.origin)", 
            "        # need to update stuff for quorem", 
            "        # && store the report && the rep value", 
            "        if(EXPEVENTS.setReporterBallot(branch, votePeriod, tx.origin, report, reputation)):", 
            "            return(1)", 
            "        else:", 
            "            return(0)", 
            "", 
            "# Error -1: reporter (you) doesn't (don't) exist, or voting period over or hasn't starred yet", 
            "# Error -2: not in hash submitting timeframe", 
            "# Python code to get the hash:", 
            "    #from bitcoin import encode", 
            "    #from hashlib import sha256", 
            "    #def sha256list(xs):", 
            "    #    data = ''.join(encode(x, 256, 32) for x in xs)", 
            "    #    hashed = int(sha256(data).hexdigest(), 16)", 
            "    #    if hashed > 2**255:", 
            "    #        return hashed - 2**256", 
            "    #    else:", 
            "    #        return hashed", 
            "def submitReportHash(branch, reportHash, votePeriod):", 
            "    # make sure the branch exists", 
            "    repIndex = REPORTING.repIDToIndex(branch, tx.origin)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.number % periodLength", 
            "    currentExpPeriod = (block.number / periodLength)", 
            "    if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):", 
            "        return(-1)", 
            "    if(residual < periodLength/2):", 
            "        # submit hash of (tx.origin, salt, Votes[])", 
            "        if(EXPEVENTS.setReportHash(branch, votePeriod, tx.origin, reportHash)):", 
            "            return(1)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(-2)", 
            "", 
            "# for ui client side", 
            "# @return 1 if success", 
            "# Error messages otherwise", 
            "    # -1: report isn't long enough", 
            "    # -2: reporter (you) doesn't (don't) exist, or voting period over or hasn't starred yet", 
            "def checkReportValidity(branch, report:arr, votePeriod):", 
            "       if(len(report)!=EXPEVENTS.getNumberEvents(branch, votePeriod)):", 
            "        return(-1)", 
            "", 
            "        # if currentExpPeriod is more than 2 periods past the current vote period", 
            "        # then there can be no more voting for that voting period", 
            "        # (reasoning being: >=1 period past means all the events in that period have expired)", 
            "        # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)", 
            "        # currently requires events to expire to vote", 
            "        currentExpPeriod = (block.number / BRANCHES.getPeriodLength(branch))", 
            "        if (REPORTING.getReporterID(branch, repIndex) != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):", 
            "            return(-2)", 
            "        else:", 
            "            return(1)", 
            "", 
            "# anti cheat provide ballot and randomNum mechanism steal deposit", 
            "def slashRep(branch, votePeriod, salt, report:arr, reporter):", 
            "        realHash = EXPEVENTS.getReportHash(branch, votePeriod, reporter)", 
            "        hashInfo = array(len(report) + 2)", 
            "        hashInfo[0] = reporter", 
            "        hashInfo[1] = salt", 
            "        i = 2", 
            "        while i < (len(report) + 2):", 
            "            hashInfo[i] = report[i]", 
            "            i += 1", 
            "        reportHash = sha256(hashInfo, chars=32*len(hashInfo))", 
            "        if(reportHash!=realHash):", 
            "            return(0)", 
            "        else:", 
            "            reporterIndex = REPORTING.repIDToIndex(branch, reporter)", 
            "            trutherIndex = REPORTING.repIDToIndex(branch, tx.origin)", 
            "            # if the truther's rep. account doesn't exist, make one", 
            "            if(REPORTING.getReporterID(branch, trutherIndex)!=tx.origin):", 
            "                trutherIndex = REPORTING.getNumberReporters(branch)", 
            "                REPORTING.addReporter(branch, tx.origin)", 
            "", 
            "            if(REPORTING.getReporterID(branch, reporterIndex)!=reporter):", 
            "                return(-2)", 
            "", 
            "            reporterBalance = REPORTING.getRepBalance(branch, reporter)", 
            "", 
            "            REPORTING.subtractRep(branch, reporterIndex, reporterBalance)", 
            "            REPORTING.addRep(branch, trutherIndex, reporterBalance*2^58 / 2^64)", 
            "        return(reporterBalance)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "checkReportValidity(int256,int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }
                ], 
                "name": "report(int256,int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "slashRep(int256,int256,int256,int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportHash", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "submitReportHash(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern makeReports: [checkReportValidity:[int256,int256[],int256]:int256, report:[int256,int256[],int256,int256]:int256, slashRep:[int256,int256,int256,int256[],int256]:int256, submitReportHash:[int256,int256,int256]:int256]"
    }, 
    "markets": {
        "address": "0x44a270caf86e229f188b340994fa8671ae94450a", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern fxpFunctions: [fx_exp:[int256]:int256, fx_log:[int256]:int256]", 
            "FXP = 0x1fa4745bcd612d19c698aad79c9ceee079cf65b6", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x3c5062d58be6ce59534e8a2d10f1d533c1a0206e", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "", 
            "# Markets' index is the marketID", 
            "# Events is a 0 indexed array of events in the market in the format of", 
            "    # [1, event, event, 2, event, 3, event, event, event]", 
            "    # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events", 
            "# Sharespurchased keeps track of the number of shares purchased for each outcome", 
            "    # sharesPurchased states starts at 1 - (same for participants[].shares[] array)", 
            "# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event", 
            "# a binary outcome state 1 is no, 2 is true, 0 if not determined", 
            "# tradingFee is a percent in fixedPoint", 
            "# tradingPeriod is which eventexpperiod market expires in", 
            "data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], alpha, cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch)", 
            "", 
            "macro TRADER_FIELDS: 3", 
            "macro EVENTS_FIELDS: 6", 
            "macro OUTCOMES_FIELDS: 2", 
            "macro WINNING_OUTCOMES_FIELDS: 8", 
            "macro FIELDS: 12", 
            "", 
            "def getMarketInfo(marketID):", 
            "    index = FIELDS", 
            "    participantNumber = self.Markets[marketID].addr2participant[tx.origin]", 
            "    descriptionLength = INFO.getDescriptionLength(marketID)", 
            "    with info = array(FIELDS + self.Markets[marketID].currentParticipant*TRADER_FIELDS + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1):", 
            "        info[0] = marketID", 
            "        info[1] = self.Markets[marketID].currentParticipant", 
            "        info[2] = self.Markets[marketID].alpha", 
            "        info[3] = participantNumber", 
            "        info[4] = self.Markets[marketID].numOutcomes", 
            "        info[5] = self.Markets[marketID].tradingPeriod", 
            "        info[6] = self.Markets[marketID].tradingFee", 
            "        info[7] = self.Markets[marketID].branch", 
            "        info[8] = self.Markets[marketID].lenEvents", 
            "        info[9] = self.Markets[marketID].cumulativeScale", 
            "        info[10] = INFO.getCreationFee(marketID)", 
            "        info[11] = INFO.getCreator(marketID)", 
            "", 
            "        # gather trader(s) info: [trader ID, yes shares, no shares]", 
            "        t = 0", 
            "        while t < self.Markets[marketID].currentParticipant:", 
            "            info[index + t*TRADER_FIELDS] = self.Markets[marketID].participants[t].participantID", 
            "            info[index + t*TRADER_FIELDS + 1] = self.Markets[marketID].participants[t].shares[1]", 
            "            info[index + t*TRADER_FIELDS + 2] = self.Markets[marketID].participants[t].shares[2]", 
            "            t += 1", 
            "        index += self.Markets[marketID].currentParticipant*TRADER_FIELDS", 
            "", 
            "        # gather event(s) info:", 
            "        # [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]", 
            "        i = 0", 
            "        while i < self.Markets[marketID].lenEvents:", 
            "            event = self.Markets[marketID].events[i]", 
            "            with eventInfo = EVENTS.getEventInfo(event, outitems=EVENTS_FIELDS):", 
            "                info[index + i*EVENTS_FIELDS] = event", 
            "                j = 1", 
            "                while j < EVENTS_FIELDS:", 
            "                    info[index + i*EVENTS_FIELDS + j] = eventInfo[j]", 
            "                    j += 1", 
            "            i += 1", 
            "        index += self.Markets[marketID].lenEvents*EVENTS_FIELDS", 
            "", 
            "        # gather outcomes info:", 
            "        # [sharesPurchased, price, winningOutcomes...]", 
            "        k = 0", 
            "        while k < self.Markets[marketID].numOutcomes:", 
            "            info[index + k*OUTCOMES_FIELDS] = self.Markets[marketID].sharesPurchased[k + 1]", 
            "            info[index + k*OUTCOMES_FIELDS + 1] = self.price(marketID, k + 1)", 
            "            k += 1", 
            "        index += self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS", 
            "        k = 0", 
            "        while k < WINNING_OUTCOMES_FIELDS:", 
            "            info[index + k] = self.Markets[marketID].winningOutcomes[k]", 
            "            k += 1", 
            "        index += WINNING_OUTCOMES_FIELDS", 
            "", 
            "        # append description character codes", 
            "        info[index] = descriptionLength", 
            "        index += 1", 
            "        with description = INFO.getDescription(marketID, outchars=descriptionLength):", 
            "            c = 0", 
            "            while c < descriptionLength:", 
            "                info[index + c] = getch(description, c)", 
            "                c += 1", 
            "        return(info: arr)", 
            "", 
            "# Gets all information about all markets on the specified branch and", 
            "# returns it as a giant array.  getMarketsInfo requires a great deal of gas.", 
            "# Invoke using eth_call with gas=9999999999999 (or other very large number).", 
            "# @param {int} branch Branch ID that we're retrieving markets on.", 
            "# @param {int} offset Starting market index (0=full load).", 
            "# @param {int} numMarketsToLoad How many markets to load (0=all markets).", 
            "# @return array Array containing all data for all markets:", 
            "#            [N, length_1, length_2, ..., length_N, info_1, info_2, ..., info_N]", 
            "#           where length_j is the number of elements stored for market j,", 
            "#           info_j is the information array for market j, and N is the total", 
            "#           number of markets in this branch.", 
            "def getMarketsInfo(branch, offset, numMarketsToLoad):", 
            "    numMarkets = BRANCHES.getNumMarkets(branch)", 
            "    with marketIDs = BRANCHES.getMarkets(branch, outitems=numMarkets):", 
            "        if numMarketsToLoad > 0 and numMarketsToLoad < numMarkets:", 
            "            numMarkets = numMarketsToLoad", 
            "        with marketsMatrix = array(numMarkets):", 
            "            with marketArrayLength = array(numMarkets):", 
            "                m = 0", 
            "                while m < numMarkets:", 
            "                    marketID = marketIDs[m + offset]", 
            "                    participantNumber = self.Markets[marketID].addr2participant[tx.origin]", 
            "                    descriptionLength = INFO.getDescriptionLength(marketID)", 
            "                    marketArrayLength[m] = FIELDS + self.Markets[marketID].currentParticipant*TRADER_FIELDS + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1", 
            "                    marketsMatrix[m] = self.getMarketInfo(marketID, outitems=marketArrayLength[m])", 
            "                    m += 1", 
            "", 
            "                # flatten the markets info matrix so it can be returned", 
            "                # (data offset by 1+numMarkets so length data can be prepended)", 
            "                totalFlatLength = 1 + numMarkets", 
            "                m = 0", 
            "                while m < numMarkets:", 
            "                    totalFlatLength += marketArrayLength[m]", 
            "                    m += 1", 
            "                with flattened = array(totalFlatLength):", 
            "                    flattened[0] = numMarkets", 
            "                    m = 0", 
            "                    while m < numMarkets:", 
            "                        flattened[m + 1] = marketArrayLength[m]", 
            "                        m += 1", 
            "                    currentFlatLength = 1 + numMarkets", 
            "                    row = 0", 
            "                    while row < numMarkets:", 
            "                        col = 0", 
            "                        while col < marketArrayLength[row]:", 
            "                            flattened[currentFlatLength + col] = marketsMatrix[row][col]", 
            "                            col += 1", 
            "                        currentFlatLength += col", 
            "                        row += 1", 
            "                    return(flattened: arr)", 
            "", 
            "# @return cost - how much it costs you to buy", 
            "#         price - current share price of that outcome after buy", 
            "def getSimulatedBuy(market, outcome, amount):", 
            "    # lmsr cost calcs", 
            "    oldCost = lsLmsr(market)", 
            "    sharesPurchased(market)[outcome] += amount", 
            "    newCost = lsLmsr(market)", 
            "    if newCost <= oldCost:", 
            "        sharesPurchased(market)[outcome] -= amount", 
            "        return(-2)", 
            "    cost = (newCost - oldCost)", 
            "    price = self.price(market, outcome)", 
            "    sharesPurchased(market)[outcome] -= amount", 
            "    return([cost, price], chars=64)", 
            "", 
            "# @return cost - how much you get paid to sell", 
            "#         price - current share price of that outcome after sell", 
            "def getSimulatedSell(market, outcome, amount):", 
            "    # lmsr cost calcs", 
            "    oldCost = lsLmsr(market)", 
            "    sharesPurchased(market)[outcome] -= amount", 
            "    newCost = lsLmsr(market)", 
            "    if oldCost <= newCost:", 
            "        sharesPurchased(market)[outcome] += amount", 
            "        return(-2)", 
            "    # these prices are in fixed point", 
            "    cost = oldCost - newCost", 
            "    price = self.price(market, outcome)", 
            "    sharesPurchased(market)[outcome] += amount", 
            "    return([cost, price], chars=64)", 
            "", 
            "def getMarketEvents(market):", 
            "    i = 0", 
            "    lenEvents = self.Markets[market].lenEvents", 
            "    events = array(lenEvents)", 
            "    while i < lenEvents:", 
            "        events[i] = self.Markets[market].events[i]", 
            "        i += 1", 
            "    return(events: arr)", 
            "", 
            "def getSharesPurchased(market, outcome):", 
            "    return(self.Markets[market].sharesPurchased[outcome])", 
            "", 
            "def getParticipantNumber(market, address):", 
            "    participantNumber = self.Markets[market].addr2participant[address]", 
            "    if(self.Markets[market].participants[participantNumber].participantID != tx.origin):", 
            "        return(-1)", 
            "    else:", 
            "        return(participantNumber)", 
            "", 
            "def getParticipantID(market, participantNumber):", 
            "    return(self.Markets[market].participants[participantNumber].participantID)", 
            "", 
            "def getParticipantSharesPurchased(market, participantNumber, outcome):", 
            "    return(self.Markets[market].participants[participantNumber].shares[outcome])", 
            "", 
            "def getNumEvents(market):", 
            "    return(self.Markets[market].lenEvents)", 
            "", 
            "def getCurrentParticipantNumber(market):", 
            "    return(self.Markets[market].currentParticipant)", 
            "", 
            "def getAlpha(market):", 
            "    return(self.Markets[market].alpha)", 
            "", 
            "def getCumScale(market):", 
            "    return(self.Markets[market].cumulativeScale)", 
            "", 
            "def getMarketNumOutcomes(market):", 
            "    return(self.Markets[market].numOutcomes)", 
            "", 
            "def getTradingPeriod(market):", 
            "    return(self.Markets[market].tradingPeriod)", 
            "", 
            "def getTradingFee(market):", 
            "    return(self.Markets[market].tradingFee)", 
            "", 
            "def getBranchID(market):", 
            "    return(self.Markets[market].branch)", 
            "", 
            "# alpha is equal to v/(n*log(n)) where v is the max percent commission", 
            "# && n is the number of outcomes people can trade. Alpha is set when", 
            "# a market is created.", 
            "macro lsLmsr($marketID):", 
            "    with $bq = Bq($marketID):", 
            "        with $i = 1:", 
            "            with $sumExp = 0:", 
            "                while $i <= numOutcomes($marketID):", 
            "                    $sumExp += FXP.fx_exp(sharesPurchased($marketID)[$i] * 2**64 / $bq)", 
            "                    $i += 1", 
            "                $bq*FXP.fx_log($sumExp)/2**64", 
            "", 
            "macro sumList($q, $a, $b):", 
            "    $i = $a + 1", 
            "    $result = $q[$a]", 
            "    while $i <= $b:", 
            "        $result += $q[$i]", 
            "        $i += 1", 
            "    $result", 
            "", 
            "macro market($marketID):", 
            "    self.Markets[$marketID]", 
            "", 
            "macro alpha($marketID):", 
            "    market($marketID).alpha", 
            "", 
            "macro cumScale($marketID):", 
            "    market($marketID).cumulativeScale", 
            "", 
            "macro numOutcomes($marketID):", 
            "    market($marketID).numOutcomes", 
            "", 
            "macro sharesPurchased($marketID):", 
            "    market($marketID).sharesPurchased", 
            "", 
            "macro particpant($marketID, $addr):", 
            "    market($marketID).participants[$addr]", 
            "", 
            "macro Bq($marketID):", 
            "   alpha($marketID) * cumScale($marketID) * sumList(sharesPurchased($marketID), 1, numOutcomes($marketID)) / 2**64", 
            "", 
            "def lsLmsr(marketID):", 
            "    return(lsLmsr(marketID))", 
            "", 
            "def price(market, outcome):", 
            "    a = lsLmsr(market)", 
            "    sharesPurchased(market)[outcome] += 2**60", 
            "    b = lsLmsr(market)", 
            "    sharesPurchased(market)[outcome] -= 2**60", 
            "    return(((b - a) * 2**64)/2**60)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def initializeMarket(marketID, events: arr, tradingPeriod, tradingFee, branch):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # add event list to the market", 
            "    save(self.Markets[marketID].events[0], events, chars=32*len(events))", 
            "    self.Markets[marketID].lenEvents = len(events)", 
            "    self.Markets[marketID].tradingPeriod = tradingPeriod", 
            "    self.Markets[marketID].tradingFee = tradingFee", 
            "    self.Markets[marketID].branch = branch", 
            "    return(1)", 
            "", 
            "def addParticipant(market, address):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    participantNumber = self.Markets[market].currentParticipant", 
            "    self.Markets[market].participants[participantNumber].participantID = address", 
            "    self.Markets[market].addr2participant[address] = participantNumber", 
            "    self.Markets[market].currentParticipant += 1", 
            "    return(participantNumber)", 
            "", 
            "def modifyShares(marketID, outcome, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    sharesPurchased(marketID)[outcome] += amount", 
            "    return(1)", 
            "", 
            "def modifyParticipantShares(marketID, participantNumber, outcome, amount):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Markets[marketID].participants[participantNumber].shares[outcome] += amount", 
            "    return(1)", 
            "", 
            "def setWinningOutcomes(market, outcomes: arr):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # largest # of winning outcomes is 8", 
            "    i = 0", 
            "    while outcomes[i] != 0:", 
            "        self.Markets[market].winningOutcomes[i] = outcomes[i]", 
            "        i += 1", 
            "    return(1)", 
            "", 
            "def getWinningOutcomes(market):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # largest # of winning outcomes is 8", 
            "    return(load(self.Markets[market].winningOutcomes[0], chars=32*8): arr)", 
            "", 
            "def initialLiquiditySetup(marketID, alpha, cumScale, numOutcomes):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Markets[marketID].alpha = alpha", 
            "    self.Markets[marketID].cumulativeScale = cumScale", 
            "    self.Markets[marketID].numOutcomes = numOutcomes", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "addParticipant(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getAlpha(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranchID(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCumScale(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCurrentParticipantNumber(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketEvents(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketInfo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketNumOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "offset", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numMarketsToLoad", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketsInfo(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEvents(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantID(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantNumber(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantSharesPurchased(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getSharesPurchased(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "getSimulatedBuy(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "unknown_out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "getSimulatedSell(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "unknown_out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTradingFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTradingPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getWinningOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "alpha", 
                        "type": "int256"
                    }, 
                    {
                        "name": "cumScale", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }
                ], 
                "name": "initialLiquiditySetup(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "tradingPeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeMarket(int256,int256[],int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }
                ], 
                "name": "lsLmsr(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "modifyParticipantShares(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "modifyShares(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "price(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcomes", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setWinningOutcomes(int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getSharesPurchased:[int256,int256]:int256, getSimulatedBuy:[int256,int256,int256]:_, getSimulatedSell:[int256,int256,int256]:_, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]"
    }, 
    "p2pWagers": {
        "address": "0x5637e628e8557528fcaa732380d471fecde52168", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "#p2p hasn't been tested", 
            "", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "", 
            "data p2pBets[](eventID, amtToBet, outcomeOneBettor, outcomeZeroBettor)", 
            "", 
            "def getEvent(ID):", 
            "\treturn(self.p2pBets[ID].eventID)", 
            "", 
            "def getAmtBet(ID):", 
            "\treturn(self.p2pBets[ID].amtToBet)", 
            "", 
            "def getOutcomeOneBettor(ID):", 
            "\treturn(self.p2pBets[ID].outcomeOneBettor)", 
            "", 
            "def getOutcomeZeroBettor(ID):", 
            "\treturn(self.p2pBets[ID].outcomeZeroBettor)", 
            "", 
            "### P2P parimutuel betting", 
            "# @return betID", 
            "def makeBet(eventID, amtToBet):", 
            "    betData = array(3)", 
            "    betData[0] = eventID", 
            "    betData[1] = block.number", 
            "    betData[2] = tx.origin", 
            "    betID = sha256(branchinfo, chars=3*32)", 
            "    self.p2pBets[betID].eventID = betData[0]", 
            "    self.p2pBets[betID].amtToBet = amtToBet", 
            "    return(betID)", 
            "", 
            "# should add a fee to market", 
            "# outcome is 0 or 1", 
            "# @return 0 if fail, 1 if success", 
            "def sendMoneytoBet(betID, outcome):", 
            "    if(CASH.balance(betID+outcome)==0):", 
            "        CASH.send(betID+outcome, self.p2pBets[betID].amtToBet)", 
            "    else:", 
            "        return(0)", 
            "    if(outcome):", 
            "        self.p2pBets[betID].outcomeOneBettor = tx.origin", 
            "    else:", 
            "        self.p2pBets[betID].outcomeZeroBettor = tx.origin", 
            "    return(1)", 
            "", 
            "# add support for a .5 outcome", 
            "# @return 0 if fail, 1 if success", 
            "def closeBet(betID):", 
            "    # outcome not determined yet", 
            "    if(EVENTS.getOutcome(self.p2pBets[betID].eventID) == 0):", 
            "        return(0)", 
            "    # pay out depending on outcome", 
            "    if(CASH.balance(betID+0)==self.p2pBets[betID].amtToBet && CASH.balance(betID+1)==self.p2pBets[betID].amtToBet):", 
            "        CASH.subtractCash(betID+0, CASH.balance(betID+0))", 
            "        CASH.subtractCash(betID+1, CASH.balance(betID+1))", 
            "        if(EVENTS.getOutcome(self.p2pBets[betID].eventID)):", 
            "            CASH.addCash(self.p2pBets[betID].outcomeOneBettor, self.p2pBets[betID].amtToBet*2)", 
            "        elif(EVENTS.getOutcome(self.p2pBets[betID].eventID) == 1):", 
            "            CASH.addCash(self.p2pBets[betID].outcomeZeroBettor, self.p2pBets[betID].amtToBet*2)", 
            "    # someone didn't pay their side of the bet, refund funds", 
            "    else:", 
            "        CASH.addCash(self.p2pBets[betID].outcomeZeroBettor, CASH.balance(betID+0))", 
            "        CASH.addCash(self.p2pBets[betID].outcomeOneBettor, CASH.balance(betID+1))", 
            "        CASH.subtractCash(betID+0, CASH.balance(betID+0))", 
            "        CASH.subtractCash(betID+1, CASH.balance(betID+1))", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "betID", 
                        "type": "int256"
                    }
                ], 
                "name": "closeBet(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getAmtBet(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getEvent(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getOutcomeOneBettor(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getOutcomeZeroBettor(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amtToBet", 
                        "type": "int256"
                    }
                ], 
                "name": "makeBet(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "betID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "sendMoneytoBet(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern p2pWagers: [closeBet:[int256]:int256, getAmtBet:[int256]:int256, getEvent:[int256]:int256, getOutcomeOneBettor:[int256]:int256, getOutcomeZeroBettor:[int256]:int256, makeBet:[int256,int256]:int256, sendMoneytoBet:[int256,int256]:int256]"
    }, 
    "payout": {
        "address": "0x9a051313590855995a93b41ef3fd5c29ec52a120", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Jack Peterson (jack@augur.net).", 
            "", 
            "def payout(outcomes_final:arr, smooth_rep:arr, reports_mask:arr, num_reports, num_events):", 
            "", 
            "    # Event participation (within columns):", 
            "    # proportion of reputation that answered each event", 
            "    with participation_events = array(num_events):", 
            "        with i = 0:", 
            "            while i < num_events:", 
            "                with k = 0:", 
            "                    while k < num_reports:", 
            "                        participation_events[i] += smooth_rep[k] * reports_mask[k*num_events + i]", 
            "                        k += 1", 
            "                participation_events[i] = ONE - participation_events[i]", 
            "                i += 1", 
            "", 
            "        # Voter participation (within rows): all events treated equally", 
            "        with participation_reports = array(num_reports):", 
            "            with i = 0:", 
            "                while i < num_reports:", 
            "                    with total = 0:", 
            "                        with j = 0:", 
            "                            while j < num_events:", 
            "                                total += reports_mask[i*num_events + j]", 
            "                                j += 1", 
            "                            participation_reports[i] = ONE - fix(total) / num_events", 
            "                        i += 1", 
            "", 
            "                # General participation", 
            "                with total = 0:", 
            "                    with i = 0:", 
            "                        while i < num_events:", 
            "                            total += participation_events[i]", 
            "                            i += 1", 
            "                    with participation = ONE - total / num_events:", 
            "                        with reporter_bonus = array(num_reports):", 
            "                            with na_bonus_reports = normalize(participation_reports):", 
            "                                with i = 0:", 
            "                                    while i < num_reports:", 
            "                                        reporter_bonus[i] = fixed_multiply(na_bonus_reports[i], participation) + fixed_multiply(smooth_rep[i], ONE - participation)", 
            "                                        i += 1", 
            "                                return(reporter_bonus: arr)", 
            "", 
            "# inset('macros/constants.se')", 
            "# inset('macros/fixed.se')", 
            "# inset('macros/arrays.se')", 
            "inset('../../macros/constants.sm')", 
            "inset('../../macros/fixed.sm')", 
            "inset('../../macros/arrays.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "outcomes_final", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "smooth_rep", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "reports_mask", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "payout(int256[],int256[],int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern payout: [payout:[int256[],int256[],int256[],int256,int256]:int256[]]"
    }, 
    "redeem_adjust": {
        "address": "0xb5c5b32e285ba059cd5c79560885ac6448ecfc36", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Joey Krug (joey@augur.net) or", 
            "# Jack Peterson (jack@augur.net).", 
            "", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPIRING = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern adjust: [reputation_delta:[int256[],int256,int256]:int256[], select_scores:[int256[],int256[],int256[],int256[],int256[],int256[],int256,int256]:int256[], weighted_delta:[int256[],int256[],int256[],int256[],int256,int256]:int256[]]", 
            "ADJUST = 0x360f45231a8f6f192dece487e30b51e8f9fca081", 
            "", 
            "def reputation_delta(branch, period, num_events, num_reports, flatsize):", 
            "    with scores = array(num_reports):", 
            "        scores = slice(EXPIRING.getScores(branch, period, outitems=num_reports), items=0, items=num_reports)", 
            "        with nr_x_2 = num_reports * 2:", 
            "            with sets = array(nr_x_2):", 
            "                sets = slice(ADJUST.reputation_delta(scores, num_reports, num_events, outitems=nr_x_2), items=0, items=nr_x_2)", 
            "                EXPIRING.setSetOne(branch, period, slice(sets, items=0, items=num_reports))", 
            "                EXPIRING.setSetTwo(branch, period, slice(sets, items=num_reports, items=nr_x_2))", 
            "                return(1)", 
            "", 
            "def weighted_delta(branch, period, num_events, num_reports, flatsize):", 
            "    with reports_filled = array(flatsize):", 
            "        reports_filled = slice(EXPIRING.getReportsFilled(branch, period, outitems=flatsize), items=0, items=flatsize)", 
            "        with reputation = array(num_reports):", 
            "            with i = 0:", 
            "                while i < num_reports:", 
            "                    reputation[i] = REPORTING.getRepByIndex(branch, i)", 
            "                    i += 1", 
            "                with set1 = array(num_reports):", 
            "                    set1 = slice(EXPIRING.getSetOne(branch, period, outitems=num_reports), items=0, items=num_reports)", 
            "                    with set2 = array(num_reports):", 
            "                        set2 = slice(EXPIRING.getSetTwo(branch, period, outitems=num_reports), items=0, items=num_reports)", 
            "                        with ne_x_3 = num_events * 3:", 
            "                            with ne_x_2 = num_events * 2:", 
            "                                with wsets = array(ne_x_3):", 
            "                                    wsets = slice(ADJUST.weighted_delta(set1, set2, reputation, reports_filled, num_reports, num_events, outitems=ne_x_3), items=0, items=ne_x_3)", 
            "                                    EXPIRING.setOld(branch, period, slice(wsets, items=0, items=num_events))", 
            "                                    EXPIRING.setNewOne(branch, period, slice(wsets, items=num_events, items=ne_x_2))", 
            "                                    EXPIRING.setNewTwo(branch, period, slice(wsets, items=ne_x_2, items=ne_x_3))", 
            "                                    return(1)", 
            "", 
            "def select_scores(branch, period, num_events, num_reports, flatsize):", 
            "    with old = array(num_events):", 
            "        old = slice(EXPIRING.returnOld(branch, period, outitems=num_events), items=0, items=num_events)", 
            "        with new1 = array(num_events):", 
            "            new1 = slice(EXPIRING.getNewOne(branch, period, outitems=num_events), items=0, items=num_events)", 
            "            with new2 = array(num_events):", 
            "                new2 = slice(EXPIRING.getNewTwo(branch, period, outitems=num_events), items=0, items=num_events)", 
            "                with set1 = array(num_reports):", 
            "                    set1 = slice(EXPIRING.getSetOne(branch, period, outitems=num_reports), items=0, items=num_reports)", 
            "                    with set2 = array(num_reports):", 
            "                        set2 = slice(EXPIRING.getSetTwo(branch, period, outitems=num_reports), items=0, items=num_reports)", 
            "                        with scores = array(num_reports):", 
            "                            scores = slice(EXPIRING.getScores(branch, period, outitems=num_reports), items=0, items=num_reports)", 
            "                            with adjusted_scores = array(num_reports):", 
            "                                adjusted_scores = slice(ADJUST.select_scores(old, new1, new2, set1, set2, scores, num_reports, num_events, outitems=num_reports), items=0, items=num_reports)", 
            "                                EXPIRING.setAdjPrinComp(branch, period, adjusted_scores)", 
            "                                return(1)", 
            "", 
            "inset('../../macros/constants.sm')", 
            "inset('../../macros/fixed.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "reputation_delta(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "select_scores(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "weighted_delta(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern redeem_adjust: [reputation_delta:[int256,int256,int256,int256,int256]:int256, select_scores:[int256,int256,int256,int256,int256]:int256, weighted_delta:[int256,int256,int256,int256,int256]:int256]"
    }, 
    "redeem_center": {
        "address": "0x608fa0fbee213d5ca2032fc30b50c16bc852b7da", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Joey Krug (joey@augur.net) or", 
            "# Jack Peterson (jack@augur.net).", 
            "", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPIRING = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "extern center: [center:[int256[],int256[],int256[],int256[],int256[],int256,int256]:int256[], covariance:[int256[],int256[],int256,int256]:int256[], tokenize:[int256[],int256]:int256[]]", 
            "CENTER = 0x8a0cf0b390a9acbaed8abe1df64e4a1eb7fde454", 
            "", 
            "def center(branch, period, num_events, num_reports, flatsize):", 
            "    with reputation = array(num_reports):", 
            "        with i = 0:", 
            "            while i < num_reports:", 
            "                reputation[i] = REPORTING.getRepByIndex(branch, i)", 
            "                i += 1", 
            "        with scaled = array(num_events):", 
            "            with scaled_max = array(num_events):", 
            "                with scaled_min = array(num_events):", 
            "                    with j = 0:", 
            "                        while j < num_events:", 
            "                            with event = EXPIRING.getEvent(branch, period, j):", 
            "                                if fix(EVENTS.getMaxValue(event)) != YES and EVENTS.getNumOutcomes(event) == 2:", 
            "                                    scaled[j] = 1", 
            "                                    scaled_min[j] = fix(EVENTS.getMinValue(event))", 
            "                                    scaled_max[j] = fix(EVENTS.getMaxValue(event))", 
            "                                else:", 
            "                                    scaled[j] = 0", 
            "                                    scaled_min[j] = NO", 
            "                                    scaled_max[j] = YES", 
            "                            j += 1", 
            "                    with reports_filled = array(flatsize):", 
            "                        reports_filled = slice(EXPIRING.getReportsFilled(branch, period, outitems=flatsize), items=0, items=flatsize)", 
            "                        with lflatsize = flatsize + num_events + 2:", 
            "                            with result = array(lflatsize):", 
            "                                result = slice(CENTER.center(reports_filled, reputation, scaled, scaled_max, scaled_min, MAX_ITERATIONS, MAX_COMPONENTS, outitems=lflatsize), items=0, items=lflatsize)", 
            "                                with wcd = array(flatsize):", 
            "                                    wcd = slice(result, items=0, items=flatsize)", 
            "                                    EXPIRING.setWeightedCenteredData(branch, period, wcd)", 
            "                                    with loading_vector = array(num_events + 2):", 
            "                                        loading_vector = slice(result, items=flatsize, items=lflatsize)", 
            "                                        EXPIRING.setLoadingVector(branch, period, loading_vector)", 
            "                                        return(1)", 
            "", 
            "def covariance(branch, period, num_events, num_reports, flatsize):", 
            "    with reputation = array(num_reports):", 
            "        with i = 0:", 
            "            while i < num_reports:", 
            "                reputation[i] = REPORTING.getRepByIndex(branch, i)", 
            "                i += 1", 
            "        with reptokens = array(num_reports):", 
            "            reptokens = slice(CENTER.tokenize(reputation, num_reports, outitems=num_reports), items=0, items=num_reports)", 
            "            with wcd = array(flatsize):", 
            "                wcd = slice(EXPIRING.getWeightedCenteredData(branch, period, outitems=flatsize), items=0, items=flatsize)", 
            "                EXPIRING.setDeflated(branch, period, wcd)", 
            "                with covrow = array(num_events):", 
            "                    covrow = slice(CENTER.covariance(wcd, reptokens, num_reports, num_events, outitems=num_events), items=0, items=num_events)", 
            "                    EXPIRING.setCovarianceMatrixRow(branch, period, covrow)", 
            "                    return(1)", 
            "", 
            "inset('../../macros/constants.sm')", 
            "inset('../../macros/fixed.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "center(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "covariance(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern redeem_center: [center:[int256,int256,int256,int256,int256]:int256, covariance:[int256,int256,int256,int256,int256]:int256]"
    }, 
    "redeem_interpolate": {
        "address": "0x9194647074999cc5792164fdebd1f653aa99397c", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Joey Krug (joey@augur.net) or", 
            "# Jack Peterson (jack@augur.net).", 
            "", 
            "# import events as EVENTS", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPIRING = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "# import interpolate as INTERPOLATE", 
            "", 
            "data Interpolate[][](reputation[], reports[])", 
            "", 
            "# - loop through reputation && check if in reporters, if so use their", 
            "#   report, if not use the fillin / not reported report (all zeroes)", 
            "# - use this to make a giant array of reports to pass to self.consensus", 
            "# - want to pass reports for each 0 indexed event in order (so we get", 
            "#   reports from an actual reporter)", 
            "# (if they didn't vote we set their array for each event to 0,0,0,0,0,0, etc...)", 
            "def read_ballots(branch, period, num_events, num_reports, flatsize):", 
            "    with reputation = array(num_reports):", 
            "        with reports = array(flatsize):", 
            "            with i = 0:", 
            "                while i < num_reports:", 
            "                    with reporterID = REPORTING.getReporterID(branch, i):", 
            "                        reputation[i] = REPORTING.getRepBalance(branch, reporterID)", 
            "                        # - checks to see if each reporter actually voted on events", 
            "                        # - if they didn't vote (simply check if they voted on first event)", 
            "                        #     do nothing (these values will be 0 by default due to Serpent array styles)", 
            "                        #     else if the reporter did report on events put their ballot into the reports array", 
            "                        # reports[i*num_events] = slice(EXPIRING.getReporterBallot(branch, period, reporterID, outitems=num_events), items=0, items=1)", 
            "                        reports[i*num_events] = EXPIRING.getReport(branch, period, reporterID, 0)", 
            "                        if reports[i*num_events] != 0:", 
            "                            with ballot = array(num_events - 1):", 
            "                                ballot = slice(EXPIRING.getReporterBallot(branch, period, reporterID, outitems=num_events), items=1, items=num_events)", 
            "                                with j = 1:", 
            "                                    while j < num_events:", 
            "                                        reports[i*num_events + j] = ballot[j - 1]", 
            "                                        j += 1", 
            "                    i += 1", 
            "                reputation = normalize(reputation)", 
            "                save(self.Interpolate[branch][period].reports[0], reports, chars=32*flatsize)", 
            "                save(self.Interpolate[branch][period].reputation[0], reputation, chars=32*num_reports)", 
            "                return(1)", 
            "", 
            "def interpolate(branch, period, num_events, num_reports, flatsize):", 
            "    with reputation = array(num_reports):", 
            "        reputation = slice(load(self.Interpolate[branch][period].reputation[0], chars=32*num_reports), items=0, items=num_reports)", 
            "        with reports = array(flatsize):", 
            "            reports = slice(load(self.Interpolate[branch][period].reports[0], chars=32*flatsize), items=0, items=num_reports)", 
            "            with reports_mask = array(flatsize):", 
            "                with reports_filled = array(flatsize):", 
            "                    with missing_values = 0:", 
            "                        with i = 0:", 
            "                            while i < flatsize:", 
            "                                if reports[i] == 0:", 
            "                                    reports_filled[i] = 0", 
            "                                    reports_mask[i] = 1", 
            "                                    missing_values = 1", 
            "                                else:", 
            "                                    reports_filled[i] = reports[i]", 
            "                                i += 1", 
            "", 
            "                        # every event must be calculated, if any missing values", 
            "                        # b/c can only be missing ALL values", 
            "                        if missing_values:", 
            "                            active_rep = 0", 
            "                            j = 0", 
            "                            while j < num_reports:", 
            "                                if reports[j*num_events] != 0:", 
            "                                    active_rep += reputation[j]", 
            "                                j += 1", 
            "                            replacements = array(num_events)", 
            "                            i = 0", 
            "                            while i < num_events:", 
            "", 
            "                                # weighted average of other reports", 
            "                                j = 0", 
            "                                while j < num_reports:", 
            "                                    replacements[i] += reputation[j] * reports[i + j*num_events] / active_rep", 
            "                                    j += 1", 
            "                                replacements[i] = catch(replacements[i])", 
            "                                i += 1", 
            "                            j = 0", 
            "                            while j < num_reports:", 
            "                                idx = j * num_events", 
            "                                if reports[idx] == 0:", 
            "                                    i = 0", 
            "                                    while i < num_events:", 
            "                                        reports_filled[i + idx] = replacements[i]", 
            "                                        i += 1", 
            "                                j += 1", 
            "                    EXPIRING.setVSize(branch, period, flatsize)", 
            "                    EXPIRING.setReportsFilled(branch, period, reports_filled)", 
            "                    EXPIRING.setReportsMask(branch, period, reports_mask)", 
            "                    return(1)", 
            "", 
            "inset('../../macros/constants.sm')", 
            "inset('../../macros/fixed.sm')", 
            "inset('../../macros/arrays.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "interpolate(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "read_ballots(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern redeem_interpolate: [interpolate:[int256,int256,int256,int256,int256]:int256, read_ballots:[int256,int256,int256,int256,int256]:int256]"
    }, 
    "redeem_payout": {
        "address": "0xa4f49043cabb4c514eb8d7425932b982dd65c74c", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Joey Krug (joey@augur.net) or", 
            "# Jack Peterson (jack@augur.net).", 
            "", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPIRING = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x3c5062d58be6ce59534e8a2d10f1d533c1a0206e", 
            "extern payout: [payout:[int256[],int256[],int256[],int256,int256]:int256[]]", 
            "PAYOUT = 0x9a051313590855995a93b41ef3fd5c29ec52a120", 
            "", 
            "def payout(branch, period, num_events, num_reports, flatsize):", 
            "    with smooth_rep = array(num_reports):", 
            "        smooth_rep = slice(EXPIRING.getSmoothRep(branch, period, outitems=num_reports), items=0, items=num_reports)", 
            "        with reports_mask = array(flatsize):", 
            "            reports_mask = slice(EXPIRING.getReportsMask(branch, period, outitems=flatsize), items=0, items=flatsize)", 
            "            with outcomes = array(num_events):", 
            "                outcomes = slice(EXPIRING.getOutcomesFinal(branch, period, outitems=num_events), items=0, items=num_events)", 
            "                with reporter_payouts = array(num_reports):", 
            "                    reporter_payouts = slice(PAYOUT.payout(outcomes, smooth_rep, reports_mask, num_reports, num_events, outitems=num_reports), items=0, items=num_reports)", 
            "", 
            "                    # get event ID for each event by taking the x index in the reports arrays", 
            "                    # - shoving it in reporting.events[] and getting the corresponding ID", 
            "                    with j = 0:", 
            "                        while j < num_events:", 
            "                            with event = EXPIRING.getEvent(branch, period, j):", 
            "", 
            "                                # then take outcomes_final and set each event outcome", 
            "                                # (BAD and BOND macros defined in consensus/constants.se)", 
            "                                EVENTS.setOutcome(event, outcomes[j])", 
            "                                if outcomes[j] != BAD:", 
            "", 
            "                                    # return bond", 
            "                                    CASH.subtractCash(event, BOND)", 
            "                                    CASH.addCash(INFO.getCreator(event), BOND)", 
            "                                else:", 
            "", 
            "                                    # give event bond money to reporters", 
            "                                    CASH.subtractCash(event, BOND)", 
            "                                    CASH.addCash(branch, BOND)", 
            "                            j += 1", 
            "                    # - need to loop through rep holders and distribute 50% of branch fees to", 
            "                    #   reporters' cashcoin addresses", 
            "                    # - also need to take reporter_payouts and redistribute reputation in the", 
            "                    #   Reporting structure accordingly", 
            "                    EXPIRING.setReporterPayouts(branch, period, reporter_payouts)", 
            "                    with i = 0:", 
            "                        while i < num_reports:", 
            "                            REPORTING.setRep(branch, i, fixed_multiply(reporter_payouts[i], EXPIRING.getTotalReputation(branch, period)))", 
            "                            CASH.addCash(REPORTING.getReporterID(branch, i), fixed_multiply(CASH.balance(branch), reporter_payouts[i]))", 
            "                            i += 1", 
            "                        CASH.subtractCash(branch, CASH.balance(branch))", 
            "                        return(1)", 
            "", 
            "inset('../../macros/constants.sm')", 
            "inset('../../macros/fixed.sm')", 
            "inset('../../macros/arrays.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "payout(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern redeem_payout: [payout:[int256,int256,int256,int256,int256]:int256]"
    }, 
    "redeem_resolve": {
        "address": "0x7368ad231be18e0c6859e6ec776c3c8e2857b747", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Joey Krug (joey@augur.net) or", 
            "# Jack Peterson (jack@augur.net).", 
            "", 
            "extern events: [getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumOutcomes:[int256]:int256, getOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256]:int256, setOutcome:[int256,int256]:int256]", 
            "EVENTS = 0x435cb3ba15fbda3c466dc527f1b9cc78f5114d4f", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPIRING = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "extern resolve: [resolve:[int256[],int256[],int256[],int256[],int256[],int256,int256]:int256[], smooth:[int256[],int256[],int256,int256]:int256[]]", 
            "RESOLVE = 0xca39ef3752a20837ece0911c1f758ba8b621a33b", 
            "", 
            "def smooth(branch, period, num_events, num_reports, flatsize):", 
            "    with reputation = array(num_reports):", 
            "        with i = 0:", 
            "            while i < num_reports:", 
            "                reputation[i] = REPORTING.getRepByIndex(branch, i)", 
            "                i += 1", 
            "            with adjusted_scores = array(num_reports):", 
            "                adjusted_scores = slice(EXPIRING.getAdjPrinComp(branch, period, outitems=num_reports), items=0, items=num_reports)", 
            "                with smooth_rep = array(num_reports):", 
            "                    smooth_rep = slice(RESOLVE.smooth(adjusted_scores, reputation, num_reports, num_events, outitems=num_reports), items=0, items=num_reports)", 
            "                    EXPIRING.setSmoothRep(branch, period, smooth_rep)", 
            "                    return(1)", 
            "", 
            "def resolve(branch, period, num_events, num_reports, flatsize):", 
            "    with reports_filled = array(flatsize):", 
            "        reports_filled = slice(EXPIRING.getReportsFilled(branch, period, outitems=flatsize), items=0, items=flatsize)", 
            "        with smooth_rep = array(num_reports):", 
            "            smooth_rep = slice(EXPIRING.getSmoothRep(branch, period, outitems=num_reports), items=0, items=num_reports)", 
            "            with scaled = array(num_events):", 
            "                with scaled_max = array(num_events):", 
            "                    with scaled_min = array(num_events):", 
            "                        with j = 0:", 
            "                            while j < num_events:", 
            "                                with event = EXPIRING.getEvent(branch, period, j):", 
            "                                    if fix(EVENTS.getMaxValue(event)) != YES and EVENTS.getNumOutcomes(event) == 2:", 
            "                                        scaled[j] = 1", 
            "                                        scaled_min[j] = fix(EVENTS.getMinValue(event))", 
            "                                        scaled_max[j] = fix(EVENTS.getMaxValue(event))", 
            "                                    else:", 
            "                                        scaled[j] = 0", 
            "                                        scaled_min[j] = NO", 
            "                                        scaled_max[j] = YES", 
            "                                j += 1", 
            "                            with outcomes = array(num_events):", 
            "                                outcomes = slice(RESOLVE.resolve(smooth_rep, reports_filled, scaled, scaled_max, scaled_min, num_reports, num_events, outitems=num_events), items=0, items=num_events)", 
            "                                EXPIRING.setOutcomesFinal(branch, period, outcomes)", 
            "                                return(1)", 
            "", 
            "inset('../../macros/constants.sm')", 
            "inset('../../macros/fixed.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "resolve(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "smooth(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern redeem_resolve: [resolve:[int256,int256,int256,int256,int256]:int256, smooth:[int256,int256,int256,int256,int256]:int256]"
    }, 
    "redeem_score": {
        "address": "0x652b9c2095f2e244b7ca144237ff6b2ff2f32d67", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Joey Krug (joey@augur.net) or", 
            "# Jack Peterson (jack@augur.net).", 
            "", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPIRING = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "extern score: [blank:[int256,int256,int256]:int256[], deflate:[int256[],int256[],int256,int256]:int256[], latent:[int256[],int256[],int256]:int256, loadings:[int256[],int256[],int256[],int256,int256]:int256[], score:[int256[],int256[],int256[],int256,int256,int256]:int256[]]", 
            "SCORE = 0xa8347d21ff9dc37c8c087a665cbcb69d8f9fee4c", 
            "", 
            "def blank(branch, period, num_events, num_reports, flatsize):", 
            "    # blank", 
            "    # loading vector (eigenvector) has num_events + 2 elements:", 
            "    #   - second-to-last element: number of iterations remaining", 
            "    #   - last element: number of components (eigenvectors) remaining", 
            "    with ne_plus_2 = num_events + 2:", 
            "        # - if element ne_plus_2 is zero, we're on the first component, so set the last", 
            "        #   element equal to MAX_COMPONENTS", 
            "        # - otherwise, decrement the last element", 
            "        with loading_vector = array(ne_plus_2):", 
            "            loading_vector = slice(EXPIRING.getLoadingVector(branch, period, outitems=ne_plus_2), items=0, items=ne_plus_2)", 
            "            if loading_vector[num_events+1] == 0:", 
            "                if num_events >= MAX_COMPONENTS:", 
            "                    loading_vector = slice(SCORE.blank(MAX_COMPONENTS-1, MAX_ITERATIONS, num_events, outitems=ne_plus_2), items=0, items=ne_plus_2)", 
            "                else:", 
            "                    loading_vector = slice(SCORE.blank(num_events-1, MAX_ITERATIONS, num_events, outitems=ne_plus_2), items=0, items=ne_plus_2)", 
            "            else:", 
            "                loading_vector = slice(SCORE.blank(loading_vector[num_events+1]-1, MAX_ITERATIONS, num_events, outitems=ne_plus_2), items=0, items=ne_plus_2)", 
            "            EXPIRING.setLoadingVector(branch, period, loading_vector)", 
            "            return(1)", 
            "", 
            "def loadings(branch, period, num_events, num_reports, flatsize):", 
            "    with ne_plus_2 = num_events + 2:", 
            "        with loading_vector = array(ne_plus_2):", 
            "            loading_vector = slice(EXPIRING.getLoadingVector(branch, period, outitems=ne_plus_2), items=0, items=ne_plus_2)", 
            "            with deflated = array(flatsize):", 
            "                deflated = slice(EXPIRING.getDeflated(branch, period, outitems=flatsize), items=0, items=flatsize)", 
            "                with reputation = array(num_reports):", 
            "                    with i = 0:", 
            "                        while i < num_reports:", 
            "                            reputation[i] = REPORTING.getRepByIndex(branch, i)", 
            "                            i += 1", 
            "                    # Iteratively diagonalize the weighted centered data matrix,", 
            "                    # deflating (subtracting out the eigenvectors) the matrix after each", 
            "                    # eigenvector is found", 
            "                    loading_vector = slice(SCORE.loadings(loading_vector, deflated, reputation, num_reports, num_events, outitems=ne_plus_2), items=0, items=ne_plus_2)", 
            "                    EXPIRING.setLoadingVector(branch, period, loading_vector)", 
            "                    if loading_vector[num_events] == 0:", 
            "                        return(0)", 
            "                    else:", 
            "                        return(1)", 
            "", 
            "def latent(branch, period, num_events, num_reports, flatsize):", 
            "    with ne_plus_2 = num_events + 2:", 
            "        with loading_vector = array(ne_plus_2):", 
            "            loading_vector = slice(EXPIRING.getLoadingVector(branch, period, outitems=ne_plus_2), items=0, items=ne_plus_2)", 
            "            with covrow = array(num_events):", 
            "                covrow = slice(EXPIRING.getCovarianceMatrixRow(branch, period, outitems=num_events), items=0, items=num_events)", 
            "                with latent = SCORE.latent(covrow, loading_vector, num_events):", 
            "                    EXPIRING.setLatent(branch, period, latent)", 
            "                    return(1)", 
            "", 
            "def deflate(branch, period, num_events, num_reports, flatsize):", 
            "    with ne_plus_2 = num_events + 2:", 
            "        with loading_vector = array(ne_plus_2):", 
            "            loading_vector = slice(EXPIRING.getLoadingVector(branch, period, outitems=ne_plus_2), items=0, items=ne_plus_2)", 
            "            with deflated = array(flatsize):", 
            "                deflated = slice(EXPIRING.getDeflated(branch, period, outitems=flatsize), items=0, items=flatsize)", 
            "                deflated = slice(SCORE.deflate(loading_vector, deflated, num_reports, num_events, outitems=flatsize), items=0, items=flatsize)", 
            "                EXPIRING.setDeflated(branch, period, deflated)", 
            "                return(1)", 
            "", 
            "def score(branch, period, num_events, num_reports, flatsize):", 
            "    with ne_plus_2 = num_events + 2:", 
            "        with loading_vector = array(ne_plus_2):", 
            "            loading_vector = slice(EXPIRING.getLoadingVector(branch, period, outitems=ne_plus_2), items=0, items=ne_plus_2)", 
            "            with wcd = array(flatsize):", 
            "                wcd = slice(EXPIRING.getWeightedCenteredData(branch, period, outitems=flatsize), items=0, items=flatsize)", 
            "                with latent = EXPIRING.getLatent(branch, period):", 
            "                    with scores = array(num_reports):", 
            "                        scores = slice(EXPIRING.getScores(branch, period, outitems=num_reports), items=0, items=num_reports)", 
            "                        scores = slice(SCORE.score(scores, loading_vector, wcd, latent, num_reports, num_events, outitems=num_reports), items=0, items=num_reports)", 
            "                        EXPIRING.setScores(branch, period, scores)", 
            "                        if loading_vector[num_events+1] == 0:", 
            "                            return(0)", 
            "                        else:", 
            "                            return(1)", 
            "", 
            "inset('../../macros/constants.sm')", 
            "inset('../../macros/fixed.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "blank(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "deflate(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "latent(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "loadings(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "flatsize", 
                        "type": "int256"
                    }
                ], 
                "name": "score(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern redeem_score: [blank:[int256,int256,int256,int256,int256]:int256, deflate:[int256,int256,int256,int256,int256]:int256, latent:[int256,int256,int256,int256,int256]:int256, loadings:[int256,int256,int256,int256,int256]:int256, score:[int256,int256,int256,int256,int256]:int256]"
    }, 
    "reporting": {
        "address": "0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "# Reporting index is the branchID", 
            "# Reporters index is the rep. address", 
            "# We 0 index reputation so can walk thru for consensus", 
            "# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future", 
            "# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key", 
            "# Events is 0 indexed as well", 
            "data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep)", 
            "data whitelists[](taken, addresses[])", 
            "", 
            "", 
            "def init():", 
            "    self.Reporting[1010101].repIDtoIndex[tx.origin] = 0", 
            "    self.Reporting[1010101].reputation[0].repValue = 47*2^64", 
            "    self.Reporting[1010101].reputation[0].reporterID = tx.origin", 
            "    self.Reporting[1010101].numberReporters = 1", 
            "    self.Reporting[1010101].totalRep += 47*2^64", 
            "", 
            "def checkWhitelist(address):", 
            "    return(self.whitelists[msg.sender].addresses[address])", 
            "", 
            "def checkContractWhitelist(contract, address):", 
            "    return(self.whitelists[contract].addresses[address])", 
            "", 
            "def setWhitelist(contract, addresses:arr):", 
            "    if self.whitelists[contract].taken:", 
            "        return(text(\"ERROR: you have to vote to change a whitelist\"):str)", 
            "    else:", 
            "        self.whitelists[contract].taken = 1", 
            "        i = 0", 
            "        l = len(addresses)", 
            "        while i <l:", 
            "            address = addresses[i]", 
            "            self.whitelists[contract].addresses[addresses] = 1", 
            "            i += 1", 
            "        return(text(\"SUCCESS\"):str)", 
            "", 
            "# @return reputation value", 
            "def getRepByIndex(branch, repIndex):", 
            "    return(self.Reporting[branch].reputation[repIndex].repValue)", 
            "", 
            "# @return reputation value", 
            "def getRepBalance(branch, address):", 
            "    repIndex = self.Reporting[branch].repIDtoIndex[address]", 
            "    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):", 
            "        return(0)", 
            "    return(self.Reporting[branch].reputation[repIndex].repValue)", 
            "", 
            "def getReporterID(branch, index):", 
            "    return(self.Reporting[branch].reputation[index].reporterID)", 
            "", 
            "def getTotalRep(branch):", 
            "    return(self.Reporting[branch].totalRep)", 
            "", 
            "def getNumberReporters(branch):", 
            "    return(self.Reporting[branch].numberReporters)", 
            "", 
            "def repIDToIndex(branch, repID):", 
            "    return(self.Reporting[branch].repIDtoIndex[repID])", 
            "", 
            "def hashReport(report: arr, salt):", 
            "    hashInfo = array(len(report) + 2)", 
            "    hashInfo[0] = tx.origin", 
            "    hashInfo[1] = salt", 
            "    i = 2", 
            "    while i < (len(report) + 2):", 
            "        hashInfo[i] = report[i-2]", 
            "        i += 1", 
            "    reportHash = sha256(hashInfo, chars=32*len(hashInfo))", 
            "    return(reportHash)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def setInitialReporters(parent, branchID):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # first vote period won't be until after the current (in this case first) basket of things has expired", 
            "        # if floor(blockNum / periodLength) is say 5 and eventsExpDates[5]", 
            "        # the current vote period should be on things from eventsExpDates 4 (when making a new branch this vote period will just fail quorem, and current vote period will be incrememented)", 
            "        # then once blockNum / periodLength is say 6 and eventsExpDates[6]", 
            "        # votePeriod 4 should close and the currentVotePeriod should be from", 
            "        # eventsExpDates 5 (anyone can call the consensus function for voteperiod 4 at this point)", 
            "    i = 0", 
            "    while i < self.Reporting[parent].numberReporters:", 
            "        reporterID = self.Reporting[parent].reputation[i].reporterID", 
            "        self.Reporting[branchID].reputation[i].reporterID = reporterID", 
            "        self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue", 
            "        self.Reporting[branchID].repIDtoIndex[reporterID] = i", 
            "        i+=1", 
            "    self.Reporting[branchID].numberReporters = i", 
            "    return(1)", 
            "", 
            "def addReporter(branch, sender):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    reporterIndex = self.Reporting[branch].numberReporters", 
            "    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex", 
            "    self.Reporting[branch].reputation[reporterIndex].repValue = 0", 
            "    self.Reporting[branch].reputation[reporterIndex].reporterID = sender", 
            "    self.Reporting[branch].numberReporters += 1", 
            "    return(1)", 
            "", 
            "def addRep(branch, index, value):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].reputation[index].repValue += value", 
            "    return(1)", 
            "", 
            "def subtractRep(branch, index, value):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].reputation[index].repValue -= value", 
            "    return(1)", 
            "", 
            "def setRep(branch, index, newRep):", 
            "    #if !self.whitelist.check(msg.sender):", 
            "    #    return(-1)", 
            "    oldRep = self.Reporting[branch].reputation[index].repValue", 
            "    self.Reporting[branch].reputation[index].repValue = newRep", 
            "    self.Reporting[branch].totalRep += newRep - oldRep", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "addRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "addReporter(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "contract", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "checkContractWhitelist(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "checkWhitelist(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumberReporters(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepByIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }
                ], 
                "name": "getReporterID(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalRep(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "report", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }
                ], 
                "name": "hashReport(int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repID", 
                        "type": "int256"
                    }
                ], 
                "name": "repIDToIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "parent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branchID", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialReporters(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "newRep", 
                        "type": "int256"
                    }
                ], 
                "name": "setRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "contract", 
                        "type": "int256"
                    }, 
                    {
                        "name": "addresses", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setWhitelist(int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]"
    }, 
    "resolve": {
        "address": "0xca39ef3752a20837ece0911c1f758ba8b621a33b", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Jack Peterson (jack@augur.net).", 
            "", 
            "extern statistics: [weighted_median:[int256[],int256[]]:int256]", 
            "STATISTICS = 0x29c1d95256f9090130e99dd9cab154ac3d3e060f", 
            "", 
            "# Absolute value of all array elements", 
            "macro array_abs($a):", 
            "    with $len = len($a):", 
            "        with $absval = array($len):", 
            "            with $i = 0:", 
            "                while $i < $len:", 
            "                    $absval[$i] = abs($a[$i])", 
            "                    $i += 1", 
            "                $absval", 
            "", 
            "def smooth(adjusted_scores:arr, reputation:arr, num_reports, num_events):", 
            "    # Weighted sum of old and new reputation vectors.", 
            "    # New: row_reward_weighted", 
            "    # Old: reputation", 
            "    reputation = normalize(reputation)", 
            "    with row_reward_weighted = array(num_reports):", 
            "        with i = 0:", 
            "            while i < num_reports:", 
            "                row_reward_weighted[i] = reputation[i]", 
            "                i += 1", 
            "", 
            "        # Overwrite the inital declaration IFF there wasn't perfect consensus.", 
            "        if maximum(array_abs(adjusted_scores)) != 0:", 
            "            with mean_weight = mean(row_reward_weighted):", 
            "                with i = 0:", 
            "                    while i < num_reports:", 
            "                        row_reward_weighted[i] = adjusted_scores[i] * row_reward_weighted[i] / mean_weight", 
            "                        i += 1", 
            "            row_reward_weighted = normalize(row_reward_weighted)", 
            "        # Freshly-calculated reward (in reputation)", 
            "        # (0.1 is the adjustable parameter \"alpha\", hard-coding it for now)", 
            "        with smooth_rep = array(num_reports):", 
            "            with i = 0:", 
            "                while i < num_reports:", 
            "                    smooth_rep[i] = row_reward_weighted[i]/10 + reputation[i]*9/10", 
            "                    i += 1", 
            "            smooth_rep = normalize(smooth_rep)", 
            "            return(smooth_rep, items=num_reports)", 
            "", 
            "def resolve(smooth_rep:arr, reports:arr, scaled:arr, scaled_max:arr, scaled_min:arr, num_reports, num_events):", 
            "    with two_num_events = 2*num_events:", 
            "        with outcomes_final = array(num_events):", 
            "            # discriminate based on contract type", 
            "            with outcomes_raw = array(num_events):", 
            "                with i = 0:", 
            "                    while i < num_events:", 
            "                        if scaled[i] == 1:", 
            "                            with active_reports = array(num_reports):", 
            "                                with j = 0:", 
            "                                    while j < num_reports:", 
            "                                        active_reports[j] = reports[i + j*num_events]", 
            "                                        j += 1", 
            "                                outcomes_raw[i] = STATISTICS.weighted_median(active_reports, smooth_rep)", 
            "                        else:", 
            "                            with j = 0:", 
            "                                while j < num_reports:", 
            "                                    outcomes_raw[i] += fixed_multiply(smooth_rep[j], reports[j*num_events + i])", 
            "                                    j += 1", 
            "                        i += 1", 
            "                with outcomes_adj = array(num_events):", 
            "                    with i = 0:", 
            "                        while i < num_events:", 
            "                            if scaled[i] == 1:", 
            "                                outcomes_adj[i] = outcomes_raw[i]", 
            "                            else:", 
            "                                outcomes_adj[i] = catch(outcomes_raw[i])", 
            "                            i += 1", 
            "                    with i = 0:", 
            "                        while i < num_events:", 
            "                            if scaled[i] == 1:", 
            "                                outcomes_final[i] = fixed_multiply(outcomes_adj[i], scaled_max[i] - scaled_min[i]) + scaled_min[i]", 
            "                            else:", 
            "                                outcomes_final[i] = outcomes_adj[i]", 
            "                            i += 1", 
            "", 
            "                    with certainty = array(num_events):", 
            "                        with i = 0:", 
            "                            while i < num_events:", 
            "                                with j = 0:", 
            "                                    while j < num_reports:", 
            "                                        if abs(reports[i + j*num_events] - outcomes_adj[i]) < 0x1197998:", 
            "                                            certainty[i] += smooth_rep[j]", 
            "                                        j += 1", 
            "                                i += 1", 
            "                        with total = 0:", 
            "                            with i = 0:", 
            "                                while i < num_events:", 
            "                                    certainty[i] = abs(certainty[i])", 
            "                                    total += certainty[i]", 
            "                                    i += 1", 
            "                            return(outcomes_final, items=num_events)", 
            "", 
            "#inset('macros/constants.se')", 
            "#inset('macros/fixed.se')", 
            "#inset('macros/arrays.se')", 
            "inset('../../macros/constants.sm')", 
            "inset('../../macros/fixed.sm')", 
            "inset('../../macros/arrays.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "smooth_rep", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "reports", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "scaled", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "scaled_max", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "scaled_min", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "resolve(int256[],int256[],int256[],int256[],int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "adjusted_scores", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "reputation", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "smooth(int256[],int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern resolve: [resolve:[int256[],int256[],int256[],int256[],int256[],int256,int256]:int256[], smooth:[int256[],int256[],int256,int256]:int256[]]"
    }, 
    "score": {
        "address": "0xa8347d21ff9dc37c8c087a665cbcb69d8f9fee4c", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Jack Peterson (jack@augur.net).", 
            "", 
            "# Outer product of vectors", 
            "macro outer_product($u, $v, $n):", 
            "    with $p = array($n^2):", 
            "        with $i = 0:", 
            "            while $i < $n:", 
            "                with $j = 0:", 
            "                    while $j < $n:", 
            "                        $p[$i*$n + $j] += fixed_multiply($u[$i], $v[$j])", 
            "                        $j += 1", 
            "                $i += 1", 
            "            $p", 
            "", 
            "# Flattened fixed-point matrix multiplication", 
            "macro matrix_multiply($a, $arows, $acols, $b, $brows, $bcols):", 
            "    with $c = array($arows*$bcols):", 
            "        with $i = 0:", 
            "            while $i < $arows:", 
            "                with $j = 0:", 
            "                    while $j < $bcols:", 
            "                        with $k = 0:", 
            "                            while $k < $acols:", 
            "                                $c[$i*$bcols + $j] += fixed_multiply($a[$i*$acols + $k], $b[$k*$bcols + $j])", 
            "                                $k += 1", 
            "                        $j += 1", 
            "                $i += 1", 
            "            $c", 
            "", 
            "def blank(components_remaining, max_iterations, num_events):", 
            "    with ne_plus_2 = num_events + 2:", 
            "        with iv = array(ne_plus_2):", 
            "            iv[0] = ONE", 
            "            iv[num_events] = max_iterations", 
            "            iv[num_events + 1] = components_remaining", 
            "            return(iv, items=ne_plus_2)", 
            "", 
            "def loadings(iv:arr, X:arr, reputation:arr, num_reports, num_events):", 
            "    # R.dot(wcd).dot(lv).dot(wcd)", 
            "    with lvsize = len(iv):", 
            "        with lv = array(lvsize):", 
            "            with j = 0:", 
            "                while j < num_reports:", 
            "                    with d_dot_lv = 0:", 
            "                        with k = 0:", 
            "                            while k < num_events:", 
            "                                d_dot_lv += X[j*num_events + k] * iv[k]", 
            "                                k += 1", 
            "                        d_dot_lv /= ONE", 
            "                        with k = 0:", 
            "                            while k < num_events:", 
            "                                lv[k] -= d_dot_lv * X[j*num_events + k] * reputation[j] / ONE^2", 
            "                                k += 1", 
            "                    j += 1", 
            "            # Normalize by length", 
            "            with lv_dot_lv = 0:", 
            "                with j = 0:", 
            "                    while j < num_events:", 
            "                        lv_dot_lv += lv[j] * lv[j]", 
            "                        j += 1", 
            "                lv_dot_lv /= ONE", 
            "                with norm_lv = lv_dot_lv / 2:", 
            "                    with j = 0:", 
            "                        while j < 11:", 
            "                            norm_lv = (norm_lv + fixed_divide(lv_dot_lv, norm_lv)) / 2", 
            "                            j += 1", 
            "                    with j = 0:", 
            "                        while j < num_events:", 
            "                            lv[j] = fixed_divide(lv[j], norm_lv)", 
            "                            j += 1", 
            "            lv[num_events] = iv[num_events] - 1", 
            "            lv[num_events + 1] = iv[num_events + 1]", 
            "            return(lv, items=lvsize)", 
            "", 
            "def latent(covrow:arr, loadings:arr, num_events):", 
            "    with lf = 0:", 
            "        with i = 0:", 
            "            while i < num_events:", 
            "                lf += fixed_multiply(covrow[i], loadings[i])", 
            "                i += 1", 
            "            if loadings[0] != 0:", 
            "                lf = fixed_divide(lf, loadings[0])", 
            "            else:", 
            "                lf = 0", 
            "            return(lf)", 
            "", 
            "def deflate(ev:arr, wcd:arr, num_reports, num_events):", 
            "    with dsz = len(wcd):", 
            "        with evop = outer_product(ev, ev, num_events):", 
            "            with ddata = array(dsz):", 
            "                with data_x_evop = matrix_multiply(wcd, num_reports, num_events, evop, num_events, num_events):", 
            "                    with i = 0:", 
            "                        while i < dsz:", 
            "                            ddata[i] = wcd[i] - data_x_evop[i]", 
            "                            i += 1", 
            "                    return(ddata, items=dsz)", 
            "", 
            "def score(scores:arr, lv:arr, wcd:arr, latent, num_reports, num_events):", 
            "    if lv[0] < 0:", 
            "        with j = 0:", 
            "            while j < num_events:", 
            "                lv[j] = -lv[j]", 
            "                j += 1", 
            "    with i = 0:", 
            "        while i < num_reports:", 
            "            with k = 0:", 
            "                while k < num_events:", 
            "                    scores[i] += fixed_multiply(wcd[i*num_events + k], latent * lv[k] / ONE)", 
            "                    k += 1", 
            "            i += 1", 
            "        return(scores, items=num_reports)", 
            "", 
            "inset('../../macros/constants.sm')", 
            "inset('../../macros/fixed.sm')", 
            "inset('../../macros/arrays.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "components_remaining", 
                        "type": "int256"
                    }, 
                    {
                        "name": "max_iterations", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "blank(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ev", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "wcd", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "deflate(int256[],int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "covrow", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "loadings", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "latent(int256[],int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "iv", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "X", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "reputation", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "loadings(int256[],int256[],int256[],int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "scores", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "lv", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "wcd", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "latent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_reports", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num_events", 
                        "type": "int256"
                    }
                ], 
                "name": "score(int256[],int256[],int256[],int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern score: [blank:[int256,int256,int256]:int256[], deflate:[int256[],int256[],int256,int256]:int256[], latent:[int256[],int256[],int256]:int256, loadings:[int256[],int256[],int256[],int256,int256]:int256[], score:[int256[],int256[],int256[],int256,int256,int256]:int256[]]"
    }, 
    "sendReputation": {
        "address": "0x9dce0b045622fd1536f0f49e3d7c5b4ffaf01bf7", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarket:[int256,int256]:int256, getBranch:[int256]:int256, getBranches:[]:int256[], getMarkets:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarkets:[int256]:int256, getPeriodLength:[int256]:int256, getReputation:[int256]:int256[], getStep:[int256]:int256, getSubstep:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, incrementStep:[int256]:int256, incrementSubstep:[int256]:int256, initializeBranch:[int256,int256,int256,int256]:int256, setStep:[int256,int256]:int256, setSubstep:[int256,int256]:int256]", 
            "BRANCHES = 0x6304d620fbdaf2d473079e44fe13d376fefe6164", 
            "extern expiringEvents: [addEvent:[int256,int256,int256]:int256, getAdjPrinComp:[int256,int256]:int256[], getCovarianceMatrixRow:[int256,int256]:int256[], getDeflated:[int256,int256]:int256[], getEvent:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getLatent:[int256,int256]:int256, getLoadingVector:[int256,int256]:int256[], getNewOne:[int256,int256]:int256[], getNewTwo:[int256,int256]:int256[], getNumberEvents:[int256,int256]:int256, getOutcomesFinal:[int256,int256]:int256[], getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256]:int256, getReporterBallot:[int256,int256,int256]:int256[], getReporterPayouts:[int256,int256]:int256[], getReportsFilled:[int256,int256]:int256[], getReportsMask:[int256,int256]:int256[], getScores:[int256,int256]:int256[], getSetOne:[int256,int256]:int256[], getSetTwo:[int256,int256]:int256[], getSmoothRep:[int256,int256]:int256[], getTotalRepReported:[int256,int256]:int256, getTotalReputation:[int256,int256]:int256, getVSize:[int256,int256]:int256, getWeightedCenteredData:[int256,int256]:int256[], moveEventsToCurrentPeriod:[int256,int256,int256]:int256, returnOld:[int256,int256]:int256[], setAdjPrinComp:[int256,int256,int256[]]:int256, setCovarianceMatrixRow:[int256,int256,int256[]]:int256, setDeflated:[int256,int256,int256[]]:int256, setLatent:[int256,int256,int256]:int256, setLoadingVector:[int256,int256,int256[]]:int256, setNewOne:[int256,int256,int256[]]:int256, setNewTwo:[int256,int256,int256[]]:int256, setOld:[int256,int256,int256[]]:int256, setOutcomesFinal:[int256,int256,int256[]]:int256, setReportHash:[int256,int256,int256,int256]:int256, setReporterBallot:[int256,int256,int256,int256[],int256]:int256, setReporterPayouts:[int256,int256,int256[]]:int256, setReportsFilled:[int256,int256,int256[]]:int256, setReportsMask:[int256,int256,int256[]]:int256, setScores:[int256,int256,int256[]]:int256, setSetOne:[int256,int256,int256[]]:int256, setSetTwo:[int256,int256,int256[]]:int256, setSmoothRep:[int256,int256,int256[]]:int256, setTotalRepReported:[int256,int256,int256]:int256, setTotalReputation:[int256,int256,int256]:int256, setVSize:[int256,int256,int256]:int256, setWeightedCenteredData:[int256,int256,int256[]]:int256]", 
            "EXPEVENTS = 0x27f07adb9921e7f69462e3e285d43c6c25768058", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "extern reporting: [addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractRep:[int256,int256,int256]:int256]", 
            "REPORTING = 0x1c6e0e4cd3980a458a6d7af1e98ba85bb67e5875", 
            "", 
            "# @return value of reputation sent, 0 if not enough reputation", 
            "# error messages otherwise", 
            "    # -1: \"Your reputation account was just created, earn some rep. before you can send to others\"", 
            "    # -2: \"Receiving address doesn't exist\"", 
            "def sendReputation(branch, recver, value):", 
            "    # VoteCoins cannot be simultaneously spent (transferred) and used to vote", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    if(value<=0 || !CASH.send(branch, 5*2^64) || EXPEVENTS.getReport(branch, currentVotePeriod, tx.origin, 0) != 0 || EXPEVENTS.getReport(branch, currentVotePeriod, msg.sender, 0) != 0 || EXPEVENTS.getReport(branch, currentVotePeriod, recver, 0) != 0):", 
            "        return(0)", 
            "    sender = tx.origin", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "    receiverIndex = REPORTING.repIDToIndex(branch, recver)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=tx.origin):", 
            "        REPORTING.addReporter(branch, sender)", 
            "        return(-1)", 
            "", 
            "    if(REPORTING.getReporterID(branch, receiverIndex)!=recver):", 
            "        return(-2)", 
            "", 
            "    senderBalance = REPORTING.getRepBalance(branch, sender)", 
            "    if(senderBalance >= value):", 
            "        if(REPORTING.subtractRep(branch, senderIndex, value) && REPORTING.addRep(branch, receiverIndex, value)):", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "sendReputation(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern sendReputation: [sendReputation:[int256,int256,int256]:int256]"
    }, 
    "statistics": {
        "address": "0x29c1d95256f9090130e99dd9cab154ac3d3e060f", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact Jack Peterson (jack@augur.net).", 
            "", 
            "macro concat($a, $b):", 
            "    with $c = array(len($a)+len($b)):", 
            "        mcopy($c, $a, chars=32*len($a))", 
            "        mcopy($c+(chars=32*len($a)), $b, chars=32*len($b))", 
            "        $c", 
            "", 
            "macro swap($a, $i, $j):", 
            "    with $t = $a[$i]:", 
            "        $a[$i] = $a[$j]", 
            "        $a[$j] = $t", 
            "", 
            "# Find index corresponding to the maximum value of an array", 
            "macro findmax($a):", 
            "    with $len = len($a):", 
            "        with $max = $a[0]:", 
            "            with $maxidx = 0:", 
            "                with $i = 1:", 
            "                    while $i < $len:", 
            "                        if $a[$i] > $max:", 
            "                            $maxval = $a[$i]", 
            "                            $maxidx = $i", 
            "                        $i += 1", 
            "                    $maxidx", 
            "", 
            "macro paired_qsort($a, $b):", 
            "    with $len = len($a):", 
            "        with $c = concat($a, $b):", 
            "            with $stack = array($len):", 
            "                with $top = 0:", 
            "                    with $h = 0:", 
            "                        with $l = 0:", 
            "                            with $x = 0:", 
            "                                with $i = 0:", 
            "                                    with $j = 0:", 
            "                                        $stack[0] = 0", 
            "                                        $stack[1] = $len - 1", 
            "                                        $top = 1", 
            "                                        while $top >= 0:", 
            "                                            $h = $stack[$top]", 
            "                                            $l = $stack[$top - 1]", 
            "                                            $top -= 2", 
            "                                            $x = $c[$h]", 
            "                                            $i = $l - 1", 
            "                                            $j = $l", 
            "", 
            "                                            while $j <= $h - 1:", 
            "                                                if $c[$j] <= $x:", 
            "                                                    $i += 1", 
            "                                                    swap($c, $i, $j)", 
            "                                                    swap($c, $i + $len, $j + $len)", 
            "                                                $j += 1", 
            "", 
            "                                            swap($c, $i+1, $h)", 
            "                                            swap($c, $i + $len + 1, $h + $len)", 
            "                                            if $i > $l:", 
            "                                                $stack[$top + 1] = $l", 
            "                                                $stack[$top + 2] = $i", 
            "                                                $top += 2", 
            "                                            if $i + 2 < $h:", 
            "                                                $stack[$top + 1] = $i + 2", 
            "                                                $stack[$top + 2] = $h", 
            "                                                $top += 2", 
            "                                        $c", 
            "", 
            "# Weighted median of an array", 
            "macro weighted_median($data, $weights):", 
            "    with n = len($data):", 
            "        with done = 0:", 
            "            with midpoint = sum($weights) / 2:", 
            "                with j = 0:", 
            "                    while j < num_present[i]:", 
            "                        if $weights[j] > midpoint:", 
            "                            with maxidx = findmax($weights):", 
            "                                wmedian = $data[maxidx]", 
            "                            done = 1", 
            "                        j += 1", 
            "                if done == 0:", 
            "                    with sorted = paired_qsort($data, $weights):", 
            "                        with sorted_data = array(n):", 
            "                            with sorted_weights = array(n):", 
            "                                with j = 0:", 
            "                                    while j < n:", 
            "                                        sorted_data[j] = sorted[j]", 
            "                                        sorted_weights[j] = sorted[j + n]", 
            "                                        j += 1", 
            "                                with cumulative_weight = 0:", 
            "                                    with idx = 0:", 
            "                                        while cumulative_weight <= midpoint:", 
            "                                            idx += 1", 
            "                                            cumulative_weight += sorted_weights[idx-1]", 
            "                                        cumulative_weight -= sorted_weights[idx-1]", 
            "                                        # conservative machine epsilon:", 
            "                                        # 0x1197998 = 18446744 = ONE / 10^12", 
            "                                        if abs(cumulative_weight - midpoint) < 0x1197998:", 
            "                                            wmedian = (sorted_data[idx-2] + sorted_data[idx-1]) / 2", 
            "                                        else:", 
            "                                            wmedian = sorted_data[idx-1]", 
            "                wmedian", 
            "", 
            "# Weighted median of an array", 
            "def weighted_median(data:arr, weights:arr):", 
            "    return(weighted_median(data, weights))", 
            "", 
            "inset('../../macros/arrays.sm')"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "data", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "weights", 
                        "type": "int256[]"
                    }
                ], 
                "name": "weighted_median(int256[],int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern statistics: [weighted_median:[int256[],int256[]]:int256]"
    }, 
    "transferShares": {
        "address": "0x615b1bbfd690a24cbf5679e7b326aab0227c492e", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern markets: [addParticipant:[int256,int256]:int256, getAlpha:[int256]:int256, getBranchID:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getSharesPurchased:[int256,int256]:int256, getSimulatedBuy:[int256,int256,int256]:_, getSimulatedSell:[int256,int256,int256]:_, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getWinningOutcomes:[int256]:int256[], initialLiquiditySetup:[int256,int256,int256,int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256]:int256, lsLmsr:[int256]:int256, modifyParticipantShares:[int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, price:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x44a270caf86e229f188b340994fa8671ae94450a", 
            "extern info: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x3c5062d58be6ce59534e8a2d10f1d533c1a0206e", 
            "extern cash: [addCash:[int256,int256]:int256, balance:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256]", 
            "CASH = 0xa36a4f0bd323f15d6ebe04810dcb770d33f3466e", 
            "", 
            "# @return amount of shares transferred", 
            "# Error messages otherwise", 
            "    # -1: invalid outcome or you haven't traded in this market (or market doesn't exist)", 
            "    # -2: user actually doesn't have the shares", 
            "    # -3: not enough money to transfer the shares", 
            "def transferShares(branch, market, outcome, amount, to):", 
            "    participantNumber = MARKETS.getParticipantNumber(market, tx.origin)", 
            "    receiverNumber = MARKETS.getParticipantNumber(market, to)", 
            "    if (outcome==0 || MARKETS.getParticipantID(market, participantNumber) != tx.origin):", 
            "        return(-1)", 
            "    if(to != MARKETS.getParticipantID(market, receiverNumber)):", 
            "        receiverNumber = MARKETS.addParticipant(market, to)", 
            "    # remove shares from the user's account", 
            "    # if user actually doesn't have the shares, return -2", 
            "    if(MARKETS.getParticipantSharesPurchased(market, participantNumber, outcome) < amount):", 
            "        return(-2)", 
            "    MARKETS.modifyParticipantShares(market, participantNumber, outcome, -amount)", 
            "    MARKETS.modifyParticipantShares(market, receiverNumber, outcome, amount)", 
            "", 
            "    # half of fees to market creator", 
            "    # other half go to branch", 
            "    oldCost = MARKETS.lsLmsr(market)", 
            "    MARKETS.modifyShares(market, outcome, 2^32)", 
            "    newCost = MARKETS.lsLmsr(market)", 
            "    price = 2^32*(newCost - oldCost)", 
            "    fee = MARKETS.getTradingFee(market)*price/2^64", 
            "    MARKETS.modifyShares(market, outcome, -2^32)", 
            "    if((CASH.balance(tx.origin) >= fee) && CASH.send(INFO.getCreator(market), fee/2) && CASH.send(branch, fee/2)):", 
            "        return(amount)", 
            "    else:", 
            "        return(-3)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "to", 
                        "type": "int256"
                    }
                ], 
                "name": "transferShares(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern transferShares: [transferShares:[int256,int256,int256,int256,int256]:int256]"
    }
}