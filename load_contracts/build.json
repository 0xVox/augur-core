{
    "backstops": {
        "address": "0xea9e799a1bbf2b88090a4a4f39ef44df16e31bdf", 
        "code": [
            "inset('refund.se')", 
            "", 
            "data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, originalEthicality, final, bondPoster)", 
            "", 
            "def getRoundTwo(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].roundTwo)", 
            "", 
            "def setRoundTwo(event, roundTwo):", 
            "    self.roundTwo[event].roundTwo = roundTwo", 
            "    return(1)", 
            "", 
            "def getBondPoster(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].bondPoster)", 
            "", 
            "def setBondPoster(event, bondPoster):", 
            "    self.roundTwo[event].bondPoster = bondPoster", 
            "    return(1)", 
            "", 
            "def getFinal(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].final)", 
            "", 
            "def setFinal(event):", 
            "    self.roundTwo[event].final = 1", 
            "    return(1)", 
            "", 
            "def getOriginalOutcome(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].originalOutcome)", 
            "", 
            "def setOriginalOutcome(event, originalOutcome):", 
            "    self.roundTwo[event].originalOutcome = originalOutcome", 
            "    return(1)", 
            "", 
            "def getOriginalEthicality(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].originalEthicality)", 
            "", 
            "def setOriginalEthicality(event, ethicality):", 
            "    self.roundTwo[event].originalEthicality = ethicality", 
            "    return(1)", 
            "", 
            "def getOriginalVotePeriod(event):", 
            "    refund()", 
            "    return(self.roundTwo[event].originalVotePeriod)", 
            "", 
            "def setOriginalVotePeriod(event, period):", 
            "    self.roundTwo[event].originalVotePeriod = period", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getBondPoster(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getFinal(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalEthicality(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalVotePeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRoundTwo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "bondPoster", 
                        "type": "int256"
                    }
                ], 
                "name": "setBondPoster(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setFinal(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethicality", 
                        "type": "int256"
                    }
                ], 
                "name": "setOriginalEthicality(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "originalOutcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setOriginalOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setOriginalVotePeriod(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "roundTwo", 
                        "type": "int256"
                    }
                ], 
                "name": "setRoundTwo(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [getBondPoster:[int256]:int256, getFinal:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getRoundTwo:[int256]:int256, setBondPoster:[int256,int256]:int256, setFinal:[int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setRoundTwo:[int256,int256]:int256]"
    }, 
    "branches": {
        "address": "0x65c474942e08998c423b0574f45226d4aac2db14", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "inset('refund.se')", 
            "", 
            "# CurrentVotePeriod is the current index in eventsExpDates", 
            "# Branches' index is the hash of the branch (aka branchID)", 
            "# currentVotePeriod is a nonce that tells us which bucket of events up to be", 
            "# voted on in the current vote period (should always be 1 behind block.timestamp/periodlength or current EventsExpDates index)", 
            "# period parameter for reporting", 
            "# currentExpPeriod = (block.timestamp / self.Branches[branch].periodLength)", 
            "# currentExpPeriod - 1 is what's up for reporting at any given time", 
            "# should add a min initial liquidity property, for non pm branches it'd be low and .5*minInitialLiquidity is == fee for event", 
            "# could also add an event fee parameter", 
            "# How to set minimum reporting fee guidelines for reporters, abs. minimum should be calc. as follows:", 
            "    #Volume per period * .5 * fee * ev/ebit * 6 >= rep market cap", 
            "    #Say ev/ebit or valuation is 15, so:", 
            "    #45 * fee * volume per period = rep market cap", 
            "", 
            "    #Want:", 
            "        #Rep market cap >> outstanding shares value at all times", 
            "data Branches[](currentVotePeriod, periodLength, markets[], numMarkets, minTradingFee, balance[], creationDate, oracleOnly, parentPeriod, baseReporters, forkPeriod, eventForkedOver, parent)", 
            "", 
            "# first param is the branch, second param is the subcurrency contract", 
            "data cash[][]", 
            "", 
            "data branchList[]", 
            "", 
            "data branchListCount", 
            "", 
            "def init():", 
            "    self.Branches[1010101].currentVotePeriod = (block.timestamp / 15) - 1", 
            "    self.Branches[1010101].periodLength = 15", 
            "    # .5%", 
            "    self.Branches[1010101].minTradingFee = 92233720368547760", 
            "    self.branchListCount = 1", 
            "    self.branchList[0] = 1010101", 
            "    # since only have to report on half this targets 3", 
            "    self.Branches[1010101].baseReporters = 2*3", 
            "", 
            "# call once after uploading (externed method not allowed in init)", 
            "def initDefaultBranch():", 
            "    refund()", 
            "    return(CASH.initiateOwner(1010101))", 
            "", 
            "def getEventForkedOver(branch):", 
            "    return(self.Branches[branch].eventForkedOver)", 
            "", 
            "def setEventForkedOver(branch, event):", 
            "    self.Branches[branch].eventForkedOver = event", 
            "    return(1)", 
            "", 
            "def getBaseReporters(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].baseReporters)", 
            "", 
            "def setBaseReporters(branch, num):", 
            "    refund()", 
            "    self.Branches[branch].baseReporters = num", 
            "    return(1)", 
            "", 
            "def getOracleOnly(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].oracleOnly)", 
            "", 
            "def getVotePeriod(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].currentVotePeriod)", 
            "", 
            "def getPeriodLength(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].periodLength)", 
            "", 
            "# branch cash balance at start of period", 
            "def setInitialBalance(branch, period, balance):", 
            "    refund()", 
            "    self.Branches[branch].balance[period] = balance", 
            "    return(balance)", 
            "", 
            "def getInitialBalance(branch, period):", 
            "    refund()", 
            "    return(self.Branches[branch].balance[period])", 
            "", 
            "# @return all markets in a branch", 
            "def getMarketsInBranch(branch):", 
            "    refund()", 
            "    numMarkets = self.Branches[branch].numMarkets", 
            "    markets = array(numMarkets)", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        markets[i] = self.Branches[branch].markets[i]", 
            "        i += 1", 
            "    return(markets: arr)", 
            "", 
            "", 
            "def getParent(branch):", 
            "    return(self.Branches[branch].parent)", 
            "", 
            "# @return all markets in a branch", 
            "def getSomeMarketsInBranch(branch, initial, last):", 
            "    refund()", 
            "    numMarkets = last - initial", 
            "    markets = array(numMarkets)", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        markets[i] = self.Branches[branch].markets[initial+i]", 
            "        i += 1", 
            "    return(markets: arr)", 
            "", 
            "def getNumMarketsBranch(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].numMarkets)", 
            "", 
            "def getMinTradingFee(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].minTradingFee)", 
            "", 
            "# @return all branches", 
            "def getBranches():", 
            "    refund()", 
            "    b = 0", 
            "    numBranches = self.branchListCount", 
            "    branches = array(numBranches)", 
            "    while b < numBranches:", 
            "        branches[b] = self.branchList[b]", 
            "        b += 1", 
            "    return(branches: arr)", 
            "", 
            "def getNumBranches():", 
            "    refund()", 
            "    return(self.branchListCount)", 
            "", 
            "def getBranchByNum(branchNumber):", 
            "    refund()", 
            "    return(self.branchList[branchNumber])", 
            "", 
            "def getCreationDate(ID):", 
            "    refund()", 
            "    return(self.Branches[ID].creationDate)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def initializeBranch(ID, currentVotePeriod, periodLength, minTradingFee, oracleOnly, parentPeriod, parent):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    refund()", 
            "    if(self.Branches[ID].periodLength==0):", 
            "        self.Branches[ID].currentVotePeriod = currentVotePeriod", 
            "        self.Branches[ID].periodLength = periodLength", 
            "        self.Branches[ID].minTradingFee = minTradingFee", 
            "        self.branchList[self.branchListCount] = ID", 
            "        self.branchListCount += 1", 
            "        self.Branches[ID].creationDate = block.timestamp", 
            "        self.Branches[ID].parentPeriod = parentPeriod", 
            "        self.Branches[ID].oracleOnly = oracleOnly", 
            "        self.Branches[ID].parent = parent", 
            "        CASH.initiateOwner(ID)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "def getParentPeriod(branch):", 
            "    refund()", 
            "    return(self.Branches[branch].parentPeriod)", 
            "", 
            "def incrementPeriod(branch):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    refund()", 
            "    self.Branches[branch].currentVotePeriod += 1", 
            "    return(1)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def addMarketToBranch(branch, market):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    refund()", 
            "    numMarkets = self.Branches[branch].numMarkets", 
            "    self.Branches[branch].markets[numMarkets] = market", 
            "    self.Branches[branch].numMarkets += 1", 
            "    return(1)", 
            "", 
            "def setForkPeriod(branch):", 
            "    self.Branches[branch].forkPeriod = self.Branches[branch].currentVotePeriod", 
            "    return(1)", 
            "", 
            "def getForkPeriod(branch):", 
            "    return(self.Branches[branch].forkPeriod)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "addMarketToBranch(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getBaseReporters(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branchNumber", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranchByNum(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "getBranches()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationDate(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventForkedOver(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getInitialBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketsInBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getMinTradingFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "getNumBranches()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumMarketsBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getOracleOnly(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getParent(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getParentPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "initial", 
                        "type": "int256"
                    }, 
                    {
                        "name": "last", 
                        "type": "int256"
                    }
                ], 
                "name": "getSomeMarketsInBranch(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getVotePeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "incrementPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "initDefaultBranch()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "currentVotePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "periodLength", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minTradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "oracleOnly", 
                        "type": "int256"
                    }, 
                    {
                        "name": "parentPeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "parent", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeBranch(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "setBaseReporters(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setEventForkedOver(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "setForkPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialBalance(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]"
    }, 
    "buy&sellShares": {
        "address": "0x848a4f71af2e9b57ecd8c1d3f99d470e2c73eba0", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x254d730690f461dc6048c8fd4d9bf49f9fc39829", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern refund.se: [checkHash:[int256,int256]:int256, commitTrade:[int256]:int256, fill_trade:[int256,int256]:int256, getID:[int256]:int256, getInitialTrade:[int256]:int256, get_amount:[int256]:int256, get_price:[int256]:int256, get_trade:[int256]:int256[], makeTradeHash:[int256,int256,int256[]]:int256, remove_trade:[int256]:int256, saveTrade:[int256,int256,int256,int256,int256,int256,int256]:int256, setInitialTrade:[int256]:int256, update_trade:[int256,int256]:_, zeroHash:[]:int256]", 
            "TRADES = 0xb8c254877dd025d04bb760e7b738e1219dbc2708", 
            "inset('refund.se')", 
            "", 
            "event log_price(market:indexed, type, price, amount, timestamp, outcome, trader:indexed)", 
            "event log_add_tx(market:indexed, sender, type, price, amount, outcome, tradeid)", 
            "event log_fill_tx(market:indexed, sender:indexed, owner:indexed, type, price, amount, tradeid, outcome)", 
            "event log_cancel(market:indexed, sender, price, amount, tradeid, outcome, type)", 
            "", 
            "# Trade types", 
            "macro BID: 1", 
            "macro ASK: 2", 
            "# Field counts", 
            "macro TRADE_FIELDS: 9", 
            "# Boolean success/failure", 
            "macro SUCCESS: 1", 
            "macro FAILURE: 0", 
            "# Error codes", 
            "macro INSUFFICIENT_BALANCE: 10", 
            "macro TRADE_ALREADY_EXISTS: 21", 
            "macro TRADE_SAME_BLOCK_PROHIBITED: 22", 
            "", 
            "macro fee_percent($market_fee, $price, $cumScale):", 
            "    4 * $market_fee * $price * (ONE-$price*2**64/$cumScale) / ($cumScale*ONE)", 
            "", 
            "macro save_trade($type, $amount, $price, $market, $outcome, $branch, $participantNumber, $fee, $sender):", 
            "    trade = [$type, $market, $amount, $price, $sender, block.number, $outcome]", 
            "    trade_id = sha256(trade, items=7)", 
            "    cumScale = MARKETS.getCumScale($market)", 
            "", 
            "    # Save trade", 
            "    if !TRADES.getID(trade_id):", 
            "        TRADES.saveTrade(trade_id, $type, $market, $amount, $price, $sender, $outcome)", 
            "        # Update market", 
            "        last_id = MARKETS.getLastTrade($market)", 
            "        MARKETS.addTrade($market, trade_id, last_id)", 
            "        # Update available and trading amounts for asks", 
            "        if $type == ASK:", 
            "            MARKETS.modifyParticipantShares($market, $participantNumber, $outcome, -$amount, 0)", 
            "            if($fee):", 
            "                CASH.sendFrom($market, ($amount * $price * $fee / ONE^2), $sender)", 
            "        # Send / escrow cash for bids", 
            "        if $type == BID:", 
            "            CASH.sendFrom($market, $amount * $price / ONE, $sender)", 
            "            if($fee):", 
            "                CASH.sendFrom($market, ($amount * $price * $fee / ONE^2), $sender)", 
            "    else:", 
            "        return(TRADE_ALREADY_EXISTS)", 
            "    log(type=log_add_tx, $market, $sender, $type, $price, $amount, $outcome, trade_id)", 
            "    return(trade_id)", 
            "", 
            "#", 
            "# Cancellation", 
            "#", 
            "# 200k gas", 
            "def cancel(trade_id):", 
            "    refund()", 
            "    # user can cancel anytime", 
            "    # Get trade", 
            "    trade = array(TRADE_FIELDS)", 
            "    trade = TRADES.get_trade(trade_id, outitems=TRADE_FIELDS)", 
            "    if !trade:", 
            "        return(0)", 
            "    type = trade[1]", 
            "    market = trade[2]", 
            "    amount = trade[3]", 
            "    price = trade[4]", 
            "    owner = trade[5]", 
            "    outcome = trade[8]", 
            "    branch = MARKETS.getBranchID(market)", 
            "    trading_fee = MARKETS.getTradingFee(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    fee = fee_percent(trading_fee, price, cumScale) * MARKETS.getMakerFees(market) / ONE", 
            "    # Check the owner", 
            "    if msg.sender == owner:", 
            "        # Clear the trade first", 
            "        remove_trade(trade_id, market)", 
            "        # Issue refunds", 
            "        if type == BID:", 
            "            # cash refund", 
            "            amt = amount * price * (fee + ONE) / ONE^2", 
            "            CASH.subtractCash(market, amt)", 
            "            CASH.addCash(msg.sender, amt)", 
            "        elif type == ASK:", 
            "            # shares refund", 
            "            participantNumber = MARKETS.getParticipantNumber(market, msg.sender)", 
            "            MARKETS.modifyParticipantShares(market, participantNumber, outcome, amount, 1)", 
            "            CASH.subtractCash(market, (amount * price * fee / ONE^2))", 
            "            CASH.addCash(msg.sender, (amount * price * fee / ONE^2))", 
            "        # Log cancellation", 
            "        log(type=log_cancel, market, msg.sender, price, amount, trade_id, outcome, type)", 
            "        return(SUCCESS)", 
            "    return(FAILURE)", 
            "", 
            "macro remove_trade($trade_id, $market):", 
            "    TRADES.remove_trade($trade_id)", 
            "    MARKETS.remove_trade_from_market($market, $trade_id)", 
            "", 
            "#", 
            "# Buy / Sell actions", 
            "# Errors:", 
            "    # -1: amount/price bad or no market", 
            "    # -2: oracle only branch", 
            "    # -3: bad outcome to trade [not needed anymore, can't buy shares that don't exist]", 
            "    # -4: not enough money or shares", 
            "#", 
            "# costs 532k", 
            "# smallest trade value is 0.00000001", 
            "def buy(amount, price, market, outcome):", 
            "    refund()", 
            "    branch = MARKETS.getBranchID(market)", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        return(-2)", 
            "    participantNumber = MARKETS.getParticipantNumber(market, msg.sender)", 
            "    # if participant doesn't exist in market, add them", 
            "    if(msg.sender != MARKETS.getParticipantID(market, participantNumber)):", 
            "        participantNumber = MARKETS.addParticipant(market, msg.sender)", 
            "    trading_fee = MARKETS.getTradingFee(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    fee = fee_percent(trading_fee, price, cumScale) * MARKETS.getMakerFees(market) / ONE", 
            "    if(price>cumScale or amount*price < 3402823669209384705829531287552 or amount*price >= 2**190):", 
            "        return(0)", 
            "    if(CASH.balance(msg.sender) < (amount * price * (fee + ONE) / ONE^2)):", 
            "        return(-4)", 
            "    save_trade(BID, amount, price, market, outcome, branch, participantNumber, fee, msg.sender)", 
            "    return(FAILURE)", 
            "", 
            "# cost 532k", 
            "# smallest trade value is 0.00000001", 
            "def sell(amount, price, market, outcome):", 
            "    refund()", 
            "    branch = MARKETS.getBranchID(market)", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        return(-2)", 
            "    participantNumber = MARKETS.getParticipantNumber(market, msg.sender)", 
            "    if(MARKETS.getParticipantID(market, participantNumber) != msg.sender):", 
            "        return(-3)", 
            "    if(MARKETS.getParticipantSharesPurchased(market, participantNumber, outcome) < amount):", 
            "        return(-4)", 
            "    trading_fee = MARKETS.getTradingFee(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    fee = fee_percent(trading_fee, price, cumScale) * MARKETS.getMakerFees(market) / ONE", 
            "    if(price>cumScale or amount*price < 3402823669209384705829531287552L or amount*price >= 2**190):", 
            "        return(0)", 
            "    if(CASH.balance(msg.sender) < (amount * price * fee / ONE^2)):", 
            "        return(-4)", 
            "    save_trade(ASK, amount, price, market, outcome, branch, participantNumber, fee, msg.sender)", 
            "    return(FAILURE)", 
            "", 
            "# Example:", 
            "    #buyer gives up say 20", 
            "    #complete set cost is say 100", 
            "    #fee is say 2", 
            "    #market should lose 20 from buyer's escrowed money", 
            "    #market should gain 100 from complete set", 
            "    #person short selling should give the market 80 [complete set cost less shares sold]", 
            "    #plus fees", 
            "        #1 should go to branch", 
            "        #1 should go to creator", 
            "def short_sell(buyer_trade_id, max_amount):", 
            "    refund()", 
            "    # check trade hash", 
            "    tradeInfo = array(3)", 
            "    tradeInfo[0] = buyer_trade_id", 
            "    tradeInfo[1] = max_amount", 
            "    tradeInfo[2] = 0", 
            "    tradeHash = sha256(tradeInfo, items=3)", 
            "    if(TRADES.checkHash(tradeHash, msg.sender)==-1):", 
            "        return(-2)", 
            "    # Get trade", 
            "    trade = array(TRADE_FIELDS)", 
            "    trade = TRADES.get_trade(buyer_trade_id, outitems=TRADE_FIELDS)", 
            "    if !trade:", 
            "        return(3)", 
            "    # Get market", 
            "    type = trade[1]", 
            "    if(type!=BID):", 
            "        return(4)", 
            "    market = trade[2]", 
            "    if(MARKETS.getOneWinningOutcome(market, 0)):", 
            "        return(-4)", 
            "    orig_amount = trade[3]", 
            "    price = trade[4]", 
            "    owner = trade[5]", 
            "    outcome = trade[8]", 
            "    if(owner == msg.sender or owner == tx.origin):", 
            "        return(5)", 
            "    # Make sure the trade has been mined, obvious HFT prevention", 
            "    if block.number <= trade[6]:", 
            "        return(TRADE_SAME_BLOCK_PROHIBITED)", 
            "    branch = MARKETS.getBranchID(market)", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        return(-1)", 
            "    creator = INFO.getCreator(market)", 
            "    trading_fee = MARKETS.getTradingFee(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    amount = min(orig_amount, max_amount)", 
            "    if(amount < 0):", 
            "        return(INSUFFICIENT_BALANCE)", 
            "    fee = amount * price * fee_percent(trading_fee, price, cumScale) / ONE^2", 
            "    makerFeeRate = MARKETS.getMakerFees(market)", 
            "    branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE", 
            "    creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE", 
            "    takerFeesTotal = branchFees + creatorFees", 
            "    cost = amount*cumScale/ONE - (amount*price/ONE - takerFeesTotal)", 
            "    if(CASH.balance(msg.sender) < cost):", 
            "        return(INSUFFICIENT_BALANCE)", 
            "", 
            "    if(amount*price/ONE < 184467440738):", 
            "        return(-4)", 
            "", 
            "    numOutcomes = MARKETS.getMarketNumOutcomes(market)", 
            "    participantNumber = MARKETS.getParticipantNumber(market, msg.sender)", 
            "    # if participant doesn't exist in market, add them", 
            "    if(msg.sender != MARKETS.getParticipantID(market, participantNumber)):", 
            "        participantNumber = MARKETS.addParticipant(market, msg.sender)", 
            "", 
            "    i = 1", 
            "    # send shares of the event to user address", 
            "    while i <= numOutcomes:", 
            "        MARKETS.modifyShares(market, i, amount)", 
            "        MARKETS.modifyParticipantShares(market, participantNumber, i, amount, 0)", 
            "        i += 1", 
            "    if(BRANCHES.getVotePeriod(branch)<MARKETS.getTradingPeriod(market)):", 
            "        MARKETS.modifySharesValue(market, amount*cumScale/ONE)", 
            "        EXPEVENTS.adjustPeriodShareValueOutstanding(branch, MARKETS.getTradingPeriod(market), amount*cumScale/ONE)", 
            "", 
            "    # send money from user acc. to market address/account", 
            "    # cost for shares", 
            "    CASH.sendFrom(market, cost-takerFeesTotal, msg.sender)", 
            "", 
            "    # Fill buy order", 
            "    # Determine fill amount", 
            "    fill = amount", 
            "    # Update trade amount or remove", 
            "    if fill < orig_amount:", 
            "        TRADES.fill_trade(trade_id, fill)", 
            "    else:", 
            "        remove_trade(trade_id, market)", 
            "    # Update balances", 
            "    ownerNum = MARKETS.getParticipantNumber(market, owner)", 
            "    MARKETS.modifyParticipantShares(market, participantNumber, outcome, -fill, 0)", 
            "    MARKETS.modifyParticipantShares(market, ownerNum, outcome, fill, 0)", 
            "    # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]", 
            "    # 75% to branch + .5% more to branch per maker fee 1% decrease", 
            "    CASH.sendFrom(branch, branchFees, msg.sender)", 
            "    # 25% to creator + .5% more to creator per 1% decrease in maker fees", 
            "    CASH.sendFrom(creator, creatorFees, msg.sender)", 
            "", 
            "    # other party [maker] pay their part of the fee here too", 
            "    fee = fee * makerFeeRate / ONE", 
            "    CASH.subtractCash(market, fee)", 
            "    CASH.addCash(creator, fee/2)", 
            "    CASH.addCash(branch, fee/2)", 
            "", 
            "    MARKETS.addFees(market, fee+takerFeesTotal)", 
            "", 
            "    # Log transaction", 
            "    log(type=log_fill_tx, market, msg.sender, owner, ASK, price, fill, trade_id, outcome)", 
            "    # Log price, fill amount, type and timestamp", 
            "    log(type=log_price, market, type, price, fill, block.timestamp, outcome, msg.sender)", 
            "    return([SUCCESS, max_amount, fill, price]: arr)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "buy(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "trade_id", 
                        "type": "int256"
                    }
                ], 
                "name": "cancel(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "sell(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "buyer_trade_id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "max_amount", 
                        "type": "int256"
                    }
                ], 
                "name": "short_sell(int256,int256)", 
                "outputs": [
                    {
                        "name": "unknown_out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "type", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeid", 
                        "type": "int256"
                    }
                ], 
                "name": "log_add_tx(int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeid", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "type", 
                        "type": "int256"
                    }
                ], 
                "name": "log_cancel(int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "owner", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "type", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeid", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "log_fill_tx(int256,int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "type", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "trader", 
                        "type": "int256"
                    }
                ], 
                "name": "log_price(int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern buy&sellShares: [buy:[int256,int256,int256,int256]:int256, cancel:[int256]:int256, sell:[int256,int256,int256,int256]:int256, short_sell:[int256,int256]:_]"
    }, 
    "cash": {
        "address": "0xbd272e493163dcfe1726cecdb14c85942ebba648", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "inset('refund.se')", 
            "", 
            "data cashcoinBalances[]", 
            "", 
            "data owners[]", 
            "", 
            "def init():", 
            "    # test initial funds", 
            "    self.cashcoinBalances[msg.sender] = 100000*ONE", 
            "", 
            "# @return: cash balance of address", 
            "def balance(address):", 
            "    refund()", 
            "    return(self.cashcoinBalances[address])", 
            "", 
            "# A random market could have a balance, and when that account was created/first used in the subcurrency, it'd have whatever contract that created it be the owner, so for example...", 
            "# needs to be called when making a market, branch, etc. or a new cash user acc.", 
            "def initiateOwner(account):", 
            "    refund()", 
            "    if(self.owners[account]==0 and self.cashcoinBalances[account]==0):", 
            "        self.owners[account] = msg.sender", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# should send values as fixed point in UI (1 is ONE, 4 is 4*ONE, .5 is ONEHALF, etc.)", 
            "# @return: value sent, 0 if fails", 
            "# If you've never used cash in augur, to initiate your account call this with value as 0", 
            "def send(recver, value):", 
            "    refund()", 
            "    if(self.owners[msg.sender]==0):", 
            "        self.owners[msg.sender] = msg.sender", 
            "    #if(self.owners[recver]==0):", 
            "    #    return(0)", 
            "    sender = msg.sender", 
            "    senderBalance = self.cashcoinBalances[sender]", 
            "    if(senderBalance >= value && value > 0):", 
            "        self.cashcoinBalances[sender] -= value", 
            "        self.cashcoinBalances[recver] += value", 
            "        return(value)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# @return value of cash sent; fail is 0", 
            "def sendFrom(recver, value, from):", 
            "    refund()", 
            "    # sendFrom would check if the sender had an owner, if it did, then it'd check and see if the msg.sender was the owner.", 
            "    # it's not owned by a regular account nor a contract owned account (i.e. a market's hash from markets.)", 
            "    if(from!=tx.origin and msg.sender!=self.owners[from] and msg.sender!=from):", 
            "        return(0)", 
            "    #if(self.owners[recver]==0):", 
            "    #    return(0)", 
            "    senderBalance = self.cashcoinBalances[from]", 
            "    if(senderBalance >= value && value > 0):", 
            "        self.cashcoinBalances[from] -= value", 
            "        self.cashcoinBalances[recver] += value", 
            "        return(value)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# make sure only coming from specific contracts", 
            "def subtractCash(ID, amount):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    #if(msg.sender!=self.owners[ID] && tx.origin!=self.owners[ID]):", 
            "    #    return(0)", 
            "    self.cashcoinBalances[ID] -= amount", 
            "    return(1)", 
            "", 
            "def addCash(ID, amount):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.cashcoinBalances[ID] += amount", 
            "    return(1)", 
            "", 
            "def setCash(address, balance):", 
            "    refund()", 
            "    #if !self.whitelist.check(msg.sender):", 
            "    #    return(-1)", 
            "    self.cashcoinBalances[address] = balance", 
            "    return(1)", 
            "", 
            "def depositEther():", 
            "    self.cashcoinBalances[msg.sender] += msg.value * ONE / WEITOETH", 
            "    return msg.value", 
            "", 
            "def withdrawEther(to, value):", 
            "    if(value < 0):", 
            "        return(-1)", 
            "    if self.cashcoinBalances[msg.sender] >= value * ONE / WEITOETH:", 
            "        self.cashcoinBalances[msg.sender] -= value * ONE / WEITOETH", 
            "        send(to, value)", 
            "        return 1", 
            "    else:", 
            "        return 0"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "addCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "balance(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "depositEther()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "account", 
                        "type": "int256"
                    }
                ], 
                "name": "initiateOwner(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "send(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }, 
                    {
                        "name": "from", 
                        "type": "int256"
                    }
                ], 
                "name": "sendFrom(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "setCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractCash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "to", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "withdrawEther(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]"
    }, 
    "closeMarket": {
        "address": "0xe6474e85765d1676bafedb09b8c79bea7bd40dcf", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x254d730690f461dc6048c8fd4d9bf49f9fc39829", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "extern closeMarketOne: [oneOutcome:[int256,int256,int256]:int256]", 
            "CLOSEONE = 0x8ce76311414e7ba3f5d0b8b5b34d262e760ecc24", 
            "extern closeMarketTwo: [twoOutcomes:[int256,int256[],int256[],int256]:int256]", 
            "CLOSETWO = 0xcd29dddf5ee743c458d16d8fae338834c9dd5c07", 
            "extern closeMarketFour: [fourOutcomes:[int256,int256[],int256[],int256]:int256]", 
            "CLOSEFOUR = 0x739dcfef11db3f02638b205f3043504001452b30", 
            "extern closeMarketEight: [eightOutcomes:[int256,int256[],int256[],int256]:int256]", 
            "CLOSEEIGHT = 0x36c4e967b672b81c505fd677768f76969b139f23", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern refund.se: [getBondPoster:[int256]:int256, getFinal:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getRoundTwo:[int256]:int256, setBondPoster:[int256,int256]:int256, setFinal:[int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setRoundTwo:[int256,int256]:int256]", 
            "BACKSTOPS = 0xea9e799a1bbf2b88090a4a4f39ef44df16e31bdf", 
            "extern makeReports: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, makeHash:[int256,int256,int256,int256]:int256, submitReport:[int256,int256,int256,int256]:int256, submitReportHash:[int256,int256]:int256, validateReport:[int256,int256,int256,int256,int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x45ec31e7768d81502bf9c022ad7fc4d27324838b", 
            "extern eventResolution: [catch:[int256]:int256, determineWinningOutcomes:[int256[],int256,int256,int256]:int256[], resolveBinary:[int256,int256,int256,int256,int256]:int256, resolveCategoricalOrScalar:[int256,int256,int256,int256,int256,int256,int256]:int256]", 
            "RESOLVE = 0x9bb51b5887354e66cb2ab2804bc875e65a31ccb5", 
            "inset('refund.se')", 
            "", 
            "# first param is the market, second param is the subcurrency contract", 
            "data cash[][]", 
            "", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "event thru(user:indexed, time)", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "# loop through events in the market, get their outcomes && use those to determine the winning events!", 
            "# distribute coins among winning events", 
            "# @return 0 if fail/trading not over yet/event not expired or closed already, if success 1", 
            "# Error messages otherwise", 
            "    # -1: Market has no cash anyway / already closed", 
            "    # -2: 0 outcome / not reported on yet", 
            "    # -3: not final round 2 event", 
            "    # -4: Outcome .5 once, pushback and retry", 
            "    # -5: Event forked and not final yet", 
            "    # -6: bonded pushed forward market not ready to be resolved", 
            "    # -7: event not reportable >.99", 
            "    # -8: market isn't in branch", 
            "# if market's events have moved due to a fork branch is the new fork", 
            "def closeMarket(branch, market):", 
            "    refund()", 
            "    if(MARKETS.getBranchID(market)!=branch):", 
            "        return(-8)", 
            "    if(CASH.balance(market)<=0):", 
            "        return(-1)", 
            "    numberEvents = MARKETS.getNumEvents(market)", 
            "    tradingPeriod = MARKETS.getTradingPeriod(market)", 
            "    period = BRANCHES.getVotePeriod(branch)", 
            "    events = array(3)", 
            "    events = MARKETS.getMarketEvents(market, outitems=3)", 
            "    i = 0", 
            "    reportingDone = 0", 
            "    resolved = 1", 
            "    while i < numberEvents:", 
            "        if(EVENTS.getOutcome(events[i])==0 && EVENTS.getmode(events[i])==0):", 
            "            resolved = 0", 
            "            i = numberEvents", 
            "        i += 1", 
            "    i = 0", 
            "    while i < numberEvents:", 
            "        numReports = EXPEVENTS.getNumReportsEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        numExpected = EXPEVENTS.getNumReportsExpectedEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        if(numReports == numExpected && numReports!=0 && numExpected!=0):", 
            "            reportingDone = 1", 
            "            i = numberEvents", 
            "        i += 1", 
            "    if((period > tradingPeriod || reportingDone) && !resolved):", 
            "        # loop through events in the market, get their outcomes && use those to determine the winning events!", 
            "        n = 0", 
            "        outcomeFour = 0", 
            "        outcomeSix = 0", 
            "        while n < numberEvents:", 
            "            votingPeriodEvent = EVENTS.getExpiration(events[n])/BRANCHES.getPeriodLength(branch)", 
            "            fxpOutcome = EVENTS.getOutcome(events[n])", 
            "            resolution = 1", 
            "            if(EVENTS.getUncaughtOutcome(events[n])==0):", 
            "                return(-2)", 
            "            if(BACKSTOPS.getRoundTwo(event) && !BACKSTOPS.getFinal(event)):", 
            "                return(-3)", 
            "            forkPeriod = BRANCHES.getForkPeriod(EVENTS.getEventBranch(events[n]))", 
            "            currentPeriod = block.timestamp / BRANCHES.getPeriodLength(branch)", 
            "            if((EVENTS.getForked(event) && !EVENTS.getForkedDone(event)) or (currentPeriod <= (forkPeriod+2))):", 
            "                return(-5)", 
            "            if(binary(events[n]) && fxpOutcome==0):", 
            "                    resolution = RESOLVE.resolveBinary(events[n], market, branch, votingPeriodEvent, msg.sender)", 
            "            elif(scalar(events[n]) && EVENTS.getmode(events[n])==0):", 
            "                    resolution = RESOLVE.resolveCategoricalOrScalar(EVENTS.getMinValue(events[n]), EVENTS.getMaxValue(events[n]), events[n], market, branch, votingPeriodEvent, msg.sender)", 
            "            elif(categorical(events[n]) && EVENTS.getmode(events[n])==0):", 
            "                    resolution = RESOLVE.resolveCategoricalOrScalar(ONE, ONE*EVENTS.getNumOutcomes(events[n]), events[n], market, branch, votingPeriodEvent, msg.sender)", 
            "            elif(resolution==-6):", 
            "                outcomeSix = 1", 
            "            n += 1", 
            "        if(outcomeFour):", 
            "            return(-4)", 
            "        elif(outcomeSix):", 
            "            return(-6)", 
            "        winningOutcomes = array(8)", 
            "        winningOutcomes = RESOLVE.determineWinningOutcomes(events, numberEvents, branch, market, outitems=8)", 
            "        MARKETS.setWinningOutcomes(market, winningOutcomes)", 
            "        MARKETS.refundClosing(MARKETS.getgasSubsidy(market), msg.sender)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# @return 1 if success", 
            "# Errors:", 
            "    # 0: reporting not done", 
            "    # -1: trader doesn't exist", 
            "def claimProceeds(branch, market):", 
            "    refund()", 
            "    if(MARKETS.getBranchID(market)!=branch):", 
            "        return(-8)", 
            "    numberEvents = MARKETS.getNumEvents(market)", 
            "    tradingPeriod = MARKETS.getTradingPeriod(market)", 
            "    period = BRANCHES.getVotePeriod(branch)", 
            "    events = array(3)", 
            "    events = MARKETS.getMarketEvents(market, outitems=3)", 
            "    i = 0", 
            "    reportingDone = 1", 
            "    resolved = 1", 
            "    while i < numberEvents:", 
            "        numReports = EXPEVENTS.getNumReportsEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        numExpected = EXPEVENTS.getNumReportsExpectedEvent(branch, EVENTS.getExpiration(events[i])/BRANCHES.getPeriodLength(branch), events[i])", 
            "        if(EVENTS.getOutcome(events[i])==0 && EVENTS.getmode(events[i])==0):", 
            "            resolved = 0", 
            "        if(numReports != numExpected && numReports!=0 and numExpected!=0):", 
            "            reportingDone = 0", 
            "            i = numberEvents", 
            "        i += 1", 
            "    if((period > tradingPeriod || reportingDone) && resolved):", 
            "        winningOutcomes = array(8)", 
            "        winningOutcomes = MARKET.getWinningOutcomes(market, outitems=8)", 
            "        outcome = 0", 
            "        # market not resolved", 
            "        if(winningOutcomes[0]==0):", 
            "            return(0)", 
            "        if(winningOutcomes[1]==0):", 
            "            outcome = CLOSEONE.oneOutcome(market, winningOutcomes[0], msg.sender)", 
            "        elif(winningOutcomes[7]):", 
            "            outcome = CLOSEEIGHT.eightOutcomes(market, winningOutcomes, events, msg.sender)", 
            "        elif(winningOutcomes[3]):", 
            "            outcome = CLOSEFOUR.fourOutcomes(market, winningOutcomes, events, msg.sender)", 
            "        elif(winningOutcomes[1]):", 
            "            outcome = CLOSETWO.twoOutcomes(market, winningOutcomes, events, msg.sender)", 
            "        return(outcome)", 
            "    else:", 
            "        return(0)", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro binary($event):", 
            "    (EVENTS.getNumOutcomes($event)==2 and ONE*EVENTS.getMaxValue($event)==TWO and EVENTS.getMinValue($event)==ONE)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "claimProceeds(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "closeMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "user", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "time", 
                        "type": "int256"
                    }
                ], 
                "name": "thru(int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern closeMarket: [claimProceeds:[int256,int256]:int256, closeMarket:[int256,int256]:int256]"
    }, 
    "closeMarketEight": {
        "address": "0x36c4e967b672b81c505fd677768f76969b139f23", 
        "code": [
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "inset('refund.se')", 
            "", 
            "# eight winning outcomes", 
            "def eightOutcomes(market, winningOutcome: arr, events: arr, sender):", 
            "    refund()", 
            "    outcomeOne = EVENTS.getOutcome(events[0])", 
            "    minValueOne = EVENTS.getMinValue(events[0])", 
            "    maxValueOne = EVENTS.getMaxValue(events[0])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[1])", 
            "    minValueTwo = EVENTS.getMinValue(events[1])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[1])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "    outcomeThree = EVENTS.getOutcome(events[2])", 
            "    minValueThree = EVENTS.getMinValue(events[2])", 
            "    maxValueThree = EVENTS.getMaxValue(events[2])", 
            "    if(outcomeThree>maxValueThree):", 
            "        outcomeThree = maxValueThree", 
            "    elif(outcomeThree<minValueThree):", 
            "        outcomeThree = minValueThree", 
            "", 
            "    outcomeOneHighSidePercent = ONE*(outcomeOne - minValueOne) / (maxValueOne - minValueOne)", 
            "    outcomeOneLowSidePercent = ONE - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = ONE*(outcomeTwo - minValueTwo) / (maxValueTwo - minValueTwo)", 
            "    outcomeTwoLowSidePercent = ONE - outcomeTwoHighSidePercent", 
            "    outcomeThreeHighSidePercent = ONE*(outcomeThree - minValueThree) / (maxValueThree - minValueThree)", 
            "    outcomeThreeLowSidePercent = ONE - outcomeThreeHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high", 
            "    pricePerShare = array(7)", 
            "    pricePerShare[0] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (ONE * ONE)", 
            "    pricePerShare[1] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (ONE * ONE)", 
            "    pricePerShare[2] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (ONE * ONE)", 
            "    pricePerShare[3] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (ONE * ONE)", 
            "    pricePerShare[4] = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)", 
            "    pricePerShare[5] = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)", 
            "    pricePerShare[6] = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)", 
            "    pricePerShare[7] = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (ONE * ONE)", 
            "", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, sender)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "", 
            "    # for each winning outcome do...", 
            "    n = 0", 
            "    while(winningOutcome[n]!=0):", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])", 
            "        MARKETS.modifyParticipantShares(market, participantNumber, winningOutcome[n], -sharesOwned)", 
            "        CASH.subtractCash(market, sharesOwned*pricePerShare[n]*MARKETS.getCumScale(market)/ONE)", 
            "        CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare[n]/ONE)", 
            "        n+=1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "eightOutcomes(int256,int256[],int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketEight: [eightOutcomes:[int256,int256[],int256[],int256]:int256]"
    }, 
    "closeMarketFour": {
        "address": "0x739dcfef11db3f02638b205f3043504001452b30", 
        "code": [
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "inset('refund.se')", 
            "", 
            "# four winning outcomes", 
            "def fourOutcomes(market, winningOutcome: arr, events: arr, sender):", 
            "    refund()", 
            "    # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high", 
            "    scalarOne = -1", 
            "    scalarTwo = -1", 
            "    if(((EVENTS.getMaxValue(events[0])!=TWO || EVENTS.getMinValue(events[0])!=ONE) && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*ONEHALF):", 
            "        scalarOne = 0", 
            "    if(((EVENTS.getMaxValue(events[1])!=TWO || EVENTS.getMinValue(events[1])!=ONE) && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*ONEHALF):", 
            "        if(scalarOne == -1):", 
            "            scalarOne = 1", 
            "        else:", 
            "            scalarTwo = 1", 
            "    elif(((EVENTS.getMaxValue(events[2])!=TWO || EVENTS.getMinValue(events[2])!=ONE) && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*ONEHALF):", 
            "        scalarTwo = 2", 
            "    outcomeOne = EVENTS.getOutcome(events[scalarOne])", 
            "    minValueOne = EVENTS.getMinValue(events[scalarOne])", 
            "    maxValueOne = EVENTS.getMaxValue(events[scalarOne])", 
            "    if(outcomeOne>maxValueOne):", 
            "        outcomeOne = maxValueOne", 
            "    elif(outcomeOne<minValueOne):", 
            "        outcomeOne = minValueOne", 
            "    outcomeTwo = EVENTS.getOutcome(events[scalarTwo])", 
            "    minValueTwo = EVENTS.getMinValue(events[scalarTwo])", 
            "    maxValueTwo = EVENTS.getMaxValue(events[scalarTwo])", 
            "    if(outcomeTwo>maxValueTwo):", 
            "        outcomeTwo = maxValueTwo", 
            "    elif(outcomeTwo<minValueTwo):", 
            "        outcomeTwo = minValueTwo", 
            "", 
            "    outcomeOneHighSidePercent = ONE*(outcomeOne - minValueOne) / (maxValueOne - minValueOne)", 
            "    outcomeOneLowSidePercent = ONE - outcomeOneHighSidePercent", 
            "    outcomeTwoHighSidePercent = ONE*(outcomeTwo - minValueTwo) / (maxValueTwo - minValueTwo)", 
            "    outcomeTwoLowSidePercent = ONE - outcomeTwoHighSidePercent", 
            "", 
            "    # price is in fixed point", 
            "    # share four goes with the high-high side", 
            "    pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / ONE", 
            "    # share three goes with the low-high side", 
            "    pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / ONE", 
            "    # share two goes with the high-low side", 
            "    pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / ONE", 
            "    # share one goes with the low-low", 
            "    # both fixed point so div by ONE to keep in fixed point", 
            "    pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / ONE", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, sender)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "    n = 0", 
            "    while(winningOutcome[n]!=0):", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])", 
            "        MARKETS.modifyParticipantShares(market, participantNumber, winningOutcome[n], -sharesOwned)", 
            "        # low-low", 
            "        if(n==0):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare1/ONE)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare1/ONE)", 
            "        # high-low", 
            "        elif(n==1):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare2/ONE)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare2/ONE)", 
            "        # low-high", 
            "        elif(n==2):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare3/ONE)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare3/ONE)", 
            "        # high-high", 
            "        elif(n==3):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare4/ONE)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare4/ONE)", 
            "        n+=1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "fourOutcomes(int256,int256[],int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketFour: [fourOutcomes:[int256,int256[],int256[],int256]:int256]"
    }, 
    "closeMarketOne": {
        "address": "0x8ce76311414e7ba3f5d0b8b5b34d262e760ecc24", 
        "code": [
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "inset('refund.se')", 
            "", 
            "# mutex result non scalar not .5", 
            "# one winning outcome", 
            "def oneOutcome(market, winningOutcome, sender):", 
            "    refund()", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, sender)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "    MARKETS.modifyParticipantShares(market, participantNumber, winningOutcome, -sharesOwned)", 
            "    CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)/ONE)", 
            "    CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)/ONE)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "oneOutcome(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketOne: [oneOutcome:[int256,int256,int256]:int256]"
    }, 
    "closeMarketTwo": {
        "address": "0xcd29dddf5ee743c458d16d8fae338834c9dd5c07", 
        "code": [
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "inset('refund.se')", 
            "", 
            "# # of winningOutcomes is 2", 
            "def twoOutcomes(market, winningOutcome: arr, events: arr, sender):", 
            "    refund()", 
            "    # look for the scalar", 
            "    scalar = 0", 
            "    if(((EVENTS.getMaxValue(events[0])!=TWO || EVENTS.getMinValue(events[0])!=ONE) && EVENTS.getNumOutcomes(events[0])==2) || EVENTS.getOutcome(events[0])==3*ONEHALF):", 
            "        scalar = 0", 
            "    elif(((EVENTS.getMaxValue(events[1])!=TWO || EVENTS.getMinValue(events[1])!=ONE) && EVENTS.getNumOutcomes(events[1])==2) || EVENTS.getOutcome(events[1])==3*ONEHALF):", 
            "        scalar = 1", 
            "    elif(((EVENTS.getMaxValue(events[2])!=TWO || EVENTS.getMinValue(events[2])!=ONE) && EVENTS.getNumOutcomes(events[2])==2) || EVENTS.getOutcome(events[2])==3*ONEHALF):", 
            "        scalar = 2", 
            "    outcome = EVENTS.getOutcome(events[scalar])", 
            "    minValue = EVENTS.getMinValue(events[scalar])", 
            "    maxValue = EVENTS.getMaxValue(events[scalar])", 
            "    if(outcome>maxValue):", 
            "        outcome = maxValue", 
            "    elif(outcome<minValue):", 
            "        outcome = minValue", 
            "    # price is in fixed point", 
            "    # share two goes with the high side", 
            "    pricePerShare2 = ONE*(outcome - minValue) / (maxValue - minValue)", 
            "    #share one goes with the low side of the calc", 
            "    pricePerShare1 = ONE - pricePerShare1", 
            "    # distribute cashcoin to the people who won money by holding winning shares", 
            "    participantNumber = MARKETS.getParticipantNumber(market, sender)", 
            "    if(participantNumber == -1):", 
            "        return(-1)", 
            "    participant = MARKETS.getParticipantID(market, participantNumber)", 
            "    # for each winning outcome do...", 
            "    n = 0", 
            "    while(winningOutcome[n]!=0):", 
            "        sharesOwned = MARKETS.getParticipantSharesPurchased(market, participantNumber, winningOutcome[n])", 
            "        MARKETS.modifyParticipantShares(market, participantNumber, winningOutcome[n], -sharesOwned)", 
            "        # low side", 
            "        if(n==0):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare1/ONE)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare1/ONE)", 
            "        # high side (of the scalar part)", 
            "        elif(n==1):", 
            "            CASH.subtractCash(market, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare2/ONE)", 
            "            CASH.addCash(participant, sharesOwned*MARKETS.getCumScale(market)/ONE*pricePerShare2/ONE)", 
            "        n+=1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "winningOutcome", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "twoOutcomes(int256,int256[],int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern closeMarketTwo: [twoOutcomes:[int256,int256[],int256[],int256]:int256]"
    }, 
    "collectFees": {
        "address": "0xcc36d11d39b0df7303163282855b67c8614cc9b6", 
        "code": [
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern consensus: [getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getRRDone:[int256,int256]:int256, incrementPeriodAfterReporting:[int256]:int256, initialPenalizedSetting:[int256,int256,int256]:int256, penalizationCatchup:[int256]:int256, penalizeWrong:[int256,int256]:int256, proportionCorrect:[int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256]", 
            "CONSENSUS = 0xdb03844ecc9b9cb26af853b07fea7199b5590665", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "inset('refund.se')", 
            "", 
            "data feeFirst[][]", 
            "data periodBalance[][]", 
            "", 
            "# -2: needs to be second half of reporting period to claim rep [1st half is when redistribution is done]", 
            "    # after this window, any unclaimed rep is pushed to the next period's redistrib. pool via the first make report submission", 
            "def collectFees(branch):", 
            "    refund()", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual < periodLength/2):", 
            "        return(-2)", 
            "    if(!CONSENSUS.getRRDone(branch, msg.sender)):", 
            "        # need to call penalize for all events and penalize for too lazy to report or catchup if necessary", 
            "        return(-1)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch) - 1", 
            "    if(!CONSENSUS.getFeesCollected(branch, msg.sender, lastPeriod) && EXPEVENTS.getReportedPeriod(branch, lastPeriod, msg.sender)):", 
            "        newRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender)", 
            "        denominator = CONSENSUS.getDenominator(branch, lastPeriod)", 
            "        if(!self.feeFirst[branch][lastPeriod]):", 
            "            self.feeFirst[branch][lastPeriod] = 1", 
            "            self.periodBalance[branch][lastPeriod] = REPORTING.getRepBalance(branch, branch)", 
            "        gainedRep = newRep * ONE / denominator * self.periodBalance[branch][lastPeriod] / ONE", 
            "        #if(lostRep) newRep should be == EXPEVENTS.getAfterRep(branch, period, msg.sender) + gainedRep", 
            "        #if(gainedRep) newRep should be == EXPEVENTS.getBeforeRep(branch, period, msg.sender) + gainedRep", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), gainedRep)", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, branch), gainedRep)", 
            "        cash = BRANCHES.getInitialBalance(branch, lastPeriod) * newRep / denominator", 
            "        CASH.addCash(msg.sender, cash)", 
            "        CASH.subtractCash(branch, cash)", 
            "        CONSENSUS.setFeesCollected(branch, msg.sender, lastPeriod)", 
            "        return(1)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "collectFees(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern collectFees: [collectFees:[int256]:int256]"
    }, 
    "completeSets": {
        "address": "0x227a05d6a894e87103fa15b180e61f4a90c944f0", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "inset('refund.se')", 
            "", 
            "# buys amount of every outcome", 
            "# cost 850k gas", 
            "def buyCompleteSets(market, amount):", 
            "    refund()", 
            "    branch = MARKETS.getBranchID(market)", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        return(-1)", 
            "    numOutcomes = MARKETS.getMarketNumOutcomes(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    cost = amount*cumScale/ONE", 
            "    if(CASH.balance(msg.sender) < price):", 
            "        return(-3)", 
            "    participantNumber = MARKETS.getParticipantNumber(market, msg.sender)", 
            "    # if participant doesn't exist in market, add them", 
            "    if(msg.sender != MARKETS.getParticipantID(market, participantNumber)):", 
            "        participantNumber = MARKETS.addParticipant(market, msg.sender)", 
            "    i = 1", 
            "    # send shares of the event to user address", 
            "    while i <= numOutcomes:", 
            "        MARKETS.modifyShares(market, i, amount)", 
            "        MARKETS.modifyParticipantShares(market, participantNumber, i, amount, 0)", 
            "        i += 1", 
            "    if(BRANCHES.getVotePeriod(branch)<MARKETS.getTradingPeriod(market)):", 
            "        MARKETS.modifySharesValue(market, amount*cumScale/ONE)", 
            "        EXPEVENTS.adjustPeriodShareValueOutstanding(branch, MARKETS.getTradingPeriod(market), amount*cumScale/ONE)", 
            "    # send money from user acc. to market address/account", 
            "    CASH.sendFrom(market, cost, msg.sender)", 
            "    return(1)", 
            "", 
            "", 
            "# sells amount of every outcome [if user owns it]", 
            "def sellCompleteSets(market, amount):", 
            "    refund()", 
            "    branch = MARKETS.getBranchID(market)", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        return(-1)", 
            "    participantNumber = MARKETS.getParticipantNumber(market, msg.sender)", 
            "    numOutcomes = MARKETS.getMarketNumOutcomes(market)", 
            "    cumScale = MARKETS.getCumScale(market)", 
            "    branch = MARKETS.getBranchID(market)", 
            "    if(MARKETS.getParticipantID(market, participantNumber) != msg.sender):", 
            "        return(-2)", 
            "    # these prices are in fixed point", 
            "    cost = amount*cumScale/ONE", 
            "    i = 1", 
            "    while i <= numOutcomes:", 
            "        if(MARKETS.getParticipantSharesPurchased(market, participantNumber, i) < amount):", 
            "            return(-3)", 
            "        i += 1", 
            "    i = 1", 
            "    while i <= numOutcomes:", 
            "        MARKETS.modifyShares(market, i, -amount)", 
            "        MARKETS.modifyParticipantShares(market, participantNumber, i, -amount, 0)", 
            "        i += 1", 
            "    if(BRANCHES.getVotePeriod(branch)<MARKETS.getTradingPeriod(market)):", 
            "        MARKETS.modifySharesValue(market, -amount*cumScale/ONE)", 
            "        EXPEVENTS.adjustPeriodShareValueOutstanding(branch, MARKETS.getTradingPeriod(market), -amount*cumScale/ONE)", 
            "    # send funds from the market to the user acc.", 
            "    CASH.subtractCash(market, cost)", 
            "    CASH.addCash(msg.sender, cost)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "buyCompleteSets(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "sellCompleteSets(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern completeSets: [buyCompleteSets:[int256,int256]:int256, sellCompleteSets:[int256,int256]:int256]"
    }, 
    "consensus": {
        "address": "0xdb03844ecc9b9cb26af853b07fea7199b5590665", 
        "code": [
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "extern refund.se: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0xf641656dfeae64f3cdc4bdaf75d9e6b131135968", 
            "extern makeReports: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, makeHash:[int256,int256,int256,int256]:int256, submitReport:[int256,int256,int256,int256]:int256, submitReportHash:[int256,int256]:int256, validateReport:[int256,int256,int256,int256,int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x45ec31e7768d81502bf9c022ad7fc4d27324838b", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern refund.se: [getBondPoster:[int256]:int256, getFinal:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getRoundTwo:[int256]:int256, setBondPoster:[int256,int256]:int256, setFinal:[int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setRoundTwo:[int256,int256]:int256]", 
            "BACKSTOPS = 0xea9e799a1bbf2b88090a4a4f39ef44df16e31bdf", 
            "inset('refund.se')", 
            "", 
            "", 
            "# todo move to consensus data_api and backstops for round 2", 
            "# round two consensus data [note/todo: UI should show round 2 events first / up top]", 
            "data bondPaid[]", 
            "data roundTwo[](roundTwo, originalVotePeriod, originalOutcome, final)", 
            "data baseReportersLastPeriod[]", 
            "", 
            "event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)", 
            "", 
            "def init():", 
            "    self.baseReportersLastPeriod[1010101] = 2*3", 
            "", 
            "# todo: make it 0.98 * old rep + 0.02 * new rep", 
            "# (1-k) * old rep + k * new rep where k = 0.2 / (number of events you reported on last period)", 
            "", 
            "", 
            "# branch takes a branchID", 
            "    # denominator takes a vote period", 
            "    # penalized takes for a given period a user / address reported for a certain event and num of events they reported on in that period in total", 
            "    # penalizedUpTo is the latest period a user has done the penalization for", 
            "    # fees collected states whether for a given period a user collected fees", 
            "    # rep collected states whether for a given period a user collected rep", 
            "data branch[](denominator[], penalized[][](event[], num, notEnoughReportsPenalized), penalizedUpTo[], feesCollected[][])", 
            "", 
            "def getFeesCollected(branch, address, period):", 
            "    return(self.branch[branch].feesCollected[period][address])", 
            "", 
            "def setFeesCollected(branch, address, period):", 
            "    self.branch[branch].feesCollected[period][address] = 1", 
            "    return(1)", 
            "", 
            "def setNotEnoughPenalized(branch, address, period):", 
            "    self.branch[branch].penalized[period][address].notEnoughReportsPenalized = 1", 
            "    return(1)", 
            "", 
            "def getNotEnoughPenalized(branch, address, period):", 
            "    return(self.branch[branch].penalized[period][address].notEnoughReportsPenalized)", 
            "", 
            "def getBaseReportersLastPeriod(branch):", 
            "    return(self.baseReportersLastPeriod[branch])", 
            "", 
            "def initialPenalizedSetting(branch, reporter, upto):", 
            "    refund()", 
            "    self.branch[branch].penalizedUpTo[reporter] = upto", 
            "    return(1)", 
            "", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "#1. Record rep at start of report period [before rep in make reports]", 
            "#2. Penalize for each event", 
            "#3. Each reporter needs to do this for all events they reported on, if not get docked", 
            "#4. For first half of the new period, people can do penalization for the last period, for the second half users have to claim rep then trading fees", 
            "#5. If you don't do it for all events or don't penalize for not reporting enough, autolose 20% rep each period one does this (b/c they're trying to cheat)", 
            "# Errors:", 
            "    # -1: pushed forward event already resolved, so can't redistribute rep based off of its original expected expiration period", 
            "    # -2: already past first half of new period and needed to penalize before then", 
            "    # -3: need to do not enough reports penalization [or lackthereof]", 
            "# roundTwoResolve needs to be called for any event here before can be penalized if it's a backstop 1 event, a la close market for other events before being penalized", 
            "# always use uncaught + caught version as opposed to actual outcome for this to be safe wrt ethicality / diff. for payouts", 
            "# make max rep loss 20%, do V way to limit excess cuts", 
            "def penalizeWrong(branch, event):", 
            "    refund()", 
            "    repBalance = REPORTING.getRepBalance(branch, msg.sender)", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    afterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender)", 
            "    if(BRANCHES.getForkPeriod(branch) == lastPeriod && penalizedForkedEventIfReportedOn && !penalizeduptolastperiod):", 
            "        self.branch[branch].penalized[lastPeriod][msg.sender].num += EXPEVENTS.getNumReportsActual(branch, lastPeriod, msg.sender)", 
            "        self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod", 
            "        self.branch[branch].denominator[lastPeriod] += afterRep", 
            "        return(1)", 
            "    elif(BRANCHES.getForkPeriod(branch) == lastPeriod):", 
            "        return(-10)", 
            "    if(BRANCHES.getForkPeriod(branch)+1 == lastPeriod && !penalizeduptolastperiod):", 
            "        self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod", 
            "        self.branch[branch].denominator[lastPeriod] += afterRep", 
            "        return(1)", 
            "    elif(BRANCHES.getForkPeriod(branch)+1 == lastPeriod):", 
            "        return(-11)", 
            "    if(EVENTS.getForked(event)):", 
            "        return(0)", 
            "    if(!self.branch[branch].penalized[lastPeriod][msg.sender].notEnoughReportsPenalized):", 
            "        return(-3)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual > periodLength/2):", 
            "        return(-2)", 
            "    # accounts for if no events in a period", 
            "    if(EXPEVENTS.getNumberEvents(branch, lastPeriod)==0):", 
            "        self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod", 
            "        self.branch[branch].denominator[lastPeriod] += afterRep", 
            "        return(1)", 
            "", 
            "    if(EVENTS.getOriginalExpiration(event)!=EVENTS.getExpiration(event) && MARKETS.getPushedForward(market)):", 
            "        if(lastPeriod==EVENTS.getOriginalExpiration(event)/BRANCHES.getPeriodLength(branch)):", 
            "            return(-1)", 
            "", 
            "    newRep = 0", 
            "    outcome = catch(EVENTS.getUncaughtOutcome(event))", 
            "    reportValue = EXPEVENTS.getReport(branch, lastPeriod, event, msg.sender)", 
            "    oldRep = EXPEVENTS.getBeforeRep(branch, lastPeriod, msg.sender)", 
            "    p = self.proportionCorrect(event)", 
            "    if(scalar(event) or categorical(event)):", 
            "        outcome = EVENTS.getUncaughtOutcome(event)", 
            "", 
            "    # for a reporter for last period if they reported on it the first time [a round 2 event], prevent them from reporting on it, but still do the rep redistrib. at the end before returning in case this event is the last one a user submits for reporting and increment the num b/c it shouldn't be penalized until the next period resolution is over", 
            "    if(BACKSTOPS.getRoundTwo(event) && !self.branch[branch].penalized[lastPeriod][msg.sender].event[event] && reportValue && outcome!=0):", 
            "        self.branch[branch].penalized[lastPeriod][msg.sender].event[event] = 1", 
            "        self.branch[branch].penalized[lastPeriod][msg.sender].num += 1", 
            "        if(EXPEVENTS.getNumReportsActual(branch, lastPeriod, msg.sender)==self.branch[branch].penalized[lastPeriod][msg.sender].num):", 
            "            newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender)", 
            "            if(newAfterRep <= 0):", 
            "                newAfterRep = 0", 
            "                EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)", 
            "            self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod", 
            "            self.branch[branch].denominator[lastPeriod] += newAfterRep", 
            "            totalRepDifference = newAfterRep - oldRep", 
            "            if(repBalance + totalRepDifference <= 0):", 
            "                totalRepDifference = -1*repBalance", 
            "            if(totalRepDifference<0):", 
            "                # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), totalRepDifference)", 
            "                # sends that rep to the branch", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), -totalRepDifference)", 
            "    if(!self.branch[branch].penalized[lastPeriod][msg.sender].event[event] && reportValue && outcome!=0):", 
            "        # wrong", 
            "        #184467440737095520 == 0.01 in fxp", 
            "        if(reportValue > outcome+184467440737095520 or reportValue < outcome-184467440737095520):", 
            "            if(scalar(event) or categorical(event) or outcome==3*ONE):", 
            "                # makes it so 1.5 penalty isn't super harsh for a scalar / categorical", 
            "                if(outcome == 3*ONEHALF && (scalar(event) or categorical(event))):", 
            "                    reportValue += ONE", 
            "                diff = reportValue - outcome", 
            "                p = -(abs(diff)/2) + ONE", 
            "            newRep = oldRep*(2*p - ONE)/ONE", 
            "        # right", 
            "        else:", 
            "            if(scalar(event) or categorical(event) or outcome==3*ONE):", 
            "                # makes it so 1.5 penalty isn't super harsh for a scalar / categorical", 
            "                if(outcome == 3*ONEHALF && (scalar(event) or categorical(event))):", 
            "                    reportValue += ONE", 
            "                diff = reportValue - outcome", 
            "                p = -(abs(diff)/2) + ONE", 
            "            newRep = oldRep*(2*(ONE-p)**2 / p + ONE)/ONE", 
            "        #smoothedRep = oldRep*.8 + newRep*.2", 
            "        smoothedRep = oldRep * 14757395258967642112/ONE + newRep * 3689348814741910528/ONE", 
            "        repChange = smoothedRep - oldRep", 
            "        newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender) + repChange", 
            "        log(type=penalize, msg.sender, outcome, oldRep, repChange, newAfterRep, p, reportValue)", 
            "        EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)", 
            "        self.branch[branch].penalized[lastPeriod][msg.sender].event[event] = 1", 
            "        self.branch[branch].penalized[lastPeriod][msg.sender].num += 1", 
            "        if(EXPEVENTS.getNumReportsActual(branch, lastPeriod, msg.sender)==self.branch[branch].penalized[lastPeriod][msg.sender].num):", 
            "            if(newAfterRep <= 0):", 
            "                newAfterRep = 0", 
            "                EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)", 
            "            self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod", 
            "            self.branch[branch].denominator[lastPeriod] += newAfterRep", 
            "            totalRepDifference = newAfterRep - oldRep", 
            "            if(repBalance + totalRepDifference <= 0):", 
            "                totalRepDifference = -1*repBalance", 
            "            if(totalRepDifference<0):", 
            "                # removes rep from reporter who lost it [those who gained rep will get it in the claim rep phase]", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), totalRepDifference)", 
            "                # sends that rep to the branch", 
            "                REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), -totalRepDifference)", 
            "    return(1)", 
            "", 
            "def getDenominator(branch, period):", 
            "    refund()", 
            "    return(self.branch[branch].denominator[period])", 
            "", 
            "# call when a user who hasn't reported for a while wants to start again and needs to catch up on penalizations", 
            "# ex:", 
            "    #period 0 voteperiod -1 - last period penalized should be -1 or starting vote period", 
            "    #add some events to period 0", 
            "    #increment", 
            "    #period 1 voteperiod 0 - shouldn't be penalizing anything yet", 
            "    #increment", 
            "    #period 2 voteperiod 1 - penalize voteperiod 0", 
            "# ex 2:", 
            "    #currently in period 100, voteperiod 99 - last period penalized up to should be 99 or starting vote period", 
            "    #add some events to period 100", 
            "    #increment to period 101", 
            "    #period 101, voteperiod 100 - shouldn't be penalizing anything yet", 
            "    #increment", 
            "    #period 102, voteperiod 101 - penalize voteperiod 100", 
            "def penalizationCatchup(branch):", 
            "    refund()", 
            "    # should only be allowed in 1st half of any period b/c rep removal / sending to branch should only be done then", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual > periodLength/2):", 
            "        return(-2)", 
            "    # find delta between this last period and last penalized up to", 
            "    lastPeriodPenalized = self.branch[branch].penalizedUpTo[msg.sender]", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    delta = lastPeriod - lastPeriodPenalized", 
            "    oldRep = REPORTING.getRepBalance(branch, msg.sender)", 
            "    if(lastPeriodPenalized!=lastPeriod && !hasReported(branch, lastPeriod)):", 
            "        if(delta <= 0):", 
            "            return(0)", 
            "        # dock 10% for each period they didn't penalize on", 
            "        #smoothedRep = oldRep*16602069666338596864/ONE", 
            "        smoothedRep = oldRep*18262276632972455936/ONE", 
            "        i = 1", 
            "        if(delta>22):", 
            "            #smoothedRep = smoothedRep*1844674407370955264/ONE", 
            "            smoothedRep = smoothedRep*18262276632972455936/ONE", 
            "            delta = 0", 
            "        while i < delta:", 
            "            #smoothedRep = smoothedRep*16602069666338596864/ONE", 
            "            smoothedRep = smoothedRep*18262276632972455936/ONE", 
            "            i += 1", 
            "        # and send it to branch for penalty rep collection", 
            "        repChange = oldRep - smoothedRep", 
            "        # removes rep from reporter who lost it", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, msg.sender), repChange)", 
            "        # sends that rep to the branch rep pool", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), repChange)", 
            "        self.branch[branch].penalizedUpTo[msg.sender] = lastPeriod", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# ui has to call this to stay cheap / not check it elsewhere", 
            "def incrementPeriodAfterReporting(branch):", 
            "    refund()", 
            "    # do this after reporting is finished", 
            "    if(periodOver(branch)):", 
            "        period = block.timestamp / BRANCHES.getPeriodLength($branch) - 1", 
            "        lastPeriod = period - 1", 
            "        percentAppealed = (EXPEVENTS.getNumRoundTwo(branch, period)*ONE/EXPEVENTS.getNumberEvents(branch, period) + EXPEVENTS.getNumRoundTwo(branch, lastPeriod)*ONE/EXPEVENTS.getNumberEvents(branch, lastPeriod)) / 2", 
            "        BRANCHES.incrementPeriod(branch)", 
            "        # mult. by 2 b/c reporters only have to report on half the things they're selected to report on", 
            "        base_reporter_quantity = 2*(3*ONE + ((333*ONE * Percent_Appealed/ONE)**3 / 2**128))/ONE", 
            "        self.baseReportersLastPeriod[branch] = BRANCHES.getBaseReporters(branch)", 
            "        BRANCHES.setBaseReporters(branch, base_reporter_quantity)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "### Helper functions:", 
            "", 
            "macro abs($a):", 
            "    if($a<0):", 
            "        $a = -$a", 
            "    $a", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "def proportionCorrect(event):", 
            "    refund()", 
            "    p = 0", 
            "    outcome = catch(EVENTS.getUncaughtOutcome(event))", 
            "    if(outcome!=0):", 
            "        # binary", 
            "        if(EVENTS.getNumOutcomes(event)==2 and EVENTS.getMaxValue(event)==TWO and EVENTS.getMinValue(event)==ONE):", 
            "            # subtract 1 to get it from 0 to 1", 
            "            avgOutcome = EVENTS.getUncaughtOutcome(event) - ONE", 
            "            # say we have outcome of 0, avg is .4, what is p?", 
            "            # p is .6 or 60%", 
            "            if(outcome == ONE):", 
            "                p = ONE - avgOutcome", 
            "            # say we have outcome of 1, avg is .8, what is p (proportion correct)?", 
            "            # p is .8 or 80%", 
            "            if(outcome == 2 * ONE):", 
            "                p = avgOutcome", 
            "            if(outcome == 3 * ONEHALF):", 
            "                return(0)", 
            "        return(p)", 
            "    else:", 
            "        return(0)", 
            "", 
            "macro periodOver($branch):", 
            "    # what the current vote period should be", 
            "    currentVotePeriod = block.timestamp / BRANCHES.getPeriodLength($branch) - 1", 
            "    # if actual vote period is less than what the current one should be, return 1, it can be incremented", 
            "    if(BRANCHES.getVotePeriod($branch) < currentVotePeriod):", 
            "        1", 
            "    else:", 
            "        0", 
            "", 
            "macro hasReported($branch, $period):", 
            "    EXPEVENTS.getReportedPeriod($branch, $period, msg.sender)", 
            "", 
            "macro repRedistributionDone($branch, $reporter):", 
            "    lastPeriodPenalized = self.branch[$branch].penalizedUpTo[$reporter]", 
            "    lastPeriod = BRANCHES.getVotePeriod($branch)-1", 
            "    if(lastPeriod==lastPeriodPenalized):", 
            "        1", 
            "    else:", 
            "        0", 
            "", 
            "def getRRDone(branch, reporter):", 
            "    refund()", 
            "    return(repRedistributionDone(branch, reporter))", 
            "", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro binary($event):", 
            "    (EVENTS.getNumOutcomes($event)==2 and EVENTS.getMaxValue($event)==TWO and EVENTS.getMinValue($event)==ONE)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)", 
            "", 
            "", 
            "# test bonded pushed forward event/market though not ready to be resolved", 
            "    # code in penalize for that:", 
            "        #elif(rejected && rejectedPeriodOver && && actuallyrejected && EXPEVENTS.getReport(branch, lastPeriodperiod, event, msg.sender) && !self.penalized[lastPeriod][msg.sender].event[event] && outcome):", 
            "        #  outcome = ONEHALF", 
            "        #  mode = ONEHALF", 
            "        #   p = self.proportionCorrect(event, rejected)", 
            "        #   oldRep = EXPEVENTS.getBeforeRep(branch, period, msg.sender)", 
            "        #   # wrong", 
            "        #   if(reportValue > outcome+.01 or reportValue < outcome-.01):", 
            "        #       if(scalar or categorical or .5):", 
            "        #         # scalar/cat are 0 - 1, binary .5 are 1-2 and 1.5", 
            "        #     # should be outcome since mode is the same", 
            "        #           p = -(abs(reportValue - mode)/2) + 1", 
            "        #       newRep = oldRep*(2*p -1)", 
            "        #   # right", 
            "        #   else:", 
            "        #       if(scalar or categorical or .5):", 
            "        #           p = -(abs(reportValue - mode)/2) + 1", 
            "        #       newRep = oldRep*(2*(1-p)**2 / p + 1)", 
            "        #   smoothedRep = oldRep*.8 + newRep*.2", 
            "        #   EXPEVENTS.setAfterRep(branch, period, oldRep + (smoothedRep - oldRep), msg.sender)", 
            "        # repChange = smoothedRep - oldRep", 
            "        # if(repChange < 0):", 
            "        #   sendToRedistribPool", 
            "        # # need to except round two events from this when added", 
            "        # if(EXPEVENTS.getNumReportsActual(branch, lastPeriod, msg.sender)==self.penalized[lastPeriod][msg.sender].num):", 
            "        #   self.totalRepPenalized[period] += oldRep", 
            "        #   self.denominator[branch][period] = self.totalRepPenalized[period] + (smoothedRep - oldRep)", 
            "        # self.penalized[lastPeriod][msg.sender].event[event] = 1", 
            "        # self.penalized[lastPeriod][msg.sender].num += 1", 
            "        #   return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getBaseReportersLastPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getDenominator(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getFeesCollected(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getNotEnoughPenalized(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "getRRDone(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "incrementPeriodAfterReporting(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "upto", 
                        "type": "int256"
                    }
                ], 
                "name": "initialPenalizedSetting(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizationCatchup(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizeWrong(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "proportionCorrect(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setFeesCollected(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setNotEnoughPenalized(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "user", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "oldrep", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "repchange", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "newafterrep", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "p", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "reportValue", 
                        "type": "int256"
                    }
                ], 
                "name": "penalize(int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern consensus: [getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getRRDone:[int256,int256]:int256, incrementPeriodAfterReporting:[int256]:int256, initialPenalizedSetting:[int256,int256,int256]:int256, penalizationCatchup:[int256]:int256, penalizeWrong:[int256,int256]:int256, proportionCorrect:[int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256]"
    }, 
    "createBranch": {
        "address": "0x45b70449612454df986ed62873cbfb81889abaca", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x254d730690f461dc6048c8fd4d9bf49f9fc39829", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "inset('refund.se')", 
            "", 
            "# period length is given in blocks", 
            "# @return branchID if success", 
            "# error messages otherwise", 
            "    # -1: bad input or parent doesn't exist", 
            "    # -2: no money for creation fee or branch already exists", 
            "def createSubbranch(description:str, periodLength, parent, tradingFee, oracleOnly):", 
            "    refund()", 
            "    if(periodLength<=0 || !BRANCHES.getPeriodLength(parent) || description==0):", 
            "        return(-1)", 
            "", 
            "    if(tradingFee < 0 or tradingFee > 2**62):", 
            "        return(-1)", 
            "    parentPeriod = BRANCHES.getVotePeriod(parent)", 
            "", 
            "    branchInfo = string(8*32+len(description))", 
            "    branchInfo[0] = BRANCH                                      #typecode", 
            "    branchInfo[1] = tx.origin                                   #creator address", 
            "    branchInfo[2] = 47*ONE                                     #creation fee", 
            "    branchInfo[3] = periodLength                                #length of voting cycle", 
            "    branchInfo[4] = block.timestamp                             #current blocktime", 
            "    branchInfo[5] = parent                                      #branchID of parent branch", 
            "    branchInfo[6] = tradingFee", 
            "    branchInfo[7] = oracleOnly", 
            "    mcopy(branchInfo+ 8*32, description, len(description))", 
            "    # people can check that these characteristics hash to the ID if they want", 
            "    # people can hand a friend their new branch hash && characteristics && say, \"don't trust me? check\"", 
            "    branchID = sha256(branchInfo, chars=len(branchInfo))", 
            "    currentVotePeriod = (block.timestamp / periodLength) - 1", 
            "    if(INFO.getCreator(branchID)==0):", 
            "        BRANCHES.initializeBranch(branchID, currentVotePeriod, periodLength, tradingFee, oracleOnly, parentPeriod, parent)", 
            "    else:", 
            "        return(-2)", 
            "    if(INFO.getCreator(parent) && CASH.sendFrom(parent, 47*ONE, msg.sender) && INFO.setInfo(branchID, description, tx.origin, 47*ONE) && REPORTING.setInitialReporters(parent, branchID)):", 
            "        return(branchID)", 
            "    else:", 
            "        return(-2)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "periodLength", 
                        "type": "int256"
                    }, 
                    {
                        "name": "parent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "oracleOnly", 
                        "type": "int256"
                    }
                ], 
                "name": "createSubbranch(bytes,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createBranch: [createSubbranch:[bytes,int256,int256,int256,int256]:int256]"
    }, 
    "createEvent": {
        "address": "0x1401ffedec68b82cfa9225c24f35725b998ccce3", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x254d730690f461dc6048c8fd4d9bf49f9fc39829", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "inset('refund.se')", 
            "", 
            "# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0", 
            "# to 11.0 would be 11 outcomes (if incremented by 0.1)", 
            "# @return eventID if success", 
            "# error messages otherwise", 
            "    # -1: we're either already past that date, branch doesn't exist, or description is bad", 
            "    # 0: not enough money to pay fees or event already exists", 
            "    # -2: max value < min value", 
            "# .025 eth to create", 
            "def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution: str):", 
            "    refund()", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    forkPeriod = BRANCHES.getForkPeriod(branch)", 
            "    if(forkPeriod && ((expDate / periodLength)==forkPeriod or (expDate / periodLength)==(forkPeriod+1))):", 
            "        return(-9)", 
            "    if(maxValue < minValue or (maxValue-minValue) < ONE):", 
            "        return(-2)", 
            "    eventID = 0", 
            "    if(periodLength && description != 0 && expDate > block.timestamp):", 
            "        eventinfo = string(8*32 + len(description))", 
            "        eventinfo[0] = EVENT                                        #typecode", 
            "        eventinfo[1] = branch                                       #branchID", 
            "        eventinfo[2] = expDate                                      #expiration date", 
            "        eventinfo[3] = msg.sender                                   #creator address", 
            "        eventinfo[4] = periodLength", 
            "        eventinfo[5] = minValue                                     #minimum outcome value", 
            "        eventinfo[6] = maxValue                                     #maximum outcome value", 
            "        eventinfo[7] = numOutcomes                                  #number of outcomes", 
            "        mcopy(eventinfo + 8*32, description, len(description))", 
            "        eventID = sha256(eventinfo, chars=len(eventinfo))", 
            "    else:", 
            "        return(-1)", 
            "    if(numOutcomes < 2 || numOutcomes > 8):", 
            "        return(0)", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    CASH.initiateOwner(eventID)", 
            "    if(!INFO.getCreator(eventID)):", 
            "        # see which future period it expires in && put the event in that bin", 
            "        # event voting periods - expDate / periodLength gives you the voting period #", 
            "        futurePeriod = expDate / periodLength", 
            "        if(INFO.setInfo(eventID, description, msg.sender, 0) && EVENTS.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes, resolution)):", 
            "            return(eventID)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "expDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "name": "resolution", 
                        "type": "bytes"
                    }
                ], 
                "name": "createEvent(int256,bytes,int256,int256,int256,int256,bytes)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createEvent: [createEvent:[int256,bytes,int256,int256,int256,int256,bytes]:int256]"
    }, 
    "createMarket": {
        "address": "0x902d91cc483c77da3be9b62b5060314887fb99d5", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x254d730690f461dc6048c8fd4d9bf49f9fc39829", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "extern makeReports: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, makeHash:[int256,int256,int256,int256]:int256, submitReport:[int256,int256,int256,int256]:int256, submitReportHash:[int256,int256]:int256, validateReport:[int256,int256,int256,int256,int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x45ec31e7768d81502bf9c022ad7fc4d27324838b", 
            "extern refund.se: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0xf641656dfeae64f3cdc4bdaf75d9e6b131135968", 
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern refund.se: [checkHash:[int256,int256]:int256, commitTrade:[int256]:int256, fill_trade:[int256,int256]:int256, getID:[int256]:int256, getInitialTrade:[int256]:int256, get_amount:[int256]:int256, get_price:[int256]:int256, get_trade:[int256]:int256[], makeTradeHash:[int256,int256,int256[]]:int256, remove_trade:[int256]:int256, saveTrade:[int256,int256,int256,int256,int256,int256,int256]:int256, setInitialTrade:[int256]:int256, update_trade:[int256,int256]:_, zeroHash:[]:int256]", 
            "TRADES = 0xb8c254877dd025d04bb760e7b738e1219dbc2708", 
            "inset('refund.se')", 
            "", 
            "macro POINTZEROSIX: 1106804644422573056", 
            "", 
            "#data CLOSEMARKET", 
            "", 
            "#def init():", 
            "#    self.CLOSEMARKET = 0", 
            "", 
            "#def setCloseMarket(value):", 
            "#    if(!self.CLOSEMARKET):", 
            "#        self.CLOSEMARKET = value", 
            "#    return(1)", 
            "", 
            "def createSingleEventMarket(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution:str, tradingFee, tag1, tag2, tag3, makerFees, extraInfo:str):", 
            "    return(self.createMarket(branch, description, tradingFee, [self.createEvent(branch, description, expDate, minValue, maxValue, numOutcomes, resolution)], tag1, tag2, tag3, makerFees, extraInfo))", 
            "", 
            "# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0", 
            "# to 11.0 would be 11 outcomes (if incremented by 0.1)", 
            "# @return eventID if success", 
            "# error messages otherwise", 
            "    # -1: we're either already past that date, branch doesn't exist, or description is bad", 
            "    # 0: not enough money to pay fees or event already exists", 
            "    # -2: max value < min value", 
            "# .025 eth to create", 
            "def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes, resolution: str):", 
            "    refund()", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    forkPeriod = BRANCHES.getForkPeriod(branch)", 
            "    if(forkPeriod && ((expDate / periodLength)==forkPeriod or (expDate / periodLength)==(forkPeriod+1))):", 
            "        return(-9)", 
            "    if(maxValue < minValue or (maxValue-minValue) < ONE):", 
            "        return(-2)", 
            "    eventID = 0", 
            "    if(periodLength && description != 0 && expDate > block.timestamp):", 
            "        eventinfo = string(8*32 + len(description))", 
            "        eventinfo[0] = EVENT                                        #typecode", 
            "        eventinfo[1] = branch                                       #branchID", 
            "        eventinfo[2] = expDate                                      #expiration date", 
            "        eventinfo[3] = msg.sender                                   #creator address", 
            "        eventinfo[4] = periodLength", 
            "        eventinfo[5] = minValue                                     #minimum outcome value", 
            "        eventinfo[6] = maxValue                                     #maximum outcome value", 
            "        eventinfo[7] = numOutcomes                                  #number of outcomes", 
            "        mcopy(eventinfo + 8*32, description, len(description))", 
            "        eventID = sha256(eventinfo, chars=len(eventinfo))", 
            "    else:", 
            "        return(-1)", 
            "    if(numOutcomes < 2 || numOutcomes > 8):", 
            "        return(0)", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    CASH.initiateOwner(eventID)", 
            "    if(!INFO.getCreator(eventID)):", 
            "        # see which future period it expires in && put the event in that bin", 
            "        # event voting periods - expDate / periodLength gives you the voting period #", 
            "        futurePeriod = expDate / periodLength", 
            "        if(INFO.setInfo(eventID, description, msg.sender, 0) && EVENTS.initializeEvent(eventID, branch, expDate, minValue, maxValue, numOutcomes, resolution)):", 
            "            return(eventID)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# tradingFee is a percent in fixedPoint", 
            "# @return marketID if success or 1 if on an oracle only branch creation we have success", 
            "# error messages otherwise", 
            "    # -1: bad input or parent doesn't exist", 
            "    # -2: too many events", 
            "    # -3: too many outcomes", 
            "    # -4: not enough money", 
            "    # -5: fee too low", 
            "    # -6: duplicate events", 
            "    # -7: event already expired", 
            "    # -8: market already exists", 
            "    # -9: would expire during non-reporting fork period", 
            "# .05 eth to create", 
            "# need to check that it's an actual subcurrency upon market creation (maybe check send/balance funs)", 
            "def createMarket(branch, description:str, tradingFee, events:arr, tag1, tag2, tag3, makerFees, extraInfo:str):", 
            "    if(makerFees<0 or makerFees > ONEHALF):", 
            "        return(0)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    # send this to branch", 
            "    creationFee = POINTZEROSIX * BRANCHES.getBaseReporters(branch) * ONE / (2*tradingFee)", 
            "    # gives ether/cash amount in fixed point", 
            "    minFee = 3500000*BRANCHES.getBaseReporters(branch)*tx.gasprice*len(events)*ONE/WEITOETH", 
            "    if(creationFee < minFee):", 
            "        creationFee = minFee", 
            "    if(CASH.balance(msg.sender) < creationFee):", 
            "        return(-4)", 
            "    # will need to get equivalent value in usd or eth or w/e via etherex exchange for subcurrency markets", 
            "    if(periodLength==0 or len(description)==0 || tradingFee < BRANCHES.getMinTradingFee(branch)):", 
            "        return(-1)", 
            "    if(tradingFee > 2^61):", 
            "        return(-1)", 
            "", 
            "    event = events[0]", 
            "    # check that events have same exp. dates && branch", 
            "    i = 0", 
            "    eventNum = len(events)", 
            "    # only supports upto 3 dimensional markets", 
            "    if(eventNum > 3):", 
            "        return(-2)", 
            "    numOutcomes = 0", 
            "    eventsConcat = 0", 
            "    cumulativeScale = 0", 
            "    tradingPeriod = 0", 
            "    while i < eventNum:", 
            "        event = events[i]", 
            "        if(i!=0):", 
            "            if(event==events[i-1]):", 
            "                return(-6)", 
            "        expirationDate = EVENTS.getExpiration(event)", 
            "        futurePeriod = expirationDate / periodLength", 
            "        if(expirationDate < block.timestamp):", 
            "            return(-7)", 
            "        forkPeriod = BRANCHES.getForkPeriod(branch)", 
            "        if(forkPeriod && (futurePeriod == forkPeriod or futurePeriod == (forkPeriod+1))):", 
            "            return(-9)", 
            "        if(EVENTS.getEventBranch(event) != branch || !INFO.getCreator(event)):", 
            "            return(-1)", 
            "        if(expirationDate > tradingPeriod):", 
            "            tradingPeriod = expirationDate", 
            "        eventsConcat += event", 
            "        if(!EVENTS.getBond(event)):", 
            "            # pay validity bond", 
            "            period = block.timestamp / TWENTYFOURHR", 
            "            validity_bond =  6 * creationFee * 2 * (1 + EVENTS.getPast24(period-1)) / (1 + EXPEVENTS.getNumberEvents(branch, BRANCHES.getVotePeriod(branch)))", 
            "            if(!CASH.sendFrom(event, validity_bond, msg.sender)):", 
            "                return(-4)", 
            "            EVENTS.setBond(event, validity_bond)", 
            "            EVENTS.addPast24(24period)", 
            "        #scalars", 
            "        maxValue = EVENTS.getMaxValue(event)", 
            "        minValue = EVENTS.getMinValue(event)", 
            "        if((maxValue!=TWO || minValue !=ONE) && EVENTS.getNumOutcomes(event)==2):", 
            "            # is a valid scalar", 
            "            cumulativeScale += maxValue - minValue", 
            "        eventNumOutcomes = EVENTS.getNumOutcomes(event)", 
            "        if(i==0):", 
            "            numOutcomes += eventNumOutcomes", 
            "        else:", 
            "            numOutcomes *= eventNumOutcomes", 
            "        i += 1", 
            "    if(numOutcomes > 8):", 
            "        return(-3)", 
            "    if(cumulativeScale==0):", 
            "        cumulativeScale = ONE", 
            "    tradingPeriod = (tradingPeriod / periodLength)", 
            "", 
            "    # formation of marketID (hash)", 
            "    marketinfo = string(11*32 + len(description))", 
            "    marketinfo[0] = MARKET", 
            "    marketinfo[1] = msg.sender", 
            "    marketinfo[2] = initialLiquidity", 
            "    marketinfo[3] = branch", 
            "    marketinfo[4] = eventsConcat", 
            "    marketinfo[5] = len(events)", 
            "    marketinfo[6] = cumulativeScale", 
            "    marketinfo[7] = alpha", 
            "    marketinfo[8] = numOutcomes", 
            "    marketinfo[9] = tradingPeriod", 
            "    marketinfo[10] = tradingFee", 
            "    mcopy(marketinfo + 11*32, description, chars=len(description))", 
            "    marketID = sha256(marketinfo, chars=len(marketinfo))", 
            "    CASH.initiateOwner(marketID)", 
            "    # pay numOutcomes fee", 
            "    # if it's already been created return 0", 
            "    if(INFO.getCreator(marketID) || MARKETS.getMarketNumOutcomes(marketID)):", 
            "        return(-8)", 
            "    if(!BRANCHES.getOracleOnly(branch) && CASH.balance(msg.sender) < creationFee):", 
            "        return(-4)", 
            "    # need at least 1.2M gas @ gas price to cover resolution + 1M for each additional event", 
            "    if(msg.value < (1200000*tx.gasprice + 1000000*tx.gasprice*(eventNum-1) + 500000*tx.gasprice)):", 
            "        return(0)", 
            "    if(CASH.sendFrom(branch, creationFee, msg.sender) && send(MARKETS, (msg.value-500000*tx.gasprice)) && INFO.setInfo(marketID, description, msg.sender, creationFee) && BRANCHES.addMarketToBranch(branch, marketID) && MARKETS.initializeMarket(marketID, events, tradingPeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumulativeScale, numOutcomes, extraInfo, msg.value-500000*tx.gasprice, creationFee, block.number)):", 
            "        i = 0", 
            "        while i < len(events):", 
            "            EVENTS.addMarket(events[i], marketID)", 
            "            expirationDate = EVENTS.getExpiration(event)", 
            "            futurePeriod = expirationDate / periodLength", 
            "            EXPEVENTS.addEvent(branch, futurePeriod, events[i], 500000*tx.gasprice)", 
            "            CASH.send(EVENTS, 500000*tx.gasprice)", 
            "            i += 1", 
            "        return(marketID)", 
            "    else:", 
            "        return(0)", 
            "", 
            "def updateTradingFee(branch, market, tradingFee):", 
            "    refund()", 
            "    if(msg.sender != INFO.getCreator(market) || tx.origin != INFO.getCreator(market)):", 
            "        return(-4)", 
            "    oldFee = MARKETS.getTradingFee(market)", 
            "    oldCreationFee = POINTZEROSIX * BRANCHES.getBaseReporters(branch) * ONE / oldFee", 
            "    newCreationFee = POINTZEROSIX * BRANCHES.getBaseReporters(branch) * ONE / tradingFee", 
            "    if(tradingFee < BRANCHES.getMinTradingFee(branch) or tradingFee > oldFee):", 
            "        return(-1)", 
            "    CASH.sendFrom(branch, newCreationFee-oldCreationFee, msg.sender)", 
            "    return(MARKETS.setTradingFee(market, tradingFee))", 
            "", 
            "# Anyone can post an \"Early Resolution Bond\"", 
            "# This bond is equal to 0.5 * Market_Fee * Market_Value", 
            "# This amount is the amount needed to pay the reporters in case this was frivolous.", 
            "# The market goes up for early resolution and reporters place claim to what is truth, however for early resolution, they have an additional option: 'Market is not ready to resolve'", 
            "    # this addl option is just the normal indeterminate (except here it's a bit of a special case, see below)", 
            "# In the event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.", 
            "    # and market remains with old expiration dateevent", 
            "# In the event any other option is found to be the consensus the early resolution bond is returned to the poster and then resolution is handled just like any other case.", 
            "def pushMarketForward(branch, market):", 
            "    refund()", 
            "    branchEventIsInForked = 0", 
            "    winningForkDecided = 0", 
            "    if(branchEventIsInForked && !winningForkDecided):", 
            "        return(0)", 
            "    # prevent for backstop 1 markets and vice versa", 
            "    # todo: if has been pushed forward in the past (see close market) don't allow it again", 
            "    numEvents = MARKETS.getNumEvents(market)", 
            "    if(marketClosed):", 
            "        return(0)", 
            "    if(CASH.sendFrom(market, numEvents*MARKETS.getTradingFee(market)*MARKETS.getTotalSharesPurchased(market)/(2*ONE), msg.sender)==0):", 
            "        return(0)", 
            "    i = 0", 
            "    # for each event in market", 
            "    while i < numEvents:", 
            "        if(1):", 
            "            #if(eventNotResolved && eventNotInRound2Adj && notRejectedBefore && event isn't already in next vote period):", 
            "            event = MARKETS.getMarketEvent(market, i)", 
            "            # push into next vote period", 
            "            period = BRANCHES.getVotePeriod(branch)", 
            "            EXPEVENTS.addEvent(branch, period+1, event)", 
            "            # set event expiration date to be after the current reporting period ends", 
            "            EVENTS.setExpiration(event, block.timestamp)", 
            "            MARKETS.setTradingPeriod(market, period+1)", 
            "            MARKETS.setPushedForward(market, 1, msg.sender)", 
            "        i += 1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "expDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "name": "resolution", 
                        "type": "bytes"
                    }
                ], 
                "name": "createEvent(int256,bytes,int256,int256,int256,int256,bytes)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "tag1", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag2", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag3", 
                        "type": "int256"
                    }, 
                    {
                        "name": "makerFees", 
                        "type": "int256"
                    }, 
                    {
                        "name": "extraInfo", 
                        "type": "bytes"
                    }
                ], 
                "name": "createMarket(int256,bytes,int256,int256[],int256,int256,int256,int256,bytes)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "expDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "name": "resolution", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag1", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag2", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag3", 
                        "type": "int256"
                    }, 
                    {
                        "name": "makerFees", 
                        "type": "int256"
                    }, 
                    {
                        "name": "extraInfo", 
                        "type": "bytes"
                    }
                ], 
                "name": "createSingleEventMarket(int256,bytes,int256,int256,int256,int256,bytes,int256,int256,int256,int256,int256,bytes)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "pushMarketForward(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }
                ], 
                "name": "updateTradingFee(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createMarket: [createEvent:[int256,bytes,int256,int256,int256,int256,bytes]:int256, createMarket:[int256,bytes,int256,int256[],int256,int256,int256,int256,bytes]:int256, createSingleEventMarket:[int256,bytes,int256,int256,int256,int256,bytes,int256,int256,int256,int256,int256,bytes]:int256, pushMarketForward:[int256,int256]:int256, updateTradingFee:[int256,int256,int256]:int256]"
    }, 
    "createSingleEventMarket": {
        "address": "0x6bde7ba55927738fa3a95187c3dee964b4ba5e50", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern createEvent: [createEvent:[int256,bytes,int256,int256,int256,int256,bytes]:int256]", 
            "CREATEEVENT = 0x1401ffedec68b82cfa9225c24f35725b998ccce3", 
            "extern createMarket: [createMarket:[int256,bytes,int256,int256[],int256,int256,int256,int256,bytes]:int256, pushMarketForward:[int256,int256]:int256, updateTradingFee:[int256,int256,int256]:int256]", 
            "CREATEMARKET = 0x6ee851dd2fef0d95dd4d192cb5e5bffc4122b411", 
            "", 
            "def createSingleEventMarket(branch, description:str, expirationBlock, minValue, maxValue, numOutcomes, resolution:str, tradingFee, tag1, tag2, tag3, makerFees, extraInfo:str):", 
            "    return(CREATEMARKET.createMarket(branch, description, tradingFee, [CREATEEVENT.createEvent(branch, description, expirationBlock, minValue, maxValue, numOutcomes, resolution)], tag1, tag2, tag3, makerFees, extraInfo))"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "expirationBlock", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "name": "resolution", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag1", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag2", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag3", 
                        "type": "int256"
                    }, 
                    {
                        "name": "makerFees", 
                        "type": "int256"
                    }, 
                    {
                        "name": "extraInfo", 
                        "type": "bytes"
                    }
                ], 
                "name": "createSingleEventMarket(int256,bytes,int256,int256,int256,int256,bytes,int256,int256,int256,int256,int256,bytes)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern createSingleEventMarket: [createSingleEventMarket:[int256,bytes,int256,int256,int256,int256,bytes,int256,int256,int256,int256,int256,bytes]:int256]"
    }, 
    "eventResolution": {
        "address": "0x9bb51b5887354e66cb2ab2804bc875e65a31ccb5", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x254d730690f461dc6048c8fd4d9bf49f9fc39829", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern makeReports: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, makeHash:[int256,int256,int256,int256]:int256, submitReport:[int256,int256,int256,int256]:int256, submitReportHash:[int256,int256]:int256, validateReport:[int256,int256,int256,int256,int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x45ec31e7768d81502bf9c022ad7fc4d27324838b", 
            "inset('refund.se')", 
            "", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "def catch(x):", 
            "    refund()", 
            "    return(catch(x))", 
            "", 
            "## helper functions:", 
            "macro closeOut($event, $market, $branch, $votingPeriodEvent, $fxpOutcome, $periodLength, $ethical, $scalar, $sender):", 
            "    # In the $event 'Market is not ready to resolve' is found to be the consensus, the early resolution bond is paid to the reporters for their labor.", 
            "    # and $market remains with old expiration date", 
            "    indeterminate = ONEHALF*3", 
            "    if($scalar):", 
            "        indeterminate = ONEHALF", 
            "    if($fxpOutcome == indeterminate && MARKETS.getPushedForward($market)):", 
            "        #set $event expiration to be the old date prior to this bond process", 
            "        EVENTS.setExpiration($event, EVENTS.getOriginalExpiration($event))", 
            "        MARKETS.setTradingPeriod($market, MARKETS.getOriginalTradingPeriod($market))", 
            "        CASH.addCash($branch, MARKETS.getTradingFee($market)*MARKETS.getTotalSharesPurchased($market)/(2*ONE))", 
            "        CASH.subtractCash($market, MARKETS.getTradingFee($market)*MARKETS.getTotalSharesPurchased($market)/(2*ONE))", 
            "        MARKETS.setPushedForward($market, 0, $sender)", 
            "        EXPEVENTS.setNumReportsExpectedEvent($branch, $votingPeriodEvent, $event, 0)", 
            "        EXPEVENTS.setNumReportsEvent($branch, $votingPeriodEvent, $event, 0)", 
            "        #set outcome to 0", 
            "        EVENTS.setOutcome($event, 0)", 
            "        EVENTS.setmode($event, 0)", 
            "        EVENTS.setEthics($event, 0)", 
            "        #set uncaughtoutcome to 0", 
            "        EVENTS.setUncaughtOutcome($event, 0)", 
            "        # need to store uncaught outcome for rejectedperiod separately as well as which period it was \"rejected\" in", 
            "        EVENTS.setRejected($event, EVENTS.getExpiration($event)/$periodLength, $fxpOutcome)", 
            "        return(-6)", 
            "    elif($fxpOutcome==indeterminate || !$ethical):", 
            "        # give $event bond money to reporters", 
            "        CASH.subtractCash($event, EVENTS.getBond($event))", 
            "        CASH.addCash($branch, EVENTS.getBond($event))", 
            "        # not $ethical is same as .5 outcome", 
            "        $fxpOutcome = indeterminate", 
            "        EVENTS.setOutcome($event, $fxpOutcome)", 
            "    else:", 
            "        # return bond", 
            "        CASH.subtractCash($event, EVENTS.getBond($event))", 
            "        CASH.addCash(INFO.getCreator($event), EVENTS.getBond($event))", 
            "        if(MARKETS.getPushedForward($market)):", 
            "            CASH.addCash(MARKETS.getBondsMan($market), MARKETS.getTradingFee($market)*MARKETS.getTotalSharesPurchased($market)/(2*ONE))", 
            "            CASH.subtractCash($market, MARKETS.getTradingFee($market)*MARKETS.getTotalSharesPurchased($market)/(2*ONE))", 
            "            # delete old $event from future events exp", 
            "            EXPEVENTS.removeEvent($branch, EVENTS.getOriginalExpiration($event)/$periodLength)", 
            "", 
            "def resolveBinary(event, market, branch, votingPeriodEvent, sender):", 
            "    refund()", 
            "    fxpOutcome = catch(EVENTS.getUncaughtOutcome(event))", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    ethical = ethic_catch(EVENTS.getEthical(event))", 
            "    EVENTS.setOutcome(event, fxpOutcome)", 
            "    EVENTS.setEthics(event, ethical)", 
            "    closeOut(event, market, branch, votingPeriodEvent, fxpOutcome,  periodLength, ethical, 0, sender)", 
            "    return(1)", 
            "", 
            "def resolveCategoricalOrScalar(scaled_min, scaled_max, event, market, branch, votingPeriodEvent, sender):", 
            "    refund()", 
            "    mode = EVENTS.getUncaughtOutcome(event)", 
            "    EVENTS.setmode(event, mode)", 
            "    fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min", 
            "    EVENTS.setOutcome(event, fxpOutcome)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    ethical = ethic_catch(EVENTS.getEthical(event))", 
            "    EVENTS.setEthics(event, ethical)", 
            "    closeOut(event, market, branch, votingPeriodEvent, fxpOutcome, periodLength, ethical, 1, sender)", 
            "    return(1)", 
            "", 
            "def determineWinningOutcomes(events: arr, numberEvents, branch, market):", 
            "    refund()", 
            "    n = 0", 
            "    winningOutcomes = array(8)", 
            "    while n < numberEvents:", 
            "        fxpOutcome = EVENTS.getOutcome(events[n])", 
            "        outcome = fxpOutcome/ONE", 
            "        indeterminate = ONEHALF*3", 
            "        if(scalar(events[n])):", 
            "            indeterminate = ONEHALF", 
            "        if(n==0):", 
            "            #scalar or .5", 
            "            if(scalar(events[n]) || fxpOutcome==3*ONEHALF):", 
            "                winningOutcomes[0] = 1", 
            "                winningOutcomes[1] = 2", 
            "            # anything besides scalar or .5", 
            "            else:", 
            "                winningOutcomes[0] += outcome", 
            "        elif(n==1):", 
            "            if(scalar(events[n]) || fxpOutcome==3*ONEHALF):", 
            "                # scalar, scalar", 
            "                if(winningOutcomes[1]):", 
            "                    winningOutcomes[2] = 3", 
            "                    winningOutcomes[3] = 4", 
            "                # nonscalar, scalar", 
            "                else:", 
            "                    #winningOutcomes[0] = winningOutcomes[0]", 
            "                    winningOutcomes[1] = winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-1])", 
            "            # scalar, nonscalar", 
            "            elif(winningOutcomes[1]):", 
            "                winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "                winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "            # nonscalar, nonscalar", 
            "            else:", 
            "                winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-1])*(outcome-1)", 
            "        elif(n==2):", 
            "            if(scalar(events[n]) || fxpOutcome==3*ONEHALF):", 
            "                #scalar, scalar, scalar", 
            "                if(winningOutcomes[3]):", 
            "                    winningOutcomes[4] = 5", 
            "                    winningOutcomes[5] = 6", 
            "                    winningOutcomes[6] = 7", 
            "                    winningOutcomes[7] = 8", 
            "                #scalar, nonscalar, scalar", 
            "                #nonscalar, scalar, scalar", 
            "                elif(winningOutcomes[1]):", 
            "                    #winningOutcomes[0] = winningOutcomes[0]", 
            "                    #winningOutcomes[1] = winningOutcomes[1]", 
            "                    winningOutcomes[2] += winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "                    winningOutcomes[3] += winningOutcomes[1] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "                #nonscalar, nonscalar, scalar", 
            "                elif(winningOutcomes[1]==0):", 
            "                    #winningOutcomes[0] = winningOutcomes[0]", 
            "                    winningOutcomes[1] += winningOutcomes[0] + EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1])", 
            "            else:", 
            "                #scalar, scalar, nonscalar", 
            "                if(winningOutcomes[3]):", 
            "                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[2] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[3] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                #scalar, nonscalar, nonscalar", 
            "                #nonscalar, scalar, nonscalar", 
            "                elif(winningOutcomes[1]):", 
            "                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                    winningOutcomes[1] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "                #nonscalar, nonscalar, nonscalar", 
            "                else:", 
            "                    winningOutcomes[0] += EVENTS.getNumOutcomes(events[n-2]) * EVENTS.getNumOutcomes(events[n-1]) * (outcome-1)", 
            "        n+=1", 
            "    return(winningOutcomes: arr)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "catch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "numberEvents", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "determineWinningOutcomes(int256[],int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votingPeriodEvent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "resolveBinary(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "scaled_min", 
                        "type": "int256"
                    }, 
                    {
                        "name": "scaled_max", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votingPeriodEvent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "resolveCategoricalOrScalar(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern eventResolution: [catch:[int256]:int256, determineWinningOutcomes:[int256[],int256,int256,int256]:int256[], resolveBinary:[int256,int256,int256,int256,int256]:int256, resolveCategoricalOrScalar:[int256,int256,int256,int256,int256,int256,int256]:int256]"
    }, 
    "events": {
        "address": "0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "inset('refund.se')", 
            "", 
            "# Events' index is the eventID", 
            "# a binary outcome has 0 for min && 1 for max value, but consensus will return ONE and TWO respectively", 
            "# so for voting 1 and 2 in fxp. need to be given for binaries, not 0 & 1", 
            "# S&P 500 scalar would be say 0 && 4700, respectively", 
            "# categorical markets have fixed point min and max", 
            " # so max-min/numOutcomes is interval between outcomes (useful for ui, e.g. 1 is >50, 2 is >100, etc.)", 
            "data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes, markets[], numMarkets, threshold, mode, uncaughtOutcome, ethical, originalExp, rejected, rejectedPeriod, rejectedUncaught, pushedBack, bond, forked, forkOver, forkOutcome, forkEthicality, resolutionSource[], resolutionSourceLength)", 
            "", 
            "data past24Hours[]", 
            "", 
            "def getForkOutcome(event):", 
            "    return(self.Events[event].forkOutcome)", 
            "", 
            "def setForkOutcome(event, value):", 
            "    self.Events[event].forkOutcome = value", 
            "    return(1)", 
            "", 
            "def getForkEthicality(event):", 
            "    return(self.Events[event].forkEthicality)", 
            "", 
            "def setForkEthicality(event, value):", 
            "    self.Events[event].forkEthicality = value", 
            "    return(1)", 
            "", 
            "def getForked(event):", 
            "    return(self.Events[event].forked)", 
            "", 
            "def setForked(event):", 
            "    self.Events[event].forked = 1", 
            "    return(1)", 
            "", 
            "def setForkDone(event):", 
            "    self.Events[event].forkOver = 1", 
            "    return(1)", 
            "", 
            "def getForkedDone(event):", 
            "    return(self.Events[event].forkOver)", 
            "", 
            "def getEventInfo(event):", 
            "    refund()", 
            "    length=self.Events[event].resolutionSourceLength", 
            "    eventinfo = string(7*32 + length)", 
            "    eventinfo[0] = self.Events[event].branch", 
            "    eventinfo[1] = self.Events[event].expirationDate", 
            "    eventinfo[2] = self.Events[event].outcome", 
            "    eventinfo[3] = self.Events[event].minValue", 
            "    eventinfo[4] = self.Events[event].maxValue", 
            "    eventinfo[5] = self.Events[event].numOutcomes", 
            "    eventinfo[6] = self.Events[event].bond", 
            "    mcopy(eventinfo + 7*32, load(self.Events[event].resolutionSource[0], chars=length), length)", 
            "    return(eventinfo: arr)", 
            "", 
            "def getResolution(event):", 
            "    refund()", 
            "    length=self.Events[event].resolutionSourceLength", 
            "    return(load(self.Events[event].resolutionSource[0], chars=length): str)", 
            "", 
            "def getPast24(period):", 
            "    refund()", 
            "    return(self.past24Hours[period])", 
            "", 
            "def addPast24(period):", 
            "    refund()", 
            "    self.past24Hours[period] += 1", 
            "    return(1)", 
            "", 
            "def getEventBranch(event):", 
            "    refund()", 
            "    return(self.Events[event].branch)", 
            "", 
            "def getPushedBack(event):", 
            "    refund()", 
            "    return(self.Events[event].pushedBack)", 
            "", 
            "def getExpiration(event):", 
            "    refund()", 
            "    return(self.Events[event].expirationDate)", 
            "", 
            "def getOriginalExpiration(event):", 
            "    refund()", 
            "    return(self.Events[event].originalExp)", 
            "", 
            "def setExpiration(event, date):", 
            "    refund()", 
            "    self.Events[event].expirationDate = date", 
            "    return(1)", 
            "", 
            "def setBranch(event, branch):", 
            "    self.Events[event].branch = branch", 
            "    return(1)", 
            "", 
            "def getOutcome(event):", 
            "    refund()", 
            "    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "    return(self.Events[event].outcome)", 
            "", 
            "def getEthics(event):", 
            "    refund()", 
            "    return(self.Events[event].ethical)", 
            "", 
            "def setEthics(event, ethicality):", 
            "    refund()", 
            "    self.Events[event].ethical = ethicality", 
            "    return(ethicality)", 
            "", 
            "def getEthical(event):", 
            "    refund()", 
            "    return(self.Events[event].ethical)", 
            "", 
            "def getMinValue(event):", 
            "    refund()", 
            "    return(self.Events[event].minValue)", 
            "", 
            "def getMaxValue(event):", 
            "    refund()", 
            "    return(self.Events[event].maxValue)", 
            "", 
            "def getNumOutcomes(event):", 
            "    refund()", 
            "    return(self.Events[event].numOutcomes)", 
            "", 
            "def setUncaughtOutcome(event, outcome):", 
            "    refund()", 
            "    self.Events[event].uncaughtOutcome = outcome", 
            "    return(1)", 
            "", 
            "def getUncaughtOutcome(event):", 
            "    refund()", 
            "    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "    return(self.Events[event].uncaughtOutcome)", 
            "", 
            "def initializeEvent(ID, branch, expirationDate, minValue, maxValue, numOutcomes, resolution: str):", 
            "    refund()", 
            "    # check that msg.sender is one of our function contracts", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    if(self.Events[ID].expirationDate==0):", 
            "        self.Events[ID].branch = branch", 
            "        self.Events[ID].expirationDate = expirationDate", 
            "        self.Events[ID].originalExp = originalExp", 
            "        self.Events[ID].minValue = minValue", 
            "        self.Events[ID].maxValue = maxValue", 
            "        self.Events[ID].numOutcomes = numOutcomes", 
            "        save(self.Events[ID].resolutionSource[0], resolution, chars=len(resolution))", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "def setBond(event, bond):", 
            "    refund()", 
            "    self.Events[ID].bond = bond", 
            "    return(1)", 
            "", 
            "def addMarket(event, marketID):", 
            "    refund()", 
            "    self.Events[event].markets[self.Events[event].numMarkets] = marketID", 
            "    self.Events[event].numMarkets += 1", 
            "    return(1)", 
            "", 
            "def getBranch(event):", 
            "    return(self.Events[event].branch)", 
            "", 
            "def getBond(event):", 
            "    refund()", 
            "    return(self.Events[event].bond)", 
            "", 
            "def getMarkets(event):", 
            "    refund()", 
            "    i = 0", 
            "    markets = array(self.Events[event].numMarkets)", 
            "    while i < self.Events[event].numMarkets:", 
            "        markets[i] = self.Events[event].markets[i]", 
            "        i += 1", 
            "    return(markets: arr)", 
            "", 
            "def getMarket(event, marketIndex):", 
            "    refund()", 
            "    return(self.Events[event].markets[marketIndex])", 
            "", 
            "def getNumMarkets(event):", 
            "    refund()", 
            "    return(self.Events[event].numMarkets)", 
            "", 
            "def setOutcome(ID, outcome):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    self.Events[ID].outcome = outcome", 
            "    return(1)", 
            "", 
            "def getReportingThreshold(event):", 
            "    refund()", 
            "    return(self.Events[event].threshold)", 
            "", 
            "def setThreshold(event, threshold):", 
            "    # do whitelist", 
            "    self.Events[event].threshold = threshold", 
            "    return(1)", 
            "", 
            "def getmode(event):", 
            "    refund()", 
            "    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good", 
            "    return(self.Events[event].mode)", 
            "", 
            "def setmode(event, mode):", 
            "    refund()", 
            "    self.Events[event].mode = mode", 
            "    return(1)", 
            "", 
            "def setRejected(event, period, uncaughtOutcome):", 
            "    refund()", 
            "    self.Events[event].rejected = 1", 
            "    self.Events[event].rejectedPeriod = period", 
            "    self.Events[event].rejectedUncaught = uncaughtOutcome", 
            "    return(1)", 
            "", 
            "def setPushedBack(event):", 
            "    refund()", 
            "    self.Events[event].pushedBack = 1", 
            "    return(1)", 
            "", 
            "def getRejected(event):", 
            "    refund()", 
            "    return(self.Events[event].rejected)", 
            "", 
            "def getRejectedPeriod(event):", 
            "    refund()", 
            "    return(self.Events[event].rejectedPeriod)", 
            "", 
            "def getRejectedUncaught(event):", 
            "    refund()", 
            "    return(self.Events[event].rejectedUncaught)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }
                ], 
                "name": "addMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "addPast24(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getBond(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEthical(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEthics(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventBranch(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventInfo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getExpiration(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkEthicality(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getForked(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getForkedDone(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "marketIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarket(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarkets(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMaxValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getMinValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumMarkets(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalExpiration(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getPast24(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getPushedBack(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRejected(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRejectedPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRejectedUncaught(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportingThreshold(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getResolution(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getUncaughtOutcome(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getmode(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expirationDate", 
                        "type": "int256"
                    }, 
                    {
                        "name": "minValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "maxValue", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "name": "resolution", 
                        "type": "bytes"
                    }
                ], 
                "name": "initializeEvent(int256,int256,int256,int256,int256,int256,bytes)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "bond", 
                        "type": "int256"
                    }
                ], 
                "name": "setBond(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "setBranch(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethicality", 
                        "type": "int256"
                    }
                ], 
                "name": "setEthics(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "date", 
                        "type": "int256"
                    }
                ], 
                "name": "setExpiration(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setForkDone(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "setForkEthicality(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "setForkOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setForked(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setPushedBack(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "uncaughtOutcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setRejected(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "threshold", 
                        "type": "int256"
                    }
                ], 
                "name": "setThreshold(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "setUncaughtOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "mode", 
                        "type": "int256"
                    }
                ], 
                "name": "setmode(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]"
    }, 
    "expiringEvents": {
        "address": "0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have receive a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "extern refund.se: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0xf641656dfeae64f3cdc4bdaf75d9e6b131135968", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "inset('refund.se')", 
            "", 
            "# [branchID][votingPeriod]", 
            "# reporthash is [reporterID] = hash", 
            "data EventsExpDates[][](numberEvents, numberRemoved, events[], numEventsToReportOn, reportHash[][], shareValue, roundTwoNumEvents, subsidy[])", 
            "", 
            "data EventIDToIndex[][]", 
            "", 
            "data branches[](beforeRep[][], afterRep[][], periodDormantRep[][], ethics[][](event[]), report[][](event[]), numReportsEvent[][], numReportsExpectedEvent[][], numReportsActual[][], reportedPeriod[][], repEvent[][], lesserReportNum[][], periodRepConstant[][])", 
            "", 
            "data requiredEvents[]", 
            "", 
            "# branch, period as params", 
            "data numReqEvents[][]", 
            "", 
            "data mode_items[][](report_value[], current_mode, current_mode_items)", 
            "", 
            "def refundCost(to, value):", 
            "    send(to, value)", 
            "    return(1)", 
            "", 
            "def getSubsidy(branch, period, event):", 
            "    return(self.EventsExpDates[branch][period].subsidy[event])", 
            "", 
            "def getPeriodRepConstant(branch, votePeriod, sender):", 
            "    return(self.branches[branch].periodRepConstant[votePeriod][sender])", 
            "", 
            "def setPeriodRepConstant(branch, votePeriod, sender, value):", 
            "    self.branches[branch].periodRepConstant[votePeriod][sender] = value", 
            "    return(1)", 
            "", 
            "def getLesserReportNum(branch, period, event):", 
            "    return(self.branches[branch].lesserReportNum[period][event])", 
            "", 
            "def getCurrentModeItems(period, event):", 
            "    return(self.mode_items[period][event].current_mode_items)", 
            "", 
            "def getCurrentMode(period, event):", 
            "    return(self.mode_items[period][event].current_mode)", 
            "", 
            "# returns weight of a report value for the mode", 
            "def getWeightOfReport(period, event, report):", 
            "    return(self.mode_items[period][event].report_value[report])", 
            "", 
            "def getRepEvent(branch, votePeriod, event):", 
            "    return(self.branches[branch].repEvent[votePeriod][event])", 
            "", 
            "def getReportedPeriod(branch, period, reporter):", 
            "    return(self.branches[branch].reportedPeriod[period][reporter])", 
            "", 
            "def getEthicReport(branch, period, event, sender):", 
            "    return(self.branches[branch].ethics[period][sender].event[event])", 
            "", 
            "def getNumReportsExpectedEvent(branch, votePeriod, eventID):", 
            "    return(self.branches[branch].numReportsExpectedEvent[votePeriod][eventID])", 
            "", 
            "def getNumReportsEvent(branch, votePeriod, eventID):", 
            "    return(self.branches[branch].numReportsEvent[votePeriod][eventID])", 
            "", 
            "def getReport(branch, period, event, sender):", 
            "    #if(whitelist):", 
            "    return(self.branches[branch].report[period][sender].event[event])", 
            "", 
            "def getBeforeRep(branch, period, sender):", 
            "    return(self.branches[branch].beforeRep[period][sender])", 
            "", 
            "def getAfterRep(branch, period, sender):", 
            "    return(self.branches[branch].afterRep[period][sender])", 
            "", 
            "def getPeriodDormantRep(branch, period, sender):", 
            "    return(self.branches[branch].periodDormantRep[period][sender])", 
            "", 
            "def getNumReportsActual(branch, votePeriod, sender):", 
            "    return(self.branches[branch].numReportsActual[sender][votePeriod])", 
            "", 
            "def getNumRoundTwo(branch, period):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][period].roundTwoNumEvents)", 
            "", 
            "def addRoundTwo(branch, period):", 
            "    refund()", 
            "    self.EventsExpDates[branch][period].roundTwoNumEvents += 1", 
            "    return(1)", 
            "", 
            "def getRequired(event):", 
            "    return(self.requiredEvents[event])", 
            "", 
            "def getNumRequired(branch, period):", 
            "    return(self.numReqEvents[branch][period])", 
            "", 
            "# Return 0 means already required", 
            "def setEventRequired(branch, period, event):", 
            "    if(self.requiredEvents[event]==0):", 
            "        self.requiredEvents[event] = 1", 
            "        self.numReqEvents[branch][period] += 1", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# With this function you can get the eventIDs and report on outcomes", 
            "# @return all events in a branch and expiration period", 
            "def getEvents(branch, expDateIndex):", 
            "    refund()", 
            "    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents", 
            "    events = array(numEvents)", 
            "    i = 0", 
            "    while i < numEvents:", 
            "        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]", 
            "        i += 1", 
            "    return(events: arr)", 
            "", 
            "def getEventsToReportOn(branch, expDateIndex):", 
            "    refund()", 
            "    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents", 
            "    events = array(numEvents*2)", 
            "    i = 0", 
            "    while i < numEvents:", 
            "        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]", 
            "        reportingThreshold = self.calculateReportingThreshold(branch, events[i], expDateIndex, msg.sender)", 
            "        x = array(1)", 
            "        x[0] = msg.sender + events[i]", 
            "        shaHash = sha3(x, items=1)/ONE", 
            "        if((shaHash < reportingThreshold || shaHash<EVENTS.getReportingThreshold(events[i]) || self.getRequired(events[i])) && !EVENTS.getOutcome(events[i])):", 
            "            events[i+1] = 1", 
            "        else:", 
            "            events[i+1] = 0", 
            "        i += 2", 
            "    return(events: arr)", 
            "", 
            "", 
            "# eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))", 
            "    # a^b=exp(b*ln(a))=e^(b*ln(a)).", 
            "def calculateReportingThreshold(branch, eventID, votePeriod, sender):", 
            "    repConstant = self.getPeriodRepConstant(branch, votePeriod, sender)", 
            "    if(repConstant==0):", 
            "        logOutput = FXP.fx_log(REPORTING.getRepBalance(branch, sender)*ONE/REPORTING.getActiveRep(branch))", 
            "        repConstant = FXP.fx_exp(22136092888451461120*logOutput/ONE) + 18446744073709552", 
            "        expectedEventsForReporter = repConstant * self.getNumEventsToReportOn(branch, votePeriod)", 
            "        total = expectedEventsForReporter", 
            "        eventsInPeriod = self.getNumberEvents(branch, expDateIndex)-self.getNumRemoved(branch, votePeriod)", 
            "        numRequiredEvents = self.getNumRequired(branch, votePeriod)", 
            "        minimum = min(30-numRequiredEvents, eventsInPeriod-numRequiredEvents)", 
            "        if(total/ONE < minimum):", 
            "            total = minimum*ONE", 
            "            repConstant = repConstant*ratio / ONE", 
            "        self.setPeriodRepConstant(branch, votePeriod, sender, repConstant)", 
            "    reportingThreshold = self.getLesserReportNum(branch, votePeriod, eventID)*repConstant*ONE", 
            "    return(reportingThreshold)", 
            "", 
            "def getEventsRange(branch, expDateIndex, start, end):", 
            "    refund()", 
            "    numEvents = end-start", 
            "    events = array(numEvents)", 
            "    i = start", 
            "    index = 0", 
            "    while i < end:", 
            "        events[index] = self.EventsExpDates[branch][expDateIndex].events[i]", 
            "        index += 1", 
            "        i += 1", 
            "    return(events: arr)", 
            "", 
            "def getEventIndex(period, eventID):", 
            "    refund()", 
            "    return(self.EventIDToIndex[period][eventID])", 
            "", 
            "# we should probably make this bonded too", 
            "# -1: voting not started", 
            "def setNumEventsToReportOn(branch):", 
            "    refund()", 
            "    # after voting has started", 
            "    expDateIndex = BRANCHES.getVotePeriod(branch)", 
            "    self.EventsExpDates[branch][expDateIndex].numEventsToReportOn = (self.EventsExpDates[branch][expDateIndex].numberEvents - self.numReqEvents[branch][expDateIndex] - self.EventsExpDates[branch][expDateIndex].numberRemoved)*BRANCHES.getBaseReporters(branch)", 
            "    return(1)", 
            "", 
            "def getNumEventsToReportOn(branch, expDateIndex):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][expDateIndex].numEventsToReportOn)", 
            "", 
            "def getShareValue(branch, expIndex):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][expIndex].shareValue)", 
            "", 
            "def getNumberEvents(branch, expDateIndex):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][expDateIndex].numberEvents)", 
            "", 
            "def getEvent(branch, expDateIndex, eventIndex):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][expDateIndex].events[eventIndex])", 
            "", 
            "def getReportHash(branch, expDateIndex, reporter, event):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event])", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def addEvent(branch, futurePeriod, eventID, subsidy):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID", 
            "    self.EventIDToIndex[futurePeriod][eventID] = self.EventsExpDates[branch][futurePeriod].numberEvents", 
            "    self.EventsExpDates[branch][futurePeriod].numberEvents += 1", 
            "    self.EventsExpDates[branch][futurePeriod].subsidy[eventID] += subsidy", 
            "    return(1)", 
            "", 
            "def removeEvent(branch, period):", 
            "    refund()", 
            "    self.EventsExpDates[branch][period].numberRemoved += 1", 
            "    return(1)", 
            "", 
            "def getNumRemoved(branch, period):", 
            "    refund()", 
            "    return(self.EventsExpDates[branch][period].numberRemoved)", 
            "", 
            "def adjustPeriodShareValueOutstanding(branch, expIndex, amount):", 
            "    refund()", 
            "    self.EventsExpDates[branch][expIndex].shareValue += amount", 
            "    return(1)", 
            "", 
            "def setReportHash(branch, expDateIndex, reporter, reportHash, event):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #\treturn(-1)", 
            "    self.EventsExpDates[branch][expDateIndex].reportHash[reporter][event] = reportHash", 
            "    return(1)", 
            "", 
            "# called in case an event doesn't get reported on at all in a period", 
            "def moveEvent(branch, event):", 
            "    if(BRANCHES.getVotePeriod(branch) > EVENTS.getExpiration(event)/BRANCHES.getPeriodLength(branch) && !EVENTS.getUncaughtOutcome(event)):", 
            "        # add to next expiration period", 
            "        self.addEvent(branch, block.timestamp/BRANCHES.getPeriodLength(branch), event)", 
            "        EVENTS.setExpiration(event, block.timestamp)", 
            "        return(1)", 
            "    else:", 
            "        return(0)", 
            "", 
            "def addToWeightOfReport(period, event, report, amount):", 
            "    self.mode_items[period][event].report_value[report] += amount", 
            "    return(1)", 
            "", 
            "def setCurrentMode(period, event, mode):", 
            "    self.mode_items[period][event].current_mode = mode", 
            "    return(1)", 
            "", 
            "# basically setting current mode's weight", 
            "def setCurrentModeItems(period, event, modeReport):", 
            "    self.mode_items[period][event].current_mode = self.mode_items[period][event].report_value[modeReport]", 
            "    return(1)", 
            "", 
            "def addRepEvent(branch, votePeriod, event, amount):", 
            "    self.branches[branch].repEvent[votePeriod][event] += amount", 
            "    return(1)", 
            "", 
            "def setReportedPeriod(branch, period, reporter):", 
            "    self.branches[branch].reportedPeriod[period][reporter] = 1", 
            "    return(1)", 
            "", 
            "def setEthicReport(branch, period, event, ethics, sender):", 
            "    self.branches[branch].ethics[period][sender].event[event] = ethics", 
            "    return(1)", 
            "", 
            "def setNumReportsExpectedEvent(branch, votePeriod, eventID, num):", 
            "    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] = num", 
            "    return(1)", 
            "", 
            "def setNumReportsEvent(branch, votePeriod, eventID, num):", 
            "    self.branches[branch].numReportsEvent[votePeriod][eventID] = num", 
            "    return(1)", 
            "", 
            "def addReportToEvent(branch, votePeriod, eventID):", 
            "    self.branches[branch].numReportsEvent[votePeriod][eventID] += 1", 
            "    return(1)", 
            "", 
            "def addReportExpected(branch, votePeriod, eventID):", 
            "    self.branches[branch].numReportsExpectedEvent[votePeriod][eventID] += 1", 
            "    return(1)", 
            "", 
            "def setReport(branch, period, event, report, sender):", 
            "    self.branches[branch].report[period][sender].event[event] = report", 
            "    return(1)", 
            "", 
            "def setBeforeRep(branch, period, rep, sender):", 
            "    self.branches[branch].beforeRep[period][sender] = rep", 
            "    return(rep)", 
            "", 
            "def setAfterRep(branch, period, rep, sender):", 
            "    self.branches[branch].afterRep[period][sender] = rep", 
            "    return(rep)", 
            "", 
            "def setPeriodDormantRep(branch, period, rep, sender):", 
            "    self.branches[branch].periodDormantRep[period][sender] = rep", 
            "    return(rep)", 
            "", 
            "def setLesserReportNum(branch, period, event, num):", 
            "    self.branches[branch].lesserReportNum[period][event] = num", 
            "    return(1)", 
            "", 
            "#In the rare possibility that no one gets randomly selected to report on a market in a given period, on the last day, we can change the sha3 threshold.", 
            "def setReportingThreshold(event):", 
            "    refund()", 
            "    # first check is if event expDate is in the current vote period and second is if blockNum is near expiration of commit period (within 24 hr.)", 
            "    # final check is if < 3 reports so far", 
            "    # so if in 24 hr we'd be in the next half of the vote period, we're within 24 hr of the end of this one", 
            "    branch = EVENTS.getBranch(event)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    votePeriod = BRANCHES.getVotePeriod(branch)", 
            "    if(votePeriod==EVENTS.getExpiration(event)/periodLength and (((block.timestamp + TWENTYFOURHR) % periodLength) > periodLength/2) and self.branches[branch].numReportsExpectedEvent[votePeriod][event]<3):", 
            "        EVENTS.setThreshold(event, 2**192)", 
            "        return(1)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "futurePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "subsidy", 
                        "type": "int256"
                    }
                ], 
                "name": "addEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "addRepEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "addReportExpected(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "addReportToEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "addRoundTwo(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "addToWeightOfReport(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "adjustPeriodShareValueOutstanding(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "calculateReportingThreshold(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getAfterRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getBeforeRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getCurrentMode(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getCurrentModeItems(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getEthicReport(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "start", 
                        "type": "int256"
                    }, 
                    {
                        "name": "end", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventsRange(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getEventsToReportOn(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getLesserReportNum(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEventsToReportOn(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumRemoved(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReportsActual(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReportsEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumReportsExpectedEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumRequired(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumRoundTwo(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumberEvents(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodDormantRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getPeriodRepConstant(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepEvent(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "getReport(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportHash(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "getReportedPeriod(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getRequired(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getShareValue(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "getSubsidy(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }
                ], 
                "name": "getWeightOfReport(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "moveEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "to", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "refundCost(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "removeEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "rep", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setAfterRep(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "rep", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setBeforeRep(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "mode", 
                        "type": "int256"
                    }
                ], 
                "name": "setCurrentMode(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "modeReport", 
                        "type": "int256"
                    }
                ], 
                "name": "setCurrentModeItems(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethics", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setEthicReport(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setEventRequired(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "setLesserReportNum(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "setNumEventsToReportOn(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "setNumReportsEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "setNumReportsExpectedEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "rep", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setPeriodDormantRep(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "setPeriodRepConstant(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setReport(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "expDateIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportHash", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportHash(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportedPeriod(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }
                ], 
                "name": "setReportingThreshold(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]"
    }, 
    "faucets": {
        "address": "0x78954c7be678a2ebd369332860cdcbefb1753488", 
        "code": [
            "# This software (Augur) allows buying and selling event options in Ethereum.", 
            "#", 
            "# Copyright (c) 2015 Forecast Foundation OU", 
            "#", 
            "# This program is free software; you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation; either version 2 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is free software: you can redistribute it and/or modify", 
            "# it under the terms of the GNU General Public License as published by", 
            "# the Free Software Foundation, either version 3 of the License, or", 
            "# (at your option) any later version.", 
            "#", 
            "# This program is distributed in the hope that it will be useful,", 
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "# GNU General Public License for more details.", 
            "#", 
            "# You should have received a copy of the GNU General Public License", 
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "#", 
            "# If you have questions, please contact jack@augur.net or joey@augur.net.", 
            "", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern consensus: [getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getRRDone:[int256,int256]:int256, incrementPeriodAfterReporting:[int256]:int256, initialPenalizedSetting:[int256,int256,int256]:int256, penalizationCatchup:[int256]:int256, penalizeWrong:[int256,int256]:int256, proportionCorrect:[int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256]", 
            "CONSENSUS = 0xdb03844ecc9b9cb26af853b07fea7199b5590665", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "inset('refund.se')", 
            "", 
            "# Error -1: Hey, you're not broke!", 
            "def cashFaucet():", 
            "    refund()", 
            "    if CASH.balance(msg.sender) > 5*ONE:", 
            "        return(-1)", 
            "    CASH.setCash(msg.sender, 10000*ONE)", 
            "    return(1)", 
            "", 
            "def reputationFaucet(branch):", 
            "    refund()", 
            "    if REPORTING.repIDToIndex(branch, msg.sender) != 0 or REPORTING.getReporterID(branch, 0) == msg.sender:", 
            "        index = REPORTING.repIDToIndex(branch, msg.sender)", 
            "    else:", 
            "        index = REPORTING.getNumberReporters(branch)", 
            "        REPORTING.addReporter(branch, msg.sender)", 
            "    REPORTING.setRep(branch, index, 47*ONE)", 
            "    CONSENSUS.initialPenalizedSetting(branch, msg.sender, (BRANCHES.getVotePeriod(branch)-1))", 
            "    return(1)", 
            "", 
            "def fundNewAccount(branch):", 
            "    CASH.send(self, 0)", 
            "    self.reputationFaucet(branch)", 
            "    CASH.setCash(msg.sender, 10000*2^64)", 
            "    return(1)", 
            "", 
            "#def claimInitialRep(parent, branchID):", 
            "#    refund()", 
            "#    if(BRANCHES.getParent(branchID)!=parent):", 
            "#        return(0)", 
            "    # have 1 month to claim", 
            "    # make sure user can only claim once, use before rep of period where fork was initiated in todo", 
            "#    if(REPORTING.repIDToIndex(branchID, msg.sender)==0 && block.timestamp < (BRANCHES.getCreationDate(branchID) + TWENTYFOURHR*30)):", 
            "#        i = REPORTING.getNumberReporters(branchID)", 
            "#        parentPeriod = BRANCHES.getParentPeriod(branchID)", 
            "        # is this the right before rep so user hasn't lost round 2 bond if they made one", 
            "#        rep = EXPEVENTS.getBeforeRep(parent, parentPeriod, msg.sender)", 
            "#        reporterID = msg.sender", 
            "#        self.Reporting[branchID].reputation[i].reporterID = reporterID", 
            "#        if(self.Reporting[branchID].fork && (userReportedOutcomeEqualToOutcomePreFork || userDidntReportOnForkedEvent || (forkedOverEthicality && userReportedOnEthicalityEqualToPreFork))):", 
            "            # take away 30% of rep from liars and those who didn't report", 
            "#            repDecrease = rep*12912720851596685312/ONE", 
            " #           rep = rep - repDecrease", 
            "  #          amountLeftToPayBonder = doubleOfTheBond - bondDoubledThusFar", 
            "   #         if(repDecrease < amountLeftToPayBonder):", 
            "                # send all the rep to the fork bond poster", 
            "    #        else:", 
            "                # send amountLeftToPayBonder [if positive] to the fork bond poster", 
            "                # send the rest to the new branch's redistribution pool", 
            "     #   self.Reporting[branchID].reputation[i].repValue = rep", 
            "      #  self.Reporting[branchID].activeRep += rep", 
            "       # self.Reporting[branchID].repIDtoIndex[reporterID] = i", 
            "#        if(fork):", 
            " #           forkPeriod = fetchPeriodWhenForked", 
            "  #          CONSENSUS.initialPenalizedSetting(branch, msg.sender, forkPeriod)", 
            "   #     else:", 
            "    #        CONSENSUS.initialPenalizedSetting(branch, msg.sender, (BRANCHES.getVotePeriod(branch)-1))", 
            "     #   self.Reporting[branchID].dormantRep[i].reporterID = reporterID", 
            "      #  dormantRep = EXPEVENTS.getPeriodDormantRep(parent, BRANCHES.getParentPeriod(branchID), msg.sender)", 
            "#        self.Reporting[branchID].dormantRep[i].repValue = dormantRep", 
            " #       self.Reporting[branchID].numberReporters += 1", 
            "  #      self.Reporting[branchID].totalRep += rep + dormantRep", 
            "   #     return(1)", 
            "    #else:", 
            "        # already claimed or too late", 
            "        #return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [], 
                "name": "cashFaucet()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "fundNewAccount(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "reputationFaucet(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern faucets: [cashFaucet:[]:int256, fundNewAccount:[int256]:int256, reputationFaucet:[int256]:int256]"
    }, 
    "fxpFunctions": {
        "address": "0xf641656dfeae64f3cdc4bdaf75d9e6b131135968", 
        "code": [
            "inset('refund.se')", 
            "", 
            "macro fx_floor_log2($x):", 
            "    with $y = $x / 0x10000000000000000:", 
            "        with $lo = 0:", 
            "            with $hi = 191:", 
            "                with $mid = ($hi + $lo)/2:", 
            "                    while (($lo + 1) != $hi):", 
            "                        if $y < 2**$mid:", 
            "                            $hi = $mid", 
            "                        else:", 
            "                            $lo = $mid", 
            "                        $mid = ($hi + $lo)/2", 
            "                    $lo", 
            "", 
            "macro fx_log2_small($x):", 
            "    with $result = -0x48A49EAD9B2CD16BE:", 
            "        with $temp = $x:", 
            "            $result += 0x124DC64B2741E5F083*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x36A569D528A96FF419*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x880785B1DE09970584*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x10AF33C52EB996E92A6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x19FD6E8AC1305DD6D3F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x2086485A91622AE7378*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x210382DF5A3175686B4*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1B58D71F02D9DA4F7B6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1288E14C2FB8C4C1595*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0xA44C5BBEB599D5AB38*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x4A0E619C630B69BC17*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1AE8CAEA63CF2593A9*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x7C3EF5A5BFC21BA1F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x1BD202FA82B683802*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x4A90858A0731AD74*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result -= 0x8CB3CD4376E76EF*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xA6B8F8E68CD877*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result - 0x5D5316875D9E3*$temp / 0x10000000000000000", 
            "", 
            "macro fx_log2($x):", 
            "    with $y = fx_floor_log2($x):", 
            "        with $z = $x / 2**$y:", 
            "            $y * 0x10000000000000000 + fx_log2_small($z)", 
            "", 
            "macro fx_log($x):", 
            "    fx_log2($x) * 0x10000000000000000 / 0x171547652B82FE177", 
            "", 
            "macro fx_exp2_small($x):", 
            "    with $result = 0x10000000000000000:", 
            "        with $temp = $x:", 
            "            $result += 0xB17217F7D1CF79AC*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x3D7F7BFF058B1D56*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xE35846B82505F32*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x276556DF749D7C6*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x5761FF9E294A6F*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xA184897C5558D*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0xFFE5FE24386C*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x162C023B2A1D*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1B5250C02BF*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1E4D3F1A83*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1E87B8E21*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x1C768AA3*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result += 0x164F0A9*$temp / 0x10000000000000000", 
            "            $temp = $temp*$x / 0x10000000000000000", 
            "            $result + 0x1B08D3*$temp / 0x10000000000000000", 
            "", 
            "macro fx_exp2($x):", 
            "    with $y = $x / 0x10000000000000000:", 
            "        with $z = $x % 0x10000000000000000:", 
            "            fx_exp2_small($z) * 2**$y", 
            "", 
            "macro fx_exp($x):", 
            "    fx_exp2($x * 0x10000000000000000 / 0xB17217F7D1CF79AC)", 
            "", 
            "def fx_exp(x):", 
            "    refund()", 
            "    return(fx_exp(x))", 
            "", 
            "def fx_log(x):", 
            "    refund()", 
            "    return(fx_log(x))", 
            "", 
            "def sqrt(n):", 
            "    refund()", 
            "    val = n", 
            "    i = 0", 
            "    while i < 11:", 
            "        val = (val + n*ONE/val)/2", 
            "        i += 1", 
            "    return val"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "fx_exp(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "x", 
                        "type": "int256"
                    }
                ], 
                "name": "fx_log(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "n", 
                        "type": "int256"
                    }
                ], 
                "name": "sqrt(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]"
    }, 
    "info": {
        "address": "0x254d730690f461dc6048c8fd4d9bf49f9fc39829", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "inset('refund.se')", 
            "", 
            "# Every entity in our contract has similar metadata.", 
            "# Instead of putting it in each entity, we put all the", 
            "# metadata here.", 
            "# Info's index is the hash of the item we're getting info on", 
            "data Info[](description[2048], descriptionLength, creator, creationFee)", 
            "", 
            "def init():", 
            "    description = text(\"Root branch\")", 
            "    save(self.Info[1010101].description[0], description, chars=len(description))", 
            "    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826", 
            "    self.Info[1010101].creationFee = 10", 
            "    self.Info[1010101].descriptionLength = len(description)", 
            "", 
            "def getDescription(ID):", 
            "\trefund()", 
            "\tlength=self.Info[ID].descriptionLength", 
            "\treturn(load(self.Info[ID].description[0], chars=length): str)", 
            "", 
            "def getDescriptionLength(ID):", 
            "\trefund()", 
            "\treturn(self.Info[ID].descriptionLength)", 
            "", 
            "def getCreator(ID):", 
            "\trefund()", 
            "\treturn(self.Info[ID].creator)", 
            "", 
            "def getCreationFee(ID):", 
            "\trefund()", 
            "\treturn(self.Info[ID].creationFee)", 
            "", 
            "# @return 1 if success, 0 if creator already exists", 
            "def setInfo(ID, description: str, creator, fee):", 
            "\trefund()", 
            "\t#if(!self.whitelist.check(msg.sender)):", 
            "\t#\treturn(-1)", 
            "\t# check that msg.sender is one of our function contracts", 
            "\tif(self.Info[ID].creator == 0):", 
            "\t\tsave(self.Info[ID].description[0], description, chars=len(description))", 
            "\t\tself.Info[ID].descriptionLength = len(description)", 
            "\t\tself.Info[ID].creationFee = fee", 
            "\t\tself.Info[ID].creator = creator", 
            "\t\treturn(1)", 
            "\telse:", 
            "\t\treturn(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreator(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getDescription(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }
                ], 
                "name": "getDescriptionLength(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "ID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "description", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "creator", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fee", 
                        "type": "int256"
                    }
                ], 
                "name": "setInfo(int256,bytes,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]"
    }, 
    "makeReports": {
        "address": "0x45ec31e7768d81502bf9c022ad7fc4d27324838b", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "extern refund.se: [getBondPoster:[int256]:int256, getFinal:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getRoundTwo:[int256]:int256, setBondPoster:[int256,int256]:int256, setFinal:[int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setRoundTwo:[int256,int256]:int256]", 
            "BACKSTOPS = 0xea9e799a1bbf2b88090a4a4f39ef44df16e31bdf", 
            "# import forking as FORKING", 
            "extern refund.se: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0xf641656dfeae64f3cdc4bdaf75d9e6b131135968", 
            "inset('refund.se')", 
            "", 
            "def makeHash(salt, report, eventID, sender):", 
            "    hashInfo = array(4)", 
            "    hashInfo[0] = sender", 
            "    hashInfo[1] = salt", 
            "    hashInfo[2] = report", 
            "    hashInfo[3] = eventID", 
            "    reportHash = sha256(hashInfo, chars=32*len(hashInfo))", 
            "    return(reportHash)", 
            "", 
            "# Error -1: invalid event", 
            "# Error -2: not in first half of period [commit part]", 
            "def submitReportHash(event, reportHash):", 
            "    branch = EVENTS.getBranch(event)", 
            "    votePeriod = BRANCHES.getVotePeriod(branch)", 
            "    # first report of period, num events not set", 
            "    if(EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)==0):", 
            "        EXPEVENTS.setNumEventsToReportOn(branch)", 
            "        BRANCHES.setInitialBalance(branch, votePeriod, CASH.balance(branch))", 
            "    eventIndex = EXPEVENTS.getEventIndex(votePeriod, event)", 
            "    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "    if(eventIndex==0 && (eventID==0 || event!=eventID)):", 
            "        return(-1)", 
            "    reportingThreshold = 0", 
            "    if(EXPEVENTS.getRequired(event) || EVENTS.getReportingThreshold(event)):", 
            "        reportingThreshold = 2**192", 
            "    else:", 
            "        if(EXPEVENTS.getLesserReportNum(branch, votePeriod, event)==0):", 
            "            EXPEVENTS.setLesserReportNum(branch, votePeriod, event, self.calculateReportTargetForEvent(branch, event, votePeriod, msg.sender))", 
            "        reportingThreshold = EXPEVENTS.calculateReportingThreshold(branch, event, votePeriod, msg.sender)", 
            "    x = array(1)", 
            "    x[0] = msg.sender + event", 
            "    # div by ONE b/c is out of 2**192 rather than 2**256 [to avoid looping around]", 
            "    shaHash = sha3(x, items=1)/ONE", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual < periodLength/2 && shaHash <= reportingThreshold):", 
            "        if(EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, event)==0):", 
            "            EXPEVENTS.addReportExpected(branch, votePeriod, event)", 
            "        EXPEVENTS.setReportHash(branch, votePeriod, msg.sender, reportHash, event)", 
            "        return(1)", 
            "    return(-2)", 
            "", 
            "# @return 1 if success", 
            "# Error messages", 
            "    # 0: reporter doesn't exist or has <.5 rep", 
            "    # -1: has already reported", 
            "    # -2: not in second half of period [reveal part]", 
            "    # -3: hash doesn't match", 
            "    # -4: bad report", 
            "    # -5: invalid event", 
            "    # -6: already resolved", 
            "    # -7: <48 hr left in period, too late to report, able to put up readj. bonds though", 
            "def submitReport(event, salt, report, ethics):", 
            "    balance = REPORTING.getRepBalance(branch, msg.sender)", 
            "    if(balance<ONEHALF):", 
            "        return(0)", 
            "    branch = EVENTS.getBranch(event)", 
            "    votePeriod = BRANCHES.getVotePeriod(branch)", 
            "    if(EXPEVENTS.getReport(branch, votePeriod, event, msg.sender)):", 
            "        return(-1)", 
            "    eventIndex = EXPEVENTS.getEventIndex(votePeriod, event)", 
            "    # makes sure event is in the given branch and vote period", 
            "    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "    if(eventIndex==0 && (eventID==0 || event!=eventID)):", 
            "        return(-5)", 
            "    elif(EVENTS.getOutcome(event)!=0):", 
            "        return(-6)", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    # commented out for testing", 
            "    #if(block.timestamp/periodLength!=((block.timestamp + 2*TWENTYFOURHR)/periodLength)):", 
            "    #    return(-7)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual > periodLength/2):", 
            "        realHash = EXPEVENTS.getReportHash(branch, votePeriod, msg.sender, event)", 
            "        if(self.makeHash(salt, report, eventID, sender)!=realHash || realHash==0):", 
            "            return(-3)", 
            "        # forkedOverEthicality = FORKING.getForkedOverEthicality(event)", 
            "        forkedOverThisEvent = 0", 
            "        if(BRANCHES.getEventForkedOver(branch) == event):", 
            "            forkedOverThisEvent = 1", 
            "        roundTwo = BACKSTOPS.getRoundTwo(event)", 
            "        report = self.validateReport(event, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance)", 
            "        if(report == -4):", 
            "            return(-4)", 
            "        EXPEVENTS.setReport(branch, votePeriod, eventID, report, msg.sender)", 
            "        # set ethics value for event", 
            "        ethics = ethics", 
            "        if(ethics!=ONE || ethics!=0):", 
            "            ethics = ONE", 
            "        if(forkedOverThisEvent):", 
            "            # fork remove ethicality option if was forked over ethicality, other ethicality choice is the ethicality", 
            "            if(forkedOverEthicality):", 
            "                oldEthical = ethic_catch(EVENTS.getEthical(event))", 
            "                if(oldEthical == ONE):", 
            "                    ethics = 0", 
            "                else:", 
            "                    ethics = ONE", 
            "            EXPEVENTS.setEthicReport(branch, votePeriod, event, ethics, msg.sender)", 
            "            ethics = (EVENTS.getForkEthicality(event)*EXPEVENTS.getRepEvent(branch, votePeriod, event) + ethics*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, event) + balance)", 
            "            EVENTS.setForkEthicality(event, ethics)", 
            "        else:", 
            "            EXPEVENTS.setEthicReport(branch, votePeriod, event, ethics, msg.sender)", 
            "            if(roundTwo):", 
            "                ethics = (EVENTS.getEthics(event)*EXPEVENTS.getRepEvent(branch, votePeriod, event) + ethics*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, event) + balance)", 
            "            else:", 
            "                ethics = (EVENTS.getEthics(event)*EXPEVENTS.getNumReportsEvent(branch, votePeriod, event) + ethics) / (EXPEVENTS.getNumReportsEvent(branch, votePeriod, event) + 1)", 
            "            EVENTS.setEthics(eventID, ethics)", 
            "        EXPEVENTS.addReportToEvent(branch, votePeriod, eventID)", 
            "        EXPEVENTS.addRepEvent(branch, votePeriod, event, EXPEVENTS.getBeforeRep(branch, period, msg.sender))", 
            "        # if 1st report of the period for a reporter", 
            "        if(!EXPEVENTS.getReportedPeriod(branch, votePeriod, msg.sender)):", 
            "            dormantRep = REPORTING.balanceOf(branch, msg.sender)", 
            "            # Record rep at start of report period", 
            "            EXPEVENTS.setBeforeRep(branch, votePeriod, balance, msg.sender)", 
            "            EXPEVENTS.setAfterRep(branch, votePeriod, balance, msg.sender)", 
            "            EXPEVENTS.setPeriodDormantRep(branch, votePeriod, dormantRep, msg.sender)", 
            "            EXPEVENTS.setReportedPeriod(branch, votePeriod, msg.sender)", 
            "        return(1)", 
            "    return(-2)", 
            "", 
            "# validates and submits report", 
            "# weights reports by rep if round 2 and fork", 
            "def validateReport(eventID, branch, votePeriod, report, forkedOverEthicality, forkedOverThisEvent, roundTwo, balance):", 
            "    outcome = 0", 
            "    # binary", 
            "    if(EVENTS.getNumOutcomes(eventID)==2 and EVENTS.getMaxValue(eventID)==TWO && EVENTS.getMinValue(eventID)==ONE):", 
            "        if(report>2*ONE or report<ONE or report==0):", 
            "            return(-4)", 
            "        # outcome is calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "        elif(forkedOverThisEvent):", 
            "            # in case of fork remove the original outcome as a possible response if didn't fork over ethics", 
            "            if(!forkedOverEthicality && report == catch(EVENTS.getUncaughtOutcome(eventID))):", 
            "                return(-4)", 
            "            outcome = (EVENTS.getForkOutcome(eventID)*EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + report*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + balance)", 
            "            EVENTS.setForkOutcome(eventID, outcome)", 
            "        else:", 
            "            if(roundTwo):", 
            "                outcome = (EVENTS.getUncaughtOutcome(eventID)*EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + report*balance) / (EXPEVENTS.getRepEvent(branch, votePeriod, eventID) + balance)", 
            "            else:", 
            "                outcome = (EVENTS.getUncaughtOutcome(eventID)*EXPEVENTS.getNumReportsEvent(branch, votePeriod, eventID) + report) / (EXPEVENTS.getNumReportsEvent(branch, votePeriod, eventID) + 1)", 
            "            EVENTS.setUncaughtOutcome(eventID, outcome)", 
            "    # scalar or categorical", 
            "    else:", 
            "        if(report > ONE):", 
            "            report = ONE", 
            "        elif(report<=0):", 
            "            # 1 is the new 0", 
            "            report = 1", 
            "        # in case of fork remove the original outcome as a possible response if didn't fork over ethics", 
            "        if(forkedOverThisEvent):", 
            "            if(!forkedOverEthicality && report == EVENTS.getUncaughtOutcome(eventID)):", 
            "                return(-4)", 
            "            # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "            EXPEVENTS.addToWeightOfReport(votePeriod, eventID, report, balance)", 
            "            if(EXPEVENTS.getWeightOfReport(votePeriod, eventID, report) > EXPEVENTS.getCurrentModeItems(votePeriod, eventID)):", 
            "                EXPEVENTS.setCurrentMode(votePeriod, event, report)", 
            "                EXPEVENTS.setCurrentModeItems(votePeriod, eventID, report)", 
            "            outcome = EXPEVENTS.getCurrentMode(votePeriod, eventID)", 
            "            EVENTS.setForkOutcome(eventID, outcome)", 
            "        else:", 
            "            if(roundTwo):", 
            "                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "                EXPEVENTS.addToWeightOfReport(votePeriod, eventID, report, balance)", 
            "                if(EXPEVENTS.getWeightOfReport(votePeriod, eventID, report) > EXPEVENTS.getCurrentModeItems(votePeriod, eventID)):", 
            "                    EXPEVENTS.setCurrentMode(votePeriod, event, report)", 
            "                    EXPEVENTS.setCurrentModeItems(votePeriod, eventID, report)", 
            "                outcome = EXPEVENTS.getCurrentMode(votePeriod, eventID)", 
            "            else:", 
            "                # outcome (uncaught and mode) is calculated as we go along on a report by report basis (i.e. lazily evaluating things)", 
            "                EXPEVENTS.addToWeightOfReport(votePeriod, eventID, report, 1)", 
            "                if(EXPEVENTS.getWeightOfReport(votePeriod, eventID, report) > EXPEVENTS.getCurrentModeItems(votePeriod, eventID)):", 
            "                    EXPEVENTS.setCurrentMode(votePeriod, event, report)", 
            "                    EXPEVENTS.setCurrentModeItems(votePeriod, eventID, report)", 
            "                outcome = EXPEVENTS.getCurrentMode(votePeriod, eventID)", 
            "            EVENTS.setUncaughtOutcome(eventID, outcome)", 
            "    return(report)", 
            "", 
            "### Helper functions:", 
            "def calculateReportTargetForEvent(branch, eventID, votePeriod, sender):", 
            "    numMarkets = EVENTS.getNumMarkets(eventID)", 
            "    if(numMarkets>25):", 
            "        numMarkets = 25", 
            "    markets = array(numMarkets)", 
            "    markets = EVENTS.getMarkets(eventID, outitems=numMarkets)", 
            "    totalFees = 0", 
            "    shareValue = 0", 
            "    i = 0", 
            "    while i < numMarkets:", 
            "        shareValue += MARKETS.getSharesValue(markets[i])", 
            "        totalFees += MARKETS.getFees(markets[i])", 
            "        i += 1", 
            "    totalVal = EXPEVENTS.getShareValue(branch, votePeriod)", 
            "    shareFraction = shareValue*ONE/totalVal", 
            "    numReportersOnMarket = BRANCHES.getBaseReporters(branch)*((-(267*shareFraction**2)/(2*ONE) + (533*shareFraction)/2 + 1*ONE))", 
            "    totalFeesInWei = totalFees * WEITOETH / ONE", 
            "    canPayForThisManyReporters = totalFeesInWei/(3500000*tx.gasprice)", 
            "    lesser = max(canPayForThisManyReporters*ONE, numReportersOnMarket)", 
            "    EXPEVENTS.refundCost(sender, EXPEVENTS.getSubsidy(branch, votePeriod, eventID))", 
            "    return(lesser)", 
            "", 
            "# eventsExpected == (numberReportEstimate*((reporterList[n]/totalRep)**1.2+.001))", 
            "    # a^b=exp(b*ln(a))=e^(b*ln(a)).", 
            "# returns num events to report on in fxp", 
            "def getNumEventsToReport(branch, votePeriod):", 
            "    prelim = EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)", 
            "    repConstant = REPORTING.getRepBalance(branch, msg.sender)*ONE/REPORTING.getActiveRep(branch)", 
            "    logOutput = FXP.fx_log(repConstant)", 
            "    exp = FXP.fx_exp(22136092888451461120*logOutput/ONE) + 18446744073709552", 
            "    total = exp*prelim + EXPEVENTS.getNumRequired(branch, votePeriod)*ONE", 
            "    eventsInPeriod = EXPEVENTS.getNumberEvents(branch, expDateIndex)-EXPEVENTS.getNumRemoved(branch, votePeriod)", 
            "    minimum = min(30+EXPEVENTS.getNumRequired(branch, votePeriod), eventsInPeriod)", 
            "    if(total/ONE < minimum):", 
            "        total = minimum*ONE", 
            "    return(total)", 
            "", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "calculateReportTargetForEvent(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEventsToReport(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "makeHash(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "ethics", 
                        "type": "int256"
                    }
                ], 
                "name": "submitReport(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reportHash", 
                        "type": "int256"
                    }
                ], 
                "name": "submitReportHash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "forkedOverEthicality", 
                        "type": "int256"
                    }, 
                    {
                        "name": "forkedOverThisEvent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "roundTwo", 
                        "type": "int256"
                    }, 
                    {
                        "name": "balance", 
                        "type": "int256"
                    }
                ], 
                "name": "validateReport(int256,int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern makeReports: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, makeHash:[int256,int256,int256,int256]:int256, submitReport:[int256,int256,int256,int256]:int256, submitReportHash:[int256,int256]:int256, validateReport:[int256,int256,int256,int256,int256,int256,int256,int256]:int256]"
    }, 
    "markets": {
        "address": "0x6428dec6166f621e38ebd24945645cef1b9127cf", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x254d730690f461dc6048c8fd4d9bf49f9fc39829", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "inset('refund.se')", 
            "", 
            "# Markets' index is the marketID", 
            "# Events is a 0 indexed array of events in the market in the format of", 
            "    # [1, event, event, 2, event, 3, event, event, event]", 
            "    # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events", 
            "# Sharespurchased keeps track of the number of shares purchased for each outcome", 
            "    # sharesPurchased states starts at 1 - (same for participants[].shares[] array)", 
            "# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event", 
            "# a binary outcome state 1 is no, 2 is true, 0 if not determined", 
            "# tradingFee is a percent in fixedPoint", 
            "# tradingPeriod is which eventexpperiod market expires in", 
            "data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch, volume, pushingForward, bondsMan, originalPeriod, trade_ids[](id, next_id, prev_id), last_trade, total_trades, tag1, tag2, tag3, makerFees, extraInfo[], extraInfoLen, sharesValue, gasSubsidy, fees, blockNum)", 
            "", 
            "def addFees(market, amount):", 
            "    self.Markets[market].fees += amount", 
            "    return(1)", 
            "", 
            "def refundClosing(amount, to):", 
            "    send(amount, to)", 
            "    return(1)", 
            "", 
            "def getFees(market):", 
            "    return(self.Markets[market].fees)", 
            "", 
            "def getMakerFees(market):", 
            "    return(self.Markets[market].makerFees)", 
            "", 
            "def getgasSubsidy(market):", 
            "    return(self.Markets[market].gasSubsidy)", 
            "", 
            "def getSharesValue(market):", 
            "    return(self.Markets[market].sharesValue)", 
            "", 
            "def returnTags(market):", 
            "    tags = array(3)", 
            "    tags[0] = self.Markets[market].tag1", 
            "    tags[1] = self.Markets[market].tag2", 
            "    tags[2] = self.Markets[market].tag3", 
            "    return(tags: arr)", 
            "", 
            "def getTotalSharesPurchased(market):", 
            "    refund()", 
            "    total = 0", 
            "    n = self.Markets[market].numOutcomes", 
            "    i = 1", 
            "    while i <= n:", 
            "      total += self.Markets[market].sharesPurchased[i]", 
            "      i += 1", 
            "    return(total)", 
            "", 
            "def getMarketEvent(market, index):", 
            "    refund()", 
            "    return(self.Markets[market].events[index])", 
            "", 
            "def getCreationBlock(market):", 
            "    return(self.Markets[market].blockNum)", 
            "", 
            "def getMarketEvents(market):", 
            "    refund()", 
            "    return(load(self.Markets[market].events[0], items=self.Markets[market].lenEvents): arr)", 
            "", 
            "def getSharesPurchased(market, outcome):", 
            "    refund()", 
            "    return(self.Markets[market].sharesPurchased[outcome])", 
            "", 
            "def getExtraInfo(market):", 
            "    refund()", 
            "    length=self.Markets[market].extraInfoLen", 
            "    return(load(self.Markets[market].extraInfo[0], chars=length): str)", 
            "", 
            "def getVolume(market):", 
            "    refund()", 
            "    return(self.Markets[market].volume)", 
            "", 
            "def getParticipantNumber(market, address):", 
            "    refund()", 
            "    participantNumber = self.Markets[market].addr2participant[address]", 
            "    return(participantNumber)", 
            "", 
            "def getParticipantID(market, participantNumber):", 
            "    refund()", 
            "    return(self.Markets[market].participants[participantNumber].participantID)", 
            "", 
            "def getParticipantSharesPurchased(market, participantNumber, outcome):", 
            "    refund()", 
            "    return(self.Markets[market].participants[participantNumber].shares[outcome])", 
            "", 
            "def getNumEvents(market):", 
            "    refund()", 
            "    return(self.Markets[market].lenEvents)", 
            "", 
            "def getCurrentParticipantNumber(market):", 
            "    refund()", 
            "    return(self.Markets[market].currentParticipant)", 
            "", 
            "def getCumScale(market):", 
            "    refund()", 
            "    return(self.Markets[market].cumulativeScale)", 
            "", 
            "def getMarketNumOutcomes(market):", 
            "    refund()", 
            "    return(self.Markets[market].numOutcomes)", 
            "", 
            "def getTradingPeriod(market):", 
            "    refund()", 
            "    return(self.Markets[market].tradingPeriod)", 
            "", 
            "def getOriginalTradingPeriod(market):", 
            "    refund()", 
            "    return(self.Markets[market].originalPeriod)", 
            "", 
            "def setTradingPeriod(market, period):", 
            "    refund()", 
            "    self.Markets[market].tradingPeriod = period", 
            "    return(1)", 
            "", 
            "def getTradingFee(market):", 
            "    refund()", 
            "    return(self.Markets[market].tradingFee)", 
            "", 
            "def getBranchID(market):", 
            "    refund()", 
            "    return(self.Markets[market].branch)", 
            "", 
            "macro market($marketID):", 
            "    self.Markets[$marketID]", 
            "", 
            "macro cumScale($marketID):", 
            "    market($marketID).cumulativeScale", 
            "", 
            "macro numOutcomes($marketID):", 
            "    market($marketID).numOutcomes", 
            "", 
            "macro sharesPurchased($marketID):", 
            "    market($marketID).sharesPurchased", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def initializeMarket(marketID, events: arr, tradingPeriod, tradingFee, branch, tag1, tag2, tag3, makerFees, cumScale, numOutcomes, extraInfo: str, gasSubsidy, creationFee, block):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # add event list to the market", 
            "    save(self.Markets[marketID].events[0], events, items=len(events))", 
            "    self.Markets[marketID].lenEvents = len(events)", 
            "    save(self.Markets[marketID].extraInfo[0], extraInfo, chars=len(extraInfo))", 
            "    self.Markets[marketID].extraInfoLen = len(extraInfo)", 
            "    self.Markets[marketID].tradingPeriod = tradingPeriod", 
            "    self.Markets[marketID].originalPeriod = tradingPeriod", 
            "    self.Markets[marketID].tradingFee = tradingFee", 
            "    self.Markets[marketID].branch = branch", 
            "    self.Markets[marketID].cumulativeScale = cumScale", 
            "    self.Markets[marketID].numOutcomes = numOutcomes", 
            "    self.Markets[marketID].tag1 = tag1", 
            "    self.Markets[marketID].tag2 = tag2", 
            "    self.Markets[marketID].gasSubsidy = gasSubsidy", 
            "    self.Markets[marketID].tag3 = tag3", 
            "    self.Markets[marketID].makerFees = makerFees", 
            "    self.Markets[marketID].fees = creationFee", 
            "    self.Markets[marketID].blockNum = block", 
            "    return(1)", 
            "", 
            "def addParticipant(market, address):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    participantNumber = self.Markets[market].currentParticipant", 
            "    self.Markets[market].participants[participantNumber].participantID = address", 
            "    self.Markets[market].addr2participant[address] = participantNumber", 
            "    self.Markets[market].currentParticipant += 1", 
            "    return(participantNumber)", 
            "", 
            "def modifyShares(marketID, outcome, amount):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    sharesPurchased(marketID)[outcome] += amount", 
            "    return(1)", 
            "", 
            "def modifySharesValue(marketID, amount):", 
            "    self.Markets[marketID].sharesValue += amount", 
            "    return(1)", 
            "", 
            "def modifyParticipantShares(marketID, participantNumber, outcome, amount, cancel):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Markets[marketID].participants[participantNumber].shares[outcome] += amount", 
            "    if(amount<0):", 
            "        amount = amount*-1", 
            "    if(cancel):", 
            "        amount = -1*amount", 
            "    self.Markets[marketID].volume += amount", 
            "    return(1)", 
            "", 
            "def setWinningOutcomes(market, outcomes: arr):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # largest # of winning outcomes is 8", 
            "    save(self.Markets[market].winningOutcomes[0], outcomes, items=len(outcomes))", 
            "    return(1)", 
            "", 
            "def getWinningOutcomes(market):", 
            "    refund()", 
            "    # do whitelist, if oracle system branch, always return outcome, if in whitelist it's good, if not, log", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # largest # of winning outcomes is 8", 
            "    return(load(self.Markets[market].winningOutcomes[0], items=8): arr)", 
            "", 
            "def getOneWinningOutcome(market, num):", 
            "    refund()", 
            "    # whitelist", 
            "    return(self.Markets[market].winningOutcomes[num])", 
            "", 
            "def setTradingFee(market, fee):", 
            "    refund()", 
            "    self.Markets[market].tradingFee = fee", 
            "    return(fee)", 
            "", 
            "def setPushedForward(market, bool, sender):", 
            "    refund()", 
            "    self.Markets[market].pushingForward = bool", 
            "    self.Markets[market].bondsMan = sender", 
            "    return(1)", 
            "", 
            "def getPushedForward(market):", 
            "    refund()", 
            "    return(self.Markets[market].pushingForward)", 
            "", 
            "def getBondsMan(market):", 
            "    refund()", 
            "    return(self.Markets[market].bondsMan)", 
            "", 
            "def getLastTrade(market):", 
            "    refund()", 
            "    return(self.Markets[market].last_trade)", 
            "", 
            "def addTrade(market, trade_id, last_id):", 
            "    refund()", 
            "    self.Markets[market].trade_ids[last_id].next_id = trade_id", 
            "    self.Markets[market].trade_ids[trade_id].prev_id = last_id", 
            "    self.Markets[market].trade_ids[trade_id].id = trade_id", 
            "    self.Markets[market].last_trade = trade_id", 
            "    self.Markets[market].total_trades += 1", 
            "    return(1)", 
            "", 
            "def remove_trade_from_market(market_id, trade_id):", 
            "    refund()", 
            "    prev_id = self.Markets[market_id].trade_ids[trade_id].prev_id", 
            "    next_id = self.Markets[market_id].trade_ids[trade_id].next_id", 
            "    if prev_id and next_id:", 
            "        self.Markets[market_id].trade_ids[prev_id].next_id = next_id", 
            "        self.Markets[market_id].trade_ids[next_id].prev_id = prev_id", 
            "    elif prev_id:", 
            "        self.Markets[market_id].last_trade = prev_id", 
            "        self.Markets[market_id].trade_ids[prev_id].next_id = 0", 
            "", 
            "    if next_id:", 
            "        self.Markets[market_id].trade_ids[trade_id].next_id = 0", 
            "    if prev_id:", 
            "        self.Markets[market_id].trade_ids[trade_id].prev_id = 0", 
            "    self.Markets[market_id].trade_ids[trade_id].id = 0", 
            "    self.Markets[market_id].total_trades -= 1", 
            "    return(1)", 
            "", 
            "def get_trade_ids(market_id):", 
            "    refund()", 
            "    trades_count = self.Markets[market_id].total_trades", 
            "    trade_id = self.Markets[market_id].last_trade", 
            "    trade_ids = array(trades_count)", 
            "", 
            "    i = 0", 
            "    while i < trades_count:", 
            "        trade_ids[i] = self.Markets[market_id].trade_ids[trade_id].id", 
            "        trade_id = self.Markets[market_id].trade_ids[trade_id].prev_id", 
            "        i = i + 1", 
            "", 
            "    if trade_ids:", 
            "        return(trade_ids:arr)", 
            "    return([FAILURE]:arr)", 
            "", 
            "def get_total_trades(market_id):", 
            "    refund()", 
            "    return(self.Markets[market_id].total_trades)", 
            "", 
            "", 
            "", 
            "macro EVENTS_FIELDS: 6", 
            "macro OUTCOMES_FIELDS: 2", 
            "macro WINNING_OUTCOMES_FIELDS: 8", 
            "macro FIELDS: 16", 
            "", 
            "def getMarketInfo(marketID):", 
            "    refund()", 
            "    index = FIELDS", 
            "    participantNumber = self.Markets[marketID].addr2participant[msg.sender]", 
            "    descriptionLength = INFO.getDescriptionLength(marketID)", 
            "    traderFields = 1 + self.Markets[marketID].numOutcomes", 
            "    with info = array(FIELDS + self.Markets[marketID].currentParticipant*traderFields + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1):", 
            "        numEvents = self.Markets[marketID].lenEvents", 
            "        info[0] = marketID", 
            "        info[1] = self.Markets[marketID].currentParticipant", 
            "        info[2] = self.Markets[marketID].makerFees", 
            "        info[3] = participantNumber", 
            "        info[4] = self.Markets[marketID].numOutcomes", 
            "        info[5] = self.Markets[marketID].tradingPeriod", 
            "        info[6] = self.Markets[marketID].tradingFee", 
            "        info[7] = self.Markets[marketID].branch", 
            "        info[8] = self.Markets[marketID].lenEvents", 
            "        info[9] = self.Markets[marketID].cumulativeScale", 
            "        info[10] = self.Markets[marketID].blockNum", 
            "        info[11] = INFO.getCreationFee(marketID)", 
            "        info[12] = INFO.getCreator(marketID)", 
            "        info[13] = self.Markets[marketID].tag1", 
            "        info[14] = self.Markets[marketID].tag2", 
            "        info[15] = self.Markets[marketID].tag3", 
            "", 
            "        # gather trader(s) info: [trader ID, 1 shares, 2 shares, 3 shares, ...]", 
            "        t = 0", 
            "        while t < self.Markets[marketID].currentParticipant:", 
            "            info[index + t*traderFields] = self.Markets[marketID].participants[t].participantID", 
            "            o = 1", 
            "            while o < self.Markets[marketID].numOutcomes + 1:", 
            "                info[index + t*traderFields + o] = self.Markets[marketID].participants[t].shares[o]", 
            "                o += 1", 
            "            t += 1", 
            "        index += self.Markets[marketID].currentParticipant*traderFields", 
            "", 
            "        # gather event(s) info:", 
            "        # [eventID, expirationDate, outcome, minValue, maxValue, numOutcomes]", 
            "        with events = slice(load(self.Markets[marketID].events[0], chars=32*numEvents), items=0, items=numEvents):", 
            "            i = 0", 
            "            while i < numEvents:", 
            "                with eventInfo = EVENTS.getEventInfo(events[i], outitems=EVENTS_FIELDS):", 
            "                    info[index + i*EVENTS_FIELDS] = events[i]", 
            "                    j = 1", 
            "                    while j < EVENTS_FIELDS:", 
            "                        info[index + i*EVENTS_FIELDS + j] = eventInfo[j]", 
            "                        j += 1", 
            "                i += 1", 
            "        index += numEvents*EVENTS_FIELDS", 
            "", 
            "        # gather outcomes info:", 
            "        # [sharesPurchased, price, winningOutcomes...]", 
            "        k = 0", 
            "        while k < self.Markets[marketID].numOutcomes:", 
            "            info[index + k*OUTCOMES_FIELDS] = self.Markets[marketID].sharesPurchased[k + 1]", 
            "            k += 2", 
            "        index += self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS", 
            "        k = 0", 
            "        while k < WINNING_OUTCOMES_FIELDS:", 
            "            info[index + k] = self.Markets[marketID].winningOutcomes[k]", 
            "            k += 1", 
            "        index += WINNING_OUTCOMES_FIELDS", 
            "", 
            "        # append description character codes", 
            "        info[index] = descriptionLength", 
            "        index += 1", 
            "        with description = INFO.getDescription(marketID, outchars=descriptionLength):", 
            "            c = 0", 
            "            while c < descriptionLength:", 
            "                info[index + c] = getch(description, c)", 
            "                c += 1", 
            "        return(info: arr)", 
            "", 
            "# Gets all information about all markets on the specified branch and", 
            "# returns it as a giant array.  getMarketsInfo requires a great deal of gas.", 
            "# Invoke using eth_call with gas=9999999999999 (or other very large number).", 
            "# @param {int} branch Branch ID that we're retrieving markets on.", 
            "# @param {int} offset Starting market index (0=full load).", 
            "# @param {int} numMarketsToLoad How many markets to load (0=all markets).", 
            "# @return array Array containing all data for all markets:", 
            "#            [N, length_1, length_2, ..., length_N, info_1, info_2, ..., info_N]", 
            "#           where length_j is the number of elements stored for market j,", 
            "#           info_j is the information array for market j, and N is the total", 
            "#           number of markets in this branch.", 
            "def getMarketsInfo(branch, offset, numMarketsToLoad):", 
            "    refund()", 
            "    numMarkets = BRANCHES.getNumMarketsBranch(branch)", 
            "    with marketIDs = BRANCHES.getMarketsInBranch(branch, outitems=numMarkets):", 
            "        if numMarketsToLoad > 0 and numMarketsToLoad < numMarkets:", 
            "            numMarkets = numMarketsToLoad", 
            "        with marketsMatrix = array(numMarkets):", 
            "            with marketArrayLength = array(numMarkets):", 
            "                m = 0", 
            "                while m < numMarkets:", 
            "                    marketID = marketIDs[m + offset]", 
            "                    traderFields = 1 + self.Markets[marketID].numOutcomes", 
            "                    participantNumber = self.Markets[marketID].addr2participant[msg.sender]", 
            "                    descriptionLength = INFO.getDescriptionLength(marketID)", 
            "                    marketArrayLength[m] = FIELDS + self.Markets[marketID].currentParticipant*traderFields + self.Markets[marketID].lenEvents*EVENTS_FIELDS + self.Markets[marketID].numOutcomes*OUTCOMES_FIELDS + WINNING_OUTCOMES_FIELDS + descriptionLength + 1", 
            "                    marketsMatrix[m] = self.getMarketInfo(marketID, outitems=marketArrayLength[m])", 
            "                    m += 1", 
            "", 
            "                # flatten the markets info matrix so it can be returned", 
            "                # (data offset by 1+numMarkets so length data can be prepended)", 
            "                totalFlatLength = 1 + numMarkets", 
            "                m = 0", 
            "                while m < numMarkets:", 
            "                    totalFlatLength += marketArrayLength[m]", 
            "                    m += 1", 
            "                with flattened = array(totalFlatLength):", 
            "                    flattened[0] = numMarkets", 
            "                    m = 0", 
            "                    while m < numMarkets:", 
            "                        flattened[m + 1] = marketArrayLength[m]", 
            "                        m += 1", 
            "                    currentFlatLength = 1 + numMarkets", 
            "                    row = 0", 
            "                    while row < numMarkets:", 
            "                        col = 0", 
            "                        while col < marketArrayLength[row]:", 
            "                            flattened[currentFlatLength + col] = marketsMatrix[row][col]", 
            "                            col += 1", 
            "                        currentFlatLength += col", 
            "                        row += 1", 
            "                    return(flattened: arr)", 
            "", 
            "def getSender():", 
            "    return(msg.sender)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "addFees(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "addParticipant(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "trade_id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "last_id", 
                        "type": "int256"
                    }
                ], 
                "name": "addTrade(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getBondsMan(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getBranchID(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCreationBlock(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCumScale(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getCurrentParticipantNumber(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getExtraInfo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getFees(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getLastTrade(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMakerFees(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketEvent(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketEvents(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketInfo(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketNumOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "offset", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numMarketsToLoad", 
                        "type": "int256"
                    }
                ], 
                "name": "getMarketsInfo(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumEvents(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "num", 
                        "type": "int256"
                    }
                ], 
                "name": "getOneWinningOutcome(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getOriginalTradingPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantID(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantNumber(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getParticipantSharesPurchased(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getPushedForward(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "getSender()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "getSharesPurchased(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getSharesValue(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalSharesPurchased(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTradingFee(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getTradingPeriod(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getVolume(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getWinningOutcomes(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market_id", 
                        "type": "int256"
                    }
                ], 
                "name": "get_total_trades(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market_id", 
                        "type": "int256"
                    }
                ], 
                "name": "get_trade_ids(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "getgasSubsidy(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "events", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "tradingPeriod", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tradingFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag1", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag2", 
                        "type": "int256"
                    }, 
                    {
                        "name": "tag3", 
                        "type": "int256"
                    }, 
                    {
                        "name": "makerFees", 
                        "type": "int256"
                    }, 
                    {
                        "name": "cumScale", 
                        "type": "int256"
                    }, 
                    {
                        "name": "numOutcomes", 
                        "type": "int256"
                    }, 
                    {
                        "name": "extraInfo", 
                        "type": "bytes"
                    }, 
                    {
                        "name": "gasSubsidy", 
                        "type": "int256"
                    }, 
                    {
                        "name": "creationFee", 
                        "type": "int256"
                    }, 
                    {
                        "name": "block", 
                        "type": "int256"
                    }
                ], 
                "name": "initializeMarket(int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "participantNumber", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "cancel", 
                        "type": "int256"
                    }
                ], 
                "name": "modifyParticipantShares(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "modifyShares(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "marketID", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "modifySharesValue(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "to", 
                        "type": "int256"
                    }
                ], 
                "name": "refundClosing(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market_id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "trade_id", 
                        "type": "int256"
                    }
                ], 
                "name": "remove_trade_from_market(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }
                ], 
                "name": "returnTags(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "bool", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "setPushedForward(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fee", 
                        "type": "int256"
                    }
                ], 
                "name": "setTradingFee(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "period", 
                        "type": "int256"
                    }
                ], 
                "name": "setTradingPeriod(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcomes", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setWinningOutcomes(int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]"
    }, 
    "penalizeNotEnoughReports": {
        "address": "0x9b066e999b90d78caf5f9a6eaa8a84e36d4a8e51", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern consensus: [getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getRRDone:[int256,int256]:int256, incrementPeriodAfterReporting:[int256]:int256, initialPenalizedSetting:[int256,int256,int256]:int256, penalizationCatchup:[int256]:int256, penalizeWrong:[int256,int256]:int256, proportionCorrect:[int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256]", 
            "CONSENSUS = 0xdb03844ecc9b9cb26af853b07fea7199b5590665", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "extern refund.se: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0xf641656dfeae64f3cdc4bdaf75d9e6b131135968", 
            "extern makeReports: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, makeHash:[int256,int256,int256,int256]:int256, submitReport:[int256,int256,int256,int256]:int256, submitReportHash:[int256,int256]:int256, validateReport:[int256,int256,int256,int256,int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x45ec31e7768d81502bf9c022ad7fc4d27324838b", 
            "inset('refund.se')", 
            "", 
            "# Basically, if you don't access the account, the rep just sort of sits there, proverbially speaking, it's burned.  If you access the account, it's sent to the branch's rep account and distributed like trading fees.  To prevent double claiming, similarly to trading fees each rep acc. that hadn't claimed rep or trading fees but reported that past period would neither be able to send nor receive rep until they claimed.  You'd get % of people that reported fees / rep", 
            "# Errors:", 
            "    # -1: already done", 
            "    # -2: hasn't reported this period", 
            "def penalizeNotEnoughReports(branch):", 
            "    refund()", 
            "    lastPeriod = BRANCHES.getVotePeriod(branch)-1", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(CONSENSUS.getNotEnoughPenalized(branch, msg.sender, lastPeriod)):", 
            "        return(-1)", 
            "    # accounts for if no events in a period", 
            "    if(EXPEVENTS.getNumberEvents(branch, lastPeriod)==0):", 
            "        CONSENSUS.setNotEnoughPenalized(branch, msg.sender, lastPeriod)", 
            "        return(1)", 
            "    if(BRANCHES.getForkPeriod(branch)+1 == lastPeriod):", 
            "        CONSENSUS.setNotEnoughPenalized(branch, msg.sender, lastPeriod)", 
            "        return(1)", 
            "", 
            "    if(!EXPEVENTS.getReportedPeriod(branch, lastPeriod, msg.sender)):", 
            "        return(-2)", 
            "    if(residual > periodLength/2):", 
            "        return(-2)", 
            "    numEvents = MAKEREPORTS.getNumEventsToReport(branch, lastPeriod)", 
            "    repConstant = REPORTING.getRepBalance(branch, msg.sender)*ONE/REPORTING.getActiveRep(branch)", 
            "    logOutput = FXP.fx_log(repConstant)", 
            "    exp = FXP.fx_exp(22136092888451461120*logOutput/ONE)", 
            "    exp += 18446744073709552", 
            "    baseReporters = CONSENSUS.getBaseReportersLastPeriod(branch)", 
            "    total = exp*baseReporters", 
            "    # correction for if people have more than x [4.6% of at 40 min reporters] rep in one account - they report on everything (hence incentive to divy rep into mult. accounts and not pool) i.e. if((exp(ln(rep%)*1.2)+0.001)*40 > 1)", 
            "    if(total > ONE):", 
            "        numEvents = (EXPEVENTS.getNumEventsToReportOn(branch, votePeriod)/baseReporters)*ONE + EXPEVENTS.getNumRequired(branch, votePeriod)", 
            "    numReportsActual = EXPEVENTS.getNumReportsActual(branch, lastPeriod, msg.sender)", 
            "    if(numEvents/(2*ONE) > EXPEVENTS.getNumReportsActual(branch, lastPeriod, msg.sender)):", 
            "        originalRep = REPORTING.getRepBalance(branch, msg.sender)", 
            "        # penalize people", 
            "        # can number reported on be greater than num expected to report on", 
            "        newRep = 3689348814741910528*numReportsActual*originalRep / numEvents", 
            "        oldRep = originalRep*14757395258967642112 / ONE", 
            "        repChange = (oldRep+newRep) - originalRep", 
            "        if(repChange > 0):", 
            "            return(1)", 
            "        # removes rep from reporter who lost it", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, msg.sender), repChange)", 
            "        # sends that rep to the branch rep pool", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), -repChange)", 
            "        EXPEVENTS.setBeforeRep(branch, lastPeriod, oldRep+newRep, msg.sender)", 
            "        EXPEVENTS.setAfterRep(branch, lastPeriod, oldRep+newRep, msg.sender)", 
            "    CONSENSUS.setNotEnoughPenalized(branch, msg.sender, lastPeriod)", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "penalizeNotEnoughReports(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern penalizeNotEnoughReports: [penalizeNotEnoughReports:[int256]:int256]"
    }, 
    "reporting": {
        "address": "0x078f90d721992b617a2c65f17340b05add6f9552", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "inset('refund.se')", 
            "", 
            "# Reporting index is the branchID", 
            "# Reporters index is the rep. address", 
            "# We 0 index reputation so can walk thru for consensus", 
            "# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future", 
            "# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key", 
            "# Events is 0 indexed as well", 
            "data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[], totalRep, dormantRep[](repValue, reporterID), activeRep, fork)", 
            "", 
            "data whitelists[](addresses[], taken)", 
            "", 
            "def init():", 
            "    self.Reporting[1010101].repIDtoIndex[msg.sender] = 0", 
            "    self.Reporting[1010101].reputation[0].repValue = 0", 
            "    self.Reporting[1010101].reputation[0].reporterID = msg.sender", 
            "    self.Reporting[1010101].numberReporters = 2", 
            "    self.Reporting[1010101].repIDtoIndex[1010101] = 1", 
            "    self.Reporting[1010101].reputation[1].repValue = 0", 
            "    self.Reporting[1010101].reputation[1].reporterID = 1010101", 
            "", 
            "def checkWhitelist(address):", 
            "    refund()", 
            "    return(self.whitelists[msg.sender].addresses[address])", 
            "", 
            "def getActiveRep(branch):", 
            "    return(self.Reporting[branch].activeRep)", 
            "", 
            "def adjustActiveRep(branch, amount):", 
            "    self.Reporting[branch].activeRep += amount", 
            "    return(1)", 
            "", 
            "def setFork(branch):", 
            "    self.Reporting[branch].fork = 1", 
            "    return(1)", 
            "", 
            "def getFork(branch):", 
            "    return(self.Reporting[branch].fork)", 
            "", 
            "def checkContractWhitelist(contract, address):", 
            "    refund()", 
            "    return(self.whitelists[contract].addresses[address])", 
            "", 
            "def setWhitelist(contract, addresses:arr):", 
            "    refund()", 
            "    if self.whitelists[contract].taken:", 
            "        return(text(\"ERROR: you have to vote to change a whitelist\"):str)", 
            "    else:", 
            "        self.whitelists[contract].taken = 1", 
            "        i = 0", 
            "        l = len(addresses)", 
            "        while i <l:", 
            "            address = addresses[i]", 
            "            self.whitelists[contract].addresses[addresses] = 1", 
            "            i += 1", 
            "        return(text(\"SUCCESS\"):str)", 
            "", 
            "# @return reputation value", 
            "def getRepByIndex(branch, repIndex):", 
            "    refund()", 
            "    return(self.Reporting[branch].reputation[repIndex].repValue)", 
            "", 
            "# @return reputation value", 
            "def getRepBalance(branch, address):", 
            "    refund()", 
            "    repIndex = self.Reporting[branch].repIDtoIndex[address]", 
            "    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):", 
            "        return(0)", 
            "    return(self.Reporting[branch].reputation[repIndex].repValue)", 
            "", 
            "def getDormantRepByIndex(branch, repIndex):", 
            "    refund()", 
            "    return(self.Reporting[branch].dormantRep[repIndex].repValue)", 
            "", 
            "# @return reputation value", 
            "# getDormantRepBalance", 
            "def balanceOf(branch, address):", 
            "    refund()", 
            "    repIndex = self.Reporting[branch].repIDtoIndex[address]", 
            "    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):", 
            "        return(0)", 
            "    return(self.Reporting[branch].dormantRep[repIndex].repValue)", 
            "", 
            "# return total supply of dormant rep", 
            "def totalSupply(branch):", 
            "    return((self.Reporting[branch].totalRep - self.Reporting[branch].activeRep))", 
            "", 
            "def getReporterID(branch, index):", 
            "    refund()", 
            "    return(self.Reporting[branch].reputation[index].reporterID)", 
            "", 
            "def getTotalRep(branch):", 
            "    refund()", 
            "    return(self.Reporting[branch].totalRep)", 
            "", 
            "# will return 0s for array values after it's looped through all the ones you", 
            "# have an actual balance in", 
            "def getReputation(address):", 
            "    refund()", 
            "    branchListCount = BRANCHES.getNumBranches()", 
            "    if(address):", 
            "        branches = array(2*branchListCount)", 
            "        branchList = array(branchListCount)", 
            "        branchList = BRANCHES.getBranches(outitems=branchListCount)", 
            "        i = 0", 
            "        b = 0", 
            "        while i < branchListCount:", 
            "            branch = branchList[i]", 
            "            balance = self.getRepBalance(branch, address)", 
            "            if(balance!=0):", 
            "                branches[b] = branch", 
            "                branches[b+1] = balance", 
            "                b += 2", 
            "            i += 1", 
            "    else:", 
            "        address = msg.sender", 
            "        branches = array(2*branchListCount)", 
            "        branchList = array(branchListCount)", 
            "        branchList = BRANCHES.getBranches(outitems=branchListCount)", 
            "        i = 0", 
            "        b = 0", 
            "        while i < branchListCount:", 
            "            branch = branchList[i]", 
            "            balance = self.getRepBalance(branch, address)", 
            "            if(balance!=0):", 
            "                branches[b] = branch", 
            "                branches[b+1] = balance", 
            "                b += 2", 
            "            i += 1", 
            "    return(branches: arr)", 
            "", 
            "def getNumberReporters(branch):", 
            "    refund()", 
            "    return(self.Reporting[branch].numberReporters)", 
            "", 
            "def repIDToIndex(branch, repID):", 
            "    refund()", 
            "    return(self.Reporting[branch].repIDtoIndex[repID])", 
            "", 
            "def hashReport(report: arr, salt):", 
            "    refund()", 
            "    hashInfo = array(len(report) + 2)", 
            "    hashInfo[0] = msg.sender", 
            "    hashInfo[1] = salt", 
            "    i = 2", 
            "    while i < (len(report) + 2):", 
            "        hashInfo[i] = report[i-2]", 
            "        i += 1", 
            "    reportHash = sha256(hashInfo, chars=32*len(hashInfo))", 
            "    return(reportHash)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "def setInitialReporters(parent, branchID):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    # add branch as a \"reporter\"", 
            "    self.Reporting[branchID].numberReporters = 1", 
            "    self.Reporting[branchID].repIDtoIndex[branchID] = 0", 
            "    self.Reporting[branchID].reputation[0].repValue = 0", 
            "    self.Reporting[branchID].reputation[0].reporterID = branchID", 
            "    return(1)", 
            "", 
            "def addReporter(branch, sender):", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    refund()", 
            "    reporterIndex = self.Reporting[branch].numberReporters", 
            "    self.Reporting[branch].repIDtoIndex[sender] = reporterIndex", 
            "    self.Reporting[branch].reputation[reporterIndex].repValue = 0", 
            "    self.Reporting[branch].reputation[reporterIndex].reporterID = sender", 
            "    self.Reporting[branch].dormantRep[reporterIndex].reporterID = sender", 
            "    self.Reporting[branch].numberReporters += 1", 
            "    return(1)", 
            "", 
            "def addRep(branch, index, value):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].reputation[index].repValue += value", 
            "    return(1)", 
            "", 
            "def subtractRep(branch, index, value):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].reputation[index].repValue -= value", 
            "    return(1)", 
            "", 
            "def setRep(branch, index, newRep):", 
            "    refund()", 
            "    #if !self.whitelist.check(msg.sender):", 
            "    #    return(-1)", 
            "    oldRep = self.Reporting[branch].reputation[index].repValue", 
            "    self.Reporting[branch].reputation[index].repValue = newRep", 
            "    self.Reporting[branch].activeRep += newRep - oldRep", 
            "    self.Reporting[branch].totalRep += newRep - oldRep", 
            "    return(1)", 
            "", 
            "def addDormantRep(branch, index, value):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].dormantRep[index].repValue += value", 
            "    return(1)", 
            "", 
            "def subtractDormantRep(branch, index, value):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    self.Reporting[branch].dormantRep[index].repValue -= value", 
            "    return(1)", 
            "", 
            "# check that msg.sender is one of our function contracts", 
            "# make this cheaper", 
            "def setSaleDistribution(addresses: arr, balances: arr, branchID):", 
            "    refund()", 
            "    #if(!self.whitelist.check(msg.sender)):", 
            "    #    return(-1)", 
            "    i = 0", 
            "    while i < len(addresses):", 
            "        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].reporterID = addresses[i]", 
            "        self.Reporting[branchID].reputation[self.Reporting[branchID].numberReporters].repValue = balances[i]", 
            "        self.Reporting[branchID].dormantRep[self.Reporting[branchID].numberReporters].reporterID = addresses[i]", 
            "        self.Reporting[branchID].repIDtoIndex[addresses[i]] = self.Reporting[branchID].numberReporters", 
            "        self.Reporting[branchID].numberReporters += 1", 
            "        i+=1", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "addDormantRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "addRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "addReporter(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }
                ], 
                "name": "adjustActiveRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "balanceOf(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "contract", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "checkContractWhitelist(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "checkWhitelist(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getActiveRep(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getDormantRepByIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getFork(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getNumberReporters(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepBalance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repIndex", 
                        "type": "int256"
                    }
                ], 
                "name": "getRepByIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }
                ], 
                "name": "getReporterID(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "address", 
                        "type": "int256"
                    }
                ], 
                "name": "getReputation(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "getTotalRep(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "report", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }
                ], 
                "name": "hashReport(int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "repID", 
                        "type": "int256"
                    }
                ], 
                "name": "repIDToIndex(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "setFork(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "parent", 
                        "type": "int256"
                    }, 
                    {
                        "name": "branchID", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialReporters(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "newRep", 
                        "type": "int256"
                    }
                ], 
                "name": "setRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "addresses", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "balances", 
                        "type": "int256[]"
                    }, 
                    {
                        "name": "branchID", 
                        "type": "int256"
                    }
                ], 
                "name": "setSaleDistribution(int256[],int256[],int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "contract", 
                        "type": "int256"
                    }, 
                    {
                        "name": "addresses", 
                        "type": "int256[]"
                    }
                ], 
                "name": "setWhitelist(int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "bytes"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractDormantRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "index", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "subtractRep(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }
                ], 
                "name": "totalSupply(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]"
    }, 
    "roundTwo": {
        "address": "0x00dac9a399eafc564ddba8e948d99ab13ed6e6e3", 
        "code": [
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x254d730690f461dc6048c8fd4d9bf49f9fc39829", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPIRING = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "extern refund.se: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, getBond:[int256]:int256, getBranch:[int256]:int256, getEthical:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getExpiration:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getPushedBack:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getRejectedUncaught:[int256]:int256, getReportingThreshold:[int256]:int256, getResolution:[int256]:bytes, getUncaughtOutcome:[int256]:int256, getmode:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setEthics:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setOutcome:[int256,int256]:int256, setPushedBack:[int256]:int256, setRejected:[int256,int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, setmode:[int256,int256]:int256]", 
            "EVENTS = 0x7e115a8fdcdc564a3313a16d3308e9a2ccf8fce9", 
            "extern refund.se: [fx_exp:[int256]:int256, fx_log:[int256]:int256, sqrt:[int256]:int256]", 
            "FXP = 0xf641656dfeae64f3cdc4bdaf75d9e6b131135968", 
            "extern makeReports: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, makeHash:[int256,int256,int256,int256]:int256, submitReport:[int256,int256,int256,int256]:int256, submitReportHash:[int256,int256]:int256, validateReport:[int256,int256,int256,int256,int256,int256,int256,int256]:int256]", 
            "MAKEREPORTS = 0x45ec31e7768d81502bf9c022ad7fc4d27324838b", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern refund.se: [getBondPoster:[int256]:int256, getFinal:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getRoundTwo:[int256]:int256, setBondPoster:[int256,int256]:int256, setFinal:[int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setRoundTwo:[int256,int256]:int256]", 
            "BACKSTOPS = 0xea9e799a1bbf2b88090a4a4f39ef44df16e31bdf", 
            "extern sendReputation: [allowance:[int256,int256]:int256, approve:[int256,int256,int256]:int256, convertToActiveRep:[int256,int256]:int256, convertToDormantRep:[int256,int256]:int256, sendReputation:[int256,int256,int256]:int256, transfer:[int256,int256,int256]:int256, transferFrom:[int256,int256,int256,int256]:int256]", 
            "SENDREP = 0x20364b3ec5d1ef6435b68bb3eaf0752b778b8909", 
            "inset('refund.se')", 
            "", 
            "", 
            "# todo do bond", 
            "# Appeal_Bond = Market_Value * (0.01 + Market_Fee / 2) + Average_Adjudication_Cost", 
            "    # Average_Adjudication_Cost = Total fees paid to reporters for all markets in this reporting round / number of markets in this reporting round.", 
            "        # needs an abs min of ~200 rep.", 
            "# Reporting period is 2 months minus 48 hours.  This 48 hours allows for the appeals to take place before the next reporting round begins.", 
            "# todo make sure network isn't forked / forking atm", 
            "def roundTwoPostBond(branch, event, eventIndex, votePeriod):", 
            "    refund()", 
            "    bond = 100*ONE", 
            "    if(BRANCHES.getVotePeriod(branch)!=votePeriod):", 
            "        return(0)", 
            "    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "    # if so, we're in the final 24 hours and event is in this branch + votePeriod", 
            "    if(!resolving && block.timestamp/BRANCHES.getPeriodLength(branch)!=((block.timestamp + 2*TWENTYFOURHR)/BRANCHES.getPeriodLength(branch)) && eventID!=0 && event==eventID && BACKSTOPS.getRoundTwo(event)==0 && EVENTS.getForked(event)==0):", 
            "        if(SENDREP.sendReputation(branch, event, bond)==0):", 
            "            return(0)", 
            "        period = BRANCHES.getVotePeriod(branch)", 
            "        # remove from events in # to report on calc for last period", 
            "        EXPIRING.removeEvent(branch, period)", 
            "        # makes event required reporting in round 2 (the next period) as well", 
            "        EXPIRING.setEventRequired(branch, period+1, event)", 
            "        # push event into next period", 
            "        EXPIRING.addEvent(branch, period+1, event)", 
            "        # set event expiration date to be after the current reporting period ends", 
            "        EVENTS.setExpiration(event, block.timestamp)", 
            "        # set round two to true so can't be done again", 
            "        BACKSTOPS.setRoundTwo(event, 1)", 
            "        BACKSTOPS.setOriginalVotePeriod(event, votePeriod)", 
            "        if(scalar(event) or categorical(event)):", 
            "            BACKSTOPS.setOriginalOutcome(event, EVENTS.getUncaughtOutcome(event))", 
            "        else:", 
            "            BACKSTOPS.setOriginalOutcome(event, catch(EVENTS.getUncaughtOutcome(event)))", 
            "        BACKSTOPS.setOriginalEthicality(event, ethic_catch(EVENTS.getEthical(event)))", 
            "        EXPEVENTS.addRoundTwo(branch, period)", 
            "        BACKSTOPS.setBondPoster(event, msg.sender)", 
            "        EVENTS.setUncaughtOutcome(event, 0)", 
            "        EVENTS.setmode(event, 0)", 
            "        EVENTS.setEthics(event, 0)", 
            "        return(1)", 
            "        EVENTS.setUncaughtOutcome(event, 0)", 
            "        EVENTS.setmode(event, 0)", 
            "        EVENTS.setEthics(event, 0)", 
            "        return(1)", 
            "", 
            "def roundTwoResolve(branch, event, eventIndex, votePeriod):", 
            "    refund()", 
            "    overruled = 1", 
            "    bond = 100*ONE", 
            "    votedOnAgain = 0", 
            "    eventID = EXPEVENTS.getEvent(branch, votePeriod, eventIndex)", 
            "    if(scalar(event) or categorical(event)):", 
            "        if(BACKSTOPS.getOriginalOutcome(event) == EVENTS.getUncaughtOutcome(event) && BACKSTOPS.getOriginalEthicality(event)==ethic_catch(EVENTS.getEthical(event))):", 
            "            overruled = 0", 
            "    elif(BACKSTOPS.getOriginalOutcome(event) == catch(EVENTS.getUncaughtOutcome(event)) && BACKSTOPS.getOriginalEthicality(event)==ethic_catch(EVENTS.getEthical(event))):", 
            "        overruled = 0", 
            "    if(BRANCHES.getVotePeriod(branch) > (EVENTS.getExpiration(event) / BRANCHES.getPeriodLength(branch))):", 
            "        votedOnAgain = 1", 
            "    # todo any round 2 events besides forked one should have bond returned", 
            "    if(forked && didntForkOverThisEventSpecifically && bondNotReturned && BACKSTOPS.getRoundTwo(event)):", 
            "        # return the bond", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, event), bond)", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getBondPoster(event)), bond)", 
            "        bondReturned = 1", 
            "        BACKSTOPS.setRoundTwo(event, 0)", 
            "        return(1)", 
            "    elif(overruled && votedOnAgain && BACKSTOPS.getRoundTwo(event) && votePeriod!=BACKSTOPS.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked && msg.sender == bondPoster):", 
            "        # return the bond", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, event), bond)", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, BACKSTOPS.getBondPoster(event)), bond)", 
            "        # and set final outcome / event bond, etc", 
            "        self.resolve(branch, event, msg.sender)", 
            "        # reward the bonded challenger with whatever rep would normally be taken from the liars up to 2x the bond, then beyond that the people who originally reported whatever the actual truth was would get the rest. then regular rbcr for the round 2 reporting [don't count ethicality here]", 
            "        BACKSTOPS.setFinal(event)", 
            "        return(2*bond)", 
            "    elif(votedOnAgain && BACKSTOPS.getRoundTwo(event) && votePeriod!=BACKSTOPS.getOriginalVotePeriod(event) && eventID!=0 && event==eventID && !forked):", 
            "        # lose bond", 
            "        REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, event), bond)", 
            "        REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), bond)", 
            "        # and set final outcome / event bond, etc", 
            "        self.resolve(branch, event, msg.sender)", 
            "        # rbcr from original period/orig. outcome stands, rbcr from round 2 happens as usual as well", 
            "        BACKSTOPS.setFinal(event)", 
            "    # not voted on again yet", 
            "    else:", 
            "        return(0)", 
            "", 
            "macro scalar($event):", 
            "    ((EVENTS.getMaxValue($event)!=TWO || EVENTS.getMinValue($event)!=ONE) && EVENTS.getNumOutcomes($event)==2)", 
            "", 
            "macro binary($event):", 
            "    (EVENTS.getNumOutcomes($event)==2 and EVENTS.getMaxValue($event)==TWO and EVENTS.getMinValue($event)==2**6Z)", 
            "", 
            "macro categorical($event):", 
            "    (EVENTS.getNumOutcomes($event)>2)", 
            "", 
            "macro YES: TWO", 
            "macro NO: ONE", 
            "macro BAD: 3 * ONEHALF", 
            "macro CATCH_TOLERANCE: ONE / 10", 
            "", 
            "# Bins values to 1, 1.5, 2", 
            "macro catch($x):", 
            "    if($x < (BAD - CATCH_TOLERANCE)):", 
            "        NO", 
            "    elif($x > (BAD + CATCH_TOLERANCE)):", 
            "        YES", 
            "    else:", 
            "        BAD", 
            "", 
            "macro ethic_catch($x):", 
            "    if($x < ONEHALF):", 
            "        0", 
            "    else:", 
            "        ONE", 
            "", 
            "# take from bond to pay for resolution of a round 2 event", 
            "def resolve(branch, event, sender):", 
            "    refund()", 
            "    bond = EVENTS.getBond(event)", 
            "    ethical = ethic_catch(EVENTS.getEthical(event))", 
            "    payback = min(1000000*tx.gasprice*ONE/WEITOETH, bond)", 
            "    # binary", 
            "    if(binary(event)):", 
            "        fxpOutcome = catch(EVENTS.getUncaughtOutcome(event))", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "        if(fxpOutcome==3*ONEHALF || !ethical):", 
            "            # give event bond money to reporters", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(branch, bond-payback)", 
            "            CASH.addCash(sender, payback)", 
            "            # not ethical is same as 1.5 outcome w/ binary", 
            "            fxpOutcome = 3*ONEHALF", 
            "            EVENTS.setOutcome(event, fxpOutcome)", 
            "        else:", 
            "            # return bond", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(sender, payback)", 
            "            CASH.addCash(INFO.getCreator(event), bond-payback)", 
            "        return(1)", 
            "    # scalar", 
            "    elif(scalar(event) or categorical(event)):", 
            "        mode = EVENTS.getUncaughtOutcome(event)", 
            "        EVENTS.setmode(event, mode)", 
            "        scaled_max = EVENTS.getMaxValue(event)", 
            "        scaled_min = EVENTS.getMinValue(event)", 
            "        fxpOutcome = mode * (scaled_max - scaled_min)/ONE + scaled_min", 
            "        EVENTS.setOutcome(event, fxpOutcome)", 
            "        if(fxpOutcome==ONEHALF || !ethical):", 
            "            # give event bond money to reporters", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(branch, bond-payback)", 
            "            CASH.addCash(sender, payback)", 
            "            # not ethical is same as .5 outcome w/ scalar", 
            "            fxpOutcome = ONEHALF", 
            "            EVENTS.setOutcome(event, fxpOutcome)", 
            "            EVENTS.setmode(event, fxpOutcome)", 
            "        else:", 
            "            # return bond", 
            "            CASH.subtractCash(event, bond)", 
            "            CASH.addCash(sender, payback)", 
            "            CASH.addCash(INFO.getCreator(event), bond-payback)", 
            "        return(1)", 
            "    # (should never be reached)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "resolve(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "roundTwoPostBond(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "event", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventIndex", 
                        "type": "int256"
                    }, 
                    {
                        "name": "votePeriod", 
                        "type": "int256"
                    }
                ], 
                "name": "roundTwoResolve(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern roundTwo: [resolve:[int256,int256,int256]:int256, roundTwoPostBond:[int256,int256,int256,int256]:int256, roundTwoResolve:[int256,int256,int256,int256]:int256]"
    }, 
    "sendReputation": {
        "address": "0x20364b3ec5d1ef6435b68bb3eaf0752b778b8909", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "extern makeReports: [calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, getNumEventsToReport:[int256,int256]:int256, makeHash:[int256,int256,int256,int256]:int256, submitReport:[int256,int256,int256,int256]:int256, submitReportHash:[int256,int256]:int256, validateReport:[int256,int256,int256,int256,int256,int256,int256,int256]:int256]", 
            "REPORTS = 0x45ec31e7768d81502bf9c022ad7fc4d27324838b", 
            "extern consensus: [getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeesCollected:[int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getRRDone:[int256,int256]:int256, incrementPeriodAfterReporting:[int256]:int256, initialPenalizedSetting:[int256,int256,int256]:int256, penalizationCatchup:[int256]:int256, penalizeWrong:[int256,int256]:int256, proportionCorrect:[int256]:int256, setFeesCollected:[int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256]", 
            "CONSENSUS = 0xdb03844ecc9b9cb26af853b07fea7199b5590665", 
            "inset('refund.se')", 
            "", 
            "# sender/owner, then spender", 
            "data amountCanSpend[][]", 
            "", 
            "event Transfer(_from:indexed, _to:indexed, _value)", 
            "event Approval(_owner:indexed, _spender:indexed, value)", 
            "", 
            "# @return value of reputation sent, 0 if not enough reputation", 
            "# error messages otherwise", 
            "    # -1: \"Your reputation account was just created, earn some rep. before you can send to others\"", 
            "    # -2: \"Receiving address doesn't exist\"", 
            "def sendReputation(branch, recver, value):", 
            "    refund()", 
            "    # Rep cannot be simultaneously spent (transferred) and used to vote", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    # you can't trade if you or the person you're sending to have submitted a report, or at all in the second half of the period [b/c you can messup / cheat w/ reporting] and you can't trade in the first half of a period until you've been penalized for reporting wrongly/not reporting", 
            "    # use a diff. fun. than getReport here", 
            "    #if(value<=0 || EXPEVENTS.getReport(branch, currentVotePeriod, tx.origin, 0) != 0 || EXPEVENTS.getReport(branch, currentVotePeriod, msg.sender, 0) != 0 || EXPEVENTS.getReport(branch, currentVotePeriod, recver, 0) != 0):", 
            "    # EXPIRING.getReportedPeriod(branch, current)", 
            "    #    return(0)", 
            "    # need to check all this for the person it's being sent to as well", 
            "    #if(REPORTS.getRRUpToDate()!=1):", 
            "    #    doIt()", 
            "    #    self.RRDone = true", 
            "    #if(hasReported(lastPeriod) && periodOver && hasntcollectedfees && residual > periodLength/2):", 
            "    #    CONSENSUS.collectFees(lastPeriod)", 
            "    # before rep, after rep, balance", 
            "    # person you're sending to needs rr up to date / done as well", 
            "    # auto increment vote period if needed", 
            "    sender = tx.origin", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "    receiverIndex = REPORTING.repIDToIndex(branch, recver)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one, only if in first half of period", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=tx.origin):", 
            "        REPORTING.addReporter(branch, sender)", 
            "        CONSENSUS.initialPenalizedSetting(branch, tx.origin, (BRANCHES.getVotePeriod(branch)-1))", 
            "        return(-1)", 
            "", 
            "    if(REPORTING.getReporterID(branch, receiverIndex)!=recver):", 
            "        return(-2)", 
            "", 
            "    senderBalance = REPORTING.getRepBalance(branch, sender)", 
            "    if(senderBalance >= value && value > 0):", 
            "        if(REPORTING.subtractRep(branch, senderIndex, value) && REPORTING.addRep(branch, receiverIndex, value)):", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# @return value of reputation sent, 0 if not enough reputation", 
            "# error messages otherwise", 
            "    # -1: \"Your reputation account was just created, earn some rep. before you can send to others\"", 
            "    # -2: \"Receiving address doesn't exist\"", 
            "# sendDormantRep", 
            "def transfer(branch, recver, value):", 
            "    refund()", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    if(value<=0):", 
            "        return(0)", 
            "", 
            "    sender = msg.sender", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "    receiverIndex = REPORTING.repIDToIndex(branch, recver)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=msg.sender):", 
            "        CONSENSUS.initialPenalizedSetting(branch, msg.sender, (BRANCHES.getVotePeriod(branch)-1))", 
            "        REPORTING.addReporter(branch, sender)", 
            "        CONSENSUS.initialPenalizedSetting(branch, msg.sender, (BRANCHES.getVotePeriod(branch)-1))", 
            "        return(-1)", 
            "", 
            "    if(REPORTING.getReporterID(branch, receiverIndex)!=recver):", 
            "        return(-2)", 
            "", 
            "    senderBalance = REPORTING.balanceOf(branch, sender)", 
            "    if(senderBalance >= value && value > 0):", 
            "        if(REPORTING.subtractDormantRep(branch, senderIndex, value) && REPORTING.addDormantRep(branch, receiverIndex, value)):", 
            "            log(type=Transfer, msg.sender, recver, value)", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# fails unless from has authorized sender", 
            "def transferFrom(branch, from, recver, value):", 
            "    refund()", 
            "    currentVotePeriod = BRANCHES.getVotePeriod(branch)", 
            "    if(value<=0):", 
            "        return(0)", 
            "", 
            "    sender = from", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "    receiverIndex = REPORTING.repIDToIndex(branch, recver)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=from):", 
            "        CONSENSUS.initialPenalizedSetting(branch, from, (BRANCHES.getVotePeriod(branch)-1))", 
            "        REPORTING.addReporter(branch, sender)", 
            "        CONSENSUS.initialPenalizedSetting(branch, from, (BRANCHES.getVotePeriod(branch)-1))", 
            "        return(-1)", 
            "", 
            "    if(REPORTING.getReporterID(branch, receiverIndex)!=recver):", 
            "        return(-2)", 
            "", 
            "    senderBalance = REPORTING.balanceOf(branch, sender)", 
            "    if(senderBalance >= value && value > 0 && self.amountCanSpend[from][msg.sender]>=value):", 
            "        if(REPORTING.subtractDormantRep(branch, senderIndex, value) && REPORTING.addDormantRep(branch, receiverIndex, value)):", 
            "            self.amountCanSpend[from][msg.sender] -= value", 
            "            log(type=Transfer, from, recver, value)", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# allows spender to withdraw from your account", 
            "def approve(branch, spender, value):", 
            "    self.amountCanSpend[msg.sender][spender] = value", 
            "    log(type=Approval, msg.sender, spender, value)", 
            "    return(1)", 
            "", 
            "# returns amount spender can withdraw from owner", 
            "def allowance(owner, spender):", 
            "    return(self.amountCanSpend[owner][spender])", 
            "", 
            "# error messages", 
            "    # -1: not in first half of reporting period", 
            "# shouldn't be penalized for dormant rep when converting back to active due to not reporting beyond the dormant penalization", 
            "def convertToDormantRep(branch, value):", 
            "    refund()", 
            "    # if not in first half of reporting period", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual > periodLength/2):", 
            "      return(-1)", 
            "\t\t# benny comment:", 
            "            #```Maybe still have this sort-of variable \"power\" to it, but REP initially doesn't have \"full-power\", or REP that hasn't been used to report over the past week has now let it's \"power-meter\" drop to only 20% earning power (it's kind-of dormant), that then ramps back up to 100% power once it gets used a bit. Could there be an element of this type of time-decay programmed into the REP that's helps incentive? Something like this would make the system more automatic, rather than relying on the user to manually switch \"on\" or switch \"off\" the REP. If a user knows, \"I better report this week or my REP's power meter goes down to 20% again, and it's gonna take extra effort to get it back to full-power\", well that's pretty good incentive to keep the user active, without actually taking it from them.```", 
            "", 
            "    if(value<=0):", 
            "        return(0)", 
            "", 
            "    #if(REPORTS.getRRUpToDate()!=1):", 
            "    #    doIt()", 
            "", 
            "    #if(hasReported(lastPeriod) && periodOver):", 
            "        #CONSENSUS.collectFees(lastPeriod)", 
            "", 
            "    sender = tx.origin", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=tx.origin):", 
            "        REPORTING.addReporter(branch, sender)", 
            "        CONSENSUS.initialPenalizedSetting(branch, tx.origin, (BRANCHES.getVotePeriod(branch)-1))", 
            "        return(-1)", 
            "", 
            "    senderBalance = REPORTING.getRepBalance(branch, sender)", 
            "    if(senderBalance >= value):", 
            "        if(REPORTING.subtractRep(branch, senderIndex, value) && REPORTING.addDormantRep(branch, senderIndex, value)):", 
            "            REPORTING.adjustActiveRep(branch, -value)", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)", 
            "", 
            "# error messages", 
            "    # -1: not in first half of reporting period", 
            "def convertToActiveRep(branch, value):", 
            "    refund()", 
            "    # if not in first half of reporting period", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual > periodLength/2):", 
            "      return(-1)", 
            "", 
            "    if(value<=0):", 
            "        return(0)", 
            "", 
            "    #if(REPORTS.getRRUpToDate()):", 
            "        #doIt()", 
            "    #if(hasReported(lastPeriod) && periodOver):", 
            "        #CONSENSUS.collectFees(lastPeriod)", 
            "", 
            "    sender = tx.origin", 
            "    senderIndex = REPORTING.repIDToIndex(branch, sender)", 
            "", 
            "    # if the sender's rep. account doesn't exist, make one", 
            "    if(REPORTING.getReporterID(branch, senderIndex)!=tx.origin):", 
            "        REPORTING.addReporter(branch, sender)", 
            "        CONSENSUS.initialPenalizedSetting(branch, tx.origin, (BRANCHES.getVotePeriod(branch)-1))", 
            "        return(-1)", 
            "", 
            "    senderBalance = REPORTING.balanceOf(branch, sender)", 
            "    if(senderBalance >= value):", 
            "        if(REPORTING.subtractDormantRep(branch, senderIndex, value) && REPORTING.addRep(branch, senderIndex, value)):", 
            "            REPORTING.adjustActiveRep(branch, value)", 
            "            return(value)", 
            "        else:", 
            "            return(0)", 
            "    else:", 
            "        return(0)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "owner", 
                        "type": "int256"
                    }, 
                    {
                        "name": "spender", 
                        "type": "int256"
                    }
                ], 
                "name": "allowance(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "spender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "approve(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "convertToActiveRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "convertToDormantRep(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "sendReputation(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "transfer(int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "from", 
                        "type": "int256"
                    }, 
                    {
                        "name": "recver", 
                        "type": "int256"
                    }, 
                    {
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "transferFrom(int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "_owner", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "_spender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "value", 
                        "type": "int256"
                    }
                ], 
                "name": "Approval(int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "_from", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "_to", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "_value", 
                        "type": "int256"
                    }
                ], 
                "name": "Transfer(int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern sendReputation: [allowance:[int256,int256]:int256, approve:[int256,int256,int256]:int256, convertToActiveRep:[int256,int256]:int256, convertToDormantRep:[int256,int256]:int256, sendReputation:[int256,int256,int256]:int256, transfer:[int256,int256,int256]:int256, transferFrom:[int256,int256,int256,int256]:int256]"
    }, 
    "slashRep": {
        "address": "0xf26f89c68fffd5f06db8fb23c015189f1e0fd648", 
        "code": [
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern expiringEvents: [addEvent:[int256,int256,int256,int256]:int256, addRepEvent:[int256,int256,int256,int256]:int256, addReportExpected:[int256,int256,int256]:int256, addReportToEvent:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodShareValueOutstanding:[int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getEventsToReportOn:[int256,int256]:int256[], getLesserReportNum:[int256,int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsActual:[int256,int256,int256]:int256, getNumReportsEvent:[int256,int256,int256]:int256, getNumReportsExpectedEvent:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepConstant:[int256,int256,int256]:int256, getRepEvent:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getReportHash:[int256,int256,int256,int256]:int256, getReportedPeriod:[int256,int256,int256]:int256, getRequired:[int256]:int256, getShareValue:[int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setNumReportsEvent:[int256,int256,int256,int256]:int256, setNumReportsExpectedEvent:[int256,int256,int256,int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepConstant:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, setReportHash:[int256,int256,int256,int256,int256]:int256, setReportedPeriod:[int256,int256,int256]:int256, setReportingThreshold:[int256]:int256]", 
            "EXPEVENTS = 0x25b9da0d8f2a33fae066e3e2a5a97bdd88b41bbf", 
            "extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOf:[int256,int256]:int256, checkContractWhitelist:[int256,int256]:int256, checkWhitelist:[int256]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getFork:[int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, hashReport:[int256[],int256]:int256, repIDToIndex:[int256,int256]:int256, setFork:[int256]:int256, setInitialReporters:[int256,int256]:int256, setRep:[int256,int256,int256]:int256, setSaleDistribution:[int256[],int256[],int256]:int256, setWhitelist:[int256,int256[]]:bytes, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, totalSupply:[int256]:int256]", 
            "REPORTING = 0x078f90d721992b617a2c65f17340b05add6f9552", 
            "", 
            "inset('refund.se')", 
            "", 
            "# anti cheat provide ballot and randomNum mechanism steal deposit", 
            "# Returns:", 
            "    # 0: not a valid claim", 
            "    # -2: reporter doesn't exist", 
            "def slashRep(branch, salt, report, reporter, eventID):", 
            "    refund()", 
            "    periodLength = BRANCHES.getPeriodLength(branch)", 
            "    residual = block.timestamp % periodLength", 
            "    if(residual > periodLength/2):", 
            "        return(-2)", 
            "    votePeriod = BRANCHES.getVotePeriod(branch)", 
            "    realHash = EXPEVENTS.getReportHash(branch, votePeriod, reporter, eventID)", 
            "    hashInfo = array(4)", 
            "    hashInfo[0] = reporter", 
            "    hashInfo[1] = salt", 
            "    hashInfo[2] = report", 
            "    hashInfo[3] = eventID", 
            "    reportHash = sha256(hashInfo, chars=32*len(hashInfo))", 
            "    if(reportHash!=realHash):", 
            "        return(0)", 
            "    else:", 
            "        reporterIndex = REPORTING.repIDToIndex(branch, reporter)", 
            "        trutherIndex = REPORTING.repIDToIndex(branch, msg.sender)", 
            "        # if the truther's rep. account doesn't exist, make one", 
            "        if(REPORTING.getReporterID(branch, trutherIndex)!=msg.sender):", 
            "            trutherIndex = REPORTING.getNumberReporters(branch)", 
            "            REPORTING.addReporter(branch, msg.sender)", 
            "        if(REPORTING.getReporterID(branch, reporterIndex)!=reporter):", 
            "            return(-2)", 
            "        reporterBalance = REPORTING.getRepBalance(branch, reporter)", 
            "        REPORTING.setRep(branch, reporterIndex, 0)", 
            "        trutherBalance = REPORTING.getRepBalance(branch, msg.sender)", 
            "        REPORTING.setRep(branch, trutherIndex, (trutherBalance + reporterBalance*ONEHALF / ONE))", 
            "    return(reporterBalance)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "branch", 
                        "type": "int256"
                    }, 
                    {
                        "name": "salt", 
                        "type": "int256"
                    }, 
                    {
                        "name": "report", 
                        "type": "int256"
                    }, 
                    {
                        "name": "reporter", 
                        "type": "int256"
                    }, 
                    {
                        "name": "eventID", 
                        "type": "int256"
                    }
                ], 
                "name": "slashRep(int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern slashRep: [slashRep:[int256,int256,int256,int256,int256]:int256]"
    }, 
    "trade": {
        "address": "0x6818102e23a0f35e31b61f0ad84df66ad0996824", 
        "code": [
            "# This software (Augur) allows buying && selling event outcomes in ethereum", 
            "# Copyright (C) 2015 Forecast Foundation OU", 
            "#    This program is free software; you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation; either version 2 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is free software: you can redistribute it &&/or modify", 
            "#    it under the terms of the GNU General Public License as published by", 
            "#    the Free Software Foundation, either version 3 of the License, or", 
            "#    (at your option) any later version.", 
            "#", 
            "#    This program is distributed in the hope that it will be useful,", 
            "#    but WITHOUT ANY WARRANTY; without even the implied warranty of", 
            "#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", 
            "#    GNU General Public License for more details.", 
            "#", 
            "#    You should have received a copy of the GNU General Public License", 
            "#    along with this program.  If not, see <http://www.gnu.org/licenses/>.", 
            "# Any questions please contact joey@augur.net", 
            "", 
            "# Note: must spend at least 1 in ONE", 
            "", 
            "extern branches: [addMarketToBranch:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranches:[]:int256[], getCreationDate:[int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getInitialBalance:[int256,int256]:int256, getMarketsInBranch:[int256]:int256[], getMinTradingFee:[int256]:int256, getNumBranches:[]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getSomeMarketsInBranch:[int256,int256,int256]:int256[], getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initDefaultBranch:[]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256]:int256]", 
            "BRANCHES = 0x65c474942e08998c423b0574f45226d4aac2db14", 
            "extern refund.se: [getCreationFee:[int256]:int256, getCreator:[int256]:int256, getDescription:[int256]:bytes, getDescriptionLength:[int256]:int256, setInfo:[int256,bytes,int256,int256]:int256]", 
            "INFO = 0x254d730690f461dc6048c8fd4d9bf49f9fc39829", 
            "extern refund.se: [addCash:[int256,int256]:int256, balance:[int256]:int256, depositEther:[]:int256, initiateOwner:[int256]:int256, send:[int256,int256]:int256, sendFrom:[int256,int256,int256]:int256, setCash:[int256,int256]:int256, subtractCash:[int256,int256]:int256, withdrawEther:[int256,int256]:int256]", 
            "CASH = 0xbd272e493163dcfe1726cecdb14c85942ebba648", 
            "extern markets: [addFees:[int256,int256]:int256, addParticipant:[int256,int256]:int256, addTrade:[int256,int256,int256]:int256, getBondsMan:[int256]:int256, getBranchID:[int256]:int256, getCreationBlock:[int256]:int256, getCumScale:[int256]:int256, getCurrentParticipantNumber:[int256]:int256, getExtraInfo:[int256]:bytes, getFees:[int256]:int256, getLastTrade:[int256]:int256, getMakerFees:[int256]:int256, getMarketEvent:[int256,int256]:int256, getMarketEvents:[int256]:int256[], getMarketInfo:[int256]:int256[], getMarketNumOutcomes:[int256]:int256, getMarketsInfo:[int256,int256,int256]:int256[], getNumEvents:[int256]:int256, getOneWinningOutcome:[int256,int256]:int256, getOriginalTradingPeriod:[int256]:int256, getParticipantID:[int256,int256]:int256, getParticipantNumber:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSender:[]:int256, getSharesPurchased:[int256,int256]:int256, getSharesValue:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, getVolume:[int256]:int256, getWinningOutcomes:[int256]:int256[], get_total_trades:[int256]:int256, get_trade_ids:[int256]:int256[], getgasSubsidy:[int256]:int256, initializeMarket:[int256,int256[],int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, modifyParticipantShares:[int256,int256,int256,int256,int256]:int256, modifyShares:[int256,int256,int256]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, remove_trade_from_market:[int256,int256]:int256, returnTags:[int256]:int256[], setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, setWinningOutcomes:[int256,int256[]]:int256]", 
            "MARKETS = 0x6428dec6166f621e38ebd24945645cef1b9127cf", 
            "extern refund.se: [checkHash:[int256,int256]:int256, commitTrade:[int256]:int256, fill_trade:[int256,int256]:int256, getID:[int256]:int256, getInitialTrade:[int256]:int256, get_amount:[int256]:int256, get_price:[int256]:int256, get_trade:[int256]:int256[], makeTradeHash:[int256,int256,int256[]]:int256, remove_trade:[int256]:int256, saveTrade:[int256,int256,int256,int256,int256,int256,int256]:int256, setInitialTrade:[int256]:int256, update_trade:[int256,int256]:_, zeroHash:[]:int256]", 
            "TRADES = 0xb8c254877dd025d04bb760e7b738e1219dbc2708", 
            "inset('refund.se')", 
            "", 
            "event log_price(market:indexed, type, price, amount, timestamp, outcome, trader:indexed)", 
            "event log_fill_tx(market:indexed, sender:indexed, owner:indexed, type, price, amount, tradeid, outcome)", 
            "", 
            "# Trade types", 
            "macro BID: 1", 
            "macro ASK: 2", 
            "# Field counts", 
            "macro TRADE_FIELDS: 9", 
            "# Boolean success/failure", 
            "macro SUCCESS: 1", 
            "# Error codes", 
            "macro INSUFFICIENT_BALANCE: 10", 
            "macro TRADE_SAME_BLOCK_PROHIBITED: 22", 
            "", 
            "macro fee_percent($market_fee, $price, $cumScale):", 
            "    4 * $market_fee * $price * (ONE-$price*2**64/$cumScale) / ($cumScale*ONE)", 
            "", 
            "macro remove_trade($trade_id, $market):", 
            "    TRADES.remove_trade($trade_id)", 
            "    MARKETS.remove_trade_from_market($market, $trade_id)", 
            "", 
            "#", 
            "# Trade", 
            "#", 
            "# Errors:", 
            "    # -1: oracle only branch", 
            "    # -2: bad trade hash", 
            "    # -3: trader doesn't exist / own shares in this market", 
            "    # -4: must buy at least .00000001 in value", 
            "    # 10: insufficient balance", 
            "#Exchange(Market, outcome, sender, amount, receiver, payment) - transfers amount shares from sender to receiver for payment amount", 
            "#max value is max amount to spend to buy [including fees]", 
            "#max amount is max shares to sell", 
            "# 500k gas", 
            "def trade(max_value, max_amount, trade_ids:arr):", 
            "    refund()", 
            "    if(BRANCHES.getOracleOnly(branch)):", 
            "        return(-1)", 
            "    i = 0", 
            "    trades = 0", 
            "    while i < len(trade_ids):", 
            "        trades += trade_ids[i]", 
            "        i+=1", 
            "    tradeInfo = array(3)", 
            "    tradeInfo[0] = trades", 
            "    tradeInfo[1] = max_amount", 
            "    tradeInfo[2] = max_value", 
            "    tradeHash = sha256(tradeInfo, items=3)", 
            "    if(TRADES.checkHash(tradeHash, msg.sender)==-1):", 
            "        return(-2)", 
            "    max_value = max_value", 
            "    max_amount = max_amount", 
            "    # Try to fulfill each trade passed", 
            "    t = 0", 
            "    while t < len(trade_ids):", 
            "        trade_id = trade_ids[t]", 
            "        # Get trade", 
            "        trade = array(TRADE_FIELDS)", 
            "        trade = TRADES.get_trade(trade_id, outitems=TRADE_FIELDS)", 
            "        if !trade:", 
            "            return(0)", 
            "        # Get market", 
            "        type = trade[1]", 
            "        market = trade[2]", 
            "        creator = INFO.getCreator(market)", 
            "        amount = trade[3]", 
            "        price = trade[4]", 
            "        owner = trade[5]", 
            "        outcome = trade[8]", 
            "        if(owner == msg.sender or owner == tx.origin):", 
            "            return(0)", 
            "        # Make sure the trade has been mined, obvious HFT prevention", 
            "        if block.number <= trade[6]:", 
            "            return(TRADE_SAME_BLOCK_PROHIBITED)", 
            "        branch = MARKETS.getBranchID(market)", 
            "        trading_fee = MARKETS.getTradingFee(market)", 
            "        cumScale = MARKETS.getCumScale(market)", 
            "        fee = fee_percent(trading_fee, price, cumScale)", 
            "", 
            "        # Fill buy order", 
            "        if type == BID:", 
            "            # Get available balance of shares", 
            "            participantNumber = MARKETS.getParticipantNumber(market, msg.sender)", 
            "            balance = MARKETS.getParticipantSharesPurchased(market, participantNumber, outcome)", 
            "            if(balance > 0 and max_amount > 0):", 
            "                if(MARKETS.getParticipantID(market, participantNumber) != msg.sender):", 
            "                    return(-3)", 
            "                makerFeeRate = MARKETS.getMakerFees(market)", 
            "                sender = MARKETS.getParticipantNumber(market, msg.sender)", 
            "                ownerNum = MARKETS.getParticipantNumber(market, owner)", 
            "                # Determine fill amount", 
            "                fill = min(amount, min(balance, max_amount))", 
            "                # Calculate value", 
            "                value = (fill * price)/ONE", 
            "                # must trade at least 0.00000001 in value", 
            "                if(value < 184467440738):", 
            "                    return(-4)", 
            "                # Update trade amount or remove", 
            "                if fill < amount:", 
            "                    TRADES.fill_trade(trade_id, fill)", 
            "                else:", 
            "                    remove_trade(trade_id, market)", 
            "                # Update balances", 
            "                MARKETS.modifyParticipantShares(market, sender, outcome, -fill, 0)", 
            "                MARKETS.modifyParticipantShares(market, ownerNum, outcome, fill, 0)", 
            "                # Transfer cash from person who bid to the person here who is selling [bidder has already sent/escrowed the cash to/with the market when submitting bid]", 
            "                fee = value * fee / ONE", 
            "                # THREEFOURTHS is 3/4", 
            "                branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE", 
            "                creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE", 
            "                takerFeesTotal = branchFees + creatorFees", 
            "                CASH.addCash(msg.sender, value-takerFeesTotal)", 
            "                # 75% to branch + .5% more to branch per maker fee 1% decrease", 
            "                CASH.addCash(branch, branchFees)", 
            "                # 25% to creator + .5% more to creator per 1% decrease in maker fees", 
            "                CASH.addCash(creator, creatorFees)", 
            "                CASH.subtractCash(market, value)", 
            "", 
            "                # other party [maker] pay their part of the fee here too", 
            "                fee = fee * makerFeeRate / ONE", 
            "                CASH.subtractCash(market, fee)", 
            "                CASH.addCash(creator, fee/2)", 
            "                CASH.addCash(branch, fee/2)", 
            "", 
            "                # needed to keep track of how many fees a market has raised", 
            "                MARKETS.addFees(market, fee+takerFeesTotal)", 
            "                # Update max_amount", 
            "                max_amount -= fill", 
            "                # Log transaction", 
            "                log(type=log_fill_tx, market, msg.sender, owner, ASK, price, fill, trade_id, outcome)", 
            "            else:", 
            "                return(INSUFFICIENT_BALANCE)", 
            "        elif type == ASK:", 
            "            balance = CASH.balance(msg.sender)", 
            "            makerFeeRate = MARKETS.getMakerFees(market)", 
            "            feeRate = 3*2**64/2**65 - makerFeeRate", 
            "            maxAmountGivenBalance = balance*2**64/(feeRate+2**64)", 
            "            max_value = min(maxAmountGivenBalance, max_value)", 
            "            if max_value > 0:", 
            "                # Calculate value of trade", 
            "                trade_value = amount * price / ONE", 
            "                # Determine fill value", 
            "                value = min(max_value, trade_value)", 
            "                if(value < 184467440738):", 
            "                    return(-4)", 
            "                fee = value * fee / ONE", 
            "                branchFees = (THREEFOURTHS+(ONEHALF - makerFeeRate)/2)*fee / ONE", 
            "                creatorFees = (ONEFOURTH+(ONEHALF - makerFeeRate)/2)*fee / ONE", 
            "                takerFeesTotal = branchFees + creatorFees", 
            "                if(balance < (value + takerFeesTotal)):", 
            "                    return(INSUFFICIENT_BALANCE)", 
            "                fill = 0", 
            "                # Calculate fill amount, update trade amount or remove filled trade", 
            "                if value < trade_value:", 
            "                    fill = value*ONE / price", 
            "                    TRADES.fill_trade(trade_id, fill)", 
            "                else:", 
            "                    fill = amount", 
            "                    remove_trade(trade_id, market)", 
            "                participantNumber = MARKETS.getParticipantNumber(market, msg.sender)", 
            "                # if participant doesn't exist in market, add them", 
            "                if(msg.sender != MARKETS.getParticipantID(market, participantNumber)):", 
            "                    participantNumber = MARKETS.addParticipant(market, msg.sender)", 
            "", 
            "                # Update balances [user asking has already gotten rid of shares in escrow, just need to add them to the buyer]", 
            "                MARKETS.modifyParticipantShares(market, participantNumber, outcome, fill, 0)", 
            "                # Transfer cash from user to person who has ask order and pay fee to branch and market creator", 
            "                # 75% to branch + .5% more to branch per maker fee 1% decrease", 
            "                CASH.addCash(branch, branchFees)", 
            "                # 25% to creator + .5% more to creator per 1% decrease in maker fees", 
            "                CASH.addCash(creator, creatorFees)", 
            "                cost = value + takerFeesTotal", 
            "                CASH.addCash(owner, value)", 
            "                CASH.subtractCash(msg.sender, cost)", 
            "", 
            "                # other party [maker] pay their part of the fee here too", 
            "                fee = fee * makerFeeRate / ONE", 
            "                CASH.subtractCash(market, fee)", 
            "                CASH.addCash(creator, fee/2)", 
            "                CASH.addCash(branch, fee/2)", 
            "", 
            "                MARKETS.addFees(market, fee+takerFeesTotal)", 
            "                # Update max_value", 
            "                max_value -= value", 
            "                # Log transaction", 
            "                log(type=log_fill_tx, market, msg.sender, owner, BID, price, fill, trade_id, outcome)", 
            "            else:", 
            "                return(INSUFFICIENT_BALANCE)", 
            "", 
            "        # Log price, fill amount, type and timestamp", 
            "        log(type=log_price, market, type, price, fill, block.timestamp, outcome, msg.sender)", 
            "        # Next trade", 
            "        t += 1", 
            "    return([SUCCESS, max_value, max_amount]: arr)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "max_value", 
                        "type": "int256"
                    }, 
                    {
                        "name": "max_amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "trade_ids", 
                        "type": "int256[]"
                    }
                ], 
                "name": "trade(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "unknown_out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "owner", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "type", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "tradeid", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "log_fill_tx(int256,int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }, 
            {
                "inputs": [
                    {
                        "indexed": true, 
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "type", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "timestamp", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": false, 
                        "name": "outcome", 
                        "type": "int256"
                    }, 
                    {
                        "indexed": true, 
                        "name": "trader", 
                        "type": "int256"
                    }
                ], 
                "name": "log_price(int256,int256,int256,int256,int256,int256,int256)", 
                "type": "event"
            }
        ], 
        "sig": "extern trade: [trade:[int256,int256,int256[]]:_]"
    }, 
    "trades": {
        "address": "0xb8c254877dd025d04bb760e7b738e1219dbc2708", 
        "code": [
            "inset('refund.se')", 
            "", 
            "# reporter", 
            "data tradeCommits[](hash, block)", 
            "# tradeID", 
            "data trades[](id, type, market, amount, price, owner, block, refhash, outcome, initialTrade)", 
            "", 
            "def makeTradeHash(max_value, max_amount, trade_ids: arr):", 
            "    refund()", 
            "    i = 0", 
            "    trades = 0", 
            "    while i < len(trade_ids):", 
            "        trades += trade_ids[i]", 
            "        i+=1", 
            "    tradeInfo = array(3)", 
            "    tradeInfo[0] = trades", 
            "    tradeInfo[1] = max_amount", 
            "    tradeInfo[2] = max_value", 
            "    tradeHash = sha256(tradeInfo, items=3)", 
            "    return(tradeHash)", 
            "", 
            "def commitTrade(hash):", 
            "    refund()", 
            "    self.tradeCommits[msg.sender].hash = hash", 
            "    self.tradeCommits[msg.sender].block = block.number", 
            "    return(1)", 
            "", 
            "def setInitialTrade(id):", 
            "    refund()", 
            "    self.trades[id].initialTrade = 1", 
            "    return(1)", 
            "", 
            "def getInitialTrade(id):", 
            "    refund()", 
            "    return(self.trades[id].initialTrade)", 
            "", 
            "def zeroHash():", 
            "    refund()", 
            "    self.tradeCommits[msg.sender].hash = 0", 
            "    return(1)", 
            "", 
            "def checkHash(tradeHash, sender):", 
            "    refund()", 
            "    if(self.tradeCommits[sender].hash != tradeHash || block.number <= self.tradeCommits[sender].block):", 
            "        return(-1)", 
            "    else:", 
            "        return(1)", 
            "", 
            "def getID(tradeID):", 
            "    refund()", 
            "    return(self.trades[tradeID].id)", 
            "", 
            "def saveTrade(trade_id, type, market, amount, price, sender, outcome):", 
            "    refund()", 
            "    self.trades[trade_id].id = trade_id", 
            "    self.trades[trade_id].type = type", 
            "    self.trades[trade_id].market = market", 
            "    self.trades[trade_id].amount = amount", 
            "    self.trades[trade_id].price = price", 
            "    self.trades[trade_id].owner = sender", 
            "    self.trades[trade_id].block = block.number", 
            "    self.trades[trade_id].outcome = outcome", 
            "    self.trades[trade_id].refhash = ref(self.trades[trade_id].id)", 
            "    return(1)", 
            "", 
            "def get_trade(id):", 
            "    refund()", 
            "    trade = array(9)", 
            "    trade[0] = self.trades[id].id", 
            "    trade[1] = self.trades[id].type", 
            "    trade[2] = self.trades[id].market", 
            "    trade[3] = self.trades[id].amount", 
            "    trade[4] = self.trades[id].price", 
            "    trade[5] = self.trades[id].owner", 
            "    trade[6] = self.trades[id].block", 
            "    trade[7] = self.trades[id].refhash", 
            "    trade[8] = self.trades[id].outcome", 
            "    if trade:", 
            "        return(trade:arr)", 
            "    return([0]:arr)", 
            "", 
            "def get_amount(id):", 
            "    refund()", 
            "    return(self.trades[id].amount)", 
            "", 
            "def get_price(id):", 
            "    refund()", 
            "    return(self.trades[id].price)", 
            "", 
            "def update_trade(id, price):", 
            "    refund()", 
            "    self.trades[id].price = price", 
            "    self.trades[id].block = block.number", 
            "", 
            "def remove_trade(id):", 
            "    refund()", 
            "    self.trades[id].id = 0", 
            "    self.trades[id].type = 0", 
            "    self.trades[id].market = 0", 
            "    self.trades[id].amount = 0", 
            "    self.trades[id].price = 0", 
            "    self.trades[id].owner = 0", 
            "    self.trades[id].block = 0", 
            "    self.trades[id].refhash = 0", 
            "    self.trades[id].outcome = 0", 
            "    return(1)", 
            "", 
            "def fill_trade(id, fill):", 
            "    refund()", 
            "    self.trades[trade_id].amount -= fill", 
            "    return(1)"
        ], 
        "fullsig": [
            {
                "inputs": [
                    {
                        "name": "tradeHash", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }
                ], 
                "name": "checkHash(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "hash", 
                        "type": "int256"
                    }
                ], 
                "name": "commitTrade(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "fill", 
                        "type": "int256"
                    }
                ], 
                "name": "fill_trade(int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "tradeID", 
                        "type": "int256"
                    }
                ], 
                "name": "getID(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "getInitialTrade(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "get_amount(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "get_price(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "get_trade(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256[]"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "max_value", 
                        "type": "int256"
                    }, 
                    {
                        "name": "max_amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "trade_ids", 
                        "type": "int256[]"
                    }
                ], 
                "name": "makeTradeHash(int256,int256,int256[])", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "remove_trade(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "trade_id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "type", 
                        "type": "int256"
                    }, 
                    {
                        "name": "market", 
                        "type": "int256"
                    }, 
                    {
                        "name": "amount", 
                        "type": "int256"
                    }, 
                    {
                        "name": "price", 
                        "type": "int256"
                    }, 
                    {
                        "name": "sender", 
                        "type": "int256"
                    }, 
                    {
                        "name": "outcome", 
                        "type": "int256"
                    }
                ], 
                "name": "saveTrade(int256,int256,int256,int256,int256,int256,int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }
                ], 
                "name": "setInitialTrade(int256)", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }, 
            {
                "inputs": [
                    {
                        "name": "id", 
                        "type": "int256"
                    }, 
                    {
                        "name": "price", 
                        "type": "int256"
                    }
                ], 
                "name": "update_trade(int256,int256)", 
                "outputs": [], 
                "type": "function"
            }, 
            {
                "inputs": [], 
                "name": "zeroHash()", 
                "outputs": [
                    {
                        "name": "out", 
                        "type": "int256"
                    }
                ], 
                "type": "function"
            }
        ], 
        "sig": "extern refund.se: [checkHash:[int256,int256]:int256, commitTrade:[int256]:int256, fill_trade:[int256,int256]:int256, getID:[int256]:int256, getInitialTrade:[int256]:int256, get_amount:[int256]:int256, get_price:[int256]:int256, get_trade:[int256]:int256[], makeTradeHash:[int256,int256,int256[]]:int256, remove_trade:[int256]:int256, saveTrade:[int256,int256,int256,int256,int256,int256,int256]:int256, setInitialTrade:[int256]:int256, update_trade:[int256,int256]:_, zeroHash:[]:int256]"
    }
}