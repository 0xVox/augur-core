BRANCH = 0
EVENT = 1
MARKET = 2

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](typecode, description[], creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# RepRequired is the amount of reputation required to reach quorem
# markets[] is a 0 index array of market hashes (a.k.a. marketID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the upcoming vote period
data Branches[](currentVotePeriod, markets[], marketCount, periodLength, repRequired)

# Events' index is the eventID
data Events[](branch, expirationDate, outcome)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](eventsExpDates[](events[], totalRepReported, reporters[][]), reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market
# Sharespurchased keeps track of the number of shares purchased for each outcome
# Participants is a 0 indexed array of participants, their cashIDs, and the shares in each outcome they've purchased of an event (events' indexes are actual event IDs)
# sharesPurchased is 0 indexed (0 is outcome 0, 1 is outcome 1, 2 is outcome 2 (notice we're on a new event here if they're binary))
   # ex: eventIndex*2 is outcome 0, eventIndex*2 + 1 is outcome one for each corresponding event 
   #    self.Markets[$marketID].sharesPurchased[$i*2]
   #    self.Markets[$marketID].sharesPurchased[$i*2 + 1]
data Markets[](branch, events[], sharesPurchased[], participants[](participantID, event[](shares[2])), lossLimit, tradingFee, currentParticipant, winningEvents[], alpha)

data cashcoin_balances[2^160]
data bananas[]

def tests():
	x = self.testCashBal()
	y = self.testSendCash()
	z = self.testSendRep()
	w = self.testMakeSubbranch()
	v = self.testMakeEvent()
	#self.testMakeMarket()
	#self.testBuyShares()
	#self.testSellShares()
	#self.testVote()
	#self.testQuoremChecker()
	#self.testRedeem()
	#self.testCloseMarket()
	if(x and y and z and w and v):
		return(1)
	else:
		return(0)

def testCashBal():
	bal = self.get_cash_balance(tx.origin)
	if(bal==1000000*2^64):
		return(1)
	else:
		return(0)

def testSendCash():
	self.send_cashcoin(0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826, 47)
	if(self.cashcoin_balances[0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826]==47):
		return(1)
	else:
		return(0)

def testSendRep():
	if(self.send_reputation(1010101, 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826, 20)!=1):
		return(1)
	else:
		return(0)

def testMakeSubbranch():
	newBranchID = self.make_subbranch(text("Hello World!"), 10, 1010101, 447)
	if(self.Branches[newBranchID].repRequired==447):
		return(1)
	else:
		return(0)

def testMakeEvent():
	if(self.create_event(1010101, text("lol"), 447)):
		return(1)
	else:
		return(0)

def init():
	self.cashcoin_balances[tx.origin] = 1000000*2^64
	self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
	self.Reporting[1010101].reputation[0].repValue = 47
	self.Reporting[1010101].reputation[0].reporterID = tx.origin
	# number of reporters is 0 indexed
	self.Reporting[1010101].numberReporters = 0
	self.Info[1010101].typecode = 0
	self.Info[1010101].description[] = "initial branch"
	self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
	self.Info[1010101].creationFee = 10
	self.Branches[1010101].currentVotePeriod = block.number / 403200
	self.Branches[1010101].marketCount = 0
	self.Branches[1010101].periodLength = 403200
	self.Branches[1010101].repRequired = 14000000

def get_cash_balance(address):
	return(self.cashcoin_balances[address])

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
def send_cashcoin(recver, value):
	sender = tx.origin
	sender_balance = self.cashcoin_balances[sender]
	if(sender_balance >= value):
		self.cashcoin_balances[sender] -= value
		self.cashcoin_balances[recver] += value
		return(1)
	else:
		return(0)

def send_reputation(branch, recver, value):
	if(value<=0 or !self.send_cashcoin(branch, 5*2^64)):
		return(0)
	sender = tx.origin
	senderIndex = self.Reporting[oldBranch].repIDtoIndex[sender]
	receiverIndex = self.Reporting[newBranch].repIDtoIndex[recver]
	# if the sender's rep. account doesn't exist, make one
	if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
			self.Reporting[branch].numberReporters += 1
			reporterIndex = self.Reporting[branch].numberReporters
			self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
			self.Reporting[branch].reputation[reporterIndex].repValue = 0
			self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
			return(text("Your reputation account was just created, earn some rep. before you can send to others"))

	if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
		return(text("Receiving address doesn't exist"))
		
	sender_balance = self.Reporting[branch].reputation[senderIndex].repValue
	if(sender_balance >= value):
		self.Reporting[branch].reputation[senderIndex].repValue -= value
		self.Reporting[branch].reputation[receiverIndex].repValue += value
		return(1)
	else:
		return(0)
		
def get_rep_balance(branch, address):
	return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)

# period length is given in blocks
# description format is branchName:description
def make_subbranch(description:s, periodLength, parent, repRequired):
	if(periodLength<=0 or !self.Branches[parent].periodLength or !repRequired or description==0):
		return(0)
	branchCharacteristics = array(8)
	branchCharacteristics[0] = BRANCH
	branchCharacteristics[1] = description
	branchCharacteristics[2] = tx.origin
	branchCharacteristics[3] = 47*2^64
	branchCharacteristics[4] = periodLength
	branchCharacteristics[5] = block.number
	branchCharacteristics[6] = parent
	branchCharacteristics[7] = repRequired

	# people can check that these characteristics hash to the ID if they want
	# people can hand a friend their new branch hash and characteristics and say, "don't trust me? check"
	branchID = sha256(branchCharacteristics, 8)
	if(!self.Branches[branchID].periodLength and !self.Info[branchID].creator and self.send_cashcoin(branchID, 47*2^64)):
		self.Info[branchID].typecode = BRANCH
		self.Info[branchID].description[] = description
		self.Info[branchID].creator = tx.origin
		self.Info[branchID].creationFee = 47*2^64
		self.Branches[branchID].periodLength = periodLength
		self.Branches[branchID].repRequired = repRequired
		self.Branches[branchID].currentVotePeriod = block.number / periodLength
		i = 0
		while i < self.Reporting[parent].numberReporters:
			self.Reporting[branchID].reputation[i].reporterID = self.Reporting[parent].reputation[i].reporterID
			self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
			i+=1
		return(branchID)
	else:
		return(0)

def create_event(branch, description:s, expDate):
	if(self.Branches[branch].periodLength and description!=0 and expDate>block.number):
		eventCharacteristics = array(6)
		eventCharacteristics[0] = description
		eventCharacteristics[1] = EVENT
		eventCharacteristics[2] = branch
		eventCharacteristics[3] = expDate
		eventCharacteristics[4] = tx.origin
		eventCharacteristics[5] = 42*2^64
		eventID = sha256(eventCharacteristics, 6)
	else:
		return(0)

	if (!self.Info[eventID].creator and !self.Events[eventID].branch and self.send_cashcoin(branch, 42*2^64)):
		self.Info[eventID].typecode = EVENT
		self.Info[eventID].description[] = description
		self.Info[eventID].creator = tx.origin
		self.Info[eventID].creationFee = 42*2^64
		self.Events[eventID].branch = branch
		self.Events[eventID].expirationDate = expDate
		
		# see when it expires, compare that to currentvotingperiod number and last voting period and add it in to the proper spot        
		# data Branches[](eventsExpDates[](numberEvents, events[])
		#403200 is number of blocks == 8 weeks
		# 0 means it expires in the next period
		futurePeriod = expDate / self.Branches[branch].periodLength
		self.Reporting[branch].eventsExpDates[futurePeriod].events[len(self.Reporting[branch].eventsExpDates[futurePeriod].events[])] = eventID
		return(eventID)
	else:
		return(0)