BRANCH = 0
EVENT = 1
MARKET = 2

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](typecode, description[], creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# RepRequired is the amount of reputation required to reach quorem
# markets[] is a 0 index array of market hashes (a.k.a. marketID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the upcoming vote period
data Branches[](currentVotePeriod, markets[], marketCount, periodLength, repRequired)

# Events' index is the eventID
data Events[](branch, expirationDate, outcome)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](eventsExpDates[](numberEvents, events[], totalRepReported, reporters[][]), reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market
# Sharespurchased keeps track of the number of shares purchased for each outcome
# Participants is a 0 indexed array of participants, their cashIDs, and the shares in each outcome they've purchased of an event (events' indexes are actual event IDs)
# sharesPurchased is 0 indexed (0 is outcome 0, 1 is outcome 1, 2 is outcome 2 (notice we're on a new event here if they're binary))
   # ex: eventIndex*2 is outcome 0, eventIndex*2 + 1 is outcome one for each corresponding event 
   #    self.Markets[$marketID].sharesPurchased[$i*2]
   #    self.Markets[$marketID].sharesPurchased[$i*2 + 1]
data Markets[](branch, events[], sharesPurchased[], participants[](participantID, event[](shares[2])), lossLimit, tradingFee, numberEvents, currentParticipant, winningEvents[], alpha)

data cashcoin_balances[2^160]

def tests():
	self.testCashBal()
	self.testSendCash()
	self.testSendRep()
	self.testMakeSubbranch()
	self.testMakeEvent()
	self.testMakeMarket()
	#self.testBuyShares()
	#self.testSellShares()
	#self.testVote()
	#self.testQuoremChecker()
	#self.testRedeem()
	#self.testCloseMarket()


def testCashBal():
	bal = self.get_cash_balance(tx.origin)
	log(bal)
	return(1)

def testSendCash():
	self.send_cashcoin(0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826, 47)
	log(self.cashcoin_balances[0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826])
	return(1)

def testSendRep():
	self.send_reputation(1010101, 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826, 20)
	log(self.Reporting[1010101].reputation[self.Reporting[1010101].repIDtoIndex[0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826]].repValue)
	return(1)

def testMakeSubbranch():
	newBranchID = self.make_subbranch(text("Hello World!"), 10, 1010101, 447)
	if(self.Branches[newBranchID].repRequired==447):
		log(newBranchID)
		return(1)
	else:
		return(0)

def testMakeEvent():
	eventID = self.create_event(1010101, text("lol"), 447)
	log(eventID)
	self.testMakeMarket(eventID)
	return(1)

def testMakeMarket(eventID):
	marketID = self.create_market(1010101, text("elections 2016 market"), 15*2^64, 0, 1, [eventID])
	log(marketID)

exp_halfZ = [2^64, 0x1a61298e1e069bc97, 0x2b7e151628aed2a6b, 0x47b4ff993f15055f7, 0x763992e35376b730d, 0xc2eb7ec98f05d8ea7, 0x1415e5bf6fb105f2d5, 0x211d8e4272d7b6a1aa, 0x3699205c4e74b0cf1b, 0x5a0462b7877aa8b7cf, 0x9469c4cb819c78fb38, 0xf4b122790ddfb1298d, 0x1936dc5690c08f37a9b, 0x2992442102d91286adc, 0x448a216abb76a9bc7e8, 0x7100adbac7dab4a4e30, 0xba4f53ea38636f85f00]

def log(x):
 	return(1)

def init():
	self.cashcoin_balances[tx.origin] = 1000000*10*2^64
	self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
	self.Reporting[1010101].reputation[0].repValue = 47
	self.Reporting[1010101].reputation[0].reporterID = tx.origin
	self.Reporting[1010101].repIDtoIndex[0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826] = 1
	self.Reporting[1010101].reputation[1].reporterID = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
	# number of reporters is 0 indexed
	self.Reporting[1010101].numberReporters = 1
	self.Info[1010101].typecode = 0
	self.Info[1010101].description[] = "initial branch"
	self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
	self.Info[1010101].creationFee = 10
	self.Branches[1010101].currentVotePeriod = block.number / 403200
	self.Branches[1010101].marketCount = 0
	self.Branches[1010101].periodLength = 403200
	self.Branches[1010101].repRequired = 14000000

def get_cash_balance(address):
	return(self.cashcoin_balances[address])

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
def send_cashcoin(recver, value):
	sender = tx.origin
	sender_balance = self.cashcoin_balances[sender]
	if(sender_balance >= value):
		self.cashcoin_balances[sender] -= value
		self.cashcoin_balances[recver] += value
		return(1)
	else:
		return(0)

def send_reputation(branch, recver, value):
	if(value<=0 or !self.send_cashcoin(branch, 5)):
		return(0)
	sender = tx.origin
	senderIndex = self.Reporting[branch].repIDtoIndex[sender]
	receiverIndex = self.Reporting[branch].repIDtoIndex[recver]
	# if the sender's rep. account doesn't exist, make one
	if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
			self.Reporting[branch].numberReporters += 1
			reporterIndex = self.Reporting[branch].numberReporters
			self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
			self.Reporting[branch].reputation[reporterIndex].repValue = 0
			self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
			return(text("Your reputation account was just created, earn some rep. before you can send to others"): s)

	if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
		return(text("Receiving address doesn't exist"): s)
		
	sender_balance = self.Reporting[branch].reputation[senderIndex].repValue
	if(sender_balance >= value):
		self.Reporting[branch].reputation[senderIndex].repValue -= value
		self.Reporting[branch].reputation[receiverIndex].repValue += value
		return(1)
	else:
		return(0)
		
def get_rep_balance(branch, address):
	return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)

def make_subbranch(description:s, periodLength, parent, repRequired):
	if(periodLength<=0 or !self.Branches[parent].periodLength or !repRequired or description==0):
		return(0)
	branchCharacteristics = array(7)
	branchCharacteristics[0] = BRANCH
	branchCharacteristics[1] = tx.origin
	branchCharacteristics[2] = 47*2^64
	branchCharacteristics[3] = periodLength
	branchCharacteristics[4] = block.number
	branchCharacteristics[5] = parent
	branchCharacteristics[6] = repRequired

	# people can check that these characteristics hash to the ID if they want
	# people can hand a friend their new branch hash and characteristics and say, "don't trust me? check"
	branchID = sha256(branchCharacteristics, 7)
	if(!self.Branches[branchID].periodLength and !self.Info[branchID].creator and self.send_cashcoin(branchID, 47)):
		self.Info[branchID].typecode = BRANCH
		self.Info[branchID].description[] = description
		self.Info[branchID].creator = tx.origin
		self.Info[branchID].creationFee = 47*2^64
		self.Branches[branchID].periodLength = periodLength
		self.Branches[branchID].repRequired = repRequired
		self.Branches[branchID].currentVotePeriod = block.number / periodLength
		i = 0
		while i < self.Reporting[parent].numberReporters:
			self.Reporting[branchID].reputation[i].reporterID = self.Reporting[parent].reputation[i].reporterID
			self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
			i+=1
		# because there is a 0th reporter
		self.Reporting[branchID].numberReporters = i-1
		return(branchID)
	else:
		return(0)
		
def create_event(branch, description:s, expDate):
	if(self.Branches[branch].periodLength and description!=0 and expDate>block.number):
		eventCharacteristics = array(6)
		eventCharacteristics[0] = description
		eventCharacteristics[1] = EVENT
		eventCharacteristics[2] = branch
		eventCharacteristics[3] = expDate
		eventCharacteristics[4] = tx.origin
		eventCharacteristics[5] = 42*2^64
		eventID = sha256(eventCharacteristics, 6)
	else:
		return(0)

	if (!self.Info[eventID].creator and !self.Events[eventID].branch and self.send_cashcoin(branch, 42)):
		self.Info[eventID].typecode = EVENT
		self.Info[eventID].description[] = description
		self.Info[eventID].creator = tx.origin
		self.Info[eventID].creationFee = 42*2^64
		self.Events[eventID].branch = branch
		self.Events[eventID].expirationDate = expDate
		
		# see when it expires, compare that to currentvotingperiod number and last voting period and add it in to the proper spot        
		# data Branches[](eventsExpDates[](numberEvents, events[])
		#403200 is number of blocks == 8 weeks
		# 0 means it expires in the next period
		futurePeriod = expDate / self.Branches[branch].periodLength
		self.Reporting[branch].eventsExpDates[futurePeriod].events[self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents] = eventID
		self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents += 1
		return(eventID)
	else:
		return(0)

# lossLimit is a fixedpoint syntax number (so a losslimit of 1 is 2^64) (0 if not using lmsr)
# ditto for alpha
# tradingFee is a fixedpoint number as well
def create_market(branch, description:s, lossLimit, alpha, tradingFee, events:a):
	# check that events have same exp. dates and branch
	i = 0
	numEvents = len(events)
	expDate = self.Events[events[0]].expirationDate
	while i < numEvents:
		event = events[i]
		if self.Events[event].expirationDate != expDate:
			return(0)
		if self.Events[event].branch != branch:
			return(0)

	# initialLiquidity is a fixedpoint number
	# divide by 2^64 to stay in fixedpoint
	initialLiquidity = lossLimit*self.log(numEvents*2^64)/2^64
	if(numEvents > 200 or self.cashcoin_balances[tx.origin]<initialLiquidity or !self.Branches[branch].periodLength or description==0 or !lossLimit or !tradingFee or !alpha):
		return(0)
	# formation of marketID (hash)
	marketCharacteristics = array(9)
	marketCharacteristics[0] = MARKET
	marketCharacteristics[1] = tx.origin
	marketCharacteristics[2] = initialLiquidity
	marketCharacteristics[3] = branch
	marketCharacteristics[4] = events
	marketCharacteristics[5] = numEvents
	marketCharacteristics[6] = lossLimit
	marketCharacteristics[7] = tradingFee
	marketCharacteristics[8] = alpha
	marketID = sha256(marketCharacteristics, 9)

	if(self.send_cashcoin(marketID, initialLiquidity)):
		# add event list to the market
		i = 0
		while i<numEvents:
			eventID = events[i]
			if(!self.Info[eventID].creator or self.Events[eventID].branch!=branch):
				return(0)
			# initialize market events array with eventIDs from the eventList
			self.Markets[marketID].events[i] = eventID
			i+=1

		# creator of the first market in a branch gets the branch's creation fee
		if(self.Branches[branch].marketCount==0):
			self.send_cashcoin(tx.origin, self.Info[branch].creationFee)
			
		self.Info[marketID].typecode = MARKET
		self.Info[marketID].description[] = description
		self.Info[marketID].creator = tx.origin
		self.Info[marketID].creationFee = initialLiquidity
		self.cashcoin_balances[marketID] = initialLiquidity
		self.Markets[marketID].lossLimit = lossLimit
		self.Markets[marketID].tradingFee = tradingFee
		self.Markets[marketID].branch = branch
		self.Markets[marketID].alpha = alpha
		# add the market to the branch
		marketCount = self.Branches[branch].marketCount
		self.Branches[branch].markets[marketCount] = marketID
		self.Branches[branch].marketCount += 1
		return(marketID)
	else:
		return(0)