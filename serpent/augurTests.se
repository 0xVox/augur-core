BRANCH = 0
EVENT = 1
MARKET = 2


# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](typecode, description[], creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# RepRequired is the amount of reputation required to reach quorem
# markets[] is a 0 index array of market hashes (a.k.a. marketID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the upcoming vote period
data Branches[](currentVotePeriod, markets[], marketCount, periodLength, repRequired)

# Events' index is the eventID
data Events[](branch, expirationDate, outcome)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](eventsExpDates[](numberEvents, events[], totalRepReported, reporters[][]), reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market
# Sharespurchased keeps track of the number of shares purchased for each outcome
# Participants is a 0 indexed array of participants, their cashIDs, and the shares in each outcome they've purchased of an event (events' indexes are actual event IDs)
# sharesPurchased is 0 indexed (0 is outcome 0, 1 is outcome 1, 2 is outcome 2 (notice we're on a new event here if they're binary))
   # ex: eventIndex*2 is outcome 0, eventIndex*2 + 1 is outcome one for each corresponding event 
   #    self.Markets[$marketID].sharesPurchased[$i*2]
   #    self.Markets[$marketID].sharesPurchased[$i*2 + 1]
data Markets[](branch, events[], sharesPurchased[], participants[](participantID, event[](shares[2])), lossLimit, tradingFee, numberEvents, currentParticipant, winningEvents[], alpha)

data cashcoin_balances[2^160]

def tests():
	#self.testCashBal()
	#self.testSendCash()
	#self.testSendRep()
	#self.testMakeSubbranch()
	self.testMakeEvent()
	#& self.testMakeMarket()
	#self.testBuyShares()
	#self.testSellShares()
	#self.testVote()
	#self.testQuoremChecker()
	#self.testRedeem()
	#self.testCloseMarket()


def testCashBal():
	bal = self.get_cash_balance(tx.origin)
	log(bal)
	return(1)

def testSendCash():
	self.send_cashcoin(0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826, 47)
	log(self.cashcoin_balances[0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826])
	return(1)

def testSendRep():
	self.send_reputation(1010101, 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826, 20)
	log(self.Reporting[1010101].reputation[self.Reporting[1010101].repIDtoIndex[0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826]].repValue)
	return(1)

def testMakeSubbranch():
	newBranchID = self.make_subbranch(text("Hello World!"), 10, 1010101, 447)
	if(self.Branches[newBranchID].repRequired==447):
		log(newBranchID)
		return(1)
	else:
		return(0)

def testMakeEvent():
	eventID = self.create_event(1010101, text("lol"), 447)
	log(eventID)
	self.testMakeMarket(eventID)
	return(1)

def testMakeMarket(eventID):
	x = array(1)
	x[0] = eventID
	marketID = self.create_market(1010101, text("elections 2016 market"), 15*2^64, 0, 1, x)
	log(marketID)
	self.testBuyShares(eventID, marketID)

def testBuyShares(eventID, marketID):
	log(self.buy_shares(1010101, eventID, marketID, 1, 10, 2))
	# should be 10
	log(self.Markets[marketID].participants[0].event[eventID].shares[1])

def init():
	self.cashcoin_balances[tx.origin] = 1000000*30*2^64
	self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
	self.Reporting[1010101].reputation[0].repValue = 47
	self.Reporting[1010101].reputation[0].reporterID = tx.origin
	self.Reporting[1010101].repIDtoIndex[0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826] = 1
	self.Reporting[1010101].reputation[1].reporterID = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
	# number of reporters is 0 indexed
	self.Reporting[1010101].numberReporters = 1
	self.Info[1010101].typecode = 0
	self.Info[1010101].description[] = "initial branch"
	self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
	self.Info[1010101].creationFee = 10
	self.Branches[1010101].currentVotePeriod = block.number / 403200
	self.Branches[1010101].marketCount = 0
	self.Branches[1010101].periodLength = 403200
	self.Branches[1010101].repRequired = 14000000

def get_cash_balance(address):
	return(self.cashcoin_balances[address])

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
def send_cashcoin(recver, value):
	sender = tx.origin
	sender_balance = self.cashcoin_balances[sender]
	if(sender_balance >= value):
		self.cashcoin_balances[sender] -= value
		self.cashcoin_balances[recver] += value
		return(1)
	else:
		return(0)

def send_reputation(branch, recver, value):
	if(value<=0 or !self.send_cashcoin(branch, 5)):
		return(0)
	sender = tx.origin
	senderIndex = self.Reporting[branch].repIDtoIndex[sender]
	receiverIndex = self.Reporting[branch].repIDtoIndex[recver]
	# if the sender's rep. account doesn't exist, make one
	if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
			self.Reporting[branch].numberReporters += 1
			reporterIndex = self.Reporting[branch].numberReporters
			self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
			self.Reporting[branch].reputation[reporterIndex].repValue = 0
			self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
			return(text("Your reputation account was just created, earn some rep. before you can send to others"): s)

	if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
		return(text("Receiving address doesn't exist"): s)
		
	sender_balance = self.Reporting[branch].reputation[senderIndex].repValue
	if(sender_balance >= value):
		self.Reporting[branch].reputation[senderIndex].repValue -= value
		self.Reporting[branch].reputation[receiverIndex].repValue += value
		return(1)
	else:
		return(0)
		
def get_rep_balance(branch, address):
	return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)

def make_subbranch(description:s, periodLength, parent, repRequired):
	if(periodLength<=0 or !self.Branches[parent].periodLength or !repRequired or description==0):
		return(0)
	branchCharacteristics = array(7)
	branchCharacteristics[0] = BRANCH
	branchCharacteristics[1] = tx.origin
	branchCharacteristics[2] = 47*2^64
	branchCharacteristics[3] = periodLength
	branchCharacteristics[4] = block.number
	branchCharacteristics[5] = parent
	branchCharacteristics[6] = repRequired

	# people can check that these characteristics hash to the ID if they want
	# people can hand a friend their new branch hash and characteristics and say, "don't trust me? check"
	branchID = sha256(branchCharacteristics, 7)
	if(!self.Branches[branchID].periodLength and !self.Info[branchID].creator and self.send_cashcoin(branchID, 47)):
		self.Info[branchID].typecode = BRANCH
		self.Info[branchID].description[] = description
		self.Info[branchID].creator = tx.origin
		self.Info[branchID].creationFee = 47*2^64
		self.Branches[branchID].periodLength = periodLength
		self.Branches[branchID].repRequired = repRequired
		self.Branches[branchID].currentVotePeriod = block.number / periodLength
		i = 0
		while i < self.Reporting[parent].numberReporters:
			self.Reporting[branchID].reputation[i].reporterID = self.Reporting[parent].reputation[i].reporterID
			self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
			i+=1
		# because there is a 0th reporter
		self.Reporting[branchID].numberReporters = i-1
		return(branchID)
	else:
		return(0)
		
def create_event(branch, description:s, expDate):
	if(self.Branches[branch].periodLength and description!=0 and expDate>block.number):
		eventCharacteristics = array(5)
		eventCharacteristics[0] = EVENT
		eventCharacteristics[1] = branch
		eventCharacteristics[2] = expDate
		eventCharacteristics[3] = tx.origin
		eventCharacteristics[4] = 42*2^64
		eventID = sha256(eventCharacteristics, 5)
	else:
		return(0)

	if (!self.Info[eventID].creator and !self.Events[eventID].branch and self.send_cashcoin(branch, 42)):
		self.Info[eventID].typecode = EVENT
		self.Info[eventID].description[] = description
		self.Info[eventID].creator = tx.origin
		self.Info[eventID].creationFee = 42*2^64
		self.Events[eventID].branch = branch
		self.Events[eventID].expirationDate = expDate
		
		# see when it expires, compare that to currentvotingperiod number and last voting period and add it in to the proper spot        
		# data Branches[](eventsExpDates[](numberEvents, events[])
		#403200 is number of blocks == 8 weeks
		# 0 means it expires in the next period
		futurePeriod = expDate / self.Branches[branch].periodLength
		self.Reporting[branch].eventsExpDates[futurePeriod].events[self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents] = eventID
		self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents += 1
		return(eventID)
	else:
		return(0)

# lossLimit is a fixedpoint syntax number (so a losslimit of 1 is 2^64) (0 if not using lmsr)
# ditto for alpha
# tradingFee is a fixedpoint number as well --- perhaps make it a percent
def create_market(branch, description:s, lossLimit, alpha, tradingFee, events:a):
	# check that events have same exp. dates and branch
	i = 0
	numEvents = len(events)
	eventsConcat = 0
	expDate = self.Events[events[0]].expirationDate
	while i < numEvents:
		event = events[i]
		eventsConcat += events[i]
		if self.Events[event].expirationDate != expDate:
			return(0)
		if self.Events[event].branch != branch:
			return(0)
		i+=1

	if(numEvents > 200 or !self.Branches[branch].periodLength or description==0 or !lossLimit or !tradingFee or (!alpha and !lossLimit)):
		return(0)
	# formation of marketID (hash)
	marketCharacteristics = array(9)
	marketCharacteristics[0] = MARKET
	marketCharacteristics[1] = tx.origin
	marketCharacteristics[2] = initialLiquidity
	marketCharacteristics[3] = branch
	marketCharacteristics[4] = eventsConcat
	marketCharacteristics[5] = numEvents
	marketCharacteristics[6] = lossLimit
	marketCharacteristics[7] = tradingFee
	marketCharacteristics[8] = alpha
	marketID = sha256(marketCharacteristics, 9)

	# if regular lmsr
	if(losslimit):
		# initialLiquidity is a fixedpoint number
		# divide by 2^64 to stay in fixedpoint
		initialLiquidity = lossLimit*self.log(numEvents*2^64)/2^64
	# ls-lmsr needs a very small initial liquidity
	elif(alpha):
		initialLiquidity = 2^62

	if(self.send_cashcoin(marketID, initialLiquidity)):
		# add event list to the market
		i = 0
		while i<numEvents:
			eventID = events[i]
			if(!self.Info[eventID].creator or self.Events[eventID].branch!=branch):
				return(0)
			# initialize market events array with eventIDs from the eventList
			self.Markets[marketID].events[i] = eventID
			i+=1

		self.Markets[marketID].numberEvents = numEvents
		# creator of the first market in a branch gets the branch's creation fee
		if(self.Branches[branch].marketCount==0):
			self.send_cashcoin(tx.origin, self.Info[branch].creationFee)
			
		self.Info[marketID].typecode = MARKET
		self.Info[marketID].description[] = description
		self.Info[marketID].creator = tx.origin
		self.Info[marketID].creationFee = initialLiquidity
		self.cashcoin_balances[marketID] = initialLiquidity
		self.Markets[marketID].lossLimit = lossLimit
		self.Markets[marketID].tradingFee = tradingFee
		self.Markets[marketID].branch = branch
		self.Markets[marketID].alpha = alpha
		# add the market to the branch
		marketCount = self.Branches[branch].marketCount
		self.Branches[branch].markets[marketCount] = marketID
		self.Branches[branch].marketCount += 1
		return(marketID)
	else:
		return(0)


# alpha is equal to v/(n*log(n)) where v is the max percent commission,
# and n is the number of outcomes people can trade. Alpha is set when
# a market is created.
macro ls_lmsr($marketID):
	with $Bq = 0:
		with $l = self.Markets[$marketID].numberEvents:
			with $i = 0:
				while $i < $l:
					$Bq += self.Markets[$marketID].sharesPurchased[$i*2]
					$Bq += self.Markets[$marketID].sharesPurchased[$i*2 + 1]
					$i += 1
				$Bq *= self.Markets[$marketID].alpha
				$i = 0
				with $sum_exp = 0:
					with $a = 0:
						with $b = 0:
							while $i < $l:
								$a = self.Markets[$marketID].sharesPurchased[$i*2]
								$b = self.Markets[$marketID].sharesPurchased[$i*2 + 1]
								$sum_exp += self.exp($a*2^64/$Bq)
								$sum_exp += self.exp($b*2^64/$Bq)
								$i += 1
							$Bq*self.log($sum_exp)/2^64

macro lmsr($marketID):
	with $sum_exp = 0:
		with $B = self.Markets[$marketID].lossLimit:
			with $l = self.Markets[$marketID].numberEvents:
				with $i = 0:
					with $a = 0:
						with $b = 0:
							while $i < $l:
								$a = self.Markets[$marketID].sharesPurchased[$i*2]
								$b = self.Markets[$marketID].sharesPurchased[$i*2 + 1]
								$sum_exp += self.exp($a*2^64/$B)
								$sum_exp += self.exp($b*2^64/$B)
								$i += 1
							$B*self.log($sum_exp)/2^64

# fee should be in fixed point
# amount of shares should be an integer
# trading fees go to branch directly and are distributed upon rbcr
# cost of shares go directly to the market
# so markets using lmsr should charge a higher fee here because the market creator will get less as fees from market making
# ls-lmsr markets won't have much in fees in the branch, so the market creator will thus get a lot of fees himself hmmm...
# is there a way to pool ls-lmsr fees separately?
def buy_shares(branch, event, market, outcome, amount, fee):
	if (block.number >= self.Events[event].expirationDate or fee<self.Markets[market].tradingFee or self.Events[event].branch!=branch or self.cashcoin_balances[tx.origin]<fee):
		return(0)
	# pay one-fourth of trading fee to market creator via sending to market.creator
	# other half is stored in branchID cashcoin balance
	self.cashcoin_balances[tx.origin] -= fee
	marketCreatorFee = fee - (3*fee)/4
	self.cashcoin_balances[self.Info[market].creator] += marketCreatorFee
	self.cashcoin_balances[branch] += (3*fee)/4

	# find the right event index
	i = 0
	while (i<self.Markets[market].numberEvents and self.Markets[market].events[i] != event):
			i+=1
	# event doesn't exist in index
	if(i==self.Markets[market].numberEvents):
		return(0)
	oldCost = 0
	newCost = 0
	# using ls-lmsr
	if(self.Markets[market].alpha):
		# for the first trade's oldcost shares bought will be at 0
		# only 2 outcomes poss. for now
		oldCost = ls_lmsr(market)
		# if buying outcome 1
		if outcome:
			self.Markets[market].sharesPurchased[i*2+1] += amount
		# outcome is no
		else:
			self.Markets[market].sharesPurchased[i*2] += amount
		newCost = ls_lmsr(market) 
	# regular lmsr
	else:
		if(self.Markets[market].lossLimit):
			# for the first trade's oldcost shares bought will be at 0
			# only 2 outcomes poss. for now
			oldCost = lmsr(market)
			# if buying outcome 1
			if outcome:
				self.Markets[market].sharesPurchased[i*2+1] += amount
			# outcome is no
			else:
				self.Markets[market].sharesPurchased[i*2] += amount
			newCost = lmsr(market) 

	# these prices are in fixed point
	pricePerShare = newCost - oldCost
	participantNumber = self.Markets[market].currentParticipant
	
	# send shares of the event to user address
	if outcome:
		# if user doesn't have enough money, revert
		if(self.cashcoin_balances[tx.origin]<amount*pricePerShare):
			self.Markets[market].sharesPurchased[i*2+1] -= amount
			return(0)
		else:
			# send ether from user acc. to market address/account
			self.send_cashcoin(market, pricePerShare*amount)
			self.Markets[market].participants[participantNumber].participantID = tx.origin
			self.Markets[market].participants[participantNumber].event[event].shares[1] += amount
			self.Markets[market].currentParticipant += 1
			return(participantNumber)
			
	# outcome 0
	else:
		# if user doesn't have enough money, revert
		if(self.cashcoin_balances[tx.origin]<amount*pricePerShare):
			self.Markets[market].sharesPurchased[i*2] -= amount
			return(0)
		else:
			# send ether from user acc. to market address/account
			self.send_cashcoin(market, pricePerShare*amount)
			self.Markets[market].participants[participantNumber].participantID = tx.origin
			self.Markets[market].participants[participantNumber].event[event].shares[0] += amount
			self.Markets[market].currentParticipant += 1
			return(participantNumber)

inset('fixedpoint.se')