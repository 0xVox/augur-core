# inset('logging.se')
inset('macros.se')

# Minimum value of array
macro minimum($a):
    with $min = $a[0]:
        with $i = 1:
            with $len = len($a):
                while $i < $len:
                    if $a[$i] < $min:
                        $min = $a[$i]
                    $i += 1
                $min

# Outer product of vectors
macro outer_product($u, $v, $n):
    with $p = array($n^2):
        with $i = 0:
            while $i < $n:
                with $j = 0:
                    while $j < $n:
                        $p[$i*$n + $j] += fixed_multiply($u[$i], $v[$j])
                        $j += 1
                $i += 1
            $p

def blank(components_remaining, max_iterations, num_events):
    with ne_plus_2 = num_events + 2:
        with iv = array(ne_plus_2):
            iv[0] = ONE
            iv[num_events] = max_iterations
            iv[num_events + 1] = components_remaining - 1
            return(iv, items=ne_plus_2)

def loadings(iv:arr, X:arr, reputation:arr, num_reports, num_events):
    # R.dot(wcd).dot(lv).dot(wcd)
    with lflatsize = len(iv):
        with lv = array(lflatsize):
            with j = 0:
                while j < num_reports:
                    with d_dot_lv = 0:
                        with k = 0:
                            while k < num_events:
                                d_dot_lv += X[j*num_events + k] * iv[k]
                                k += 1
                        d_dot_lv /= ONE
                        with k = 0:
                            while k < num_events:
                                lv[k] -= d_dot_lv * X[j*num_events + k] * reputation[j] / ONE^2
                                k += 1
                    j += 1
            # Normalize by length
            with lv_dot_lv = 0:
                with j = 0:
                    while j < num_events:
                        lv_dot_lv += lv[j] * lv[j]
                        j += 1
                lv_dot_lv /= ONE
                with norm_lv = lv_dot_lv / 2:
                    with j = 0:
                        while j < 11:
                            norm_lv = (norm_lv + fixed_divide(lv_dot_lv, norm_lv)) / 2
                            j += 1
                    with j = 0:
                        while j < num_events:
                            lv[j] = fixed_divide(lv[j], norm_lv)
                            j += 1
            lv[num_events] = iv[num_events] - 1
            lv[num_events + 1] = iv[num_events + 1]
            return(lv, items=lflatsize)

def latent(covslice:arr, loadings:arr, num_events):
    with lf = 0:
        with i = 0:
            while i < num_events:
                lf += fixed_multiply(covslice[i], loadings[i])
                i += 1
            if loadings[0] != 0:
                lf = fixed_divide(lf, loadings[0])
            else:
                lf = 0
            return(lf)

def deflate(ev:arr, wcd:arr, num_reports, num_events):
    with dsz = len(wcd):
        with evop = outer_product(ev, ev, num_events):
            with ddata = array(dsz):
                with data_x_evop = matrix_multiply(wcd, num_reports, num_events, evop, num_events, num_events):
                    with i = 0:
                        while i < dsz:
                            ddata[i] = wcd[i] - data_x_evop[i]
                            i += 1
                    return(ddata, items=dsz)

def score(scores:arr, lv:arr, wcd:arr, latent, num_reports, num_events):
    if lv[0] < 0:
        with j = 0:
            while j < num_events:
                lv[j] = -lv[j]
                j += 1
    with i = 0:
        while i < num_reports:
            with k = 0:
                while k < num_events:
                    scores[i] += fixed_multiply(wcd[i*num_events + k], latent * lv[k] / ONE)
                    k += 1
            i += 1
        return(scores, items=num_reports)

def reputation_delta(scores:arr, num_reports, num_events):
    # Which of the two possible 'new' reputation vectors had more in common
    # with the original 'old' reputation?
    # set1: [0, num_reports - 1]
    # set2: [num_reports, 2*num_reports - 1]
    with two_num_reports = 2*num_reports:
        with sets = array(two_num_reports):
            with set1_compare = abs(minimum(scores)):
                with set2_compare = maximum(scores):
                    with i = 0:
                        while i < num_reports:
                            sets[i] = scores[i] + set1_compare
                            i += 1
                        while i < two_num_reports:
                            sets[i] = scores[i - num_reports] - set2_compare
                            i += 1
                        return(sets, items=two_num_reports)

def weighted_delta(set1:arr, set2:arr, reputation:arr, reports:arr, num_reports, num_events):
    reputation = normalize(reputation)
    with three_num_events = 3*num_events:
        with wsets = array(three_num_events):
            with wset1 = normalize(set1):
                with wset2 = normalize(set2):
                    with i = 0:
                        with two_num_events = 2*num_events:
                            while i < num_events:
                                with k = 0:
                                    while k < num_reports:
                                        with pos = k*num_events + i:
                                            wsets[i] += fixed_multiply(reputation[k], reports[pos])
                                            wsets[i + num_events] += fixed_multiply(wset1[k], reports[pos])
                                            wsets[i + two_num_events] += fixed_multiply(wset2[k], reports[pos])
                                        k += 1
                                i += 1
                            return(wsets, items=three_num_events)

def select_scores(old:arr, new1:arr, new2:arr, set1:arr, set2:arr, scores:arr, num_reports, num_events):
    # Difference in sum of squared errors. If > 0, then new1 had higher
    # errors (use new2); conversely if < 0, then use new1.
    with sse1 = 0:
        with sse2 = 0:
            with i = 0:
                while i < num_events:
                    sse1 += fixed_multiply(new1[i] - old[i], new1[i] - old[i])
                    sse2 += fixed_multiply(new2[i] - old[i], new2[i] - old[i])
                    i += 1
            with ref_ind = sse1 - sse2:
                with adjusted_scores = array(num_reports):
                    if ref_ind <= 0:
                        adjusted_scores = set1
                    else:
                        adjusted_scores = set2
                    return(adjusted_scores, items=num_reports)
