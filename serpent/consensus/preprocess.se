# inset('logging.se')
inset('macros.se')
inset('weighted-median.se')

def interpolate(reports:arr, reputation:arr, scaled:arr, scaled_max:arr, scaled_min:arr):
    # returns:
    #   reports_filled: [0, flatsize - 1]
    #   reports_mask: [flatsize, 2*flatsize - 1]
    #
    # normalize reputation vector
    reputation = normalize(reputation)
    with num_reports = len(reputation):
        with flatsize = len(reports):
            with two_flatsize = 2*flatsize:
                with num_events = flatsize / num_reports:
                    with scaled_reports = array(flatsize):
                        with i = 0:
                            while i < num_events:
                                with j = 0:
                                    while j < num_reports:
                                        with idx = i + j*num_events:
                                            if reports[idx] == NA:
                                                scaled_reports[idx] = NA
                                            else:
                                                if scaled[i] == 1:
                                                    scaled_reports[idx] = fixed_divide(reports[idx] - scaled_min[i], scaled_max[i] - scaled_min[i])
                                                else:
                                                    scaled_reports[idx] = reports[idx]
                                        j += 1
                                i += 1
                        # use existing data and reputations to fill missing observations
                        # (weighted average or median over all non-missing data)
                        with reports_interp = array(two_flatsize):
                            with missing_values = 0:
                                with i = 0:
                                    while i < flatsize:
                                        if reports[i] == NA:
                                            reports_interp[i + flatsize] = ONE # reports_mask
                                            missing_values += 1
                                        else:
                                            reports_interp[i] = scaled_reports[i]
                                        i += 1
                                if missing_values:
                                    with num_present = array(num_events):
                                        with i = 0:
                                            while i < num_events:
                                                with j = 0:
                                                    while j < num_reports:
                                                        if reports[i + j*num_reports] != NA:
                                                            num_present[i] += 1
                                                        j += 1
                                                i += 1
                                        with i = 0:
                                            while i < num_events:
                                                if num_present[i] < num_reports:
                                                    with total_active_reputation = 0:
                                                        with active_reputation = array(num_present[i]):
                                                            with active_reports = array(num_present[i]):
                                                                with nan_indices = array(num_reports - num_present[i]):
                                                                    with nan_index = 0:
                                                                        with active_index = 0:
                                                                            with j = 0:
                                                                                while j < num_reports:
                                                                                    with idx = i + j*num_reports:
                                                                                        if scaled_reports[idx] == NA:
                                                                                            nan_indices[nan_index] = idx
                                                                                            nan_index += 1
                                                                                        else:
                                                                                            total_active_reputation += reputation[j]
                                                                                            active_reputation[active_index] = reputation[j]
                                                                                            active_reports[active_index] = scaled_reports[idx]
                                                                                            active_index += 1
                                                                                    j += 1
                                                                    with guess = 0:
                                                                        if scaled[i] == 0:
                                                                            with j = 0:
                                                                                while j < num_present[i]:
                                                                                    active_reputation[j] = fixed_divide(active_reputation[j], total_active_reputation)
                                                                                    guess += fixed_multiply(active_reputation[j], active_reports[j])
                                                                                    j += 1
                                                                            guess = catch(guess)
                                                                        else:
                                                                            with j = 0:
                                                                                while j < num_present[i]:
                                                                                    active_reputation[j] = fixed_divide(active_reputation[j], total_active_reputation)
                                                                                    j += 1
                                                                            guess = weighted_median(active_reports, active_reputation)
                                                                        with j = 0:
                                                                            while j < num_reports - num_present[i]:
                                                                                reports_interp[nan_indices[j]] = guess
                                                                                j += 1
                                                i += 1
                                else:
                                    with i = 0:
                                        while i < flatsize:
                                            reports_interp[i] = scaled_reports[i]
                                            i += 1
                                return(reports_interp, items=two_flatsize)

def center(reports_filled:arr, reputation:arr, scaled:arr, scaled_max:arr, scaled_min:arr, max_iterations, max_components):
    with num_reports = len(reputation):
        with flatsize = len(reports_filled):
            with num_events = flatsize / num_reports:
                # calculate weighted centered data matrix
                with weighted_means = array(num_events):
                    with total_weight = 0:
                        with i = 0:
                            while i < num_reports:
                                with j = 0:
                                    while j < num_events:
                                        weighted_means[j] += reputation[i] * reports_filled[i * num_events + j]
                                        j += 1
                                total_weight += reputation[i]
                                i += 1
                            with j = 0:
                                while j < num_events:
                                    weighted_means[j] /= total_weight
                                    j += 1
                            # weighted centered data (wcd): [0, flatsize-1]
                            # loading_vector [1 0 0 . . . 0]: [flatsize, flatsize + num_events]
                            with lflatsize = flatsize + num_events + 2:
                                with wcd = array(lflatsize):
                                    with i = 0:
                                        while i < flatsize:
                                            wcd[i] = reports_filled[i] - weighted_means[i % num_events]
                                            i += 1
                                        wcd[i] = ONE
                                        wcd[lflatsize - 2] = max_iterations
                                        if max_components < num_events:
                                            wcd[lflatsize - 1] = max_components
                                        else:
                                            wcd[lflatsize - 1] = num_events
                                        return(wcd, items=lflatsize)

def tokenize(reputation:arr, num_reports):
    with tokens = array(num_reports):
        with i = 0:
            while i < num_reports:
                tokens[i] = reputation[i] * COINS * ONE
                i += 1
            return(tokens, items=num_reports)

# First row of the covariance matrix
def covariance(wcd:arr, tokens:arr, num_reports, num_events):
    with cov = array(num_events):
        with wcd_x_tokens = array(num_reports):
            with i = 0:
                while i < num_reports:
                    wcd_x_tokens[i] = fixed_multiply(wcd[i*num_events], tokens[i])
                    i += 1
            with alltokens = sum(tokens):
                with i = 0:
                    while i < num_events:
                        with j = 0:
                            while j < num_reports:
                                cov[i] += fixed_multiply(wcd_x_tokens[j], wcd[j*num_events + i])
                                j += 1
                        cov[i] = fixed_divide(cov[i], alltokens - ONE)
                        i += 1
                    return(cov, items=num_events)
