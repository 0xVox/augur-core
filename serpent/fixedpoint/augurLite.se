# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C)  2014 Chris Calderon, Joey Krug, Alan Lu, Jack Peterson
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joeykrug@gmail.com

BRANCH = 0
EVENT = 1
MARKET = 2

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](typecode, description[2048], descriptionLength, creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# RepRequired is the amount of reputation required to reach quorem
# markets[] is a 0 index array of market hashes (a.k.a. marketID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the current vote period
data Branches[](currentVotePeriod, markets[], marketCount, periodLength, repRequired)

# Events' index is the eventID
# a binary outcome has 0 for min && 1 for max value (ditto for categorical even though not actually true)
# S&P 500 would be say 0 && 4700, respectively
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
# v_size = numReports * numEvents
# reportsFilled, reportsMask, weightedCenteredData, loadingVector, scores, set1, set2, old,
# new1, new2, adjPrinComp, smoothRep, outcomesFinal, consensusReward is all consensus data
data Reporting[](eventsExpDates[](numberEvents, events[], totalRepReported, reporters[][], vSize, reportsFilled[], reportsMask[], weightedCenteredData[], loadingVector[], scores[], set1[], set2[], old[], new1[], new2[], adjPrinComp[], smoothRep[], outcomesFinal[]), reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market in the format of
	# [1, event, event, 2, event, 3, event, event, event]
	# 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
# Sharespurchased keeps track of the number of shares purchased for each outcome
	# sharesPurchased states starts at 1 - (same for participants[].shares[] array)
# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event
# a binary outcome state 1 is no, 2 is true, 0 if not determined
# tradingFee is a percent in fixedPoint
data Markets[](branch, events[], sharesPurchased[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcome, alpha, cumulativeScale, numOutcomes, tradingPeriod, tradingFee)

data p2pBets[](eventID, amtToBet, outcomeOneBettor, outcomeZeroBettor)

data cashcoinBalances[]

def init():
	# test initial funds
	self.cashcoinBalances[tx.origin] = 1000000*2^64
	self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
	self.Reporting[1010101].reputation[0].repValue = 47
	self.Reporting[1010101].reputation[0].reporterID = tx.origin
	self.Reporting[1010101].numberReporters = 1
	self.Info[1010101].typecode = 0
	self.Info[1010101].description[] = "initial branch"
	self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
	self.Info[1010101].creationFee = 10
	self.Branches[1010101].currentVotePeriod = block.number / 403200
	self.Branches[1010101].marketCount = 0
	self.Branches[1010101].periodLength = 403200
	self.Branches[1010101].repRequired = 14000000

# string chunks
macro chunks($l):
	$l + if(l%32 != 0, 1, 0)

def balance(address):
	return(self.cashcoinBalances[address])

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
def send(recver, value):
	sender = tx.origin
	senderBalance = self.cashcoinBalances[sender]
	if(senderBalance >= value):
		self.cashcoinBalances[sender] -= value
		self.cashcoinBalances[recver] += value
		return(1)
	else:
		return(0)

def sendFrom(recver, value, from):
	if(from!=tx.origin):
		return(0)
	senderBalance = self.cashcoinBalances[from]
	if(senderBalance >= value):
		self.cashcoinBalances[from] -= value
		self.cashcoinBalances[recver] += value
		return(1)
	else:
		return(0)

def sendReputation(branch, recver, value):
	if(value<=0 || !self.send(branch, 5*2^64)):
		return(0)
	sender = tx.origin
	senderIndex = self.Reporting[branch].repIDtoIndex[sender]
	receiverIndex = self.Reporting[branch].repIDtoIndex[recver]
	# if the sender's rep. account doesn't exist, make one
	if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
		reporterIndex = self.Reporting[branch].numberReporters
		self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
		self.Reporting[branch].reputation[reporterIndex].repValue = 0
		self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
		self.Reporting[branch].numberReporters += 1
		return(text("Your reputation account was just created, earn some rep. before you can send to others"): str)

	if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
		return(text("Receiving address doesn't exist"): str)
		
	senderBalance = self.Reporting[branch].reputation[senderIndex].repValue
	if(senderBalance >= value):
		self.Reporting[branch].reputation[senderIndex].repValue -= value
		self.Reporting[branch].reputation[receiverIndex].repValue += value
		return(1)
	else:
		return(0)
		
def getRepBalance(branch, address):
	return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)

# period length is given in blocks
# description format is branchName:description
# is there some way we can include the description bytes in the sha256 hash?
def makeSubBranch(description:str, periodLength, parent, repRequired):
	if(periodLength<=0 || !self.Branches[parent].periodLength || !repRequired || description==0):
		return(0)
	branchInfo = string((items=7)+len(description))
	branchInfo[0] = BRANCH                                      #typecode
	branchInfo[1] = tx.origin                                   #creator address
	branchInfo[2] = 47*2^64                                     #creation fee
	branchInfo[3] = periodLength                                #length of voting cycle
	branchInfo[4] = block.number                                #current block number
	branchInfo[5] = parent                                      #branchID of parent branch
	branchInfo[6] = repRequired                                 #minimum rep required to vote
	mcopy(branchInfo+(items=7), description, len(description))
	# people can check that these characteristics hash to the ID if they want
	# people can hand a friend their new branch hash && characteristics && say, "don't trust me? check"
	branchID = sha256(branchinfo, chars=len(branchinfo))

	if(!self.Branches[branchID].periodLength && !self.Info[branchID].creator && self.send(branchID, 47*2^64)):
		self.Info[branchID].typecode = BRANCH
		self.Info[branchID].creator = tx.origin
		self.Info[branchID].creationFee = 47*2^64
		self.Info[branchID].descriptionLength = len(description)
		save(self.Info[branchID].description[0], description, chars=len(description))
		self.Branches[branchID].periodLength = periodLength
		self.Branches[branchID].repRequired = repRequired
		# first vote period won't be until after the current (in this case first) basket of things has expired
		self.Branches[branchID].currentVotePeriod = (block.number / periodLength) + 1
		i = 0
		while i < self.Reporting[parent].numberReporters:
			self.Reporting[branchID].reputation[i].reporterID = self.Reporting[parent].reputation[i].reporterID
			self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
			i+=1
		self.Reporting[branchID].numberReporters = i
		return(branchID)
	else:
		return(0)

# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0
# to 11.0 would be 11 outcomes (if incremented by 0.1)
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes):
	if(self.Branches[branch].periodLength && description!=0 && expDate>block.number):
		eventinfo = string((items=8)+len(description))
		eventinfo[0] = EVENT                                        #typecode
		eventinfo[1] = branch                                       #branchID
		eventinfo[2] = expDate                                      #expiration date
		eventinfo[3] = tx.origin                                    #creator address
		eventinfo[4] = 42*2^64                                      #creation fee
		eventinfo[5] = minValue                                     #minimum outcome value
		eventinfo[6] = maxValue                                     #maximum outcome value
		eventinfo[7] = numOutcomes                                  #number of outcomes
		mcopy(eventinfo+(items=8), description, len(description))
		eventID = sha256(eventinfo, chars=len(eventinfo))
	else:
		return(0)

	# can't have a scalar && categorical event in one
	# you can make a market like that though!
	if(numOutcomes!=2 && maxValue!=1):
		return(0)
	# send fee and bond
	if(self.balance(tx.origin)>=85*2^64):
		if (!self.Info[eventID].creator && !self.Events[eventID].branch && self.send(branch, 42*2^64) && self.send(eventID, 43*2^64)):
			self.Info[eventID].typecode = EVENT
			self.Info[eventID].creator = tx.origin
			self.Info[eventID].creationFee = 42*2^64
			self.Info[eventID].descriptionLength = len(description)
			save(self.Info[eventID].description[0], description, chars=len(description))
			self.Events[eventID].branch = branch
			self.Events[eventID].expirationDate = expDate
			self.Events[eventID].minValue = minValue
			self.Events[eventID].maxValue = maxValue
			self.Events[eventID].numOutcomes = numOutcomes
			# see which future period it expires in && put the event in that bin
			# event voting periods - expDate / periodLength gives you the voting period #
			futurePeriod = expDate / self.Branches[branch].periodLength
			self.Reporting[branch].eventsExpDates[futurePeriod].events[self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents] = eventID
			self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents += 1
			return(eventID)
		else:
			return(0)

# alpha is equal to v/(n*log(n)) where v is the max percent commission,
# && n is the number of outcomes people can trade. Alpha is set when
# a market is created.
macro lsLmsr($marketID):
	with $Bq = 0:
		with $l = self.Markets[$marketID].numOutcomes:
			with $i = 1:
				while $i <= $l:
					$Bq += self.Markets[$marketID].sharesPurchased[$i]
					$i += 1
				$Bq *= self.Markets[$marketID].alpha
				$Bq *= self.Markets[$marketID].cumulativeScale
				$i = 1
				with $sumExp = 0:
					with $a = 0:
							while $i <= $l:
								$a = self.Markets[$marketID].sharesPurchased[$i]
								$sumExp += self.exp($a*2^64/$Bq)
								$i += 1
							$Bq*self.log($sumExp)/2^64

# alpha is a fixedpoint number / calc. it in UI
# z is the optimal initial vector for each outcome
# z = liquidity / (1+(alpha*n*ln(n)))
# initialLiquidity is initial number of shares of each outcome you want to buy/initialize/set
# tradingFee is a percent in fixedPoint
def createMarket(branch, description:str, alpha, initialLiquidity, tradingFee, events:arr):
	if(!self.Branches[branch].periodLength || description==0 || !initialLiquidity || alpha <= (2^64 / 132) || tradingFee <= 2^64):
		return(0)
	# check that events have same exp. dates && branch
	i = 0
	eventNum = len(events)
	# only supports 3 dimensional markets atm
	if(eventNum > 3):
		return(0)
	numOutcomes = 0
	eventsConcat = 0
	cumulativeScale = 0
	tradingPeriod = 0
	while i < eventNum:
			event = events[i]
			if(self.Events[event].expirationDate > tradingPeriod):
				tradingPeriod = self.Events[event].expirationDate
			eventsConcat += event
			if (self.Events[event].branch != branch || !self.Info[eventID].creator):
				return(0)
			#scalars
			if(self.Events[event].maxValue!=1):
				# not a scalar but also not categorical or binary - invalid event
				if(self.Events[event].numOutcomes!=2):
					return(0)
				# is a valid scalar
				cumulativeScale += self.Events[event].maxValue - self.Events[event].minValue
			if(i==0):
				numOutcomes += self.Events[event].numOutcomes
			else:
				numOutcomes *= self.Events[event].numOutcomes
			i += 1
	if(numOutcomes > 200):
		return(0)
	tradingPeriod = tradingPeriod / self.Branches[branch].periodLength
	# formation of marketID (hash)
	marketinfo = string((items=11)+len(description))
	marketinfo[0] = MARKET
	marketinfo[1] = tx.origin
	marketinfo[2] = initialLiquidity
	marketinfo[3] = branch
	marketinfo[4] = eventsConcat
	marketinfo[5] = len(events)
	marketinfo[6] = cumulativeScale
	marketinfo[7] = alpha
	marketinfo[8] = numOutcomes
	marketinfo[9] = tradingPeriod
	marketinfo[10] = tradingFee
	mcopy(marketinfo+(items=11), description, chars=len(description))
	marketID = sha256(marketinfo, chars=len(marketinfo))

	# buy some of all outcomes
	# ls-lmsr needs at least a very small initial liquidity
	y = 1
	while y <= numOutcomes:
		self.Markets[marketID].sharesPurchased[y] += initialLiquidity
	cost = lsLmsr(marketID)

	if(self.send(marketID, cost)):
		# add event list to the market
		save(self.Markets[marketID].events[0], events, items=eventNum)      
		self.Info[marketID].typecode = MARKET
		self.Info[marketID].creator = tx.origin
		self.Info[marketID].creationFee = initialLiquidity
		self.Info[marketID].descriptionLength = len(description)
		save(self.Info[marketID].description[0], description, chars=len(description))
		self.Markets[marketID].branch = branch
		self.Markets[marketID].alpha = alpha
		self.Markets[marketID].lenEvents = len(events)
		self.Markets[marketID].cumulativeScale = cumulativeScale
		self.Markets[marketID].numOutcomes = numOutcomes
		self.Markets[marketID].tradingPeriod = tradingPeriod
		self.Markets[marketID].tradingFee = tradingFee
		# add the market to the branch
		marketCount = self.Branches[branch].marketCount
		self.Branches[branch].markets[marketCount] = marketID
		self.Branches[branch].marketCount += 1
		return(marketID)
	else:
		# revert shares bought
		y = 1
		while y <= numOutcomes:
			self.Markets[marketID].sharesPurchased[y] -= initialLiquidity
		return(0)

# amount of shares should be an integer
def buyShares(branch, market, outcome, amount):
	# can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)
	if (self.Markets[market].branch!=branch || outcome==0 || self.Branches[branch].currentVotePeriod>=self.Markets[marketID].tradingPeriod):
		return(0)
	# lmsr cost calcs
	oldCost = lsLmsr(market)
	self.Markets[market].sharesPurchased[outcome] += amount
	newCost = lsLmsr(market)

	# these prices are in fixed point
	pricePerShare = newCost - oldCost
	participantNumber = self.Markets[market].currentParticipant
  
	# send shares of the event to user address
	# if user doesn't have enough money, revert
	if(self.cashcoinBalances[tx.origin]<((amount*pricePerShare)+(self.Markets[marketID].tradingFee*amount*pricePerShare/2^64))):
		self.Markets[market].sharesPurchased[outcome] -= amount
		return(0)
	else:
		# send money from user acc. to market address/account
		# cost for shares
		self.send(market, amount*pricePerShare)
		# half of fees to market creator
		self.send(self.Info[marketID].creator, (self.Markets[marketID].tradingFee*amount*pricePerShare)/2^65)
		# other half go to branch
		self.send(branch, (self.Markets[marketID].tradingFee*amount*pricePerShare)/2^65)
		self.Markets[market].participants[participantNumber].participantID = tx.origin
		self.Markets[market].participants[participantNumber].shares[outcome] += amount
		self.Markets[market].currentParticipant += 1
		return(participantNumber)

# amount is amount of shares to buy
# instead of inputting particip. num could just loop through array if dont have it
def sellShares(branch, market, outcome, amount, participantNumber):
	# can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)
	if (self.Markets[market].participants[participantNumber].participantID != tx.origin || self.Markets[market].branch!=branch || outcome==0 || self.Branches[branch].currentVotePeriod>=self.Markets[marketID].tradingPeriod):
		return(0)
	# lmsr cost calcs
	oldCost = lsLmsr(market)
	self.Markets[market].sharesPurchased[outcome] -= amount
	newCost = lsLmsr(market)

	# these prices are in fixed point
	pricePerShare = oldCost - newCost
	participantNumber = self.Markets[market].currentParticipant

	# remove shares from the user's account
	# if user actually doesn't have the shares, revert
	if(self.Markets[market].participants[participantNumber].shares[outcome] < amount):
		self.Markets[market].sharesPurchased[outcome] += amount
		return(0)
	else:
		# send bitcoin from the market to the user acc.
		self.cashcoinBalances[market] -= priceToPayPerShare*amount
		# half of fees go to market creator
		self.cashcoinBalances[self.Info[marketID].creator] +=  (self.Markets[marketID].tradingFee*amount*priceToPayPerShare)/2^65
		# half go to branch
		self.cashcoinBalances[branch] += (self.Markets[marketID].tradingFee*amount*priceToPayPerShare)/2^65
		self.cashcoinBalances[tx.origin] += (priceToPayPerShare*amount - ((self.Markets[marketID].tradingFee*amount*priceToPayPerShare)/2^64))
		self.Markets[market].participants[participantNumber].shares[outcome] -= amount
		return(1)

# a no vote is -2^64, a yes vote is 2^64 && a can't determine vote is 2^63 (a empty ballot is 0)
# atm voters who do vote are req. to vote on all things in their respective ballots (rest just auto .5 them)
# ui should handle this by filling in things you didn't vote on automatically & ask to be sure you didn't want to vote on them
# UI makeBallot function does this
	# ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[votePeriod].numberEvents
	# && loop through the events[] array from 0 to numberEvents -1 for the votes list / order
# people could report something like 16027*2^64 for a scalar
def vote(branch, report:arr):
	# make sure the branch exists
	repIndex = self.Reporting[branch].repIDtoIndex[tx.origin]
	# need report length to be same as number of items in the current eventexpdates voting period events!
	if(len(report)!=self.Reporting[branch].eventsExpDates[self.Branches[branch].currentVotePeriod].numberEvents):
		return(0)

	# if current period is more than 2 periods past the vote period
	# then there can be no more voting for that voting period
	# (reasoning being: >1 period past means all the events in that period have expired)
	# (>2 periods past mean the events have exp. & people have had 1 full period to vote)
	# currently requires events to expire to vote
	currentPeriod = block.number / self.Branches[branch].periodLength
	if (self.Reporting[branch].reputation[repIndex].reporterID != tx.origin | currentPeriod > (self.Branches[branch].currentVotePeriod+2) | currentPeriod < (self.Branches[branch].currentVotePeriod+1)):
		return(0)

	reputation = self.Reporting[branch].reputation[repIndex].repValue
	# need to update stuff for quorem
	# && store the report && the rep value
	save(self.Reporting[branchID].eventsExpDates[self.Branches[branch].currentVotePeriod].reporters[tx.origin][0], report, items=len(report))
	self.Reporting[branchID].eventsExpDates[self.Branches[branchID].currentVotePeriod].totalRepReported += reputation
	return(1)

# returns whether a quorem has a matured event && whether
# the number of required reports are met
def checkQuorum(branch):
	currentPeriod = block.number / self.Branches[branch].periodLength
	# provided the currentPeriod is >2 periods past the things we're going to rbcr on
	# we can then conclude it has matured && people have had time to vote
	if (currentPeriod > (self.Branches[branch].currentVotePeriod+2)):
		matured = true
	else:
		matured = false
	currentVotePeriod = self.Branches[branchID].currentVotePeriod
	# check that enough people actually did vote
	if (self.Reporting[branch].eventsExpDates[currentVotePeriod].totalRepReported >= self.Branches[branch].repRequired):
		met = true
	else:
		met = false
	if(met && matured):
		return(1)
	else:
		return(0)

### API (for UI)

# atm voters who do vote are req. to vote on all things in their respective ballots (even if just a 0 / no vote)
# ui should handle this ^
# ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents
# && loop through the events[] array from 0 to numberEvents -1 for the votes list / order
# UI will need a function to get the items in that array above so it can make a report!
# w/ this function you can get the eventIDs, look them up && report on outcomes (probably w/ another function to look them up) -- make sure in this function to check that the report value is not >maxvalue or <minvalue for the event
def makeBallot(branch):
	numEvents = self.Reporting[branch].eventsExpDates[self.Branches[branch].currentVotePeriod].numberEvents
	eventArray = array(numEvents)
	i = 0
	while i < numEvents:
		eventID = self.Reporting[branch].eventsExpDates[self.Branches[branch].currentVotePeriod].events[numEvents]
		eventArray[i] = eventID
	return(eventArray: arr)

# arrayIndex only matters if array
def api(dataStructure, itemNumber, arrayIndex, ID):
	if(dataStructure==0):
		if(itemNumber==0):
			return(self.Info[ID].typecode)
		elif(itemNumber==1):
			length=self.Info[ID].descriptionLength
			return(load(self.Info[ID].description[0], chars=length))
		elif(itemNumber==2):
			return(self.Info[ID].descriptionLength)
		elif(itemNumber==3):
			return(self.Info[ID].creator)
		elif(itemNumber==4):
			return(self.Info[ID].creationFee)
	elif(dataStructure==1):
		if(itemNumber==0):
			return(self.Branches[ID].currentVotePeriod)
		elif(itemNumber==1):
			return(self.Branches[ID].markets[arrayIndex])
		elif(itemNumber==2):
			return(self.Branches[ID].marketCount)
		elif(itemNumber==3):
			return(self.Branches[ID].periodLength)
		elif(itemNumber==4):
			return(self.Branches[ID].repRequired)
	elif(dataStructure==2):
		if(itemNumber==0):
			return(self.Events[ID].branch)
		elif(itemNumber==1):
			return(self.Events[ID].expirationDate)
		elif(itemNumber==2):
			return(self.Events[ID].outcome)
		elif(itemNumber==3):
			return(self.Events[ID].minValue)
		elif(itemNumber==4):
			return(self.Events[ID].maxValue)
		elif(itemNumber==5):
			return(self.Events[ID].numOutcomes)
	elif(dataStructure==3):
		if(itemNumber==0):
			return(text("Please call the eventsExpApi function"): str)
		elif(itemNumber==1):
			return(text("Please call the reputation api function"): str)
		elif(itemNumber==2):
			return(self.Reporting[ID].numberReporters)
		elif(itemNumber==3):
			return(self.Reporting[ID].repIDtoIndex[arrayIndex])
	elif(dataStructure==4):
		if(itemNumber==0):
			return(self.Markets[ID].branch)
		elif(itemNumber==1):
			return(self.Markets[ID].events[arrayIndex])
		elif(itemNumber==2):
			return(self.Markets[ID].sharesPurchased[arrayIndex])
		elif(itemNumber==3):
			return(text("Please call the participants api function"): str)
		elif(itemNumber==4):
			return(self.Markets[ID].lenEvents)
		elif(itemNumber==5):
			return(self.Markets[ID].currentParticipant)
		elif(itemNumber==6):
			return(self.Markets[ID].winningOutcome)
		elif(itemNumber==7):
			return(self.Markets[ID].alpha)
		elif(itemNumber==8):
			return(self.Markets[ID].cumulativeScale)
		elif(itemNumber==9):
			return(self.Markets[ID].numOutcomes)
		elif(itemNumber==10):
			return(self.Markets[ID].tradingPeriod)
		elif(itemNumber==11):
			return(self.Markets[ID].tradingFee)
	elif(dataStructure==5):
		if(itemNumber==0):
			return(self.p2pBets[ID].eventID)
		elif(itemNumber==1):
			return(self.p2pBets[ID].amtToBet)
		elif(itemNumber==2):
			return(self.p2pBets[ID].outcomeOneBettor)
		elif(itemNumber==3):
			return(self.p2pBets[ID].outcomeZeroBettor)

def eventsExpApi(expDateIndex, itemNumber, arrayIndexOne, arrayIndexTwo, ID):
	if(itemNumber==0):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].numberEvents)
	elif(itemNumber==1):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].events[arrayIndexOne])
	elif(itemNumber==2):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].totalRepReported)
	elif(itemNumber==3):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].reporters[arrayIndexOne][ArrayIndexTwo])
	elif(itemNumber==4):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].vSize)
	elif(itemNumber==5):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].reportsFilled[arrayIndexOne])
	elif(itemNumber==6):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].reportsMask[arrayIndexOne])
	elif(itemNumber==7):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].weightedCenteredData[arrayIndexOne])
	elif(itemNumber==8):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].loadingVector[arrayIndexOne])
	elif(itemNumber==9):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].scores[arrayIndexOne])
	elif(itemNumber==10):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].set1[arrayIndexOne])
	elif(itemNumber==11):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].set2[arrayIndexOne])
	elif(itemNumber==12):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].old[arrayIndexOne])
	elif(itemNumber==13):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].new1[arrayIndexOne])
	elif(itemNumber==14):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].new2[arrayIndexOne])
	elif(itemNumber==15):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].adjPrinComp[arrayIndexOne])
	elif(itemNumber==16):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].smoothRep[arrayIndexOne])
	elif(itemNumber==17):
		return(self.Reporting[ID].eventsExpDates[expDateIndex].outcomesFinal[arrayIndexOne])

def reputationApi(reputationIndex, itemNumber, branchID):
	if(itemNumber==0):
		return(self.Reporting[branchID].reputation[reputationIndex].repValue)
	elif(itemNumber==1):
		return(self.Reporting[branchID].reputation[reputationIndex].reporterID)

# eventID && outcomeNumber only needed if itemNumber is 1
# remove this
def marketParticipantsApi(participantIndex, itemNumber, eventID, outcomeNumber, marketID):
	if(itemNumber==0):
		return(self.Markets[marketID].participants[participantIndex].participantID)
	elif(itemNumber==1):
		return(self.Markets[marketID].participants[participantIndex].shares[outcomeNumber])

inset('fixedpoint.se')
inset('consensus.se')