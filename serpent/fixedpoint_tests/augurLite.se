# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C)  2014 Chris Calderon, Joey Krug, Alan Lu, Jack Peterson
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joeykrug@gmail.com
# 	var evm = '0x...';
#	var address = web3.eth.transact({code: evm});
#	var contract = web3.eth.contract(address, desc);
#	serpent mk_full_signature

BRANCH = 0
EVENT = 1
MARKET = 2

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](typecode, description[2048], descriptionLength, creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# RepRequired is the amount of reputation required to reach quorem
# markets[] is a 0 index array of market hashes (a.k.a. marketID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the current vote period
data Branches[](currentVotePeriod, markets[], marketCount, periodLength, repRequired)

# Events' index is the eventID
# a binary outcome has 0 for min && 1 for max value (ditto for categorical even though not actually true)
# S&P 500 would be say 0 && 4700, respectively
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
# v_size = numReports * numEvents
# reportsFilled, reportsMask, weightedCenteredData, loadingVector, scores, set1, set2, old,
# new1, new2, adjPrinComp, smoothRep, outcomesFinal, consensusReward is all consensus data
data Reporting[](eventsExpDates[](numberEvents, events[], totalRepReported, reporters[][], vSize, reportsFilled[], reportsMask[], weightedCenteredData[], loadingVector[], scores[], set1[], set2[], old[], new1[], new2[], adjPrinComp[], smoothRep[], outcomesFinal[]), reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market in the format of
	# [1, event, event, 2, event, 3, event, event, event]
	# 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
# Sharespurchased keeps track of the number of shares purchased for each outcome
	# sharesPurchased states starts at 1 - (same for participants[].shares[] array)
# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event
# a binary outcome state 1 is no, 2 is true, 0 if not determined
# tradingFee is a percent in fixedPoint
data Markets[](branch, events[], sharesPurchased[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcome, alpha, cumulativeScale, numOutcomes, tradingPeriod, tradingFee)

data p2pBets[](eventID, amtToBet, outcomeOneBettor, outcomeZeroBettor)

data cashcoinBalances[]

def init():
	# test initial funds
	self.cashcoinBalances[tx.origin] = 1000000*2^64
	self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
	self.Reporting[1010101].reputation[0].repValue = 47
	self.Reporting[1010101].reputation[0].reporterID = tx.origin
	self.Reporting[1010101].numberReporters = 1
	self.Info[1010101].typecode = 0
	self.Info[1010101].description[] = "initial branch"
	self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
	self.Info[1010101].creationFee = 10
	self.Branches[1010101].currentVotePeriod = block.number / 403200
	self.Branches[1010101].marketCount = 0
	self.Branches[1010101].periodLength = 403200
	self.Branches[1010101].repRequired = 14000000

# string chunks
macro chunks($l):
	$l + if(l%32 != 0, 1, 0)

def balance(address):
	return(self.cashcoinBalances[address])

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
def send(recver, value):
	sender = tx.origin
	senderBalance = self.cashcoinBalances[sender]
	if(senderBalance >= value):
		self.cashcoinBalances[sender] -= value
		self.cashcoinBalances[recver] += value
		return(1)
	else:
		return(0)

def faucet():
	sender = tx.origin
	self.cashcoinBalances[sender] = 10000*2^64
	return(10000*2^64)

def sendFrom(recver, value, from):
	if(from!=tx.origin):
		return(0)
	senderBalance = self.cashcoinBalances[from]
	if(senderBalance >= value):
		self.cashcoinBalances[from] -= value
		self.cashcoinBalances[recver] += value
		return(1)
	else:
		return(0)

def sendReputation(branch, recver, value):
	if(value<=0 || !self.send(branch, 5*2^64)):
		return(0)
	sender = tx.origin
	senderIndex = self.Reporting[branch].repIDtoIndex[sender]
	receiverIndex = self.Reporting[branch].repIDtoIndex[recver]
	# if the sender's rep. account doesn't exist, make one
	if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
		reporterIndex = self.Reporting[branch].numberReporters
		self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
		self.Reporting[branch].reputation[reporterIndex].repValue = 0
		self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
		self.Reporting[branch].numberReporters += 1
		return(text("Your reputation account was just created, earn some rep. before you can send to others"): str)

	if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
		return(text("Receiving address doesn't exist"): str)
		
	senderBalance = self.Reporting[branch].reputation[senderIndex].repValue
	if(senderBalance >= value):
		self.Reporting[branch].reputation[senderIndex].repValue -= value
		self.Reporting[branch].reputation[receiverIndex].repValue += value
		return(1)
	else:
		return(0)
		
def getRepBalance(branch, address):
	return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)


# period length is given in blocks
# description format is branchName:description
# is there some way we can include the description bytes in the sha256 hash?
def makeSubBranch(description:str, periodLength, parent, repRequired):
	if(periodLength<=0 || !self.Branches[parent].periodLength || !repRequired || description==0):
		return(0)
	branchInfo = string((items=7)+len(description))
	branchInfo[0] = BRANCH                                      #typecode
	branchInfo[1] = tx.origin                                   #creator address
	branchInfo[2] = 47*2^64                                     #creation fee
	branchInfo[3] = periodLength                                #length of voting cycle
	branchInfo[4] = block.number                                #current block number
	branchInfo[5] = parent                                      #branchID of parent branch
	branchInfo[6] = repRequired                                 #minimum rep required to vote
	mcopy(branchInfo+(items=7), description, len(description))
	# people can check that these characteristics hash to the ID if they want
	# people can hand a friend their new branch hash && characteristics && say, "don't trust me? check"
	branchID = sha256(branchinfo, chars=len(branchinfo))

	if(!self.Branches[branchID].periodLength && !self.Info[branchID].creator && self.send(branchID, 47*2^64)):
		self.Info[branchID].typecode = BRANCH
		self.Info[branchID].creator = tx.origin
		self.Info[branchID].creationFee = 47*2^64
		self.Info[branchID].descriptionLength = len(description)
		save(self.Info[branchID].description[0], description, chars=len(description))
		self.Branches[branchID].periodLength = periodLength
		self.Branches[branchID].repRequired = repRequired
		# first vote period won't be until after the current (in this case first) basket of things has expired
		self.Branches[branchID].currentVotePeriod = (block.number / periodLength) + 1
		i = 0
		while i < self.Reporting[parent].numberReporters:
			self.Reporting[branchID].reputation[i].reporterID = self.Reporting[parent].reputation[i].reporterID
			self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
			i+=1
		self.Reporting[branchID].numberReporters = i
		return(branchID)
	else:
		return(0)

# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0
# to 11.0 would be 11 outcomes (if incremented by 0.1)
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes):
	if(self.Branches[branch].periodLength && description!=0 && expDate>block.number):
		eventinfo = string((items=8)+len(description))
		eventinfo[0] = EVENT                                        #typecode
		eventinfo[1] = branch                                       #branchID
		eventinfo[2] = expDate                                      #expiration date
		eventinfo[3] = tx.origin                                    #creator address
		eventinfo[4] = 42*2^64                                      #creation fee
		eventinfo[5] = minValue                                     #minimum outcome value
		eventinfo[6] = maxValue                                     #maximum outcome value
		eventinfo[7] = numOutcomes                                  #number of outcomes
		mcopy(eventinfo+(items=8), description, len(description))
		eventID = sha256(eventinfo, chars=len(eventinfo))
	else:
		return(0)

	# can't have a scalar && categorical event in one
	# you can make a market like that though!
	if(numOutcomes!=2 && maxValue!=1):
		return(0)
	# send fee and bond
	if(self.balance(tx.origin)>=85*2^64):
		if (!self.Info[eventID].creator && !self.Events[eventID].branch && self.send(branch, 42*2^64) && self.send(eventID, 43*2^64)):
			self.Info[eventID].typecode = EVENT
			self.Info[eventID].creator = tx.origin
			self.Info[eventID].creationFee = 42*2^64
			self.Info[eventID].descriptionLength = len(description)
			save(self.Info[eventID].description[0], description, chars=len(description))
			self.Events[eventID].branch = branch
			self.Events[eventID].expirationDate = expDate
			self.Events[eventID].minValue = minValue
			self.Events[eventID].maxValue = maxValue
			self.Events[eventID].numOutcomes = numOutcomes
			# see which future period it expires in && put the event in that bin
			# event voting periods - expDate / periodLength gives you the voting period #
			futurePeriod = expDate / self.Branches[branch].periodLength
			self.Reporting[branch].eventsExpDates[futurePeriod].events[self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents] = eventID
			self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents += 1
			return(eventID)
		else:
			return(0)

