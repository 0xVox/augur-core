# includes
extern fp:[new, mul, div, intpart, fracpart, log, exp, pow, sqrt]
FixedPoint = create('fixedpoint.se')

BRANCH = 0
EVENT = 1
MARKET = 2

# for a market, creationFee is same as initial liquidity
data Info[](typecode, description[], creator, creationFee)

# currentVotePeriod is where we are in the eventsExpDates, lastPeriodEnd is the last voting period block number
# when sending rep check if it's in the same branch or a child branch of the branch sending from
# but what prevents me from adding a parent branch as a child branch
# keep track of parent branches, make so cant add as a child branch
# how do we keep track of parent branches?
# take the branch that we add it to as a subbranch, and add it and any of its parentbranches to the new child branch
data Branches[](currentVotePeriod, markets[], marketCount, periodLength, lastPeriodEnd, parent)

data Events[](branch, expirationDate)

# index is branchID
# reporter index is the rep. address
# we 0 index reputation so can walk thru for consensus
data Reporting[](eventsExpDates[](numberEvents, events[], totalRepReported, reporters[]), reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

data Markets[](branch, events[](eventID, sharesPurchased[2]), participants[](participantID, event[](shares[2])), lossLimit, tradingFee, numberEvents, currentParticipant)

data cashcoin_balances[]

data repRequired = 447

def init():
    # test initial funds
    cashcoin_balances[0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826] = 1000000
    self.Reporting[1010101].repIDtoIndex["chris and joey's rep"] = 0
    self.Reporting[1010101].reputation[0].repValue = 47
    self.Reporting[1010101].reputation[0].reporterID = "chris and joey's rep"

### Version 2.0:
    # blockchain explorer to get / examine data or make rpc api calls to the contract to get it
    # local contract calls don't cost gas
    # Scalar event where people update what type of share they bought using a thing
    # in an array where index is their scalar x and value
    # is the share updated number of shares bought
    # how do we make this code updatable
    # how do we scale / what if a ton of events, markets, etc.
    # api voting option
    # seigniorage
    # if current vote period is == 0 then we looped past 2^256 --- set values in array to 0 at that point
    # may need a ballot max size b/c cost so need a systematic way to do voting (e.g. vote on first xxx events, then next set are another ballot)
    # randomized voter selection? - first x events expiring vote on in one ballot - random selection, then another ballot
    # new market maker

### To do:
    # make sure this follows paul's whitepaper well
    # add multiple events into markets buy / sell feature
    # scalars
    # real branching / subbranching
    # people can currently send votecoin to any branch, "Houston, we have a problem!"
    # voting consensus & redeem tx
    # contract should send msg.values around, not cashcoin -- i'll (joey) fix this
    # what if people pass functions incorrect values, need to detect that junk and return 0

### Actual code begins

def send_reputation(recver, value, branch):
    sender = tx.origin
    # if the sender's rep. account doesn't exist, make one
    if(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[sender]].reporterID!=tx.origin):
            self.Reporting[branch].numberReporters += 1
            reporterIndex = self.Reporting[branch].numberReporters
            self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
            self.Reporting[branch].reputation[reporterIndex].repValue = 0
            self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
            return("Your reputation account was just created, earn some rep. before you can send to others")

    if(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[recver]].reporterID!=recver):
        return("Receiving address doesn't exist")
        
    sender_balance = self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[sender]].repValue
    if(sender_balance >= value):
        self.Reporting[branch].reputation[repIDtoIndex[sender]].repValue -= value
        self.Reporting[branch].reputation[repIDtoIndex[recver]].repValue += value
        return(1)
    else:
        return(0)
        
        
def get_rep_balance(branch, address):
    return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)
    



# when sending rep check if it's in the same branch or a child branch of the branch sending from
# but what prevents me from adding a parent branch as a child branch
# keep track of parent branches, make so cant add as a child branch
# how do we keep track of parent branches?
# take the branch that we add it to as a subbranch, and add it and any of its parentbranches to the new child branch

# update w/ stuff from above funct.

def send_rep_newbranch(to, value, oldBranch, newBranch):
        # if no branch created (defined as a nonzero period)
        tempID = Branches[newBranch].parent
        while tempID != oldBranch and tempID != 0 and Branches[tempID].periodLength != 0:
            tempID = Branches[tempID].parent
        if tempID != oldBranch:
            return(0)
            
        if(!self.Branches[oldBranch].periodLength | !self.Branches[newBranch].periodLength | value<=0):
            return(0)
        else:
            from = tx.origin
            
            fromvalue = self.Branches[oldBranch].reputation[from]
            if(fromvalue >= value):
                self.Branches[fromBranch].reputation[from] -= value
                self.Branches[toBranch].reputation[to] += value
                return(1)
            else:
                return(0)

# period length is given in blocks
def make_subbranch(branchName:s, description:s, periodLength, parent):
    # add current vote period initializations, etc to this creation as well as last period end
    # as well as eventsExpDates[](numberEvents, events[]) to 0  
    # give fee to first mark etto  created on new branch
    branchCharacteristics = array(9)
    branchCharacteristics[0] = branchName
    branchCharacteristics[1] = description
    branchCharacteristics[2] = periodLength
    # event and market counts both 0
    branchCharacteristics[3] = 0
    branchCharacteristics[4] = 0
    branchCharacteristics[5] = periodLength
    branchCharacteristics[6] = tx.origin
    branchCharacteristics[7] = msg.value
    branchCharacteristics[8] = BRANCH
    
    #initialize number reporters to 0 so we start at 0 

    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash and characteristics and say, "don't trust me? check"
    branchID = sha256(eventCharacteristics, 9)

    if(!self.Branches[branchID].periodLength and !self.Info[branchID].creator):
        self.Branches[branchID].eventCount = 0
        self.Branches[branchID].marketCount = 0
        self.Branches[branchID].periodLength = periodLength
        
        self.Branches[branchID].parent = parent
        self.Info[branchID].typecode = BRANCH
        self.Info[branchID].description[] = description
        self.Info[branchID].creator = tx.origin
        self.Info[branchID].creationFee = msg.value
        # add this branch to parent subbranch
        self.Branches[parent].subBranches[numbersubBranches] = branchID
        self.Branches[parent].numbersubBranches += 1
        return(1)
    else:
        return(0)
        
def get_cash_balance():
    return(self.cashcoin_balances[tx.origin])
    
def send_cashcoin(recver, value):
    sender = tx.origin
    sender_balance = self.cashcoin_balances[sender]
    if(sender_balance >= value):
        self.cashcoin_balances[sender] -= value
        self.cashcoin_balances[recver] += value
        return(1)
    else:
        return(0)
        
def create_event(branch, description:s, expDate):
    if(self.Info[branch].creator and self.Branches[branch].periodLength and description!=0 and expDate>block.number):
        eventCharacteristics = array(6)
        eventCharacteristics[0] = description
        eventCharacteristics[1] = EVENT
        eventCharacteristics[2] = branch
        eventCharacteristics[3] = expDate
        eventCharacteristics[4] = tx.origin
        eventCharacteristics[5] = msg.value
    
        eventID = sha256(eventCharacteristics, 6)
    else:
        return(0)

    #should be greater than 0.01 bitcoin, using 10 whatevers to test
    if (msg.value >= 10 and !self.Info[eventID].creator and !self.Events[eventID].branch):
        self.Info[eventID].typecode = EVENT
        self.Info[eventID].description[] = description
        self.Info[eventID].creator = tx.origin
        self.Info[eventID].creationFee = msg.value

        self.Events[eventID].branch = branch
        self.Events[eventID].expirationDate = expDate
        
        # add the event to the branch
        # see when it expires, compare that to currentvotingperiod number and last voting period and add it in to the proper spot
        
        # data Branches[](eventsExpDates[](numberEvents, events[])
        
        #403200 is number of blocks == 8 weeks
        # 0 means it expires in the next period
        periodsInFuture = (expDate - self.Branches[branch].lastPeriodEnd) / 403200
        
        currentPeriod = self.Branches[branch].currentVotePeriod
        
        self.Reporting[branch].eventsExpDates[(periodsInFuture+currentPeriod)].events[self.Reporting[branch].eventsExpDates[(periodsInFuture+currentPeriod)].numberEvents] = eventID
        self.Reporting[branch].eventsExpDates[periodsInFuture].numberEvents += 1
        return(1)
    else:
        return(0)

def create_market(branch, description:s, lossLimit, tradingFee, events:a):
    # what happens if number of Events isn't the same length as eventList?
    # market could mature when last event expires/matures
    # shares can't be bought sold except for the redemption tx after expired
    
    # check l log n stuff for liquidity
    if(numberEvents > 200 or funding<(lossLimit*FixedPoint.log(arglen(events), as=fp)) or self.cashcoin_balances[tx.origin]<funding):
        return(0)
    if(!self.Info[branch].creator or !self.Branches[branch].periodLength):
        return(0)

    # formation of marketID (hash)
    marketCharacteristics = array(9)
    marketCharacteristics[0] = branch
    marketCharacteristics[1] = tradingFee
    marketCharacteristics[2] = MARKET
    marketCharacteristics[3] = tx.origin
    # this is just what's provided by market maker, pre event creation fees addition
    marketCharacteristics[4] = msg.value
    marketCharacteristics[5] = lossLimit
        # need to USE PROPER MULTIDIMEN ARRAY SYNTAX HERE!!!
    marketCharacteristics[6] = eventList
    marketCharacteristics[7] = arglen(events)
    marketCharacteristics[8] = description

    marketID = sha256(marketCharacteristics, 9)

    # add event list to the market along with those event fees
    i = 0
    bal = 0
    while i<arglen(events):
        eventID = events[i]
        if(!self.Info[eventID].creator or !self.Events[eventID].expirationDate or self.Events[eventID].branch!=branch):
            return(0)
        bal += self.Info[eventID].creationFee
        # set to 0 now so no one else can spend it
        self.Info[eventID].creationFee = 0
        # initialize market events array with eventIDs from the eventList
        self.Markets[marketID].events[i].eventID = eventID
        # then need to set each respective event's number of share bought to 0
        self.Markets[marketID].events[i].sharesPurchased[0] = 0
        self.Markets[marketID].events[i].sharesPurchased[1] = 0
        i+=1

    # bal now contains event creation fees and the market's funding
    # so event creation fees are essentially added to initial liquidity
    bal += msg.value
    
    # creator of the first market in a branch gets the branch's creation fee
    if(self.Branches[branch].marketCount==0):
        bal += self.Info[branch].creationFee
        # set to 0 now so no one else can spend it
        self.Info[branch].creationFee = 0
        
    self.Info[marketID].typecode = MARKET
    self.Info[marketID].description[] = description
    self.Info[marketID].creator = tx.origin
    # this is all the market's liquidity & fees in one
    self.Info[marketID].creationFee = bal
    
    self.cashcoin_balances[marketID] = bal
    
    self.Markets[marketID].lossLimit = lossLimit
    self.Markets[marketID].tradingFee = tradingFee
    self.Markets[marketID].numberEvents = numberEvents
    self.Markets[marketID].branch = branch

    # add the market to the branch
    marketCount = self.Branches[branch].marketCount
    self.Branches[branch].markets[marketCount] = marketID
    self.Branches[branch].marketCount += 1
    return(1)

# MAKE THIS A MACRO!
def lmsr(shares:a, lossLimit):
    # *** LOGARITHMIC MARKET SCORING RULE ***
    #(like a regular market scoring rule, except it uses logarithms)
    # this need sto be updated with Abe's stuff!
    stop = arglen(shares)
    i = 0
    res = 0
    while i < stop:
        res += FixedPoint.exp(FixedPoint.div(shares[i], lossLimit, as=fp), as=fp)
        i += 1
    logpf = FixedPoint.log(res, as=fp)
    cost = FixedPoint.mul(lossLimit, logpf, as=fp)
    return(cost)

# currently this only works for binary single event outcomes
def buy_shares(branch, event, market, outcome, amount, fee):
    if (block.number >= self.Events[event].expirationDate or fee<self.Markets[market].tradingFee):
        return(0)
    
    # NEED TO DETERMINE HOW TO HANDLE FEES for everything DUE TO NEW LMSR STRUCTURE STUFF after new market maker implemented
    # pay half of trading fee to market creator via sending to market.creator
    # other half goes to votecoin holders! - store in a market fee pool
    self.cashcoin_balances[tx.origin] = self.cashcoin_balances[tx.origin] - fee
    self.cashcoin_balances[self.Info[market].creator] = self.cashcoin_balances[self.Info[market].creator] + fee/2
    # find the right event index
    i = 0
    while (i<self.Markets[market].numberEvents):
        if(self.Markets[market].events[i].eventID == event):
            break
        else:
            i+=1
    if(i==self.Markets[market].numberEvents):
        return(0)
    # for the first trade oldcost shares bought will be at 0
    oldCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[], self.Markets[market].lossLimit)
    # if buying outcome 1
    if outcome:
        self.Markets[market].events[i].sharesPurchased[1] += amount
    # outcome is no
    else:
        self.Markets[market].events[i].sharesPurchased[0] += amount
    
    newCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[], self.Markets[market].lossLimit) 
    pricePerShare = newCost - oldCost

    # send bitcoin from user acc. to event address/account
    self.cashcoin_balances[tx.origin] -= pricePerShare*amount
    self.cashcoin_balances[market] += pricePerShare*amount
    
    participantNumber = self.Markets[market].currentParticipant
    
    # send shares of the event to user address
    if outcome:
        # if user didn't have enough money, revert
        if(self.cashcoin_balances[tx.origin]<amount):
            self.Markets[market].events[i].sharesPurchased[1] -= amount
            #send bitcoin back
            self.cashcoin_balances[market] -= priceToPayPerShare*amount
            self.cashcoin_balances[tx.origin] += priceToPayPerShare*amount
            return(0)
        else:
            self.Markets[market].participants[participantNumber].participantID = tx.origin
            self.Markets[market].participants[participantNumber].event[event].shares[1] += amount
            self.Markets[market].currentParticipant += 1
            return(participantNumber)
    else:
        # if user didn't have enough money, revert
        if(self.cashcoin_balances[tx.origin]<amount):
            self.Markets[market].events[i].sharesPurchased[0] -= amount
            #send bitcoin back
            self.cashcoin_balances[market] -= priceToPayPerShare*amount
            self.cashcoin_balances[tx.origin] += priceToPayPerShare*amount
            return(0)
        else:            
            self.Markets[market].participants[participantNumber].participantID = tx.origin
            self.Markets[market].participants[participantNumber].event[event].shares[0] += amount
            self.Markets[market].currentParticipant += 1
            return(participantNumber)

#amount is amount of shares to buy
def sell_shares(buy, branch, event, market, outcome, amount, fee, participantNumber):
    # When sell check that event hasn't expired
    if (block.number >= self.Events[event].expirationDate or fee<self.Markets[market].tradingFee):
        return(0)
    if(self.Markets[market].participants[participantNumber].participantID != tx.origin):
        return(0)
        
    # NEED TO DETERMINE HOW TO HANDLE FEES for everything DUE TO NEW LMSR STRUCTURE STUFF after new market maker implemented
    # pay half of trading fee to market creator via sending to market.creator
    # other half goes to votecoin holders! - store in a market fee pool
    self.cashcoin_balances[tx.origin] = self.cashcoin_balances[tx.origin] - fee
    self.cashcoin_balances[self.Info[market].creator] = self.cashcoin_balances[self.Info[market].creator] + fee/2
    # find the right event index
    i = 0
    while (i<self.Markets[market].numberEvents):
        if(self.Markets[market].events[i].eventID == event):
            break
        else:
            i+=1
    # for the first trade oldcost shares bought will be at 0
    oldCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[], self.Markets[market].lossLimit)
    
    # send unspent shares from the user to the event
    if outcome:
        self.Markets[market].events[i].sharesPurchased[1] -= amount
    # outcome is no
    else:
        self.Markets[market].events[i].sharesPurchased[0] -= amount
    
    newCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[], self.Markets[market].lossLimit)
    priceToPayPerShare = oldCost - newCost

    # send bitcoin from the market to the user acc.
    self.cashcoin_balances[market] -= priceToPayPerShare*amount
    self.cashcoin_balances[tx.origin] += priceToPayPerShare*amount

    # remove shares from the user's account
    if outcome:
        # if user actually doesn't have the shares, revert
        if(self.Markets[market].participants[participantNumber].event[event].shares[1]<amount):
            self.Markets[market].events[i].sharesPurchased[1] += amount
            #send bitcoin back
            self.cashcoin_balances[market] += priceToPayPerShare*amount
            self.cashcoin_balances[tx.origin] -= priceToPayPerShare*amount
            return(0)
        else:
            self.Markets[market].participants[participantNumber].event[event].shares[1] -= amount
            return(1)
    else:
        # if user actually doesn't have the shares, revert
        if(self.Markets[market].participants[participantNumber].event[event].shares[0]<amount):
            self.Markets[market].events[i].sharesPurchased[0] += amount
            # send bitcoin back
            self.cashcoin_balances[market] += priceToPayPerShare*amount
            self.cashcoin_balances[tx.origin] -= priceToPayPerShare*amount
            return(0)
        else:
            self.Markets[market].participants[participantNumber].event[event].shares[0] -= amount
            return(1)

def queryShareCost():
    return(1)

#check if the eventID is in the current voting period pointed to by the branchID's currentVotePeriod 
def in(branchID, eventID):
    i = 0
    while i < self.Branches[branchID].EventsExpDates[self.Branches[branchID].

#make sure people can change their vote during the voting period
def vote(branchID, report:a):
    # make sure the branch exists
    repIndex = self.Reporting[branch].repIDtoIndex[tx.origin]
    if self.Branches[branchID].lastPeriodEnd == 0:
        return(0)
    if self.Branches[branchID].lastPeriodEnd + self.Branches[branchID].periodLength > block.number:
        return(0)
    if (self.Reporting[branch].reputation[repIndex].reporterID != tx.origin):
        return(0)
    reputation = self.Reporting[branch].reputation[repIndex].repValue

    # first we scale the report by the reputation the voter has
    i = 0
    while i < arglen(report):
        if report[i] > 1:
            return(0) # people should not have votes greater than 1! they need to be in (0, 1)


    # need to update stuff for quorem
    # and store the report and the rep value
    self.Reporting[branchID].eventsExpDates[self.Branches[branchID].currentVotePeriod].reporters[tx.origin] = report
    self.Reporting[branchID].eventsExpDates[self.Branches[branchID].currentVotePeriod].totalRepReported += self.Reporting[branchID].reputation[repIndex].repValue
    return(1)

# returns whether a quorem has a matured event and whether
# the number of required reports are met as a tuple (matured, met)
# MAKE THIS A MACRO!
def check_quorum(branch, eventExpirationBlock):
    if (block.number >= eventExpirationBlock):
        matured = true
    else:
        matured = false
    currentVotePeriod = self.Branches[branchID].currentVotePeriod
    if (self.Reporting[branch].eventsExpDates[currentVotePeriod].totalRepReported >= repRequired):
        met = true
    else:
        met = false
    if(met and matured):
        return(1)
    else:
        return(0)
        
def redeem():
    # add 403200 is number of blocks == 8 weeks to lastperiodend and update it
    # and add 1 to the current vote period
    # check quorem for events we're voting on 
    # perhaps give the redeemer some fees to cover svd costs
    # event must be expired/mature to do svd which could occur in a redeem tx or separately
    # will need to loop through eventid holders in mkt and distribute coins
    # X Bitcoin in market /qi is the price per share once a market is closed
    # remember to give back part of the init. liquidity
    
    
    # loop through reputation and check if in reporters, if so use their report, if not use the fillin / not reported report
    # and get the repvalue from reputation
    # and tx fees
    if(check_quorum):
        # do stuff
        return(1)
    else:
        # woah
        # from 1.0:
        # suicide(addr) - destroys the contract, sending all ether to the given address
        # don't try suicide nobody's worth it, don't try suicide
        suicide(0)
        return(0)
