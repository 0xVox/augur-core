# includes
extern fp:[new, mul, div, intpart, fracpart, log, exp, pow, sqrt]
FixedPoint = create('fixedpoint.se')

BRANCH = 0
EVENT = 1
MARKET = 2

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](typecode, description[], creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# LastPeriodEnd is the last voting period's block number
# Parent is the branch's parent branch.
# Branches' index is the hash of the branch (aka branchID)
# RepRequired is the amount of reputation required to reach quorem
data Branches[](currentVotePeriod, markets[], marketCount, periodLength, lastPeriodEnd, parent, repRequired)

# Events' index is the eventID
data Events[](branch, expirationDate)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
data Reporting[](eventsExpDates[](numberEvents, events[], totalRepReported, reporters[]), reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market
# Sharespurchased keeps track of the number of shares purchased for each outcome
# Participants is a 0 indexed array of participants, their cashIDs, and the shares in each outcome they've purchased of an event
data Markets[](branch, events[](eventID, sharesPurchased[2]), participants[](participantID, event[](shares[2])), lossLimit, tradingFee, numberEvents, currentParticipant)

data cashcoin_balances[2^160]

data repRequired = 447

def init():
    # test initial funds
    cashcoin_balances[0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826] = 1000000
    self.Reporting[1010101].repIDtoIndex[42] = 0                     # a string index will break given how serpent currently does strings; I'll (Vitalik) probably
                                                                     # update serpent to make strings eval to integers again in normal
                                                                     # cases, and add a specific "long string" mechanism, eg.
                                                                     # text("1284721864982164124124asfbqiuwfuqwfuq2fu12bufb12ufb12t")
    self.Reporting[1010101].reputation[0].repValue = 47
    self.Reporting[1010101].reputation[0].reporterID = 42
    # number of reporters is 0 indexed
    self.Reporting[1010101].numberReporters = 0
    self.Info[1010101].typecode = 0
    self.Info[1010101].description[] = "initial branch"
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Branches[1010101].currentVotePeriod = 0
    self.Branches[1010101].marketCount = 0
    self.Branches[1010101].periodLength = 403200
    self.Branches[1010101].lastPeriodEnd = block.number
    self.Branches[1010101].parent = 0
    self.Branches[1010101].repRequired = 14000000


### Version 2.0:
    # blockchain explorer to get / examine data or make rpc api calls to the contract to get it
    # check for branch collisions
    # local contract calls don't cost gas
    # Scalar event where people update what type of share they bought using a thing
    # in an array where index is their scalar x and value
    # is the share updated number of shares bought
    # how do we make this code updatable
    # how do we scale / what if a ton of events, markets, etc.
    # api voting option
    # seigniorage
    # if current vote period is == 0 then we looped past 2^256 --- set values in array to 0 at that point
    # may need a ballot max size b/c cost so need a systematic way to do voting (e.g. vote on first xxx events, then next set are another ballot)
    # randomized voter selection hmmm? - first x events expiring vote on in one ballot - random selection, then another ballot
    # new market maker
    # vote encryption
    # ica
    # market auditing

### To do:
    # make sure this follows paul's whitepaper well
    # contract should send msg.values around, not cashcoin -- i'll (joey) fix this
    # what if people pass functions incorrect values, need to detect that junk and return 0
    # fast voting cycle first few days to get the 60% problem away from a branch, e.g. what if not enough people vote 60% of votes -- need to get the cycle length parameters right
    # we had planned allowing people to send coins selectively to branches
    # polish functions to be completely consistent w/ data structure additions
    # make period length a var
    # branching the way whitepaper does it (distribute rep to the holders from first branch)

### Urgent todo:
    # add multiple events into markets buy / sell feature
    # voting consensus & redeem tx

### Actual code begins

def get_cash_balance():
    return(self.cashcoin_balances[tx.origin])

# we should have the UI check that the receiver add. is valid 
# ^^^ nah, let people send money to bad addresses if they want, so they can do proof of burn! ~chris
def send_cashcoin(recver, value):
    sender = tx.origin
    sender_balance = self.cashcoin_balances[sender]
    if(sender_balance >= value):
        self.cashcoin_balances[sender] -= value
        self.cashcoin_balances[recver] += value
        return(1)
    else:
        return(0)

def send_reputation(recver, value, branch):
    if(self.send_cashcoin(branch, 10)):
        sender = tx.origin
        senderIndex = self.Reporting[branch].repIDtoIndex[sender]
        receiverIndex = self.Reporting[branch].repIDtoIndex[recver]
        # if the sender's rep. account doesn't exist, make one
        if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
                self.Reporting[branch].numberReporters += 1
                reporterIndex = self.Reporting[branch].numberReporters
                self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
                self.Reporting[branch].reputation[reporterIndex].repValue = 0
                self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
                return("Your reputation account was just created, earn some rep. before you can send to others")
                
        if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
            return("Receiving address doesn't exist")
            
        sender_balance = self.Reporting[branch].reputation[senderIndex].repValue
        if(sender_balance >= value):
            self.Reporting[branch].reputation[senderIndex].repValue -= value
            self.Reporting[branch].reputation[receiverIndex].repValue += value
            return(1)
        else:
            return(0)
    else:
        return(0)
        
def get_rep_balance(branch, address):
    return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)
    
def send_rep_diffbranch(recver, value, oldBranch, newBranch):
        # check branch is a subbranch
        tempID = Branches[newBranch].parent
        while tempID != oldBranch and tempID != 0 and Branches[tempID].periodLength != 0:
            tempID = Branches[tempID].parent
                
        if tempID != oldBranch:
            return(0)
        if(self.send_cashcoin(branch, 10)):
            # if no branch exists (defined as a nonzero period)
            if(!self.Branches[oldBranch].periodLength | !self.Branches[newBranch].periodLength | value<=0):
                return(0)
            sender = tx.origin
            senderIndex = self.Reporting[oldBranch].repIDtoIndex[sender]
            receiverIndex = self.Reporting[newBranch].repIDtoIndex[recver]
            # if the sender's rep. account doesn't exist, make one
            if(self.Reporting[oldBranch].reputation[senderIndex].reporterID!=tx.origin):
                    self.Reporting[oldBranch].numberReporters += 1
                    reporterIndex = self.Reporting[oldBranch].numberReporters
                    self.Reporting[oldBranch].repIDtoIndex[tx.origin] = reporterIndex
                    self.Reporting[oldBranch].reputation[reporterIndex].repValue = 0
                    self.Reporting[oldBranch].reputation[reporterIndex].reporterID = tx.origin
                    return("Your reputation account was just created, earn some rep. before you can send to others")
        
            if(self.Reporting[newBranch].reputation[receiverIndex].reporterID!=recver):
                self.Reporting[newBranch].numberReporters += 1
                reporterIndex = self.Reporting[newBranch].numberReporters
                self.Reporting[newBranch].repIDtoIndex[tx.origin] = reporterIndex
                self.Reporting[newBranch].reputation[reporterIndex].repValue = 0
                self.Reporting[newBranch].reputation[reporterIndex].reporterID = recver
                return("Receiving address doesn't exist on sub branch, just made one on it")
                
            else:
                sender_balance = self.Reporting[oldBranch].reputation[senderIndex].repValue
                if(sender_balance >= value):
                    self.Reporting[oldBranch].reputation[senderIndex].repValue -= value
                    self.Reporting[newBranch].reputation[receiverIndex].repValue += value
                    return(1)
                else:
                    return(0)
        else:
            return(0)

# period length is given in blocks
def make_subbranch(branchName:s, description:s, periodLength, parent, repRequired):
    # add current vote period initializations, etc to this creation as well as last period end
    branchCharacteristics = array(9)
    branchCharacteristics[0] = branchName
    branchCharacteristics[1] = description
    branchCharacteristics[2] = periodLength
    branchCharacteristics[3] = parent
    branchCharacteristics[4] = repRequired
    branchCharacteristics[5] = periodLength
    branchCharacteristics[6] = tx.origin
    branchCharacteristics[7] = msg.value
    branchCharacteristics[8] = BRANCH
    branchCharacteristics[9] = 


    # initialize number reporters to 0 so we start at 0 
    # make period length as long as not 0

    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash and characteristics and say, "don't trust me? check"
    branchID = sha256(eventCharacteristics, 9)

    if(self.send_cashcoin(branchID, 47):
        if(!self.Branches[branchID].periodLength and !self.Info[branchID].creator):
            self.Branches[branchID].eventCount = 0
            self.Branches[branchID].marketCount = 0
            self.Branches[branchID].periodLength = periodLength
            self.Branches[branchID].currentVotePeriod = 0
            self.Branches[branchID].lastPeriodEnd = block.number
            self.Branches[branchID].repRequired = repRequired
            self.Branches[branchID].parent = parent
            
            self.Info[branchID].typecode = BRANCH
            self.Info[branchID].description[] = description
            self.Info[branchID].creator = tx.origin
            self.Info[branchID].creationFee = msg.value
            return(1)
        else:
            return(0)
    else:
        return(0)
        
def create_event(branch, description:s, expDate, fee):
     # give fee to first market to be created on new branch
    if(self.Info[branch].creator and self.Branches[branch].periodLength and description!=0 and expDate>block.number):
        eventCharacteristics = array(6)
        eventCharacteristics[0] = description
        eventCharacteristics[1] = EVENT
        eventCharacteristics[2] = branch
        eventCharacteristics[3] = expDate
        eventCharacteristics[4] = tx.origin
        eventCharacteristics[5] = fee
    
        eventID = sha256(eventCharacteristics, 6)
    else:
        return(0)

    #should be greater than 0.01 cashcoins, using 10 whatevers to test
    if (self.cashcoin_balance[tx.origin] >= 10 and !self.Info[eventID].creator and !self.Events[eventID].branch):
        self.Info[eventID].typecode = EVENT
        self.Info[eventID].description[] = description
        self.Info[eventID].creator = tx.origin
        self.Info[eventID].creationFee = msg.value

        self.Events[eventID].branch = branch
        self.Events[eventID].expirationDate = expDate
        
        # add the event to the branch
        # see when it expires, compare that to currentvotingperiod number and last voting period and add it in to the proper spot
        
        # data Branches[](eventsExpDates[](numberEvents, events[])
        
        #403200 is number of blocks == 8 weeks
        # 0 means it expires in the next period
        periodsInFuture = (expDate - self.Branches[branch].lastPeriodEnd) / 403200
        
        currentPeriod = self.Branches[branch].currentVotePeriod
        
        self.Reporting[branch].eventsExpDates[(periodsInFuture+currentPeriod)].events[self.Reporting[branch].eventsExpDates[(periodsInFuture+currentPeriod)].numberEvents] = eventID
        self.Reporting[branch].eventsExpDates[periodsInFuture].numberEvents += 1
        return(1)
    else:
        return(0)

def create_market(branch, description:s, lossLimit, tradingFee, events:a):
    # what happens if number of Events isn't the same length as eventList?
    # market could mature when last event expires/matures
    # shares can't be bought sold except for the redemption tx after expired
    
    # check l log n stuff for liquidity
    if(numberEvents > 200 or funding<(lossLimit*FixedPoint.log(arglen(events), as=fp)) or self.cashcoin_balances[tx.origin]<funding):
        return(0)
    if(!self.Info[branch].creator or !self.Branches[branch].periodLength):
        return(0)

    # formation of marketID (hash)
    marketCharacteristics = array(9)
    marketCharacteristics[0] = branch
    marketCharacteristics[1] = tradingFee
    marketCharacteristics[2] = MARKET
    marketCharacteristics[3] = tx.origin
    # this is just what's provided by market maker, pre event creation fees addition
    marketCharacteristics[4] = msg.value
    marketCharacteristics[5] = lossLimit
        # need to USE PROPER MULTIDIMEN ARRAY SYNTAX HERE!!!
    marketCharacteristics[6] = eventList
    marketCharacteristics[7] = arglen(events)
    marketCharacteristics[8] = description

    marketID = sha256(marketCharacteristics, 9)

    # add event list to the market along with those event fees
    i = 0
    bal = 0
    while i<arglen(events):
        eventID = events[i]
        if(!self.Info[eventID].creator or !self.Events[eventID].expirationDate or self.Events[eventID].branch!=branch):
            return(0)
        bal += self.Info[eventID].creationFee
        # set to 0 now so no one else can spend it
        self.Info[eventID].creationFee = 0
        # initialize market events array with eventIDs from the eventList
        self.Markets[marketID].events[i].eventID = eventID
        # then need to set each respective event's number of share bought to 0
        self.Markets[marketID].events[i].sharesPurchased[0] = 0
        self.Markets[marketID].events[i].sharesPurchased[1] = 0
        i+=1

    # bal now contains event creation fees and the market's funding
    # so event creation fees are essentially added to initial liquidity
    bal += msg.value
    
    # creator of the first market in a branch gets the branch's creation fee
    if(self.Branches[branch].marketCount==0):
        bal += self.Info[branch].creationFee
        # set to 0 now so no one else can spend it
        self.Info[branch].creationFee = 0
        
    self.Info[marketID].typecode = MARKET
    self.Info[marketID].description[] = description
    self.Info[marketID].creator = tx.origin
    # this is all the market's liquidity & fees in one
    self.Info[marketID].creationFee = bal
    
    self.cashcoin_balances[marketID] = bal
    
    self.Markets[marketID].lossLimit = lossLimit
    self.Markets[marketID].tradingFee = tradingFee
    self.Markets[marketID].numberEvents = numberEvents
    self.Markets[marketID].branch = branch

    # add the market to the branch
    marketCount = self.Branches[branch].marketCount
    self.Branches[branch].markets[marketCount] = marketID
    self.Branches[branch].marketCount += 1
    return(1)

def lmsr(shares:a, lossLimit):
    # *** LOGARITHMIC MARKET SCORING RULE ***
    #(like a regular market scoring rule, except it uses logarithms)
    # this need sto be updated with Abe's stuff!
    stop = arglen(shares)
    i = 0
    res = 0
    while i < stop:
        res += FixedPoint.exp(FixedPoint.div(shares[i], lossLimit, as=fp), as=fp)
        i += 1
    logpf = FixedPoint.log(res, as=fp)
    cost = FixedPoint.mul(lossLimit, logpf, as=fp)
    return(cost)

# currently this only works for binary single event outcomes
def buy_shares(branch, event, market, outcome, amount, fee):
    if (block.number >= self.Events[event].expirationDate or fee<self.Markets[market].tradingFee):
        return(0)
    
    # NEED TO DETERMINE HOW TO HANDLE FEES for everything DUE TO NEW LMSR STRUCTURE STUFF after new market maker implemented
    # pay half of trading fee to market creator via sending to market.creator
    # other half goes to votecoin holders! - store in a market fee pool
    self.cashcoin_balances[tx.origin] = self.cashcoin_balances[tx.origin] - fee
    self.cashcoin_balances[self.Info[market].creator] = self.cashcoin_balances[self.Info[market].creator] + fee/2
    # find the right event index
    i = 0
    while (i<self.Markets[market].numberEvents):
        if(self.Markets[market].events[i].eventID == event):
            break
        else:
            i+=1
    if(i==self.Markets[market].numberEvents):
        return(0)
    # for the first trade oldcost shares bought will be at 0
    oldCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[], self.Markets[market].lossLimit)
    # if buying outcome 1
    if outcome:
        self.Markets[market].events[i].sharesPurchased[1] += amount
    # outcome is no
    else:
        self.Markets[market].events[i].sharesPurchased[0] += amount
    
    newCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[], self.Markets[market].lossLimit) 
    pricePerShare = newCost - oldCost

    # send ether from user acc. to event address/account
    self.cashcoin_balances[tx.origin] -= pricePerShare*amount
    self.cashcoin_balances[market] += pricePerShare*amount
    
    participantNumber = self.Markets[market].currentParticipant
    
    # send shares of the event to user address
    if outcome:
        # if user didn't have enough money, revert
        if(self.cashcoin_balances[tx.origin]<amount):
            self.Markets[market].events[i].sharesPurchased[1] -= amount
            #send bitcoin back
            self.cashcoin_balances[market] -= priceToPayPerShare*amount
            self.cashcoin_balances[tx.origin] += priceToPayPerShare*amount
            return(0)
        else:
            self.Markets[market].participants[participantNumber].participantID = tx.origin
            self.Markets[market].participants[participantNumber].event[event].shares[1] += amount
            self.Markets[market].currentParticipant += 1
            return(participantNumber)
    else:
        # if user didn't have enough money, revert
        if(self.cashcoin_balances[tx.origin]<amount):
            self.Markets[market].events[i].sharesPurchased[0] -= amount
            #send bitcoin back
            self.cashcoin_balances[market] -= priceToPayPerShare*amount
            self.cashcoin_balances[tx.origin] += priceToPayPerShare*amount
            return(0)
        else:            
            self.Markets[market].participants[participantNumber].participantID = tx.origin
            self.Markets[market].participants[participantNumber].event[event].shares[0] += amount
            self.Markets[market].currentParticipant += 1
            return(participantNumber)

#amount is amount of shares to buy
# instead of inputting particip. num could just loop through array if dont have it
def sell_shares(buy, branch, event, market, outcome, amount, fee, participantNumber):
    # When sell check that event hasn't expired
    if (block.number >= self.Events[event].expirationDate or fee<self.Markets[market].tradingFee):
        return(0)
    if (self.Markets[market].participants[participantNumber].participantID != tx.origin):
        return(0)
        
    # NEED TO DETERMINE HOW TO HANDLE FEES for everything DUE TO NEW LMSR STRUCTURE STUFF after new market maker implemented
    # pay half of trading fee to market creator via sending to market.creator
    # other half goes to votecoin holders! - store in a market fee pool
    self.cashcoin_balances[tx.origin] = self.cashcoin_balances[tx.origin] - fee
    self.cashcoin_balances[self.Info[market].creator] = self.cashcoin_balances[self.Info[market].creator] + fee/2
    # find the right event index
    i = 0
    while (i<self.Markets[market].numberEvents):
        if(self.Markets[market].events[i].eventID == event):
            break
        else:
            i+=1
    # for the first trade oldcost shares bought will be at 0
    oldCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[], self.Markets[market].lossLimit)
    
    # send unspent shares from the user to the event
    if outcome:
        self.Markets[market].events[i].sharesPurchased[1] -= amount
    # outcome is no
    else:
        self.Markets[market].events[i].sharesPurchased[0] -= amount
    
    newCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[], self.Markets[market].lossLimit)
    priceToPayPerShare = oldCost - newCost

    # send bitcoin from the market to the user acc.
    self.cashcoin_balances[market] -= priceToPayPerShare*amount
    self.cashcoin_balances[tx.origin] += priceToPayPerShare*amount

    # remove shares from the user's account
    if outcome:
        # if user actually doesn't have the shares, revert
        if(self.Markets[market].participants[participantNumber].event[event].shares[1]<amount):
            self.Markets[market].events[i].sharesPurchased[1] += amount
            #send bitcoin back
            self.cashcoin_balances[market] += priceToPayPerShare*amount
            self.cashcoin_balances[tx.origin] -= priceToPayPerShare*amount
            return(0)
        else:
            self.Markets[market].participants[participantNumber].event[event].shares[1] -= amount
            return(1)
    else:
        # if user actually doesn't have the shares, revert
        if(self.Markets[market].participants[participantNumber].event[event].shares[0]<amount):
            self.Markets[market].events[i].sharesPurchased[0] += amount
            # send bitcoin back
            self.cashcoin_balances[market] += priceToPayPerShare*amount
            self.cashcoin_balances[tx.origin] -= priceToPayPerShare*amount
            return(0)
        else:
            self.Markets[market].participants[participantNumber].event[event].shares[0] -= amount
            return(1)

def queryShareCost():
    return(1)

#check if the eventID is in the current voting period pointed to by the branchID's currentVotePeriod 
def in(branchID, eventID):
    i = 0
    while i < self.Branches[branchID].EventsExpDates[self.Branches[branchID].

#make sure people can change their vote during the voting period
def send_report(branchID, report:a):
    # make sure the branch exists
    repIndex = self.Reporting[branch].repIDtoIndex[tx.origin]
    if self.Branches[branchID].lastPeriodEnd == 0:
        return(0)
    # check if voting period not over
    if self.Branches[branchID].lastPeriodEnd + self.Branches[branchID].periodLength > block.number:
        return(0)
    if (self.Reporting[branch].reputation[repIndex].reporterID != tx.origin):
        return(0)
    reputation = self.Reporting[branch].reputation[repIndex].repValue

    # first we scale the report by the reputation the voter has
    i = 0
    while i < arglen(report):
        if report[i] > 1:
            return(0) # people should not have votes greater than 1! they need to be in (0, 1)
        else:
            # CHECK IF IN CUR VOTING PERIOD


    # need to update stuff for quorem
    # and store the report and the rep value
    self.Reporting[branchID].eventsExpDates[self.Branches[branchID].currentVotePeriod].reporters[tx.origin] = report
    self.Reporting[branchID].eventsExpDates[self.Branches[branchID].currentVotePeriod].totalRepReported += self.Reporting[branchID].reputation[repIndex].repValue
    return(1)

# returns whether a quorem has a matured event and whether
# the number of required reports are met as a tuple (matured, met)
# MAKE THIS A MACRO!
def check_quorum(branch, eventExpirationBlock):
    if (block.number >= eventExpirationBlock):
        matured = true
    else:
        matured = false
    currentVotePeriod = self.Branches[branchID].currentVotePeriod
    # what is rep required?
    if (self.Reporting[branch].eventsExpDates[currentVotePeriod].totalRepReported >= repRequired):
        met = true
    else:
        met = false
    if(met and matured):
        return(1)
    else:
        return(0)
        
def redeem():
    # add 403200 is number of blocks == 8 weeks to lastperiodend and update it
    # and add 1 to the current vote period
    # check quorem for events we're voting on 
    # perhaps give the redeemer some fees to cover svd costs
    # event must be expired/mature to do svd which could occur in a redeem tx or separately
    # will need to loop through eventid holders in mkt and distribute coins
    # X Bitcoin in market /qi is the price per share once a market is closed
    # remember to give back part of the init. liquidity
    
    # also give back creation fees paid by anything inc. branch creators in rbcr to the cash addresses
    # held by rep. holders

    # loop through reputation and check if in reporters, if so use their report, if not use the fillin / not reported report
    # and get the repvalue from reputation
    # and tx fees
    if(check_quorum):
        # do stuff
        return(1)
    else:
        # woah
        # from 1.0:
        # suicide(addr) - destroys the contract, sending all ether to the given address
        # don't try suicide nobody's worth it, don't try suicide
        suicide(0)
        return(0)
