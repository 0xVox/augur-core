# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C)  2014 Chris Calderon, Joey Krug, Alan Lu, Jack Peterson
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joeykrug@gmail.com

BRANCH = 0
EVENT = 1
MARKET = 2

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](description[2048], descriptionLength, creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the current vote period (should always be 1 behind block.number/periodlength or current EventsExpDates index)
data Branches[](currentVotePeriod, periodLength, step)

# Events' index is the eventID
# a binary outcome has 0 for min && 1 for max value (ditto for categorical even though not actually true) - a no is 1, yes is 2
# this is just for events array we do 0 and 1
# S&P 500 would be say 0 && 4700, respectively
# should min and max be fxp?
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an  event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
# v_size = numReports * numEvents
# reportsFilled, reportsMask, weightedCenteredData, loadingVector, scores, set1, set2, old,
# new1, new2, adjPrinComp, smoothRep, outcomesFinal, consensusReward is all consensus data
data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# [branchID][votingPeriod]
data EventsExpDates[][](numberEvents, events[], totalRepReported, reporters[][], vSize, reportsFilled[], reportsMask[], weightedCenteredData[], loadingVector[], scores[], set1[], set2[], old[], new1[], new2[], adjPrinComp[], smoothRep[], outcomesFinal[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market in the format of
    # [1, event, event, 2, event, 3, event, event, event]
    # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
# Sharespurchased keeps track of the number of shares purchased for each outcome
    # sharesPurchased states starts at 1 - (same for participants[].shares[] array)
# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event
# a binary outcome state 1 is no, 2 is true, 0 if not determined
# tradingFee is a percent in fixedPoint
# tradingPeriod is which 
data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], alpha, cumulativeScale, numOutcomes, tradingPeriod, tradingFee)

data p2pBets[](eventID, amtToBet, outcomeOneBettor, outcomeZeroBettor)

data cashcoinBalances[]

# 0th item in branchesList is the length of the branch list
data branchesList[]

def init():
    # test initial funds
    self.cashcoinBalances[tx.origin] = 1000000*2^64
    self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
    self.Reporting[1010101].reputation[0].repValue = 470*2^64
    self.Reporting[1010101].reputation[0].reporterID = tx.origin
    self.Reporting[1010101].numberReporters = 1
    self.Info[1010101].description[] = "initial branch"
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Branches[1010101].currentVotePeriod = (block.number / 403200) - 1 
    self.Branches[1010101].periodLength = 403200
    self.branchesList[0] = 2
    self.branchesList[1] = 1010101

# string chunks
macro chunks($l):
    $l + if(l%32 != 0, 1, 0)

def balance(address):
    return(self.cashcoinBalances[address])

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
def send(recver, value):
    sender = tx.origin
    senderBalance = self.cashcoinBalances[sender]
    if(senderBalance >= value):
        self.cashcoinBalances[sender] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

def faucet():
    sender = tx.origin
    self.cashcoinBalances[sender] = 10000*2^64
    return(1)

def sendFrom(recver, value, from):
    if(from!=tx.origin):
        return(0)
    senderBalance = self.cashcoinBalances[from]
    if(senderBalance >= value):
        self.cashcoinBalances[from] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

def sendReputation(branch, recver, value):
    if(value<=0 || !self.send(branch, 5*2^64)):
        return(0)
    sender = tx.origin
    senderIndex = self.Reporting[branch].repIDtoIndex[sender]
    receiverIndex = self.Reporting[branch].repIDtoIndex[recver]
    # if the sender's rep. account doesn't exist, make one
    if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
        reporterIndex = self.Reporting[branch].numberReporters
        self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
        self.Reporting[branch].reputation[reporterIndex].repValue = 0
        self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
        self.Reporting[branch].numberReporters += 1
        return(text("Your reputation account was just created, earn some rep. before you can send to others"): str)

    if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
        return(text("Receiving address doesn't exist"): str)
        
    senderBalance = self.Reporting[branch].reputation[senderIndex].repValue
    if(senderBalance >= value):
        self.Reporting[branch].reputation[senderIndex].repValue -= value
        self.Reporting[branch].reputation[receiverIndex].repValue += value
        return(value)
    else:
        return(0)
        
def getRepBalance(branch, address):
    return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)

# period length is given in blocks
# description format is branchName:description
# is there some way we can include the description bytes in the sha256 hash?
def makeSubBranch(description:str, periodLength, parent):
    if(periodLength<=0 || !self.Branches[parent].periodLength || description==0):
        return(0)
    branchInfo = string((items=6)+len(description))
    branchInfo[0] = BRANCH                                      #typecode
    branchInfo[1] = tx.origin                                   #creator address
    branchInfo[2] = 47*2^64                                     #creation fee
    branchInfo[3] = periodLength                                #length of voting cycle
    branchInfo[4] = block.number                                #current block number
    branchInfo[5] = parent                                      #branchID of parent branch
    mcopy(branchInfo+(items=6), description, len(description))
    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash && characteristics && say, "don't trust me? check"
    branchID = sha256(branchinfo, chars=len(branchInfo))

    if(self.Branches[parent].periodLength && self.Info[parent].creator && self.send(parent, 47*2^64) && self.Branches[branchID].periodLength==0):
        self.Info[branchID].creator = tx.origin
        self.Info[branchID].creationFee = 47*2^64
        self.Info[branchID].descriptionLength = len(description)
        save(self.Info[branchID].description[0], description, chars=len(description))
        self.Branches[branchID].periodLength = periodLength
        # first vote period won't be until after the current (in this case first) basket of things has expired
        # if floor(blockNum / periodLength) is say 5 and eventsExpDates[5]
        # the current vote period should be on things from eventsExpDates 4 (when making a new branch this vote period will just fail quorem, and current vote period will be incrememented)
        # then once blockNum / periodLength is say 6 and eventsExpDates[6]
        # votePeriod 4 should close and the currentVotePeriod should be from
        # eventsExpDates 5 (anyone can call the consensus function for voteperiod 4 at this point)
        self.Branches[branchID].currentVotePeriod = (block.number / periodLength) - 1
        i = 0
        while i < self.Reporting[parent].numberReporters:
            self.Reporting[branchID].reputation[i].reporterID = self.Reporting[parent].reputation[i].reporterID
            self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
            i+=1
        self.Reporting[branchID].numberReporters = i
        self.branchesList[self.branchesList[0]] = branchID
        self.branchesList[0] += 1
        return(branchID)
    else:
        return(0)

# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0
# to 11.0 would be 11 outcomes (if incremented by 0.1)
# need to make sure these values are ok
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes):
    if(self.Branches[branch].periodLength && description!=0 && expDate>block.number):
        eventinfo = string((items=8)+len(description))
        eventinfo[0] = EVENT                                        #typecode
        eventinfo[1] = branch                                       #branchID
        eventinfo[2] = expDate                                      #expiration date
        eventinfo[3] = tx.origin                                    #creator address
        eventinfo[4] = 42*2^64                                      #creation fee
        eventinfo[5] = minValue                                     #minimum outcome value
        eventinfo[6] = maxValue                                     #maximum outcome value
        eventinfo[7] = numOutcomes                                  #number of outcomes
        mcopy(eventinfo+(items=8), description, len(description))
        eventID = sha256(eventinfo, chars=len(eventinfo))
    else:
        return(0)

    # can't have a scalar && categorical event in one
    # you can make a market like that though!
    if(numOutcomes!=2 && maxValue!=1):
        return(0)

    # fee to ask a question rises if voter participation (rep reported) falls, if it's really high, the fee is lowered (participationFactor is a fixedpoint number)
    participationFactor = (self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod-2].totalRepReported * 2^64) / self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod-1].totalRepReported
    if(participationFactor==0):
        participationFactor = 1
    # send fee and bond
    if(self.balance(tx.origin)>=87*2^64):
        if (!self.Info[eventID].creator && !self.Events[eventID].branch && self.send(eventID, 42*2^64) && self.send(branch, participationFactor*45)):
            self.Info[eventID].creator = tx.origin
            self.Info[eventID].creationFee = participationFactor*45 # this is not the bond
            self.Info[eventID].descriptionLength = len(description)
            save(self.Info[eventID].description[0], description, chars=len(description))
            self.Events[eventID].branch = branch
            self.Events[eventID].expirationDate = expDate
            self.Events[eventID].minValue = minValue
            self.Events[eventID].maxValue = maxValue
            self.Events[eventID].numOutcomes = numOutcomes
            # see which future period it expires in && put the event in that bin
            # event voting periods - expDate / periodLength gives you the voting period #
            futurePeriod = (expDate / self.Branches[branch].periodLength)
            self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID
            self.EventsExpDates[branch][futurePeriod].numberEvents += 1
            return(eventID)
        else:
            return(0)

# alpha is equal to v/(n*log(n)) where v is the max percent commission
# && n is the number of outcomes people can trade. Alpha is set when
# a market is created.
macro lsLmsr($marketID):
    with $q = load(self.Markets[$marketID].sharesPurchased[1], items=self.Markets[$marketID].numOutcomes):
        with $alpha = self.Markets[$marketID].alpha:
            with $cumScale = self.Markets[$marketID].cumulativeScale:
                with $Bq = $alpha*$cumScale*sum($q):
                    with $i = 0:
                        with $len = len($q):
                            with $sumexp = 0:
                                while $i < $len:
                                    $sumexp += fxp_exp($q[$i]*2^64/$Bq)
                                    $i += 1
                                $Bq*fxp_log($sumExp)/2^64

# alpha is a fixedpoint number / calc. it in UI
# z is the optimal initial vector for each outcome
# z = liquidity / (1+(alpha*n*ln(n)))
# initialLiquidity is initial number of shares of each outcome you want to buy/initialize/set
# tradingFee is a percent in fixedPoint
# same for these values
def createMarket(branch, description:str, alpha, initialLiquidity, tradingFee, events:arr):
    if(self.Branches[branch].periodLength==0 or len(description)==0 or initialLiquidity==0 || alpha <= 2^57 || tradingFee <= 2^64):
        return(0)
    # check that events have same exp. dates && branch
    i = 0
    eventNum = len(events)
    # only supports 3 dimensional markets atm
    if(eventNum > 3):
        return(0)
    numOutcomes = 0
    eventsConcat = 0
    cumulativeScale = 0
    tradingPeriod = 0
    while i < eventNum:
        event = events[i]
        if(self.Events[event].expirationDate > tradingPeriod):
            tradingPeriod = self.Events[event].expirationDate
        eventsConcat += event
        if (self.Events[event].branch != branch || !self.Info[event].creator):
            return(0)
        #scalars
        if(self.Events[event].maxValue!=1):
            # not a scalar but also not categorical or binary - invalid event
            if(self.Events[event].numOutcomes!=2):
                return(0)
            # is a valid scalar
            cumulativeScale += self.Events[event].maxValue - self.Events[event].minValue
        if(i==0):
            numOutcomes += self.Events[event].numOutcomes
        else:
            numOutcomes *= self.Events[event].numOutcomes
        i += 1
    if(numOutcomes > 200):
        return(0)
    if(cumulativeScale==0):
        cumulativeScale = 1
    tradingPeriod = (tradingPeriod / self.Branches[branch].periodLength)
    # formation of marketID (hash)
    marketinfo = string((items=11)+len(description))
    marketinfo[0] = MARKET
    marketinfo[1] = tx.origin
    marketinfo[2] = initialLiquidity
    marketinfo[3] = branch
    marketinfo[4] = eventsConcat
    marketinfo[5] = len(events)
    marketinfo[6] = cumulativeScale
    marketinfo[7] = alpha
    marketinfo[8] = numOutcomes
    marketinfo[9] = tradingPeriod
    marketinfo[10] = tradingFee
    mcopy(marketinfo+(items=11), description, chars=len(description))
    marketID = sha256(marketinfo, chars=len(marketinfo))

    # pay numOutcomes fee
    # if it's already been created return 0
    if(!self.send(branch, numOutcomes*2^63) || self.Info[marketID].creator || self.Markets[marketID].numOutcomes):
        return(0)

    # buy some of all outcomes
    # ls-lmsr needs at least a very small initial liquidity
    y = 1
    while y <= numOutcomes:
        self.Markets[marketID].sharesPurchased[y] += initialLiquidity
        y += 1
    self.Markets[marketID].alpha = alpha
    self.Markets[marketID].cumulativeScale = cumulativeScale
    self.Markets[marketID].numOutcomes = numOutcomes
    cost = lsLmsr(marketID)
    if(self.send(marketID, cost)):
        # add event list to the market
        save(self.Markets[marketID].events[0], events, items=eventNum)
        self.Info[marketID].creator = tx.origin
        self.Info[marketID].creationFee = initialLiquidity
        self.Info[marketID].descriptionLength = len(description)
        save(self.Info[marketID].description[0], description, chars=len(description))
        self.Markets[marketID].alpha = alpha
        self.Markets[marketID].lenEvents = len(events)
        self.Markets[marketID].cumulativeScale = cumulativeScale
        self.Markets[marketID].numOutcomes = numOutcomes
        self.Markets[marketID].tradingPeriod = tradingPeriod
        self.Markets[marketID].tradingFee = tradingFee
        return(marketID)
    else:
        # revert shares bought and other variables
        y = 1
        while y <= numOutcomes:
            self.Markets[marketID].sharesPurchased[y] -= initialLiquidity
        self.Markets[marketID].alpha = 0
        self.Markets[marketID].cumulativeScale = 0
        self.Markets[marketID].numOutcomes = 0
        return(0)

# amount of shares should be an integer
def buyShares(branch, market, outcome, amount):
    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)
    if (outcome==0 || self.Branches[branch].currentVotePeriod>=self.Markets[market].tradingPeriod):
        return(0)
    # lmsr cost calcs
    oldCost = lsLmsr(market)
    self.Markets[market].sharesPurchased[outcome] += amount
    newCost = lsLmsr(market)

    # these prices are in fixed point
    price = (newCost - oldCost)
    
    if self.cashcoinBalances[tx.origin] < (price + 2^64)*self.Markets[market].tradingFee/2^64:
        self.Markets[market].sharesPurchased[outcome] -= amount
        return(0)

    participantNumber = self.Markets[market].addr2participant[tx.origin]
    if tx.origin != self.Markets[market].participants[participantNumber].participantID:
        participantNumber = self.Markets[market].currentParticipant
        self.Markets[market].currentParticipant += 1
        
    # send shares of the event to user address
    # if user doesn't have enough money, revert
    # send money from user acc. to market address/account
    # cost for shares
    self.send(market, price)
    # half of fees to market creator
    fee = self.Markets[market].tradingFee*price/2^64
    self.send(self.Info[market].creator, fee/2)
    # other half go to branch
    self.send(branch, fee/2)

    return(participantNumber)

# amount is amount of shares to buy
# instead of inputting particip. num could just loop through array if dont have it
def sellShares(branch, market, outcome, amount, participantNumber):
    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)
    if (self.Markets[market].participants[participantNumber].participantID != tx.origin || outcome==0 || self.Branches[branch].currentVotePeriod>=self.Markets[marketID].tradingPeriod):
        return(0)
    # lmsr cost calcs
    oldCost = lsLmsr(market)
    self.Markets[market].sharesPurchased[outcome] -= amount
    newCost = lsLmsr(market)

    # these prices are in fixed point
    pricePerShare = oldCost - newCost
    participantNumber = self.Markets[market].currentParticipant

    # remove shares from the user's account
    # if user actually doesn't have the shares, revert
    if(self.Markets[market].participants[participantNumber].shares[outcome] < amount):
        self.Markets[market].sharesPurchased[outcome] += amount
        return(0)
    else:
        # send bitcoin from the market to the user acc.
        self.cashcoinBalances[market] -= priceToPayPerShare*amount
        # half of fees go to market creator
        self.cashcoinBalances[self.Info[marketID].creator] +=  (self.Markets[marketID].tradingFee*amount*priceToPayPerShare)/2^65
        # half go to branch
        self.cashcoinBalances[branch] += (self.Markets[marketID].tradingFee*amount*priceToPayPerShare)/2^65
        self.cashcoinBalances[tx.origin] += (priceToPayPerShare*amount - ((self.Markets[marketID].tradingFee*amount*priceToPayPerShare)/2^64))
        self.Markets[market].participants[participantNumber].shares[outcome] -= amount
        return(amount*priceToPayPerShare)

# a no vote is -2^64, a yes vote is 2^64 && a can't determine vote is 2^63 (a empty ballot is 0)
# atm voters who do vote are req. to vote on all things in their respective ballots (rest just auto .5 them)
# ui should handle this by filling in things you didn't vote on automatically & ask to be sure you didn't want to vote on them
# UI makeBallot function does this
    # ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[votePeriod].numberEvents
    # && loop through the events[] array from 0 to numberEvents -1 for the votes list / order
# people could report something like 16027*2^64 for a scalar
def vote(branch, report:arr):
    # make sure the branch exists
    repIndex = self.Reporting[branch].repIDtoIndex[tx.origin]
    # need report length to be same as number of items in the current eventexpdates voting period events!
    if(len(report)!=self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].numberEvents):
        return(0)

    # if currentExpPeriod is more than 2 periods past the current vote period
    # then there can be no more voting for that voting period
    # (reasoning being: >1 period past means all the events in that period have expired)
    # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)
    # currently requires events to expire to vote
    currentExpPeriod = (block.number / self.Branches[branch].periodLength)
    if (self.Reporting[branch].reputation[repIndex].reporterID != tx.origin || currentExpPeriod >= (self.Branches[branch].currentVotePeriod+2) || currentExpPeriod < (self.Branches[branch].currentVotePeriod+1)):
        return(0)

    reputation = self.Reporting[branch].reputation[repIndex].repValue
    # need to update stuff for quorem
    # && store the report && the rep value
    save(self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].reporters[tx.origin][0], report, items=len(report))
    self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].totalRepReported += reputation
    return(1)

# returns whether a quorem has a matured event
# if there aren't enough events in a vote period eventsexpdate, push them to the next period and increment the vote period
def checkQuorum(branch):
    currentVotePeriod = self.Branches[branchID].currentVotePeriod
    currentPeriod = (block.number / self.Branches[branch].periodLength)
    # provided the currentPeriod is >=2 periods past the things we're going to rbcr on
    # we can then conclude it has matured && people have had time to vote
    matured = false
    enoughEvents = false
    if (currentPeriod >= (currentVotePeriod+2)):
        matured = true
    else:
        matured = false
    if (self.EventsExpDates[branch][currentVotePeriod].numberEvents<30 && matured):
        self.Branches[branchID].currentVotePeriod += 1
        x = 0
        while(x < self.EventsExpDates[branch][currentVotePeriod-1].numberEvents):
            self.EventsExpDates[branch][currentVotePeriod].events[self.EventsExpDates[branch][currentVotePeriod].numberEvents] = self.EventsExpDates[branch][currentVotePeriod-1].events[x]
            self.EventsExpDates[branch][currentVotePeriod].numberEvents += 1
            x += 1
    else:
        enoughEvents = true
    if(matured && enoughEvents):
        return(1)
    else:
        return(0)
      
# 25% of fees already distributed to market creators
# so 2/3 of remaining fees to voters = 50%
# && 1/3 of remaining fees to event creators = 25%
# what if not enough consensus or not enough events expiring upcoming
def redeem(branch):
    if(!self.checkQuorum(branch)):
        return(text("quorem not satisfied yet"): str)
    currentVotePeriod = self.Branches[branchID].currentVotePeriod
    step = self.Branches[branch].step
    if(step==0):
        # loop through reputation && check if in reporters, if so use their report, if not use the fillin / not reported report (all zeroes)
        # use this to make a giant array of votes to pass to self.consensus
        # want to pass votes for each 0 indexed event in order (so we get votes from an actual reporter)
        # (if they didn't vote we set their array for each event to 0,0,0,0,0,0, etc...)
        numReporters = self.Reporting[branch].numberReporters
        reputation = array(numReporters)
        numberEvents = self.EventsExpDates[branch][currentvotePeriod].numberEvents
        votes = array(numReporters * numberEvents)

        i = 0
        while i < numReporters:
            reporterID = self.Reporting[branch].reputation[i].reporterID
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            # checks to see if each reporter actually voted on events
            # if they didn't vote (simply check if they voted on first event) do nothing (these values will be 0 by default due to Serpent array styles)
            # else if the reporter did report on events put their ballot into the votes array
            if(self.EventsExpDates[branch][currentVotePeriod].reporters[reporterID][0] != 0):
                x = 0
                while x < numberEvents:
                    votes[x + i*numberEvents] = self.EventsExpDates[branch][currentVotePeriod].reporters[reporterID][x]
                    x += 1
            i += 1
        vSize = len(votes)

        j = 0
        scaled = array(numberEvents)
        scaledMaxFixed = array(numberEvents)
        scaledMinFixed = array(numberEvents)
        while j < numberEvents:
            if(self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue!=1):
                scaled[j] = 1
                scaledMaxFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue*2^64
                scaledMinFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].minValue*2^64
            else:
                scaled[j] = 0
                scaledMinFixed[j] = 1*2^64
                scaledMaxFixed[j] = 2*2^64
            j+=1
        result = self.interpolate(votes, reputation, scaled, scaledMaxFixed, scaledMinFixed, outsz=2*vSize)
        self.EventsExpDates[branch][currentVotePeriod].vSize = vSize
        save(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], result, items=vSize)
        save(self.EventsExpDates[branch][currentVotePeriod].reportsMask[0], slice(result, items=vSize, items=2*vSize), items=vSize)
        #def array_saveload():
        #a = [1,2,3,4,5]
        #save(self.a[0], a, items=5)
        #a = load(self.a[0], items=4)
        #log(len(a))
        #return(load(self.a[0], items=4):arr)
        # we're on step one now‏
        self.Branches[branch].step = 1
    elif(step==1):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReporters = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        reputation = array(numReporters)
        i = 0
        while i < numReporters:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i += 1
        j = 0
        scaled = array(numEvents)
        scaledMaxFixed = array(numEvents)
        scaledMinFixed = array(numEvents)
        while j < numEvents:
            if(self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue!=1):
                scaled[j] = 1
                scaledMaxFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue*2^64
                scaledMinFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].minValue*2^64
            else:
                scaled[j] = 0
                scaledMinFixed[j] = -1*2^64
                scaledMaxFixed[j] = 1*2^64
            j+=1
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        reportsFilled = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        reportsFilled = load(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
        result = self.center(reportsFilled, reputation, scaled, scaledMaxFixed, scaledMinFixed, 5, outsz=vSize+numEvents+1)
        save(self.EventsExpDates[branch][currentVotePeriod].weightedCenteredData[0], result, items=vSize)
        save(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], slice(result, items=vSize, items=len(result)), items=(len(result)-vSize))
        self.Branches[branch].step = 2
    elif(step==2):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        # loading vector is numEvents + 1 long, the last element says how many iterations of it are left, should check this
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        if(self.EventsExpDates[branch][currentVotePeriod].loadingVector[numEvents]==0):
            return(0)
        loadingVector = array(numEvents+1)
        loadingVector = load(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], items=numEvents+1)
        weightedCenteredData = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        weightedCenteredData = load(self.EventsExpDates[branch][currentVotePeriod].weightedCenteredData[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
        reputation = array(numReports)
        i = 0
        while i < numReports:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i+=1
        # multistep pca
        # call this 5 times
        loadingVector = self.pca_loadings(loadingVector, weightedCenteredData, reputation, numReports, numEvents, outsz=numEvents+1)
        save(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], loadingVector, items=len(loadingVector))
        self.Branches[branch].step = 3
    elif(step==3):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        loadingVector = array(numEvents+1)
        loadingVector = load(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], items=numEvents+1)
        weightedCenteredData = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        weightedCenteredData = load(self.EventsExpDates[branch][currentVotePeriod].weightedCenteredData[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
        scores = self.pca_scores(loadingVector, weightedCenteredData, numReports, numEvents, outsz=numReports)
        save(self.EventsExpDates[branch][currentVotePeriod].scores[0], scores, items=len(scores))
        self.Branches[branch].step = 4
    elif(step==4):
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        scores = array(numReports)
        scores = load(self.EventsExpDates[branch][currentVotePeriod].scores[0], items=len(numReports))
        result = self.calibrate_sets(scores, numReports, numEvents, outsz=3*numReports)
        # loads the first set of numReports items from result
        save(self.EventsExpDates[branch][currentVotePeriod].set1[0], result, items=numReports)
        save(self.EventsExpDates[branch][currentVotePeriod].set2[0], slice(result, items=numReports, items=2*numReports), items=numReports)
        self.Branches[branch].step = 5
    elif(step==5):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        reportsFilled = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        reportsFilled = load(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
         # loading vector is numEvents + 1 long, the last element says how many iterations of it are left, should check this
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        reputation = array(numReports)
        i = 0
        while i < numReports:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i+=1
        set1 = array(numReports)
        set2 = array(numReports)
        set1 = load(self.EventsExpDates[branch][currentVotePeriod].set1[0], items=numReports)
        set2 = load(self.EventsExpDates[branch][currentVotePeriod].set2[0], items=numReports)
        result = self.calibrate_wsets(set1, set2, reputation, reportsFilled, numReports, numEvents, outsz=3*numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].old[0], result, items=numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].new1[0], slice(result, items=numEvents, items=2*numEvents), items=numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].new2[0], slice(result, items=2*numEvents, items=3*numEvents), items=numEvents)
        self.Branches[branch].step = 6
    elif(step==6):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        old = array(numEvents)
        new1 = array(numEvents)
        new2 = array(numEvents)
        set1 = array(numReports)
        set2 = array(numReports)
        scores = array(numReports)
        old = load(self.EventsExpDates[branch][currentVotePeriod].old[0], items=numEvents)
        new1 = load(self.EventsExpDates[branch][currentVotePeriod].new1[0], items=numEvents)
        new2 = load(self.EventsExpDates[branch][currentVotePeriod].new2[0], items=numEvents)
        set1 = load(self.EventsExpDates[branch][currentVotePeriod].set1[0], items=numReports)
        set2 = load(self.EventsExpDates[branch][currentVotePeriod].set2[0], items=numReports)
        scores = load(self.EventsExpDates[branch][currentVotePeriod].scores[0], items=numReports)
        adjPrinComp = self.pca_adjust(old, new1, new2, set1, set2, scores, numReports, numEvents, outsz=numReports)
        save(self.EventsExpDates[branch][currentVotePeriod].adjPrinComp[0], adjPrinComp, items=len(adjPrinComp))
        self.Branches[branch].step = 7
    elif(step==7):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        i = 0
        while i < numReports:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i+=1
        adjPrinComp = array(numReports)
        adjPrinComp = load(self.EventsExpDates[branch][currentVotePeriod].adjPrinComp[0], items=numReports)
        smoothRep = self.smooth(adjPrinComp, reputation, numReports, numEvents, outsz=numReports)
        save(self.EventsExpDates[branch][currentVotePeriod].smoothRep[0], smoothRep, items=len(smoothRep))
        self.Branches[branch].step = 8
    elif(step==8):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        i = 0
        while i < numReports:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i+=1
        reportsFilled = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        reportsFilled = load(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
        smoothRep = array(numReports)
        smoothRep = load(self.EventsExpDates[branch][currentVotePeriod].smoothRep[0], items=numReports)
        result = self.consensus(smoothRep, reputation, reportsFilled, numReports, numEvents, outsz=numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].outcomesFinal[0], result, items=numEvents)
        self.Branches[branch].step = 9
    elif(step==9):
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        smoothRep = array(numReports)
        smoothRep = load(self.EventsExpDates[branch][currentVotePeriod].smoothRep[0], items=numReports)
        reportsMask = array(vSize)
        reportsMask = load(self.EventsExpDates[branch][currentVotePeriod].reportsMask[0], items=vSize)
        outcomesFinal = array(numEvents)
        outcomesFinal = load(self.EventsExpDates[branch][currentVotePeriod].outcomesFinal[0], items=numEvents)
        reporterBonus = self.participation(outcomesFinal, smoothRep, reportsMask, numReports, numEvents, outsz=numReports)

        # get event ID for each event by taking the x index in the votes arrays - shoving it in reporting.events[]
        # && getting the cooresponding ID
        n = 0
        while n < numEvents:
            eventID = self.EventsExpDates[branch][currentVotePeriod].events[n]
            # then take outcomes_final && set each event outcome
            self.Events[eventID].outcome = outcomesFinal[n]
            if(outcomesFinal[n]!=2^63):
                # return bond
                self.cashcoinBalances[eventID] -= 42*2^64
                self.cashcoinBalances[self.Info[eventID].creator] += 42*2^64
        # need to loop through rep holders && distribute 50% of branch fees to reporters' cashcoin addresses 
        # also need to take reporterBonus && redistribute reputation in the Reporting structure accordingly
        z = 0
        while z < numReports:
            self.Reporting[branch].reputation[z].repValue = (reporterBonus[z]*21000000)/2^64
            self.cashcoinBalances[self.Reporting[branch].reputation[z].reporterID] += self.cashcoinBalances[branch]*reporterBonus[z] / 2^64
        self.Branches[branch].currentVotePeriod += 1
        self.cashcoinBalances[branch] -= self.cashcoinBalances[branch]
        self.Branches[branch].step = 0
        return(self.Branches[branch].currentVotePeriod)


# loop through events in the market, get their outcomes && use those to determine the winning events!
# distribute coins among winning events
# when multidimen fancy payouts we report on the events separately per usual, but combine them to determine winning state of a fancy market && then payout that state
def closeMarket(branch, market):
    if(self.cashcoinBalances[market]<=0):
        return(0)
    numberEvents = self.Markets[market].lenEvents
    tradingPeriod = self.Markets[market].tradingPeriod
    # check if any events in the market were pushed back and that market has expired
    # (as long as the latest expiring event wasn't pushed back, we know they all got reported on)
    if(self.Branches[branch].currentVotePeriod > tradingPeriod && self.EventsExpDates[branch][tradingPeriod].numberEvents>=30):
        # loop through events in the market, get their outcomes && use those to determine the winning events!
        n = 0
        # (max poss. winning outcomes is 200 outcomes total all scalar multidimensional)
        winningOutcomes = array(200)
        while n < numberEvents:
            outcome = self.Events[self.Markets[market].events[n]].outcome
            if(outcome==2^63):
                # return all t3h $$$ - (@ 50 cents a share i presume)
                # give event bond money to reporters
                return(0)
            elif(outcome==0):
                return(0)
            if(n==0):
                #scalar
                if(self.Events[self.Markets[market].events[n]].maxValue!=1):
                    winningOutcomes[0] = 1
                    winningOutcomes[1] = 2
                # anything besides scalar
                else:
                    winningOutcomes[0] += outcome
            elif(n==1):
                if(self.Events[self.Markets[market].events[n]].maxValue!=1):
                    # scalar, scalar
                    if(winningOutcomes[1]):
                        winningOutcomes[2] = 3
                        winningOutcomes[3] = 4
                    # nonscalar, scalar
                    else:
                      # winningOutcomes[0] = winningOutcomes[0]
                        winningOutcomes[1] = winningOutcomes[0] + self.Events[self.Markets[market].events[n-1]].numOutcomes
                # scalar, nonscalar
                elif(winningOutcomes[1] && self.Events[self.Markets[market].events[n]].maxValue==1):
                    winningOutcomes[0] += self.Events[self.Markets[market].events[n-1]].numOutcomes*(outcome-1)
                    winningOutcomes[1] += self.Events[self.Markets[market].events[n-1]].numOutcomes*(outcome-1)
                # nonscalar, nonscalar
                else:
                    winningOutcomes[0] += self.Events[self.Markets[market].events[n-1]].numOutcomes*(outcome-1)
            elif(n==2):
                if(self.Events[self.Markets[market].events[n]].maxValue!=1):
                    #scalar, scalar, scalar
                    if(winningOutcomes[3]):
                        winningOutcomes[4] = 5
                        winningOutcomes[5] = 6
                        winningOutcomes[6] = 7
                        winningOutcomes[7] = 8
                    #scalar, nonscalar, scalar
                    #nonscalar, scalar, scalar
                    elif(winningOutcomes[1]):
                      # winningOutcomes[0] = winningOutcomes[0]
                      # winningOutcomes[1] = winningOutcomes[1]
                        winningOutcomes[2] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes
                        winningOutcomes[3] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes
                    #nonscalar, nonscalar, scalar
                    elif(winningOutcomes[1]==0):
                      # winningOutcomes[0] = winningOutcomes[0]
                        winningOutcomes[1] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes 
                else:
                    #scalar, scalar, nonscalar
                    if(winningOutcomes[3]):
                        winningOutcomes[0] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1) 
                        winningOutcomes[1] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                        winningOutcomes[2] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                        winningOutcomes[3] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                    #scalar, nonscalar, nonscalar
                    #nonscalar, scalar, nonscalar
                    elif(winningOutcomes[1]):
                        winningOutcomes[0] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                        winningOutcomes[1] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                    #nonscalar, nonscalar, nonscalar
                    else:
                        winningOutcomes[0] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
            n+=1

        pricePerShare1 = 0
        pricePerShare2 = 0
        pricePerShare3 = 0
        pricePerShare4 = 0
        pricePerShare5 = 0
        pricePerShare6 = 0
        pricePerShare7 = 0
        pricePerShare8 = 0

        if(winningOutcomes[1]==0):
            pricePerShare1 = 2^64

        elif(winningOutcomes[7]):
            outcomeOne = self.Events[self.Markets[market].events[0]].outcome
            minValueOne = self.Events[self.Markets[market].events[0]].minValue
            maxValueOne = self.Events[self.Markets[market].events[0]].maxValue
            if(outcomeOne>maxValueOne):
                outcomeOne = maxValueOne
            elif(outcomeOne<minValueOne):
                outcomeOne = minValueOne
            outcomeTwo = self.Events[self.Markets[market].events[1]].outcome
            minValueTwo = self.Events[self.Markets[market].events[1]].minValue
            maxValueTwo = self.Events[self.Markets[market].events[1]].maxValue
            if(outcomeTwo>maxValueTwo):
                outcomeTwo = maxValueTwo
            elif(outcomeTwo<minValueTwo):
                outcomeTwo = minValueTwo
            outcomeThree = self.Events[self.Markets[market].events[2]].outcome
            minValueThree = self.Events[self.Markets[market].events[2]].minValue
            maxValueThree = self.Events[self.Markets[market].events[2]].maxValue
            if(outcomeThree>maxValueThree):
                outcomeThree = maxValueThree
            elif(outcomeThree<minValueThree):
                outcomeThree = minValueThree

            outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)
            outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent
            outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)
            outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent
            outcomeThreeHighSidePercent = 2^64*(outcomeThree - 2^64*minValueThree) / (2^64*maxValueThree - 2^64*minValueThree)
            outcomeThreeLowSidePercent = 2^64 - outcomeThreeHighSidePercent
            
            # price is in fixed point
            # first is low low low, 2 is high low low, 3 is low high low, 4 is high high low, 5 is low low high, 6 is high low high, 7 is low high high, 8 is high high high
            pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
            pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
            pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeOneLowSidePercent / (2^64 * 2^64)
            pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeLowSidePercent / (2^64 * 2^64)
            pricePerShare5 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
            pricePerShare6 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
            pricePerShare7 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)
            pricePerShare8 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent * outcomeThreeHighSidePercent / (2^64 * 2^64)

            # distribute cashcoin to the people who won money by holding winning shares
            i = 0
            while i < self.Markets[market].currentParticipant:
                # for each winning outcome do...
                sharesOwned = array(8)
                while(winningOutcome[n]!=0):
                    sharesOwned[n] = self.Markets[market].participants[i].shares[winningOutcome[n]]
                    n+=1
                participant = self.Markets[market].participants[i].participantID
                self.cashcoinBalances[market] -= sharesOwned[0]*pricePerShare1
                self.cashcoinBalances[participant] += sharesOwned[0]*pricePerShare1
                self.cashcoinBalances[market] -= sharesOwned[1]*pricePerShare2
                self.cashcoinBalances[participant] += sharesOwned[1]*pricePerShare2
                self.cashcoinBalances[market] -= sharesOwned[2]*pricePerShare3
                self.cashcoinBalances[participant] += sharesOwned[2]*pricePerShare3
                self.cashcoinBalances[market] -= sharesOwned[3]*pricePerShare4
                self.cashcoinBalances[participant] += sharesOwned[3]*pricePerShare4
                self.cashcoinBalances[market] -= sharesOwned[4]*pricePerShare5
                self.cashcoinBalances[participant] += sharesOwned[4]*pricePerShare5
                self.cashcoinBalances[market] -= sharesOwned[5]*pricePerShare6
                self.cashcoinBalances[participant] += sharesOwned[5]*pricePerShare6
                self.cashcoinBalances[market] -= sharesOwned[6]*pricePerShare7
                self.cashcoinBalances[participant] += sharesOwned[6]*pricePerShare7
                self.cashcoinBalances[market] -= sharesOwned[7]*pricePerShare8
                self.cashcoinBalances[participant] += sharesOwned[7]*pricePerShare8
                i+=1

        elif(winningOutcomes[3]):
            # first is low-low && whatever, second is high-low, third is low-high, fourth is high-high
            scalarOne = -1
            scalarTwo = -1
            if(self.Events[self.Markets[market].events[0]].maxValue!=1):
                scalarOne = 0
            if(self.Events[self.Markets[market].events[1]].maxValue!=1):
                if(scalarOne == -1):
                    scalarOne = 0
                else:
                    scalarTwo = 1
            elif(self.Events[self.Markets[market].events[2]].maxValue!=1):
                scalarTwo = 2
            outcomeOne = self.Events[self.Markets[market].events[scalarOne]].outcome
            minValueOne = self.Events[self.Markets[market].events[scalarOne]].minValue
            maxValueOne = self.Events[self.Markets[market].events[scalarOne]].maxValue
            if(outcomeOne>maxValueOne):
                outcomeOne = maxValueOne
            elif(outcomeOne<minValueOne):
                outcomeOne = minValueOne
            outcomeTwo = self.Events[self.Markets[market].events[scalarTwo]].outcome
            minValueTwo = self.Events[self.Markets[market].events[scalarTwo]].minValue
            maxValueTwo = self.Events[self.Markets[market].events[scalarTwo]].maxValue
            if(outcomeTwo>maxValueTwo):
                outcomeTwo = maxValueTwo
            elif(outcomeTwo<minValueTwo):
                outcomeTwo = minValueTwo

            outcomeOneHighSidePercent = 2^64*(outcomeOne - 2^64*minValueOne) / (2^64*maxValueOne - 2^64*minValueOne)
            outcomeOneLowSidePercent = 2^64 - outcomeOneHighSidePercent
            outcomeTwoHighSidePercent = 2^64*(outcomeTwo - 2^64*minValueTwo) / (2^64*maxValueTwo - 2^64*minValueTwo)
            outcomeTwoLowSidePercent = 2^64 - outcomeTwoHighSidePercent

            # price is in fixed point
            # share four goes with the high-high side 
            pricePerShare4 = outcomeOneHighSidePercent * outcomeTwoHighSidePercent / 2^64
            # share three goes with the low-high side
            pricePerShare3 = outcomeOneLowSidePercent * outcomeTwoHighSidePercent / 2^64
            # share two goes with the high-low side
            pricePerShare2 = outcomeOneHighSidePercent * outcomeTwoLowSidePercent / 2^64
            # share one goes with the low-low
             # both fixed point so div by 2^64 to keep in fixed point
            pricePerShare1 = outcomeOneLowSidePercent * outcomeTwoLowSidePercent / 2^64
            # distribute cashcoin to the people who won money by holding winning shares
            i = 0
            while i < self.Markets[market].currentParticipant:
                # for each winning outcome do...
                n = 0
                while(winningOutcome[n]!=0):
                    sharesOwned = self.Markets[market].participants[i].shares[winningOutcome[n]]
                    participant = self.Markets[market].participants[i].participantID
                    # low-low
                    if(n==0):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare1
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare1
                    # high-low
                    elif(n==1):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare2
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare2
                    # low-high
                    elif(n==2):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare3
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare3
                    # high-high
                    elif(n==3):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare4
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare4
                    n+=1
                i+=1

        elif(winningOutcomes[1]):
            # look for the scalar
            scalar = 0
            if(self.Events[self.Markets[market].events[0]].maxValue!=1):
                scalar = 0
            elif(self.Events[self.Markets[market].events[1]].maxValue!=1):
                scalar = 1
            elif(self.Events[self.Markets[market].events[2]].maxValue!=1):
                scalar = 2
            outcome = self.Events[self.Markets[market].events[scalar]].outcome
            minValue = self.Events[self.Markets[market].events[scalar]].minValue
            maxValue = self.Events[self.Markets[market].events[scalar]].maxValue
            if(outcome>maxValue):
                outcome = maxValue
            elif(outcome<minValue):
                outcome = minValue
            # price is in fixed point
            #share two goes with the high side
            pricePerShare2 = 2^64*(outcome - 2^64*minValue) / (2^64*maxValue - 2^64*minValue)
            #share one goes with the low side of the calc
            pricePerShare1 = 2^64 - pricePerShare1
            # distribute cashcoin to the people who won money by holding winning shares
            i = 0
            while i < self.Markets[market].currentParticipant:
                # for each winning outcome do...
                n = 0
                while(winningOutcome[n]!=0):
                    sharesOwned = self.Markets[market].participants[i].shares[winningOutcome[n]]
                    participant = self.Markets[market].participants[i].participantID
                    # low side
                    if(n==0):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare1
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare1
                    # high side (of the scalar part)
                    elif(n==1):
                        self.cashcoinBalances[market] -= sharesOwned*pricePerShare2
                        self.cashcoinBalances[participant] += sharesOwned*pricePerShare2
                    n+=1
                i += 1

        # give back initial liquidity and ls-lmsr alpha fees (or as much of it/profits are left)
        initialLiquidity = self.Info[marketID].creationFee
        if(self.cashcoinBalances[market] > initialLiquidity):
            # pay back liquidity, split up excess profits
            self.cashcoinBalances[self.Info[market].creator] += initialLiquidity
            self.cashcoinBalances[market] -= initialLiquidity
            self.cashcoinBalances[branch] += self.cashcoinBalances[market] / 2
            self.cashcoinBalances[self.Info[market].creator] += self.cashcoinBalances[market] / 2
            self.cashcoinBalances[market] -= self.cashcoinBalances[market]
        # send whatever's left of the initial liquidity to the creator
        else:
            self.cashcoinBalances[self.Info[market].creator] += self.cashcoinBalances[market]
            self.cashcoinBalances[market] -= self.cashcoinBalances[market]
        q = 0
        while(winningOutcomes[q]!=0):
            self.Markets[market].winningOutcomes[q] = winningOutcomes[q]
            q += 1

        return(text("Market closed"): str)

### P2P parimutuel betting
def makeBet(eventID, amtToBet):
    betData = array(3)
    betData[0] = eventID
    betData[1] = block.number
    betData[2] = tx.origin
    betID = sha256(branchinfo, items=3)
    self.p2pBets[betID].eventID = betData[0]
    self.p2pBets[betID].amtToBet = amtToBet
    return(betID)

# should add a fee to market
# outcome is 0 or 1
def sendMoneytoBet(betID, outcome):
    if(self.cashcoinBalances[betID+outcome]==0):
        self.send(betID+outcome, self.p2pBets[betID].amtToBet)
    else:
        return(0)
    if(outcome):
        self.p2pBets[betID].outcomeOneBettor = tx.origin
    else:
        self.p2pBets[betID].outcomeZeroBettor = tx.origin
    return(1)

# add support for a .5 outcome
def closeBet(betID):
    # outcome not determined yet
    if(self.Events[self.p2pBets[betID].eventID].outcome == 0):
        return(0)
    # pay out depending on outcome
    if(self.cashcoinBalances[betID+0]==self.p2pBets[betID].amtToBet && self.cashcoinBalances[betID+1]==self.p2pBets[betID].amtToBet):
        self.cashcoinBalances[betID+0] -= self.cashcoinBalances[betID+0]
        self.cashcoinBalances[betID+1] -= self.cashcoinBalances[betID+1]
        if(self.Events[self.p2pBets[betID].eventID].outcome):
            self.cashcoinBalances[self.p2pBets[betID].outcomeOneBettor] += self.p2pBets[betID].amtToBet*2
        elif(self.Events[self.p2pBets[betID].eventID].outcome == -1):
            self.cashcoinBalances[self.p2pBets[betID].outcomeZeroBettor] += self.p2pBets[betID].amtToBet*2
    # someone didn't pay their side of the bet, refund funds
    else:
        self.cashcoinBalances[self.p2pBets[betID].outcomeZeroBettor] += self.cashcoinBalances[betID+0]
        self.cashcoinBalances[self.p2pBets[betID].outcomeOneBettor] += self.cashcoinBalances[betID+1]
        self.cashcoinBalances[betID+0] -= self.cashcoinBalances[betID+0]
        self.cashcoinBalances[betID+1] -= self.cashcoinBalances[betID+1]
    return(1)

### API (for UI)

# atm voters who do vote are req. to vote on all things in their respective ballots (even if just a 0 / no vote)
# ui should handle this ^
# ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents
# && loop through the events[] array from 0 to numberEvents -1 for the votes list / order
# UI will need a function to get the items in that array above so it can make a report!
# w/ this function you can get the eventIDs, look them up && report on outcomes (probably w/ another function to look them up) -- make sure in this function to check that the report value is not >maxvalue or <minvalue for the event
def makeBallot(branch):
    numEvents = self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].numberEvents
    eventArray = array(numEvents)
    i = 0
    while i < numEvents:
        eventID = self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].events[numEvents]
        eventArray[i] = eventID
    return(eventArray: arr)

# arrayIndex only matters if array
def api(dataStructure, itemNumber, arrayIndex, ID):
    if(dataStructure==0):
        if(itemNumber==0):
            length=self.Info[ID].descriptionLength
            return(load(self.Info[ID].description[0], chars=length))
        elif(itemNumber==1):
            return(self.Info[ID].descriptionLength)
        elif(itemNumber==2):
            return(self.Info[ID].creator)
        elif(itemNumber==3):
            return(self.Info[ID].creationFee)
    elif(dataStructure==1):
        if(itemNumber==0):
            return(self.Branches[ID].currentVotePeriod)
        elif(itemNumber==1):
            return(self.Branches[ID].periodLength)
        elif(itemNumber==2):
            return(self.Branches[ID].step)
    elif(dataStructure==2):
        if(itemNumber==0):
            return(self.Events[ID].branch)
        elif(itemNumber==1):
            return(self.Events[ID].expirationDate)
        elif(itemNumber==2):
            return(self.Events[ID].outcome)
        elif(itemNumber==3):
            return(self.Events[ID].minValue)
        elif(itemNumber==4):
            return(self.Events[ID].maxValue)
        elif(itemNumber==5):
            return(self.Events[ID].numOutcomes)
    elif(dataStructure==3):
        if(itemNumber==0):
            return(text("Please call the eventsExpApi function"): str)
        elif(itemNumber==1):
            return(text("Please call the reputation api function"): str)
        elif(itemNumber==2):
            return(self.Reporting[ID].numberReporters)
        elif(itemNumber==3):
            return(self.Reporting[ID].repIDtoIndex[arrayIndex])
    elif(dataStructure==4):
        if(itemNumber==0):
            return(self.Markets[ID].events[arrayIndex])
        elif(itemNumber==1):
            return(self.Markets[ID].sharesPurchased[arrayIndex])
        elif(itemNumber==2):
            return(text("Please call the participants api function"): str)
        elif(itemNumber==3):
            return(self.Markets[ID].lenEvents)
        elif(itemNumber==4):
            return(self.Markets[ID].currentParticipant)
        elif(itemNumber==5):
            return(self.Markets[ID].winningOutcomes[arrayIndex])
        elif(itemNumber==6):
            return(self.Markets[ID].alpha)
        elif(itemNumber==7):
            return(self.Markets[ID].cumulativeScale)
        elif(itemNumber==8):
            return(self.Markets[ID].numOutcomes)
        elif(itemNumber==9):
            return(self.Markets[ID].tradingPeriod)
        elif(itemNumber==10):
            return(self.Markets[ID].tradingFee)
    elif(dataStructure==5):
        if(itemNumber==0):
            return(self.p2pBets[ID].eventID)
        elif(itemNumber==1):
            return(self.p2pBets[ID].amtToBet)
        elif(itemNumber==2):
            return(self.p2pBets[ID].outcomeOneBettor)
        elif(itemNumber==3):
            return(self.p2pBets[ID].outcomeZeroBettor)

def eventsExpApi(expDateIndex, itemNumber, arrayIndexOne, arrayIndexTwo, ID):
    if(itemNumber==0):
        return(self.EventsExpDates[ID][expDateIndex].numberEvents)
    elif(itemNumber==1):
        return(self.EventsExpDates[ID][expDateIndex].events[arrayIndexOne])
    elif(itemNumber==2):
        return(self.EventsExpDates[ID][expDateIndex].totalRepReported)
    elif(itemNumber==3):
        return(self.EventsExpDates[ID][expDateIndex].reporters[arrayIndexOne][ArrayIndexTwo])
    elif(itemNumber==4):
        return(self.EventsExpDates[ID][expDateIndex].vSize)
    elif(itemNumber==5):
        return(self.EventsExpDates[ID][expDateIndex].reportsFilled[arrayIndexOne])
    elif(itemNumber==6):
        return(self.EventsExpDates[ID][expDateIndex].reportsMask[arrayIndexOne])
    elif(itemNumber==7):
        return(self.EventsExpDates[ID][expDateIndex].weightedCenteredData[arrayIndexOne])
    elif(itemNumber==8):
        return(self.EventsExpDates[ID][expDateIndex].loadingVector[arrayIndexOne])
    elif(itemNumber==9):
        return(self.EventsExpDates[ID][expDateIndex].scores[arrayIndexOne])
    elif(itemNumber==10):
        return(self.EventsExpDates[ID][expDateIndex].set1[arrayIndexOne])
    elif(itemNumber==11):
        return(self.EventsExpDates[ID][expDateIndex].set2[arrayIndexOne])
    elif(itemNumber==12):
        return(self.EventsExpDates[ID][expDateIndex].old[arrayIndexOne])
    elif(itemNumber==13):
        return(self.EventsExpDates[ID][expDateIndex].new1[arrayIndexOne])
    elif(itemNumber==14):
        return(self.EventsExpDates[ID][expDateIndex].new2[arrayIndexOne])
    elif(itemNumber==15):
        return(self.EventsExpDates[ID][expDateIndex].adjPrinComp[arrayIndexOne])
    elif(itemNumber==16):
        return(self.EventsExpDates[ID][expDateIndex].smoothRep[arrayIndexOne])
    elif(itemNumber==17):
        return(self.EventsExpDates[ID][expDateIndex].outcomesFinal[arrayIndexOne])

def reputationApi(reputationIndex, itemNumber, branchID):
    if(itemNumber==0):
        return(self.Reporting[branchID].reputation[reputationIndex].repValue)
    elif(itemNumber==1):
        return(self.Reporting[branchID].reputation[reputationIndex].reporterID)

# eventID && outcomeNumber only needed if itemNumber is 1
# remove this
def marketParticipantsApi(participantIndex, itemNumber, eventID, outcomeNumber, marketID):
    if(itemNumber==0):
        return(self.Markets[marketID].participants[participantIndex].participantID)
    elif(itemNumber==1):
        return(self.Markets[marketID].participants[participantIndex].shares[outcomeNumber])

def reputation(address):
    if(address):
        branches = array(2*self.branchesList[0])
        i = 1
        b = 0
        while i < self.branchesList[0]:
            branch = self.branchesList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                branches[b+2] = array(2048)
                branches[b+2] = load(self.Info[branch].description[0], items=2048)
                b += 3
            i += 1
    else:
        branches = array(self.branchesList[0])
        i = 1
        b = 0
        while i < self.branchesList[0]:
            branch = self.branchesList[i]
            branches[b] = branch
            branches[b+1] = array(2048)
            branches[b+1] = load(self.Info[branch].description[0], items=2048)
            b += 2
            i += 1
    return(branchBalances: arr)

inset('fxp_macros.se')
inset('consensus.se')
