# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C)  2014 Chris Calderon, Joey Krug, Alan Lu, Jack Peterson
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joeykrug@gmail.com

BRANCH = 0
EVENT = 1
MARKET = 2

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](description[2048], descriptionLength, creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the current vote period (should always be 1 behind block.number/periodlength or current EventsExpDates index)
data Branches[](currentVotePeriod, periodLength, step, markets[], numMarkets)

# Events' index is the eventID
# a binary outcome has 0 for min && 1 for max value, but consensus will return 1 and 2 respectively
# so for voting 1 and 2 need to be given for binaries, not 0 & 1
# S&P 500 scalar would be say 0 && 4700, respectively
# categorical markets have fixed point min and max
 # so max-min/numOutcomes is interval between outcomes (useful for ui, e.g. 1 is >50, 2 is >100, etc.)
# need outcomes returned as 1*2^64, 2*2^64, etc... .5 as 2^63
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# [branchID][votingPeriod]
# v_size = numReports * numEvents
# reportsFilled, reportsMask, weightedCenteredData, loadingVector, scores, set1, set2, old,
# new1, new2, adjPrinComp, smoothRep, outcomesFinal, consensusReward is all consensus data
data EventsExpDates[][](numberEvents, events[], totalRepReported, reporters[][], vSize, reportsFilled[], reportsMask[], weightedCenteredData[], loadingVector[], scores[], set1[], set2[], old[], new1[], new2[], adjPrinComp[], smoothRep[], outcomesFinal[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market in the format of
    # [1, event, event, 2, event, 3, event, event, event]
    # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
# Sharespurchased keeps track of the number of shares purchased for each outcome
    # sharesPurchased states starts at 1 - (same for participants[].shares[] array)
# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event
# a binary outcome state 1 is no, 2 is true, 0 if not determined
# tradingFee is a percent in fixedPoint
# tradingPeriod is which eventexpperiod market expires in
data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], alpha, cumulativeScale, numOutcomes, tradingPeriod, tradingFee)

data p2pBets[](eventID, amtToBet, outcomeOneBettor, outcomeZeroBettor)

data cashcoinBalances[]

data branchList[]

data branchListCount

def init():
    # test initial funds
    self.cashcoinBalances[tx.origin] = 100000*2^64
    self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
    self.Reporting[1010101].reputation[0].repValue = 470*2^64
    self.Reporting[1010101].reputation[0].reporterID = tx.origin
    self.Reporting[1010101].numberReporters = 1
    description = text("Root branch")
    save(self.Info[1010101].description[0], description, chars=len(description))
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Info[1010101].descriptionLength = len(description)
    self.Branches[1010101].currentVotePeriod = (block.number / 403200) - 1 
    self.Branches[1010101].periodLength = 200
    self.branchListCount = 1
    self.branchList[0] = 1010101

# @return: cash balance of address
def balance(address):
    return(self.cashcoinBalances[address])

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
# so cashcoin fees could just go to root branch, or we could not have fees besides 
# gas fee to do a send transaction
# @return: value sent, 0 if fails
def send(recver, value):
    sender = tx.origin
    senderBalance = self.cashcoinBalances[sender]
    if(senderBalance >= value):
        self.cashcoinBalances[sender] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

def faucet():
    sender = tx.origin
    self.cashcoinBalances[sender] = 10000*2^64
    index = self.Reporting[1010101].numberReporters
    self.Reporting[1010101].repIDtoIndex[tx.origin] = index
    self.Reporting[1010101].reputation[index].repValue = 47*2^64
    self.Reporting[1010101].reputation[index].reporterID = tx.origin
    self.Reporting[1010101].numberReporters += 1
    return(1)

# @return value of cash sent; fail is 0
def sendFrom(recver, value, from):
    if(from!=tx.origin):
        return(0)
    senderBalance = self.cashcoinBalances[from]
    if(senderBalance >= value):
        self.cashcoinBalances[from] -= value
        self.cashcoinBalances[recver] += value
        return(value)
    else:
        return(0)

# @return value of reputation sent, 0 if not enough reputation
# error messages otherwise
    # -1: "Your reputation account was just created, earn some rep. before you can send to others"
    # -2: "Receiving address doesn't exist"
def sendReputation(branch, recver, value):
    # VoteCoins cannot be simultaneously spent (transferred) and used to vote
    currentVotePeriod = self.Branches[branch].currentVotePeriod
    if(value<=0 || !self.send(branch, 5*2^64) || self.EventsExpDates[branch][currentVotePeriod].reporters[tx.origin][0] != 0 || self.EventsExpDates[branch][currentVotePeriod].reporters[recver][0] != 0):
        return(0)
    sender = tx.origin
    senderIndex = self.Reporting[branch].repIDtoIndex[sender]
    receiverIndex = self.Reporting[branch].repIDtoIndex[recver]
    # if the sender's rep. account doesn't exist, make one
    if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
        reporterIndex = self.Reporting[branch].numberReporters
        self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
        self.Reporting[branch].reputation[reporterIndex].repValue = 0
        self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
        self.Reporting[branch].numberReporters += 1
        return(-1)

    if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
        return(-2)
        
    senderBalance = self.Reporting[branch].reputation[senderIndex].repValue
    if(senderBalance >= value):
        self.Reporting[branch].reputation[senderIndex].repValue -= value
        self.Reporting[branch].reputation[receiverIndex].repValue += value
        return(value)
    else:
        return(0)

# @return reputation value        
def getRepBalance(branch, address):
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].reputation[repIndex].repValue)

# period length is given in blocks
# description format is branchName:description
# is there some way we can include the description bytes in the sha256 hash?
# @return branchID if success, else 0
def createSubbranch(description:str, periodLength, parent):
    if(periodLength<=0 || !self.Branches[parent].periodLength || description==0):
        return(0)

    #upcomingDecisions = 0
    #a = (block.number / self.Branches[branch].periodLength)
    #b = a
    #while b < (a+100):
    #    upcomingDecisions += self.EventsExpDates[parent][a].numberEvents
    #    b += 1
    # turned off for testing
    #if(upcomingDecisions < 500):
    #    return(0)

    branchInfo = string((items=6)+len(description))
    branchInfo[0] = BRANCH                                      #typecode
    branchInfo[1] = tx.origin                                   #creator address
    branchInfo[2] = 47*2^64                                     #creation fee
    branchInfo[3] = periodLength                                #length of voting cycle
    branchInfo[4] = block.number                                #current block number
    branchInfo[5] = parent                                      #branchID of parent branch
    mcopy(branchInfo+(items=6), description, len(description))
    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash && characteristics && say, "don't trust me? check"
    branchID = sha256(branchInfo, chars=len(branchInfo))

    if(self.Branches[parent].periodLength && self.Info[parent].creator && self.send(parent, 47*2^64) && self.Branches[branchID].periodLength==0):
        self.Info[branchID].creator = tx.origin
        self.Info[branchID].creationFee = 47*2^64
        self.Info[branchID].descriptionLength = len(description)
        save(self.Info[branchID].description[0], description, chars=len(description))
        self.Branches[branchID].periodLength = periodLength
        # first vote period won't be until after the current (in this case first) basket of things has expired
        # if floor(blockNum / periodLength) is say 5 and eventsExpDates[5]
        # the current vote period should be on things from eventsExpDates 4 (when making a new branch this vote period will just fail quorem, and current vote period will be incrememented)
        # then once blockNum / periodLength is say 6 and eventsExpDates[6]
        # votePeriod 4 should close and the currentVotePeriod should be from
        # eventsExpDates 5 (anyone can call the consensus function for voteperiod 4 at this point)
        self.Branches[branchID].currentVotePeriod = (block.number / periodLength) - 1
        i = 0
        while i < self.Reporting[parent].numberReporters:
            self.Reporting[branchID].reputation[i].reporterID = self.Reporting[parent].reputation[i].reporterID
            self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
            self.Reporting[branchID].repIDtoIndex[reporterID] = i
            i+=1
        self.Reporting[branchID].numberReporters = i
        self.branchList[self.branchListCount] = branchID
        self.branchListCount += 1
        return(branchID)
    else:
        return(0)

# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0
# to 11.0 would be 11 outcomes (if incremented by 0.1)
# need to make sure these values are ok
# @return 0 as fail state, eventID if success
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes):
    if(self.Branches[branch].periodLength && description!=0 && expDate>block.number):
        eventinfo = string((items=8)+len(description))
        eventinfo[0] = EVENT                                        #typecode
        eventinfo[1] = branch                                       #branchID
        eventinfo[2] = expDate                                      #expiration date
        eventinfo[3] = tx.origin                                    #creator address
        eventinfo[4] = 42*2^64                                      #creation fee
        eventinfo[5] = minValue                                     #minimum outcome value
        eventinfo[6] = maxValue                                     #maximum outcome value
        eventinfo[7] = numOutcomes                                  #number of outcomes
        mcopy(eventinfo+(items=8), description, len(description))
        eventID = sha256(eventinfo, chars=len(eventinfo))
    else:
        return(0)

    # can't have a scalar && categorical event in one
    # you can make a market like that though!
    if(numOutcomes!=2 && maxValue!=1):
        return(0)

    # fee to ask a question rises if voter participation (rep reported) falls, if it's really high, the fee is lowered (participationFactor is a fixedpoint number)
    participationFactor = (self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod-2].totalRepReported * 2^64) / self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod-1].totalRepReported
    if(participationFactor==0):
        participationFactor = 1
    # send fee and bond
    if(self.balance(tx.origin)>=(42*2^64 + participationFactor*45)):
        if (!self.Info[eventID].creator && !self.Events[eventID].branch && self.send(eventID, 42*2^64) && self.send(branch, participationFactor*45)):
            self.Info[eventID].creator = tx.origin
            self.Info[eventID].creationFee = participationFactor*45 # this is not the bond
            self.Info[eventID].descriptionLength = len(description)
            save(self.Info[eventID].description[0], description, chars=len(description))
            self.Events[eventID].branch = branch
            self.Events[eventID].expirationDate = expDate
            self.Events[eventID].minValue = minValue
            self.Events[eventID].maxValue = maxValue
            self.Events[eventID].numOutcomes = numOutcomes
            # see which future period it expires in && put the event in that bin
            # event voting periods - expDate / periodLength gives you the voting period #
            futurePeriod = (expDate / self.Branches[branch].periodLength)
            self.EventsExpDates[branch][futurePeriod].events[self.EventsExpDates[branch][futurePeriod].numberEvents] = eventID
            self.EventsExpDates[branch][futurePeriod].numberEvents += 1
            return(eventID)
        else:
            return(0)

# alpha is equal to v/(n*log(n)) where v is the max percent commission
# && n is the number of outcomes people can trade. Alpha is set when
# a market is created.
macro lsLmsr($marketID):
    with $bq = Bq($marketID):
        with $i = 1:
            with $sumExp = 0:
                while $i <= numOutcomes($marketID):
                    $sumExp += fx_exp(sharesPurchased($marketID)[$i] * 2**64 / $bq)
                    $i += 1
                $bq*fx_log($sumExp)/2**64

macro sumList($q, $a, $b):
    $i = $a + 1
    $result = $q[$a]
    while $i <= $b:
        $result += $q[$i]
        $i += 1
    $result

macro market($marketID):
    self.Markets[$marketID]

macro alpha($marketID):
    market($marketID).alpha

macro cumScale($marketID):
    market($marketID).cumulativeScale

macro numOutcomes($marketID):
    market($marketID).numOutcomes

macro sharesPurchased($marketID):
    market($marketID).sharesPurchased

macro Bq($marketID):
   alpha($marketID) * cumScale($marketID) * sumList(sharesPurchased($marketID), 1, numOutcomes($marketID)) / 2**64

def price(market, outcome):
    a = lsLmsr(market)
    sharesPurchased(market)[outcome] += 2**32
    b = lsLmsr(market)
    sharesPurchased(market)[outcome] -= 2**32
    return((b - a) * 2**32)

# alpha is a fixedpoint number / calc. it in UI
# z is the optimal initial vector for each outcome
# z = liquidity / (1+(alpha*n*ln(n)))
# initialLiquidity is initial number of cash in each outcome you want to buy/initialize/set
# tradingFee is a percent in fixedPoint
# same for these values
# @return 0 as fail state, marketID if success
def createMarket(branch, description:str, alpha, initialLiquidity, tradingFee, events:arr):
    if(self.Branches[branch].periodLength==0 or len(description)==0 or initialLiquidity==0 || alpha <= 2^57 || tradingFee < 2^57):
        return(0)
    # check that events have same exp. dates && branch
    i = 0
    eventNum = len(events)
    # only supports 3 dimensional markets atm
    if(eventNum > 3):
        return(0)
    numOutcomes = 0
    eventsConcat = 0
    cumulativeScale = 0
    tradingPeriod = 0
    while i < eventNum:
        event = events[i]
        if(self.Events[event].expirationDate > tradingPeriod):
            tradingPeriod = self.Events[event].expirationDate
        eventsConcat += event
        if (self.Events[event].branch != branch || !self.Info[event].creator):
            return(0)
        #scalars
        if(self.Events[event].maxValue!=1 && self.Events[event].numOutcomes==2):
            # is a valid scalar
            cumulativeScale += self.Events[event].maxValue - self.Events[event].minValue
        if(i==0):
            numOutcomes += self.Events[event].numOutcomes
        else:
            numOutcomes *= self.Events[event].numOutcomes
        i += 1
    if(numOutcomes > 200):
        return(0)
    log(cumulativeScale)
    if(cumulativeScale==0):
        cumulativeScale = 1
    tradingPeriod = (tradingPeriod / self.Branches[branch].periodLength)
    # formation of marketID (hash)
    marketinfo = string((items=11)+len(description))
    marketinfo[0] = MARKET
    marketinfo[1] = tx.origin
    marketinfo[2] = initialLiquidity
    marketinfo[3] = branch
    marketinfo[4] = eventsConcat
    marketinfo[5] = len(events)
    marketinfo[6] = cumulativeScale
    marketinfo[7] = alpha
    marketinfo[8] = numOutcomes
    marketinfo[9] = tradingPeriod
    marketinfo[10] = tradingFee
    mcopy(marketinfo+(items=11), description, chars=len(description))
    marketID = sha256(marketinfo, chars=len(marketinfo))

    # pay numOutcomes fee
    # if it's already been created return 0
    if(!self.send(branch, numOutcomes*2^63) || self.Info[marketID].creator || self.Markets[marketID].numOutcomes):
        return(0)

    # buy some of all outcomes
    # ls-lmsr needs at least a very small initial liquidity
    y = 1
    z = initialLiquidity * 2**64 / (2**64 + alpha*cumulativeScale*fx_log(initialLiquidity)/2**64)
    while y <= numOutcomes:
        sharesPurchased(marketID)[y] += z
        y += 1
    self.Markets[marketID].alpha = alpha
    self.Markets[marketID].cumulativeScale = cumulativeScale
    self.Markets[marketID].numOutcomes = numOutcomes
    if(self.send(marketID, initialLiquidity)):
        # add event list to the market
        save(self.Markets[marketID].events[0], events, items=eventNum)
        self.Info[marketID].creator = tx.origin
        self.Info[marketID].creationFee = initialLiquidity
        self.Info[marketID].descriptionLength = len(description)
        save(self.Info[marketID].description[0], description, chars=len(description))
        self.Markets[marketID].alpha = alpha
        self.Markets[marketID].lenEvents = len(events)
        self.Markets[marketID].cumulativeScale = cumulativeScale
        self.Markets[marketID].numOutcomes = numOutcomes
        self.Markets[marketID].tradingPeriod = tradingPeriod
        self.Markets[marketID].tradingFee = tradingFee
        self.Branches[branch].markets[self.Branches[branch].numMarkets] = marketID
        self.Branches[branch].numMarkets += 1
        return(marketID)
    else:
        # revert shares bought and other variables
        y = 1
        while y <= numOutcomes:
            self.Markets[marketID].sharesPurchased[y] -= z
        self.Markets[marketID].alpha = 0
        self.Markets[marketID].cumulativeScale = 0
        self.Markets[marketID].numOutcomes = 0
        return(0)

# amount of shares should be fixed point
# @return 0 if fail, else return price + fee to buy shares
def buyShares(branch, market, outcome, amount):
    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)  
    # if we have 3-4 cycles in a row of events getting pushed back market would already be closed even though events up to be decided on for a while yet never decided
    # technically this is a stalled branch and market should be open
    # if(currentPeriod + 3 >= currentVotePeriod) we're stalled
    #the question is though --- are these events part of the set that were stalled?
    #if above && the event outcomes aren't determined (0), then yes
    #then set a stalled boolean 
    stalled = 0
    if (outcome==0 || (self.Branches[branch].currentVotePeriod>=self.Markets[market].tradingPeriod && !stalled)):
        return(0)
    # lmsr cost calcs
    oldCost = lsLmsr(market)
    sharesPurchased(market)[outcome] += amount
    newCost = lsLmsr(market)
    if newCost < oldCost:
        sharesPurchased(market)[outcome] -= amount
        return(0)
    price = (newCost - oldCost)
    
    if(self.cashcoinBalances[tx.origin] < price*(self.Markets[market].tradingFee + 2^64)/2^64):
        sharesPurchased(market)[outcome] -= amount
        return(0)

    participantNumber = self.Markets[market].addr2participant[tx.origin]

    if(tx.origin != self.Markets[market].participants[participantNumber].participantID):
        participantNumber = self.Markets[market].currentParticipant
        self.Markets[market].participants[participantNumber].participantID = tx.origin
        self.Markets[market].addr2participant[tx.origin] = participantNumber
        self.Markets[market].currentParticipant += 1

    self.Markets[market].participants[participantNumber].shares[outcome] += amount
    # send shares of the event to user address
    # if user doesn't have enough money, revert
    # send money from user acc. to market address/account
    # cost for shares
    self.send(market, price)
    # half of fees to market creator
    fee = self.Markets[market].tradingFee*price/2^64
    self.send(self.Info[market].creator, fee/2)
    # other half go to branch
    self.send(branch, fee/2)
    return(price+fee)

# amount is amount of shares to sell
# instead of inputting particip. num could just loop through array if dont have it
# @return 0 if fail, returns amount you get paid if success
def sellShares(branch, market, outcome, amount):
    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)
    participantNumber = self.Markets[market].addr2participant[tx.origin]
    if (self.Markets[market].participants[participantNumber].participantID != tx.origin || outcome==0 || self.Branches[branch].currentVotePeriod>=self.Markets[market].tradingPeriod):
        return(0)
    # lmsr cost calcs
    oldCost = lsLmsr(market)
    sharesPurchased(market)[outcome] -= amount
    newCost = lsLmsr(market)
    if oldCost <= newCost:
        sharesPurchased(market)[outcome] += amount
        return(0)
    # these prices are in fixed point
    price = oldCost - newCost
    # remove shares from the user's account
    # if user actually doesn't have the shares, revert
    if self.Markets[market].participants[participantNumber].shares[outcome] < amount:
        sharesPurchased(market)[outcome] += amount
        return(0)
    else:
        # send bitcoin from the market to the user acc.
        self.cashcoinBalances[market] -= price
        fee = self.Markets[market].tradingFee*price/2^64
        log(fee)
        # half of fees go to market creator
        self.cashcoinBalances[self.Info[market].creator] += fee/2
        # half go to branch
        self.cashcoinBalances[branch] += fee/2
        price -= fee
        self.cashcoinBalances[tx.origin] += price
        self.Markets[market].participants[participantNumber].shares[outcome] -= amount
        return(price)

# a no vote is -2^64, a yes vote is 2^64 && a can't determine vote is 2^63 (a empty ballot is 0)
# atm voters who do vote are req. to vote on all things in their respective ballots (rest just auto .5 them)
# ui should handle this by filling in things you didn't vote on automatically & ask to be sure you didn't want to vote on them
# UI makeBallot function does this
    # ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[votePeriod].numberEvents
    # && loop through the events[] array fr2om 0 to numberEvents -1 for the votes list / order
# people could report something like 16027*2^64 for a scalar
# if people get behind on voting (e.g the redeem tx isn't called <1 period after it can be called) 
    # voteperiod is an optional parameter only used in the scenario that we get behind on voting periods
    # so people will need to vote on periods that are upcoming even if our currentVotePeriod is a bit behind (e.g. if current expperiod is 7 you should vote on stuff from voteperiod 6 (and then upon period 8 you can't vote anymore))
# @return 0 if fail, 1 if success
def vote(branch, report:arr, votePeriod):
    # make sure the branch exists
    repIndex = self.Reporting[branch].repIDtoIndex[tx.origin]
    if(votePeriod):
        # need report length to be same as number of items in the current eventexpdates voting period events!
        if(len(report)!=self.EventsExpDates[branch][votePeriod].numberEvents):
            return(0)

        # if currentExpPeriod is more than 2 periods past the current vote period
        # then there can be no more voting for that voting period
        # (reasoning being: >=1 period past means all the events in that period have expired)
        # (>=2 periods past mean the events have exp. & people have had 1 full period to vote)
        # currently requires events to expire to vote
        currentExpPeriod = (block.number / self.Branches[branch].periodLength)
        if (self.Reporting[branch].reputation[repIndex].reporterID != tx.origin || currentExpPeriod >= (votePeriod+2) || currentExpPeriod < (votePeriod+1)):
            return(0)

        reputation = self.Reporting[branch].reputation[repIndex].repValue
        # need to update stuff for quorem
        # && store the report && the rep value
        save(self.EventsExpDates[branch][votePeriod].reporters[tx.origin][0], report, items=len(report))
        self.EventsExpDates[branch][votePeriod].totalRepReported += reputation
        return(1)

# arrayIndex only matters if arrays
# Error: -3: "Please call the eventsExpApi function"
       # -4: "Please call the reputation api function"
       # -5: "Please call the participants api function"
def api(dataStructure, itemNumber, arrayIndex, ID):
    if(dataStructure==0):
        if(itemNumber==0):
            length=self.Info[ID].descriptionLength
            return(load(self.Info[ID].description[0], chars=length))
        elif(itemNumber==1):
            return(self.Info[ID].descriptionLength)
        elif(itemNumber==2):
            return(self.Info[ID].creator)
        elif(itemNumber==3):
            return(self.Info[ID].creationFee)
    elif(dataStructure==1):
        if(itemNumber==0):
            return(self.Branches[ID].currentVotePeriod)
        elif(itemNumber==1):
            return(self.Branches[ID].periodLength)
        elif(itemNumber==2):
            return(self.Branches[ID].step)
    elif(dataStructure==2):
        if(itemNumber==0):
            return(self.Events[ID].branch)
        elif(itemNumber==1):
            return(self.Events[ID].expirationDate)
        elif(itemNumber==2):
            return(self.Events[ID].outcome)
        elif(itemNumber==3):
            return(self.Events[ID].minValue)
        elif(itemNumber==4):
            return(self.Events[ID].maxValue)
        elif(itemNumber==5):
            return(self.Events[ID].numOutcomes)
    elif(dataStructure==3):
        if(itemNumber==0):
            return(-3)
        elif(itemNumber==1):
            return(-4)
        elif(itemNumber==2):
            return(self.Reporting[ID].numberReporters)
        elif(itemNumber==3):
            return(self.Reporting[ID].repIDtoIndex[arrayIndex])
    elif(dataStructure==4):
        if(itemNumber==0):
            return(self.Markets[ID].events[arrayIndex])
        elif(itemNumber==1):
            return(self.Markets[ID].sharesPurchased[arrayIndex])
        elif(itemNumber==2):
            return(-5)
        elif(itemNumber==3):
            return(self.Markets[ID].lenEvents)
        elif(itemNumber==4):
            return(self.Markets[ID].currentParticipant)
        elif(itemNumber==5):
            return(self.Markets[ID].winningOutcomes[arrayIndex])
        elif(itemNumber==6):
            return(self.Markets[ID].alpha)
        elif(itemNumber==7):
            return(self.Markets[ID].cumulativeScale)
        elif(itemNumber==8):
            return(self.Markets[ID].numOutcomes)
        elif(itemNumber==9):
            return(self.Markets[ID].tradingPeriod)
        elif(itemNumber==10):
            return(self.Markets[ID].tradingFee)

# eventID && outcomeNumber only needed if itemNumber is 1
def marketParticipantsApi(participantIndex, itemNumber, eventID, outcomeNumber, marketID):
    if(itemNumber==0):
        return(self.Markets[marketID].participants[participantIndex].participantID)
    elif(itemNumber==1):
        return(self.Markets[marketID].participants[participantIndex].shares[outcomeNumber])

# @return all markets in a branch
def getMarkets(branch):
    numMarkets = self.Branches[branch].numMarkets
    markets = array(numMarkets)
    i = 0
    while i < numMarkets:
        markets[i] = self.Branches[branch].markets[i]
        i += 1
    return(markets: arr)

# @return all events in a branch and expiration period
def getEvents(branch, expPeriod):
    numEvents = self.EventsExpDates[branch][expPeriod].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expPeriod].events[i]
        i += 1
    return(events: arr)

# @return all branches
def getBranches(): 
    b = 0
    numBranches = self.branchListCount
    branches = array(numBranches)
    while b < numBranches:
        branches[b] = self.branchList[b]
        b += 1
    return(branches: arr)

# will return 0s for array values after it's looped through all the ones you 
# have an actual balance in
def getReputation(address):
    if(address):
        branches = array(2*self.branchListCount)
        i = 0
        b = 0
        while i < self.branchListCount:
            branch = self.branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    else:
        address = tx.origin
        branches = array(2*self.branchListCount)
        i = 0
        b = 0
        while i < self.branchListCount:
            branch = self.branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    return(branches: arr)
    
def getBranchDesc(branch):
    length = self.Info[branch].descriptionLength
    return(load(self.Info[branch].description[0], chars=length): str)

def getEventDesc(event):
    length = self.Info[event].descriptionLength
    return(load(self.Info[event].description[0], chars=length): str)

def getMarketDesc(market):
    length = self.Info[market].descriptionLength
    return(load(self.Info[market].description[0], chars=length): str)

def getMarketEvents(market):
    i = 0
    lenEvents = self.Markets[market].lenEvents
    events = array(lenEvents)
    while i < lenEvents:
        events[i] = self.Markets[market].events[i]
        i += 1
    return(events: arr)

def getMarketInfo(market):
    info = array(8)
    info[0] = self.Info[market].creator
    info[1] = self.Info[market].creationFee
    info[2] = self.Markets[market].currentParticipant
    info[3] = self.Markets[market].alpha
    info[4] = self.Markets[market].cumulativeScale
    info[5] = self.Markets[market].numOutcomes
    info[6] = self.Markets[market].tradingPeriod
    info[7] = self.Markets[market].tradingFee
    return(info: arr)

def getEventInfo(event):
    info = array(8)
    info[0] = self.Info[event].creator
    info[1] = self.Info[event].creationFee
    info[2] = self.Events[event].branch
    info[3] = self.Events[event].expirationDate
    info[4] = self.Events[event].outcome
    info[5] = self.Events[event].minValue
    info[6] = self.Events[event].maxValue
    info[7] = self.Events[event].numOutcomes
    return(info: arr)

def getBranchInfo(branch):
    info = array(6)
    info[0] = self.Info[branch].creator
    info[1] = self.Info[branch].creationFee
    info[2] = self.Branches[branch].currentVotePeriod
    info[3] = self.Branches[branch].periodLength
    info[4] = self.Branches[branch].step
    info[5] = self.Branches[branch].numMarkets
    return(info: arr)

inset('fx_macros.se')
