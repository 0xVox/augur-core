type f: [a, b, c, d, e]

macro f($a) + f($b):
    f(add($a, $b))

macro f($a) - f($b):
    f(sub($a, $b))

macro f($a) * f($b):
    f(mul($a, $b) / 10000)

macro f($a) / f($b):
    f(sdiv($a * 10000, $b))

macro f($a) % f($b):
    f(smod($a, $b))

macro f($v) = f($w):
    $v = $w

macro unfify(f($a)):
    $a / 10000

macro fify($a):
    f($a * 10000)

def mean(u:a):
    # [0] Calculates the arithmetic mean.
    total = 0
    i = 0
    size = arglen(u)
    while i < size:
        total += u[i]
        i += 1
    return([total / size, total * 2^64 / size], 2)

def dot(u:a, v:a):
    # [1] Calculates the dot (inner) product of vectors.
    prod = 0
    i = 0
    while i < size:
        prod += u[i] * v[i]
        i += 1
    return(prod)

# Proportional distances from zero
macro get_weight($a:$asz):
    $total = 0
    $i = 0
    while $i < $asz:
        $total += $a[$i]
        $i += 1
    $wt = 0
    if $total == 0:
        $i = 0
        while $i < $asz:
            $wt[$i] += 1
            $i += 1
    $total = 0
    $i = 0
    while $i < $asz:
        $total += $a[$i]
        $i += 1
    $i = 0
    # $b = array($asz)
    $bfrac = array($asz)
    while $i < $asz:
        # $b[$i] = $a[$i] / $total
        $bfrac[$i] = $a[$i] * 2^64 / $total
        $i += 1
    # [$b, $bfrac]
    $bfrac

def test_macro():
    # [2] 
    u = [2, 5, 7]
    v = [6, 2, 3]
    size = 3
    # x = array_sum(u:size)
    x = get_weight(u:size)
    return(x, size)

def test_fixed():
    # [3]
    a = fify(5)
    b = fify(2)
    c = a / b
    e = c + (a / b)
    return(unfify(e))

# Sum elements of array
macro array_sum($a:$asz):
    $s = 0
    $i = 0
    while $i < $asz:
        $s += $a[$i]
        $i += 1
    $s

def test_sum():
    # [4]
    u = [2, 5, 7]
    v = [6, 2, 3]
    size = 3
    x = array_sum(u:size)
    return(x)
