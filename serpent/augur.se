# This software (Augur) allows buying and selling event options in ethereum
# Copyright (C)  2014 Chris Calderon, Joey Krug, Alan Lu, Jack Peterson
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joeykrug@gmail.com



BRANCH = 0
EVENT = 1
MARKET = 2

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](typecode, description[], creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# RepRequired is the amount of reputation required to reach quorem
# markets[] is a 0 index array of market hashes (a.k.a. marketID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the upcoming vote period
data Branches[](currentVotePeriod, markets[], marketCount, periodLength, repRequired)

# Events' index is the eventID
data Events[](branch, expirationDate, outcome)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](eventsExpDates[](numberEvents, events[], totalRepReported, reporters[][]), reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market
# Sharespurchased keeps track of the number of shares purchased for each outcome
# Participants is a 0 indexed array of participants, their cashIDs, and the shares in each outcome they've purchased of an event (events' indexes are actual event IDs)
# sharesPurchased is 0 indexed (0 is outcome 0, 1 is outcome 1, 2 is outcome 2 (notice we're on a new event here if they're binary))
   # ex: eventIndex*2 is outcome 0, eventIndex*2 + 1 is outcome one for each corresponding event 
   #    self.Markets[$marketID].sharesPurchased[$i*2]
   #    self.Markets[$marketID].sharesPurchased[$i*2 + 1]
data Markets[](branch, events[], sharesPurchased[], participants[](participantID, event[](shares[2])), lossLimit, tradingFee, numberEvents, currentParticipant, winningEvents[], alpha)

data cashcoin_balances[2^160]

def init():
	# test initial funds
	self.cashcoin_balances[tx.origin] = 1000000*2^64
	self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
	self.Reporting[1010101].reputation[0].repValue = 47
	self.Reporting[1010101].reputation[0].reporterID = tx.origin
	# number of reporters is 0 indexed
	self.Reporting[1010101].numberReporters = 0
	self.Info[1010101].typecode = 0
	self.Info[1010101].description[] = "initial branch"
	self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
	self.Info[1010101].creationFee = 10
	self.Branches[1010101].currentVotePeriod = block.number / 403200
	self.Branches[1010101].marketCount = 0
	self.Branches[1010101].periodLength = 403200
	self.Branches[1010101].repRequired = 14000000


def get_cash_balance(address):
	return(self.cashcoin_balances[address])

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
def send_cashcoin(recver, value):
	sender = tx.origin
	sender_balance = self.cashcoin_balances[sender]
	if(sender_balance >= value):
		self.cashcoin_balances[sender] -= value
		self.cashcoin_balances[recver] += value
		return(1)
	else:
		return(0)

def send_reputation(branch, recver, value):
	if(value<=0 or !self.send_cashcoin(branch, 5*2^64)):
		return(0)
	sender = tx.origin
	senderIndex = self.Reporting[branch].repIDtoIndex[sender]
	receiverIndex = self.Reporting[branch].repIDtoIndex[recver]
	# if the sender's rep. account doesn't exist, make one
	if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
			self.Reporting[branch].numberReporters += 1
			reporterIndex = self.Reporting[branch].numberReporters
			self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
			self.Reporting[branch].reputation[reporterIndex].repValue = 0
			self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
			return(text("Your reputation account was just created, earn some rep. before you can send to others"): s)

	if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
		return(text("Receiving address doesn't exist"): s)
		
	sender_balance = self.Reporting[branch].reputation[senderIndex].repValue
	if(sender_balance >= value):
		self.Reporting[branch].reputation[senderIndex].repValue -= value
		self.Reporting[branch].reputation[receiverIndex].repValue += value
		return(1)
	else:
		return(0)
		
def get_rep_balance(branch, address):
	return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)

# period length is given in blocks
# description format is branchName:description
# is there some way we can include the description bytes in the sha256 hash?
def make_subbranch(description:s, periodLength, parent, repRequired):
	if(periodLength<=0 or !self.Branches[parent].periodLength or !repRequired or description==0):
		return(0)
	branchCharacteristics = array(7)
	branchCharacteristics[0] = BRANCH
	branchCharacteristics[1] = tx.origin
	branchCharacteristics[2] = 47*2^64
	branchCharacteristics[3] = periodLength
	branchCharacteristics[4] = block.number
	branchCharacteristics[5] = parent
	branchCharacteristics[6] = repRequired

	# people can check that these characteristics hash to the ID if they want
	# people can hand a friend their new branch hash and characteristics and say, "don't trust me? check"
	branchID = sha256(branchCharacteristics, 7)
	if(!self.Branches[branchID].periodLength and !self.Info[branchID].creator and self.send_cashcoin(branchID, 47*2^64)):
		self.Info[branchID].typecode = BRANCH
		self.Info[branchID].description[] = description
		self.Info[branchID].creator = tx.origin
		self.Info[branchID].creationFee = 47*2^64
		self.Branches[branchID].periodLength = periodLength
		self.Branches[branchID].repRequired = repRequired
		self.Branches[branchID].currentVotePeriod = block.number / periodLength
		i = 0
		while i < self.Reporting[parent].numberReporters:
			self.Reporting[branchID].reputation[i].reporterID = self.Reporting[parent].reputation[i].reporterID
			self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
			i+=1
		# because there is a 0th reporter
		self.Reporting[branchID].numberReporters = i-1
		return(branchID)
	else:
		return(0)
		
def create_event(branch, description:s, expDate):
	if(self.Branches[branch].periodLength and description!=0 and expDate>block.number):
		eventCharacteristics = array(5)
		eventCharacteristics[0] = EVENT
		eventCharacteristics[1] = branch
		eventCharacteristics[2] = expDate
		eventCharacteristics[3] = tx.origin
		eventCharacteristics[4] = 42*2^64
		eventID = sha256(eventCharacteristics, 5)
	else:
		return(0)

	if (!self.Info[eventID].creator and !self.Events[eventID].branch and self.send_cashcoin(branch, 42*2^64)):
		self.Info[eventID].typecode = EVENT
		self.Info[eventID].description[] = description
		self.Info[eventID].creator = tx.origin
		self.Info[eventID].creationFee = 42*2^64
		self.Events[eventID].branch = branch
		self.Events[eventID].expirationDate = expDate
		
		# see when it expires, compare that to currentvotingperiod number and last voting period and add it in to the proper spot        
		# data Branches[](eventsExpDates[](numberEvents, events[])
		#403200 is number of blocks == 8 weeks
		# 0 means it expires in the next period
		futurePeriod = expDate / self.Branches[branch].periodLength
		self.Reporting[branch].eventsExpDates[futurePeriod].events[self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents] = eventID
		self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents += 1
		return(eventID)
	else:
		return(0)

# lossLimit is a fixedpoint syntax number (so a losslimit of 1 is 2^64) (0 if not using lmsr)
# ditto for alpha
# tradingFee is a fixedpoint number as well --- perhaps make it a percent
def create_market(branch, description:s, lossLimit, alpha, tradingFee, events:a):
	# check that events have same exp. dates and branch
	i = 0
	numEvents = len(events)
	eventsConcat = 0
	expDate = self.Events[events[0]].expirationDate
	while i < numEvents:
		event = events[i]
		eventsConcat += events[i]
		if self.Events[event].expirationDate != expDate:
			return(0)
		if self.Events[event].branch != branch:
			return(0)
		i+=1

	if(numEvents > 200 or !self.Branches[branch].periodLength or description==0 or !lossLimit or !tradingFee or (!alpha and !lossLimit)):
		return(0)
	# formation of marketID (hash)
	marketCharacteristics = array(9)
	marketCharacteristics[0] = MARKET
	marketCharacteristics[1] = tx.origin
	marketCharacteristics[2] = initialLiquidity
	marketCharacteristics[3] = branch
	marketCharacteristics[4] = eventsConcat
	marketCharacteristics[5] = numEvents
	marketCharacteristics[6] = lossLimit
	marketCharacteristics[7] = tradingFee
	marketCharacteristics[8] = alpha
	marketID = sha256(marketCharacteristics, 9)

	# if regular lmsr
	if(losslimit):
		# initialLiquidity is a fixedpoint number
		# divide by 2^64 to stay in fixedpoint
		initialLiquidity = lossLimit*self.log(numEvents*2^64)/2^64
	# ls-lmsr needs a very small initial liquidity
	elif(alpha):
		initialLiquidity = 2^62

	if(self.send_cashcoin(marketID, initialLiquidity)):
		# add event list to the market
		i = 0
		while i<numEvents:
			eventID = events[i]
			if(!self.Info[eventID].creator or self.Events[eventID].branch!=branch):
				return(0)
			# initialize market events array with eventIDs from the eventList
			self.Markets[marketID].events[i] = eventID
			i+=1

		# creator of the first market in a branch gets the branch's creation fee
		if(self.Branches[branch].marketCount==0):
			self.send_cashcoin(tx.origin, self.Info[branch].creationFee)
			
		self.Info[marketID].typecode = MARKET
		self.Info[marketID].description[] = description
		self.Info[marketID].creator = tx.origin
		self.Info[marketID].creationFee = initialLiquidity
		self.cashcoin_balances[marketID] = initialLiquidity
		self.Markets[marketID].lossLimit = lossLimit
		self.Markets[marketID].tradingFee = tradingFee
		self.Markets[marketID].branch = branch
		self.Markets[marketID].alpha = alpha
		# add the market to the branch
		marketCount = self.Branches[branch].marketCount
		self.Branches[branch].markets[marketCount] = marketID
		self.Branches[branch].marketCount += 1
		return(marketID)
	else:
		return(0)

# alpha is equal to v/(n*log(n)) where v is the max percent commission,
# and n is the number of outcomes people can trade. Alpha is set when
# a market is created.
macro ls_lmsr($marketID):
	with $Bq = 0:
		with $l = self.Markets[$marketID].numberEvents:
			with $i = 0:
				while $i < $l:
					$Bq += self.Markets[$marketID].sharesPurchased[$i*2]
					$Bq += self.Markets[$marketID].sharesPurchased[$i*2 + 1]
					$i += 1
				$Bq *= self.Markets[$marketID].alpha
				$i = 0
				with $sum_exp = 0:
					with $a = 0:
						with $b = 0:
							while $i < $l:
								$a = self.Markets[$marketID].sharesPurchased[$i*2]
								$b = self.Markets[$marketID].sharesPurchased[$i*2 + 1]
								$sum_exp += self.exp($a*2^64/$Bq)
								$sum_exp += self.exp($b*2^64/$Bq)
								$i += 1
							$Bq*self.log($sum_exp)/2^64

macro lmsr($marketID):
	with $sum_exp = 0:
		with $B = self.Markets[$marketID].lossLimit:
			with $l = self.Markets[$marketID].numberEvents:
				with $i = 0:
					with $a = 0:
						with $b = 0:
							while $i < $l:
								$a = self.Markets[$marketID].sharesPurchased[$i*2]
								$b = self.Markets[$marketID].sharesPurchased[$i*2 + 1]
								$sum_exp += self.exp($a*2^64/$B)
								$sum_exp += self.exp($b*2^64/$B)
								$i += 1
							$B*self.log($sum_exp)/2^64

# fee should be in fixed point
# amount of shares should be an integer
# trading fees go to branch directly and are distributed upon rbcr
# cost of shares go directly to the market
# so markets using lmsr should charge a higher fee here because the market creator will get less as fees from market making
# ls-lmsr markets won't have much in fees in the branch, so the market creator will thus get a lot of fees himself hmmm...
# is there a way to pool ls-lmsr fees separately?
def buy_shares(branch, event, market, outcome, amount, fee):
	if (block.number >= self.Events[event].expirationDate or fee<self.Markets[market].tradingFee or self.Events[event].branch!=branch or self.cashcoin_balances[tx.origin]<fee):
		return(0)
	# pay one-fourth of trading fee to market creator via sending to market.creator
	# other half is stored in branchID cashcoin balance
	self.cashcoin_balances[tx.origin] -= fee
	marketCreatorFee = fee - (3*fee)/4
	self.cashcoin_balances[self.Info[market].creator] += marketCreatorFee
	self.cashcoin_balances[branch] += (3*fee)/4
	
	# find the right event index
	i = 0
	while (i<self.Markets[market].numberEvents):
		if(self.Markets[market].events[i] == event):
			break
		else:
			i+=1
	# event doesn't exist in index
	if(i==self.Markets[market].numberEvents):
		return(0)
	oldCost = 0
	newCost = 0
	# using ls-lmsr
	if(self.Markets[market].alpha):
		# for the first trade's oldcost shares bought will be at 0
		# only 2 outcomes poss. for now
		oldCost = ls_lmsr(market)
		# if buying outcome 1
		if outcome:
			self.Markets[market].sharesPurchased[i*2+1] += amount
		# outcome is no
		else:
			self.Markets[market].sharesPurchased[i*2] += amount
		newCost = ls_lmsr(market) 
	# regular lmsr
	else:
		if(self.Markets[market].lossLimit):
			# for the first trade's oldcost shares bought will be at 0
			# only 2 outcomes poss. for now
			oldCost = lmsr(market)
			# if buying outcome 1
			if outcome:
				self.Markets[market].sharesPurchased[i*2+1] += amount
			# outcome is no
			else:
				self.Markets[market].sharesPurchased[i*2] += amount
			newCost = lmsr(market) 

	# these prices are in fixed point
	pricePerShare = newCost - oldCost
	participantNumber = self.Markets[market].currentParticipant
	
	# send shares of the event to user address
	if outcome:
		# if user doesn't have enough money, revert
		if(self.cashcoin_balances[tx.origin]<amount*pricePerShare):
			self.Markets[market].sharesPurchased[i*2+1] -= amount
			return(0)
		else:
			# send ether from user acc. to market address/account
			self.send_cashcoin(market, pricePerShare*amount)
			self.Markets[market].participants[participantNumber].participantID = tx.origin
			self.Markets[market].participants[participantNumber].event[event].shares[1] += amount
			self.Markets[market].currentParticipant += 1
			return(participantNumber)
			
	# outcome 0
	else:
		# if user doesn't have enough money, revert
		if(self.cashcoin_balances[tx.origin]<amount*pricePerShare):
			self.Markets[market].sharesPurchased[i*2] -= amount
			return(0)
		else:
			# send ether from user acc. to market address/account
			self.send_cashcoin(market, pricePerShare*amount)
			self.Markets[market].participants[participantNumber].participantID = tx.origin
			self.Markets[market].participants[participantNumber].event[event].shares[0] += amount
			self.Markets[market].currentParticipant += 1
			return(participantNumber)
			

# amount is amount of shares to buy
# instead of inputting particip. num could just loop through array if dont have it
# fee should be fixed point
def sell_shares(branch, event, market, outcome, amount, fee, participantNumber):
	# When sell check that event hasn't expired
	if (block.number >= self.Events[event].expirationDate or fee<self.Markets[market].tradingFee or self.Markets[market].participants[participantNumber].participantID != tx.origin or self.Events[event].branch!=branch or self.cashcoin_balances[tx.origin]<fee):
		return(0)

	# pay one-fourth of trading fee to market creator via sending to market.creator
	# other half is stored in branchID cashcoin balance
	self.cashcoin_balances[tx.origin] -= fee
	marketCreatorFee = fee - (3*fee)/4
	self.cashcoin_balances[self.Info[market].creator] += marketCreatorFee
	self.cashcoin_balances[branch] += (3*fee)/4

	# find the right event index
	i = 0
	while (i<self.Markets[market].numberEvents):
		if(self.Markets[market].events[i] == event):
			break
		else:
			i+=1
	# event doesn't exist in index
	if(i==self.Markets[market].numberEvents):
		return(0)

	# for the first trade oldcost shares bought will be at 0
	oldCost = 0
	newCost = 0
	# using ls-lmsr
	if(self.Markets[market].alpha):
		oldCost = ls_lmsr(market)
		# send unspent shares from the user to the event
		if outcome:
			self.Markets[market].sharesPurchased[i*2+1] -= amount
		# outcome is no
		else:
			self.Markets[market].sharesPurchased[i*2] -= amount
		newCost = ls_lmsr(market)
	# using lmsr
	else:
		if(self.Markets[market].lossLimit):
			oldCost = lmsr(market)
			# send unspent shares from the user to the event
			if outcome:
				self.Markets[market].sharesPurchased[i*2+1] -= amount
			# outcome is no
			else:
				self.Markets[market].sharesPurchased[i*2] -= amount
			newCost = ls_lmsr(market)

	# these prices are in fixed point
	priceToPayPerShare = oldCost - newCost
	# remove shares from the user's account
	if outcome:
		# if user actually doesn't have the shares, revert
		if(self.Markets[market].participants[participantNumber].event[event].shares[1]<amount):
			self.Markets[market].sharesPurchased[i*2+1] += amount
			return(0)
		else:
			# send bitcoin from the market to the user acc.
			self.cashcoin_balances[market] -= priceToPayPerShare*amount
			self.cashcoin_balances[tx.origin] += priceToPayPerShare*amount
			self.Markets[market].participants[participantNumber].event[event].shares[1] -= amount
			return(1)
	else:
		# if user actually doesn't have the shares, revert
		if(self.Markets[market].participants[participantNumber].event[event].shares[0]<amount):
			self.Markets[market].sharesPurchased[i*2] += amount
			return(0)
		else:
			# send bitcoin from the market to the user acc.
			self.cashcoin_balances[market] -= priceToPayPerShare*amount
			self.cashcoin_balances[tx.origin] += priceToPayPerShare*amount
			self.Markets[market].participants[participantNumber].event[event].shares[0] -= amount
			return(1)

def queryShareCost():
	return(1)

#check if the eventID is in the currentvotingperiod pointed to by the branchID's currentVotePeriod 
def inPeriod(branchID, eventID):
	votePeriod = self.Branches[branchID].currentVotePeriod
	i = 0
	while i < self.Reporting[branchID].eventsExpDates[votePeriod].numberEvents:
		if(eventID==self.Reporting[branchID].eventsExpDates[votePeriod].events[i]):
			return(1)
		i += 1
	return(0)

# a no vote is -2^64, a yes vote is 2^64 and a can't determine vote is 2^63 (a empty ballot is 0)
# atm voters who do vote are req. to vote on all things in their respective ballots (even if just a 0 / no vote)
# ui should handle this ^
# ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents
# and loop through the events[] array from 0 to numberEvents -1 for the votes list / order
# should make an API function for this (make ballot)!!!
# UI will need a function to get the items in that array above so it can make a report!
def vote(branch, report:a):
	# make sure the branch exists
	repIndex = self.Reporting[branch].repIDtoIndex[tx.origin]
	# need report length to be same as number of items in the current eventexpdates voting period events!
	if(len(report)!=self.Reporting[branch].eventsExpDates[self.Branches[branch].currentVotePeriod].numberEvents):
		return(0)

	# if current period is more than 2 periods past the vote period
	# then there can be no more voting for that voting period
	# (reasoning being: >1 period past means all the events in that period have expired)
	# (>2 periods past mean the events have exp. & people have had 1 full period to vote)
	# currently requires events to expire to vote
	currentPeriod = block.number / self.Branches[branch].periodLength
	if (self.Reporting[branch].reputation[repIndex].reporterID != tx.origin | currentPeriod > (self.Branches[branch].currentVotePeriod+2) | currentPeriod < (self.Branches[branch].currentVotePeriod+1)):
		return(0)

	reputation = self.Reporting[branch].reputation[repIndex].repValue

	i = 0
	while i < len(report):
		if (report[i] != 2^64 | report[i] != -2^64 | report[i] != 0 | report[i] != 2^63):
			return(0) # make sure vote values are valid
		else:
			if(!self.inPeriod(branch, report[i])):
				return(0)
		i += 1

	# need to update stuff for quorem
	# and store the report and the rep value
	while i < len(report):
		self.Reporting[branchID].eventsExpDates[0].reporters[tx.origin][i] = report[i]
		i+=1
	self.Reporting[branchID].eventsExpDates[self.Branches[branchID].currentVotePeriod].totalRepReported += reputation
	return(1)


# returns whether a quorem has a matured event and whether
# the number of required reports are met as a tuple (matured, met)
def check_quorum(branch):
	currentPeriod = block.number / self.Branches[branch].periodLength
	# provided the currentPeriod is >2 periods past the things we're going to rbcr on
	# we can then conclude it has matured and people have had time to vote
	if (currentPeriod > (self.Branches[branch].currentVotePeriod+2)):
		matured = true
	else:
		matured = false
	currentVotePeriod = self.Branches[branchID].currentVotePeriod
	# check that enough people actually did vote
	if (self.Reporting[branch].eventsExpDates[currentVotePeriod].totalRepReported >= self.Branches[branch].repRequired):
		met = true
	else:
		met = false
	if(met and matured):
		return(1)
	else:
		return(0)
		
# perhaps give the redeemer some fees to cover svd costs
# 25% of fees already distributed to market creators
# so 2/3 of remaining fees to voters = 50%
# and 1/3 of remaining fees to event creators = 25%
def redeem(branch):
	if(!self.check_quorum(branch)):
		return(text("quorem not satisfied yet"): s)
	currentVotePeriod = self.Branches[branchID].currentVotePeriod
	# loop through reputation and check if in reporters, if so use their report, if not use the fillin / not reported report
	# use this to make a giant array of votes to pass to self.consensus
	# want to pass votes for each 0 indexed event in order (so we get votes from an actual reporter)
	# (if they didn't vote we set their array for each event to 0,0,0,0,0,0, etc...)
	reputation = array(self.Reporting[branch].numberReporters-1)
	#votes = array(self.Reporting[branch].numberReporters-1)
	numberEvents = self.Reporting[branch].eventsExpDates[currentvotePeriod].numberEvents
	numReporters = self.Reporting[branch].numberReporters
	votes = array(numReporters * numberEvents)

	i = 0
	while i < numReporters:
		# checks to see if each reporter actually voted on any events
		reporterID = self.Reporting[branch].reputation[i].reporterID
		reputation[i] = self.Reporting[branch].reputation[i].repValue

		# if they didn't vote do nothing (these values will be 0 by default due to Serpent array styles)

		# else if the reporter did report on events (check if they voted on first event)
		if(self.Reporting[branch].eventsExpDates[currentVotePeriod].reporters[reporterID][0] != 0):
			x = 0
			while x < numberEvents:
				votes[x + i*numberEvents] = self.Reporting[branch].eventsExpDates[currentVotePeriod].reporters[reporterID][x]
				x += 1
		i += 1

	# populate returned arrays
	megaArray = self.consensus(votes, reputation)
	outcomes_final = array(numberEvents)
	event_bonus = array(numberEvents)
	voter_bonus = array(numReporters)
	a = 0
	while a < numberEvents:
		outcomes_final[a] = megaArray[a]
		a+=1
	b = numberEvents
	while b < (2*numberEvents):
		event_bonus[b] = megaArray[b]
		b+=1
	c = (2*numberEvents)
	while c < numReporters:
		voter_bonus[c] = megaArray[c]
		c+=1

	# get event ID for each event by taking the x index in the votes arrays - shoving it in reporting.events[]
	# and getting the cooresponding ID
	n = 0
	while n < numberEvents:
		eventID = self.Reporting[branch].eventsExpDates[currentVotePeriod].events[n]
		# then take outcomes_final and set each event outcome to -1 if false or 1 if true
		if(outcomes_final[n]==-1):
			self.Events[eventID].outcome = -1
		elif(outcomes_final[n]==1):
			self.Events[eventID].outcome = 1
		# need to loop through eventid holders and distribute 25% coins using the event_bonus to determine how much
		# of the 25% each get
		self.cashcoin_balances[self.Info[eventID].creator] += fixed_multiply(event_bonus[n], self.cashcoin_balances[branch]) / 3
		self.cashcoin_balances[branch] -= fixed_multiply(event_bonus[n], self.cashcoin_balances[branch]) / 3

	# need to loop through rep holders and distribute 50% of branch fees to voters' cashcoin addresses 
	# (use 2/3 because 25% was distributed in market creation)
	# also need to take voter_bonus and redistribute reputation in the Reporting structure accordingly
	z = 0
	while z < numReporters:
		self.Reporting[branch].reputation[z].repValue += (voter_bonus[z]*21000000)/2^64
		self.cashcoin_balances[self.Reporting[branch].reputation[z].reporterID] += 2*self.cashcoin_balances[branch] / (3*numReporters)
		self.cashcoin_balances[branch] -= 2*self.cashcoin_balances[branch] / (3*numReporters)
	self.Branches[branch].currentVotePeriod += 1
	return(self.Branches[branch].currentVotePeriod)


# loop through events in the market, get their outcomes and use those to determine the winning events!
# distribute coins among winning events
# only works for inTrade style 1 event in a market predictions at the moment
def close_market(branch, market):
	if(self.cashcoin_balances[market]<=0):
		return(0)
	currentPeriod = block.number / self.Branches[branch].periodLength
	numberEvents = self.Markets[market].numberEvents
	eventVotePeriod = self.Events[self.Markets[market].events[numberEvents-1]].expirationDate / self.Branches[branch].periodLength
	if(currentPeriod > (eventVotePeriod+2) && self.Reporting[branch].eventsExpDates[currentPeriod].totalRepReported >= self.Branches[branch].repRequired):
		# give back initial liquidity
		#self.cashcoin_balances[market] -= self.Info[market].creationFee
		#self.cashcoin_balances[self.Info[market].creator] += self.Info[market].creationFee
		# get # of shares of winning outcome

		# loop through events in the market, get their outcomes and use those to determine the winning events!
		n = 0
		e = 0
		while n < numberEvents:
			if(self.Events[self.Markets[market].events[n]].outcome):
				self.Markets[market].winningEvents[e] = self.Markets[market].events[n]
				e+=1
			n+=1

		winningShares = 0
		# number of winning events is equivalent to e
	 	#   a = 0
	 	#   while a < e:
	 	#   self.Markets[market].events[self.Markets[market].winningEvents[e]].shares

		winningEvent = self.Markets[market].winningEvents[e-1]
		winningShares = 0
		winningOutcome = self.Events[winningEvent].outcome
		winningSharesIndex = 0
		if(winningOutcome==1):
			winningShares = self.Markets[market].sharesPurchased[(2*(n-1) + 1)]
			winningSharesIndex = 1
		elif(winningOutcome==-1):
			winningShares = self.Markets[market].sharesPurchased[2*(n-1)]
			winningSharesIndex = 0
		elif(winningOutcome==0):
			return(text("outcome hasn't been decided yet"): s)
		# distribute cashcoin to the people who won money by holding winning shares
		i = 0
		while i <= self.Markets[market].currentParticipant:
			sharesOwned = self.Markets[market].participants[i].event[winningEvent].shares[winningSharesIndex]
			participant = self.Markets[market].participants[i].participantID
			# winning price is $1 / share
			# pricePerShare = 2^64
			#moneyWon = sharesOwned*pricePerShare
			self.cashcoin_balances[market] -= sharesOwned*2^64
			self.cashcoin_balances[participant] += sharesOwned*2^64

		# give back initial liquidity (or as much of it/profits are left)
		self.cashcoin_balances[self.Info[market].creator] += self.cashcoin_balances[market]
		self.cashcoin_balances[market] -= self.cashcoin_balances[market]
		return(text("Market closed"): s)

# includes
#extern fp:[new, mul, div, intpart, fracpart, log, exp, pow, sqrt]
#FixedPoint = create('fixedpoint.se')
inset('fixedpoint.se')
inset('consensus.se')