# This software (Augur) allows buying and selling event options in ethereum
# Copyright (C)  2014 Chris Calderon, Joey Krug, Alan Lu, Jack Peterson
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joeykrug@gmail.com

# includes
#extern fp:[new, mul, div, intpart, fracpart, log, exp, pow, sqrt]
#FixedPoint = create('fixedpoint.se')
inset('fixedpoint.se')
inset('consensus.se')

BRANCH = 0
EVENT = 1
MARKET = 2

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](typecode, description[], creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# LastPeriodEnd is the last voting period's block number
# Parent is the branch's parent branch.
# Branches' index is the hash of the branch (aka branchID)
# RepRequired is the amount of reputation required to reach quorem
data Branches[](currentVotePeriod, markets[], marketCount, periodLength, parent, repRequired)

# Events' index is the eventID
data Events[](branch, expirationDate, outcome)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](eventsExpDates[](numberEvents, events[], totalRepReported, reporters[][]), reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market
# Sharespurchased keeps track of the number of shares purchased for each outcome
# Participants is a 0 indexed array of participants, their cashIDs, and the shares in each outcome they've purchased of an event
data Markets[](branch, events[](eventID, sharesPurchased[2]), participants[](participantID, event[](shares[2])), lossLimit, tradingFee, numberEvents, currentParticipant, winningEvents[])

data cashcoin_balances[2^160]


### Version 2.0:
    # blockchain explorer to get / examine data or make rpc api calls to the contract to get it
    # local contract calls don't cost gas
    # Scalar event where people update what type of share they bought using a thing
    # in an array where index is their scalar x and value
    # is the share updated number of shares bought
    # how do we make this code updatable
    # how do we scale / what if a ton of events, markets, etc.
    # api voting option
    # seigniorage
    # update data structure to have reporting have markets instead of events poss.
    # if current vote period is == 0 then we looped past 2^256 --- set values in array to 0 at that point
    # may need a ballot max size b/c cost so need a systematic way to do voting (e.g. vote on first xxx events, then next set are another ballot)
    # randomized voter selection? - first x events expiring vote on in one ballot - random selection, then another ballot
    # new market maker
    # make sure events voting periods are properly setup


### To do:
    # make sure this follows paul's whitepaper well
    # proper mult. div (perhaps store all cashcoin balances as fixed)
    # add a branch initial rbcr rapid period to start w/
    # make so eventsexpdates currentindex -1 is the stuff we actually vote on in redeem tx
    # fast voting cycle first few days to get the 60% problem away from a branch, e.g. what if not enough people vote
    # 60% of votes -- need to get the cycle length parameters right
    # make transaction fee a percent of trade if doing lmsr and not Abe's
    # fix any and fix vote
    # ui functions

def init():
    # test initial funds
    cashcoin_balances[0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826] = 1000000
    self.Reporting[1010101].repIDtoIndex["chris and joey's rep"] = 0
    self.Reporting[1010101].reputation[0].repValue = 47
    self.Reporting[1010101].reputation[0].reporterID = "chris and joey's rep"
    # number of reporters is 0 indexed
    self.Reporting[1010101].numberReporters = 0
    self.Info[1010101].typecode = 0
    self.Info[1010101].description[] = "initial branch"
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Branches[1010101].currentVotePeriod = block.number / 403200
    self.Branches[1010101].marketCount = 0
    self.Branches[1010101].periodLength = 403200
    self.Branches[1010101].lastPeriodEnd = block.number
    self.Branches[1010101].parent = 0
    self.Branches[1010101].repRequired = 14000000


def get_cash_balance(address):
    return(self.cashcoin_balances[address])
    
def send_cashcoin(recver, value):
    sender = tx.origin
    sender_balance = self.cashcoin_balances[sender]
    if(sender_balance >= value):
        self.cashcoin_balances[sender] -= value
        self.cashcoin_balances[recver] += value
        return(1)
    else:
        return(0)

def send_reputation(branch, recver, value):
    if(value<=0 or !self.send_cashcoin(branch, 5)):
        return(0)
    sender = tx.origin
    senderIndex = self.Reporting[oldBranch].repIDtoIndex[sender]
    receiverIndex = self.Reporting[newBranch].repIDtoIndex[recver]
    # if the sender's rep. account doesn't exist, make one
    if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
            self.Reporting[branch].numberReporters += 1
            reporterIndex = self.Reporting[branch].numberReporters
            self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
            self.Reporting[branch].reputation[reporterIndex].repValue = 0
            self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
            return("Your reputation account was just created, earn some rep. before you can send to others")

    if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
        return("Receiving address doesn't exist")
        
    sender_balance = self.Reporting[branch].reputation[senderIndex].repValue
    if(sender_balance >= value):
        self.Reporting[branch].reputation[senderIndex].repValue -= value
        self.Reporting[branch].reputation[receiverIndex].repValue += value
        return(1)
    else:
        return(0)
        
def get_rep_balance(branch, address):
    return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)
    
def send_rep_diffbranch(oldBranch, recver, value, newBranch):
        # check branch is a subbranch
        tempID = Branches[newBranch].parent
        while tempID != oldBranch and tempID != 0 and Branches[tempID].periodLength != 0:
            tempID = Branches[tempID].parent

        if tempID != oldBranch:
            return(0)

        # if no branch exists (defined as a nonzero period)
        if(!self.Branches[oldBranch].periodLength | !self.Branches[newBranch].periodLength | value<=0 | !self.send_cashcoin(oldBranch, 10)):
            return(0)
        sender = tx.origin
        senderIndex = self.Reporting[oldBranch].repIDtoIndex[sender]
        receiverIndex = self.Reporting[newBranch].repIDtoIndex[recver]
        # if the sender's rep. account doesn't exist, make one
        if(self.Reporting[oldBranch].reputation[senderIndex].reporterID!=tx.origin):
                self.Reporting[oldBranch].numberReporters += 1
                reporterIndex = self.Reporting[oldBranch].numberReporters
                self.Reporting[oldBranch].repIDtoIndex[tx.origin] = reporterIndex
                self.Reporting[oldBranch].reputation[reporterIndex].repValue = 0
                self.Reporting[oldBranch].reputation[reporterIndex].reporterID = tx.origin
                return("Your reputation account was just created, earn some rep. before you can send to others")

        if(self.Reporting[newBranch].reputation[receiverIndex].reporterID!=recver):
            self.Reporting[newBranch].numberReporters += 1
            reporterIndex = self.Reporting[newBranch].numberReporters
            self.Reporting[newBranch].repIDtoIndex[tx.origin] = reporterIndex
            self.Reporting[newBranch].reputation[reporterIndex].repValue = 0
            self.Reporting[newBranch].reputation[reporterIndex].reporterID = recver
            return("Receiving address doesn't exist on sub branch, just made one on it")
      
        else:
            sender_balance = self.Reporting[oldBranch].reputation[senderIndex].repValue
            if(sender_balance >= value):
                self.Reporting[oldBranch].reputation[senderIndex].repValue -= value
                self.Reporting[newBranch].reputation[receiverIndex].repValue += value
                return(1)
            else:
                return(0)

# period length is given in blocks
# description format is branchName:description
def make_subbranch(description:s, periodLength, parent, repRequired):
    if(!periodLength or !self.Branches[parent].periodLength or !repRequired or description=0):
        return(0)
    branchCharacteristics = array(8)
    branchCharacteristics[0] = BRANCH
    branchCharacteristics[1] = description
    branchCharacteristics[2] = tx.origin
    branchCharacteristics[3] = 47
    branchCharacteristics[4] = periodLength
    branchCharacteristics[5] = block.number
    branchCharacteristics[6] = parent
    branchCharacteristics[7] = repRequired

    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash and characteristics and say, "don't trust me? check"
    branchID = sha256(eventCharacteristics, 8)
    if(!self.Branches[branchID].periodLength and !self.Info[branchID].creator and self.send_cashcoin(branchID, 47)):
        self.Info[branchID].typecode = BRANCH
        self.Info[branchID].description[] = description
        self.Info[branchID].creator = tx.origin
        self.Info[branchID].creationFee = 47
        self.Branches[branchID].periodLength = periodLength
        self.Branches[branchID].lastPeriodEnd = block.number
        self.Branches[branchID].parent = parent
        self.Branches[branchID].repRequired = repRequired
        self.Branches[branchID].currentVotePeriod = block.number / periodLength
        i = 0
        while i < self.Reporting[parent].numberReporters:
            self.Reporting[branchID].reputation[i].reporterID = self.Reporting[parent].reputation[i].reporterID
            self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
            i+=1
        return(1)
    else:
        return(0)
        
def create_event(branch, description:s, expDate):
    if(self.Branches[branch].periodLength and description!=0 and expDate>block.number):
        eventCharacteristics = array(6)
        eventCharacteristics[0] = description
        eventCharacteristics[1] = EVENT
        eventCharacteristics[2] = branch
        eventCharacteristics[3] = expDate
        eventCharacteristics[4] = tx.origin
        eventCharacteristics[5] = 42
        eventID = sha256(eventCharacteristics, 6)
    else:
        return(0)

    if (!self.Info[eventID].creator and !self.Events[eventID].branch and self.send_cashcoin(branch, 42)):
        self.Info[eventID].typecode = EVENT
        self.Info[eventID].description[] = description
        self.Info[eventID].creator = tx.origin
        self.Info[eventID].creationFee = 42
        self.Events[eventID].branch = branch
        self.Events[eventID].expirationDate = expDate
        
        # see when it expires, compare that to currentvotingperiod number and last voting period and add it in to the proper spot        
        # data Branches[](eventsExpDates[](numberEvents, events[])
        #403200 is number of blocks == 8 weeks
        # 0 means it expires in the next period
        futurePeriod = expDate / self.Branches[branch].periodLength
        self.Reporting[branch].eventsExpDates[futurePeriod].events[self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents] = eventID
        self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents += 1
        return(1)
    else:
        return(0)

# lossLimit is a fixedpoint syntax number
# give this function another once over
def create_market(branch, description:s, lossLimit, tradingFee, events:a):
    # check that events have same exp. dates
    x = 0
    while x < arglen(events):
        if(self.Events[events[i]].expirationDate != self.Events[events[i+1]].expirationDate and (i+1)!=arglen(events)):
            return(0)
        x+=1

    # gotta remember to divide by 2^64 when multiplying fixed point numbers
    initialLiquidity = lossLimit*self.log(arglen(events)) / 2^64
    if(arglen(events) > 200 or self.cashcoin_balances[tx.origin]<initialLiquidity or !self.Branches[branch].periodLength or description=0 or !lossLimit or !tradingFee):
        return(0)
    # formation of marketID (hash)
    marketCharacteristics = array(9)
    marketCharacteristics[0] = MARKET
    marketCharacteristics[1] = description
    marketCharacteristics[2] = tx.origin
    marketCharacteristics[3] = initialLiquidity
    marketCharacteristics[4] = branch
    marketCharacteristics[5] = events
    marketCharacteristics[6] = arglen(events)
    marketCharacteristics[7] = lossLimit
    marketCharacteristics[8] = tradingFee
    marketID = sha256(marketCharacteristics, 9)

    if(self.send_cashcoin(marketID, initialLiquidity)):
        # add event list to the market
        i = 0
        while i<arglen(events):
            eventID = events[i]
            if(!self.Info[eventID].creator or self.Events[eventID].branch!=branch):
                return(0)
            # initialize market events array with eventIDs from the eventList
            self.Markets[marketID].events[i].eventID = eventID
            i+=1

        # creator of the first market in a branch gets the branch's creation fee
        if(self.Branches[branch].marketCount==0):
            self.send_cashcoin(tx.origin, self.Info[branch].creationFee)
            
        self.Info[marketID].typecode = MARKET
        self.Info[marketID].description[] = description
        self.Info[marketID].creator = tx.origin
        self.Info[marketID].creationFee = initialLiquidity
        self.cashcoin_balances[marketID] = initialLiquidity
        self.Markets[marketID].lossLimit = lossLimit
        self.Markets[marketID].tradingFee = tradingFee
        self.Markets[marketID].numberEvents = numberEvents
        self.Markets[marketID].branch = branch
        # add the market to the branch
        marketCount = self.Branches[branch].marketCount
        self.Branches[branch].markets[marketCount] = marketID
        self.Branches[branch].marketCount += 1
        return(1)
    else:
        return(0)

# alpha is equal to v/(n*log(n)) where v is the max percent commission,
# and n is the number of outcomes people can trade. Alpha is set when
# a market is created.
macro abe_msr($shares:$numShares, $alpha):
    with Bq = 0:
        with i = 0:
            while i < $numShares:
                Bq += $shares[i]
                i += 1
            Bq = Bq * $alpha / 2^64
        with sum_of_exps = 0:
            with i = 0:
                while i < $numShares:
                    sum_of_exps += self.exp($shares[i]) * 2^64 / Bq
                    i += 1
            Bq * self.log(sum_of_exps) / 2^64

# make this a macro
#def lmsr(shares:a, lossLimit):
#    # *** LOGARITHMIC MARKET SCORING RULE ***
#    #(like a regular market scoring rule, except it uses logarithms)
#    # this need sto be updated with Abe's stuff!
#    stop = arglen(shares)
#    i = 0
#    res = 0
#    while i < stop:
#        res += FixedPoint.exp(FixedPoint.div(shares[i], lossLimit, as=fp), as=fp)
#        i += 1
#    logpf = FixedPoint.log(res, as=fp)
#    cost = FixedPoint.mul(lossLimit, logpf, as=fp)
#    return(cost)

def buy_shares(branch, event, market, outcome, amount, fee):
    if (block.number >= self.Events[event].expirationDate or fee<self.Markets[market].tradingFee or self.Events[event].branch!=branch or self.cashcoin_balances[tx.origin]<fee):
        return(0)
    # pay one-fourth of trading fee to market creator via sending to market.creator
    # other half is stored in branchID cashcoin balance
    self.cashcoin_balances[tx.origin] -= fee
    marketCreatorFee = fee - (3*fee)/4
    self.cashcoin_balances[self.Info[market].creator] += marketCreatorFee
    self.cashcoin_balances[branch] += (3*fee)/4
    
    # find the right event index
    i = 0
    while (i<self.Markets[market].numberEvents):
        if(self.Markets[market].events[i].eventID == event):
            break
        else:
            i+=1
    # event doesn't exist in index
    if(i==self.Markets[market].numberEvents):
        return(0)

    # for the first trade's oldcost shares bought will be at 0
    # only 2 outcomes poss. for now
    oldCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[]:2, self.Markets[market].lossLimit)
    # if buying outcome 1
    if outcome:
        self.Markets[market].events[i].sharesPurchased[1] += amount
    # outcome is no
    else:
        self.Markets[market].events[i].sharesPurchased[0] += amount
    newCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[]:2, self.Markets[market].lossLimit) 
    pricePerShare = newCost - oldCost
    participantNumber = self.Markets[market].currentParticipant
    
    # send shares of the event to user address
    if outcome:
        # if user doesn't have enough money, revert
        if(self.cashcoin_balances[tx.origin]<amount*pricePerShare):
            self.Markets[market].events[i].sharesPurchased[1] -= amount
            return(0)
        else:
            # send ether from user acc. to market address/account
            self.send_cashcoin(market, pricePerShare*amount)
            self.Markets[market].participants[participantNumber].participantID = tx.origin
            self.Markets[market].participants[participantNumber].event[event].shares[1] += amount
            self.Markets[market].currentParticipant += 1
            return(participantNumber)
            
    # outcome 0
    else:
        # if user doesn't have enough money, revert
        if(self.cashcoin_balances[tx.origin]<amount*pricePerShare):
            self.Markets[market].events[i].sharesPurchased[0] -= amount
            return(0)
        else:
            # send ether from user acc. to market address/account
            self.send_cashcoin(market, pricePerShare*amount)
            self.Markets[market].participants[participantNumber].participantID = tx.origin
            self.Markets[market].participants[participantNumber].event[event].shares[0] += amount
            self.Markets[market].currentParticipant += 1
            return(participantNumber)
            

# amount is amount of shares to buy
# instead of inputting particip. num could just loop through array if dont have it
def sell_shares(branch, event, market, outcome, amount, fee, participantNumber):
    # When sell check that event hasn't expired
    if (block.number >= self.Events[event].expirationDate or fee<self.Markets[market].tradingFee or self.Markets[market].participants[participantNumber].participantID != tx.origin or self.Events[event].branch!=branch or self.cashcoin_balances[tx.origin]<fee):
        return(0)

    # pay one-fourth of trading fee to market creator via sending to market.creator
    # other half is stored in branchID cashcoin balance
    self.cashcoin_balances[tx.origin] -= fee
    marketCreatorFee = fee - (3*fee)/4
    self.cashcoin_balances[self.Info[market].creator] += marketCreatorFee
    self.cashcoin_balances[branch] += (3*fee)/4

    # find the right event index
    i = 0
    while (i<self.Markets[market].numberEvents):
        if(self.Markets[market].events[i].eventID == event):
            break
        else:
            i+=1
    # event doesn't exist in index
    if(i==self.Markets[market].numberEvents):
        return(0)

    # for the first trade oldcost shares bought will be at 0
    oldCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[]:2, self.Markets[market].lossLimit)
    # send unspent shares from the user to the event
    if outcome:
        self.Markets[market].events[i].sharesPurchased[1] -= amount
    # outcome is no
    else:
        self.Markets[market].events[i].sharesPurchased[0] -= amount
    newCost = self.lmsr(self.Markets[market].events[i].sharesPurchased[]:2, self.Markets[market].lossLimit)
    priceToPayPerShare = oldCost - newCost
    # remove shares from the user's account
    if outcome:
        # if user actually doesn't have the shares, revert
        if(self.Markets[market].participants[participantNumber].event[event].shares[1]<amount):
            self.Markets[market].events[i].sharesPurchased[1] += amount
            return(0)
        else:
            # send bitcoin from the market to the user acc.
            self.cashcoin_balances[market] -= priceToPayPerShare*amount
            self.cashcoin_balances[tx.origin] += priceToPayPerShare*amount
            self.Markets[market].participants[participantNumber].event[event].shares[1] -= amount
            return(1)
    else:
        # if user actually doesn't have the shares, revert
        if(self.Markets[market].participants[participantNumber].event[event].shares[0]<amount):
            self.Markets[market].events[i].sharesPurchased[0] += amount
            return(0)
        else:
            # send bitcoin from the market to the user acc.
            self.cashcoin_balances[market] -= priceToPayPerShare*amount
            self.cashcoin_balances[tx.origin] += priceToPayPerShare*amount
            self.Markets[market].participants[participantNumber].event[event].shares[0] -= amount
            return(1)

def queryShareCost():
    return(1)

#check if the eventID is in the currentvotingperiod pointed to by the branchID's currentVotePeriod 
def inPeriod(branchID, eventID):
    votePeriod = self.Branches[branchID].currentVotePeriod
    i = 0
    while i < self.Reporting[branchID].eventsExpDates[votePeriod].numberEvents:
        if(eventID==self.Reporting[branchID].eventsExpDates[votePeriod].events[i]):
            return(1)
        i += 1
    return(0)

# make sure people can change their vote during the voting period
# a no vote is -2^64, a yes vote is 2^64 and a can't determine vote is 2^63 (a empty ballot is 0)
# atm voters who do vote are req. to vote on all things in their respective ballots (even if just a 0 / no vote)
# ui should handle this ^
# need report length to be same as number of items in the current eventexpdates voting period events!
# ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[futurePeriod].
# numberEvents and loop through the events[] array from 0 to numberEvents -1 for the votes list / order
# UI will need a function to get the items in that array above so it can make a report!
def vote(branch, report:a):
    # make sure the branch exists
    repIndex = self.Reporting[branch].repIDtoIndex[tx.origin]

    if(arglen(report)!=self.Reporting[branch].eventsExpDates[self.Branches[branch].currentVotePeriod].numberEvents):
        return(0)

    # if current period is more than 2 periods past the vote period
    # then there can be no more voting for that voting period
    # (reasoning being: >1 period past means all the events in that period have expired)
    # (>2 periods past mean the events have exp. & people have had 1 full period to vote)
    # currently requires events to expire to vote
    currentPeriod = block.number / self.Branches[branch].periodLength
    if (self.Branches[branch].lastPeriodEnd == 0 | self.Reporting[branch].reputation[repIndex].reporterID != tx.origin | currentPeriod > (self.Branches[branch].currentVotePeriod+2) | currentPeriod < (self.Branches[branch.currentVotePeriod+1])):
        return(0)

    reputation = self.Reporting[branch].reputation[repIndex].repValue

    i = 0
    while i < arglen(report):
        if (report[i] != 2^64 | report[i] != -2^64 | report[i] != 0 | report[i] != 2^63):
            return(0) # make sure vote values are valid
        else:
            if(!inPeriod(branch, report[i])):
                return(0)
        i += 1

    # need to update stuff for quorem
    # and store the report and the rep value
    while i < arglen(report):
        self.Reporting[branchID].eventsExpDates[0].reporters[tx.origin][i] = report[i]
        i+=1
    self.Reporting[branchID].eventsExpDates[self.Branches[branchID].currentVotePeriod].totalRepReported += reputation
    return(1)


# returns whether a quorem has a matured event and whether
# the number of required reports are met as a tuple (matured, met)
def check_quorum(branch):
    currentPeriod = block.number / self.Branches[branch].periodLength
    # provided the currentPeriod is >2 periods past the things we're going to rbcr on
    # we can then conclude it has matured and people have had time to vote
    if (currentPeriod > (self.Branches[branch].currentVotePeriod+2)):
        matured = true
    else:
        matured = false
    currentVotePeriod = self.Branches[branchID].currentVotePeriod
    # check that enough people actually did vote
    if (self.Reporting[branch].eventsExpDates[currentVotePeriod].totalRepReported >= self.Branches[branch].repRequired):
        met = true
    else:
        met = false
    if(met and matured):
        return(1)
    else:
        return(0)
        
# perhaps give the redeemer some fees to cover svd costs
# 25% of fees already distributed to market creators
# so 2/3 of remaining fees to voters = 50%
# and 1/3 of remaining fees to event creators = 25%
def any(branch):
    if(!self.check_quorem(branch)):
        return("quorem not satisfied yet")
    currentVotePeriod = self.Branches[branchID].currentVotePeriod
    # loop through reputation and check if in reporters, if so use their report, if not use the fillin / not reported report
    # use this to make a giant array of votes to pass to self.consensus
    # want to pass votes for each 0 indexed event in order (so we get votes from an actual reporter)
    # (if they didn't vote we set their array for each event to 0,0,0,0,0,0, etc...)
    reputation = array(self.Reporting[branch].numberReporters-1)
    votes = array(self.Reporting[branch].numberReporters-1)
    numberEvents = self.Reporting[branch].eventsExpDates[currentvotePeriod].numberEvents
    numReporters = self.Reporting[branch].numberReporters
    i = 0
    while i < numReporters:
        # checks to see if each reporter actually voted on any events
        reporterID = self.Reporting[branch].reputation[i].reporterID
        reputation[i] = self.Reporting[branch].reputation[i].repValue
        # if they didn't vote (checking event 0)
        if(self.Reporting[branch].eventsExpDates[currentVotePeriod].reporters[reporterID][0] == 0):
            # all votes are 0 for this reporter because they didn't vote
            votes[i] = array(self.Reporting[branch].eventsExpDates.numberEvents-1)
        # the reporter did report on events
        else:
            votes[i] = array(self.Reporting[branch].eventsExpDates.numberEvents-1)
            x = 0
            while x < numberEvents:
                votes[i][x] = self.Reporting[branchID].eventsExpDates[currentVotePeriod].reporters[reporterID][x]
                x += 1
        i += 1

    # populate returned arrays
    megaArray = self.consensus(votes:self.Reporting[branch].numberReporters-1, reputation:self.Reporting[branch].numberReporters-1)
    outcomes_final = array(numberEvents)
    event_bonus = array(numberEvents)
    voter_bonus = array(numReporters)
    a = 0
    while a < numberEvents:
        outcomes_final[a] = megaArray[a]
        a+=1
    b = numberEvents
    while b < (2*numberEvents):
        event_bonus[b] = megaArray[b]
        b+=1
    c = (2*numberEvents)
    while c < numReporters:
        voter_bonus[c] = megaArray[c]
        c+=1

    # get event ID for each event by taking the x index in the votes arrays - shoving it in reporting.events[]
    # and getting the cooresponding ID
    n = 0
    while n < numberEvents:
        eventID = self.Reporting[branch].eventsExpDates[currentVotePeriod].events[n]
        # then take outcomes_final and set each event outcome to -1 if false or 1 if true
        if(outcomes_final[n]==-1):
            self.Events[eventID].outcome = -1
        elif(outcomes_final[n]==1):
            self.Events[eventID].outcome = 1
        # need to loop through eventid holders and distribute 25% coins using the event_bonus to determine how much
        # of the 25% each get
        self.cashcoin_balances[self.Info[eventID].creator] += event_bonus[n] * self.cashcoin_balances[branch] / 3
        self.cashcoin_balances[branch] -= event_bonus[n] * self.cashcoin_balances[branch] / 3

    # eed to loop through rep holders and distribute 50% of branch fees to voters' cashcoin addresses
    # also need to take voter_bonus and redistribute reputation in the Reporting structure accordingly
    z = 0
    while z < numReporters:
        self.Reporting[branch].reputation[z].repValue += voter_bonus[z]*21000000
        self.cashcoin_balances[self.Reporting[branch].reputation[z].reporterID] += (2/3)*self.cashcoin_balances[branch] / numReporters
        self.cashcoin_balances[branch] -= (2/3)*self.cashcoin_balances[branch] / numReporters

    self.Branches[branch].currentVotePeriod += 1


# loop through events in the market, get their outcomes and use those to determine the winning events!
# distribute coins among winning events
# only works for inTrade style predictions at the moment
def close_market(branch, market):
    currentPeriod = block.number / self.Branches[branch].periodLength
    eventVotePeriod = self.Events[self.Markets[market].events[numberEvents-1].eventID].expirationDate / self.Branches[branch].periodLength
    if(currentPeriod > (eventVotePeriod+2) && self.Reporting[branch].eventsExpDates[currentPeriod].totalRepReported >= self.Branches[branch].repRequired):
        # give back initial liquidity
        self.cashcoin_balances[market] -= self.Info[market].creationFee
        self.cashcoin_balances[self.Info[market].creator] += self.Info[market].creationFee
        # get # of shares of winning outcome

        # loop through events in the market, get their outcomes and use those to determine the winning events!
        n = 0
        e = 0
        while n < self.Markets[market].numberEvents:
            if(self.Events[self.Markets[market].events[n].eventID].outcome):
                self.Markets[market].winningEvents[e] = self.Markets[market].events[n].eventID
                e+=1
            n+=1

        winningShares = 0
        # number of winning events is equivalent to e
     #   a = 0
     #   while a < e:
     #       self.Markets[market].events[self.Markets[market].winningEvents[e]].shares

        winningEvent = self.Markets[market].winningEvents[e]
        winningShares = 0
        winningOutcome = self.Markets[market].outcome
        winningSharesIndex = 0
        if(winningOutcome==1):
            winningShares = self.Markets[market].events[winningEvent].sharesPurchased[1]
            winningSharesIndex = 1
        elif(winningOutcome==-1):
            winningShares = self.Markets[market].events[winningEvent].sharesPurchased[0]
            winningSharesIndex = 0
        elif(winningOutcome==0):
            return("outcome hasn't been decided yet")
        # X cashcoin in market /qi is the price per winning share once a market is closed
        pricePerShare = self.cashcoin_balances[market] * 2^64 / winningShares

        # distribute cashcoin to the people who won money by holding winning shares
        i = 0
        while i <= self.Markets[market].currentParticipant:
            sharesOwned = self.Markets[market].participants[i].event[winningEvent].shares[winningSharesIndex]
            participant = self.Markets[market].participants[i].participantID
            moneyWon = pricePerShare * sharesOwned / 2^64
            self.cashcoin_balances[market] -= moneyWon
            self.cashcoin_balances[participant] += moneyWon


# check lastvote period block