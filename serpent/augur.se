# This software (Augur) allows buying and selling event options in ethereum
# Copyright (C)  2014 Chris Calderon, Joey Krug, Alan Lu, Jack Peterson
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joeykrug@gmail.com

BRANCH = 0
EVENT = 1
MARKET = 2

# Every entity in our contract has similar metadata.
# Instead of putting it in each entity, we put all the
# metadata here.
# Info's index is the hash of the item we're getting info on
data Info[](typecode, description[2048], descriptionLength, creator, creationFee)

# CurrentVotePeriod is the current index in eventsExpDates
# Branches' index is the hash of the branch (aka branchID)
# RepRequired is the amount of reputation required to reach quorem
# markets[] is a 0 index array of market hashes (a.k.a. marketID)
# currentVotePeriod is a nonce that tells us which bucket of events up to be
# voted on in the upcoming vote period
data Branches[](currentVotePeriod, markets[], marketCount, periodLength, repRequired)

# Events' index is the eventID
# a binary outcome has 0 for min and 1 for max value (ditto for categorical even though not actually true)
# S&P 500 would be say 0 and 4700, respectively
data Events[](branch, expirationDate, outcome, minValue, maxValue, numOutcomes)

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](eventsExpDates[](numberEvents, events[], totalRepReported, reporters[][]), reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market in the format of
    # [1, event, event, 2, event, 3, event, event, event]
    # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
# Sharespurchased keeps track of the number of shares purchased for each outcome
    # sharesPurchased states starts at 1 - (same for participants[].shares[] array)
# Participants is a 0 indexed array of participants, their cashIDs, and the shares in each outcome they've purchased of an event
# a binary outcome state 1 is no, 2 is true, 0 if not determined
data Markets[](branch, events[], sharesPurchased[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcome, alpha, cumulativeScale, numOutcomes, tradingPeriod)

data p2pBets[](eventID, amtToBet, outcomeOneBettor, outcomeZeroBettor)

data cashcoinBalances[]

def init():
    # test initial funds
    fx_init(0)
    self.cashcoinBalances[tx.origin] = 1000000*2^64
    self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
    self.Reporting[1010101].reputation[0].repValue = 47
    self.Reporting[1010101].reputation[0].reporterID = tx.origin
    self.Reporting[1010101].numberReporters = 1
    self.Info[1010101].typecode = 0
    self.Info[1010101].description[] = "initial branch"
    self.Info[1010101].creator = 0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826
    self.Info[1010101].creationFee = 10
    self.Branches[1010101].currentVotePeriod = block.number / 403200
    self.Branches[1010101].marketCount = 0
    self.Branches[1010101].periodLength = 403200
    self.Branches[1010101].repRequired = 14000000

# string chunks
macro chunks($l):
    $l + if(l%32 != 0, 1, 0)

def getCashBalance(address):
    return(self.cashcoinBalances[address])

# should send values as fixed point in UI (1 is 2^64, 4 is 4*2^64, .5 is 2^63, etc.)
def sendCashcoin(recver, value):
    sender = tx.origin
    senderBalance = self.cashcoinBalances[sender]
    if(senderBalance >= value):
        self.cashcoinBalances[sender] -= value
        self.cashcoinBalances[recver] += value
        return(1)
    else:
        return(0)

def sendReputation(branch, recver, value):
    if(value<=0 or !self.sendCashcoin(branch, 5*2^64)):
        return(0)
    sender = tx.origin
    senderIndex = self.Reporting[branch].repIDtoIndex[sender]
    receiverIndex = self.Reporting[branch].repIDtoIndex[recver]
    # if the sender's rep. account doesn't exist, make one
    if(self.Reporting[branch].reputation[senderIndex].reporterID!=tx.origin):
        reporterIndex = self.Reporting[branch].numberReporters
        self.Reporting[branch].repIDtoIndex[tx.origin] = reporterIndex
        self.Reporting[branch].reputation[reporterIndex].repValue = 0
        self.Reporting[branch].reputation[reporterIndex].reporterID = tx.origin
        self.Reporting[branch].numberReporters += 1
        return(text("Your reputation account was just created, earn some rep. before you can send to others"): str)

    if(self.Reporting[branch].reputation[receiverIndex].reporterID!=recver):
        return(text("Receiving address doesn't exist"): str)
        
    senderBalance = self.Reporting[branch].reputation[senderIndex].repValue
    if(senderBalance >= value):
        self.Reporting[branch].reputation[senderIndex].repValue -= value
        self.Reporting[branch].reputation[receiverIndex].repValue += value
        return(1)
    else:
        return(0)
        
def getRepBalance(branch, address):
    return(self.Reporting[branch].reputation[self.Reporting[branch].repIDtoIndex[address]].repValue)

# period length is given in blocks
# description format is branchName:description
# is there some way we can include the description bytes in the sha256 hash?
def makeSubBranch(description:str, periodLength, parent, repRequired):
    if(periodLength<=0 or !self.Branches[parent].periodLength or !repRequired or description==0):
        return(0)
    branchInfo = string((items=7)+len(description))
    branchInfo[0] = BRANCH                                      #typecode
    branchInfo[1] = tx.origin                                   #creator address
    branchInfo[2] = 47*2^64                                     #creation fee
    branchInfo[3] = periodLength                                #length of voting cycle
    branchInfo[4] = block.number                                #current block number
    branchInfo[5] = parent                                      #branchID of parent branch
    branchInfo[6] = repRequired                                 #minimum rep required to vote
    mcopy(branchInfo+(items=7), description, len(description))
    # people can check that these characteristics hash to the ID if they want
    # people can hand a friend their new branch hash and characteristics and say, "don't trust me? check"
    branchID = sha256(branchinfo, chars=len(branchinfo))

    if(!self.Branches[branchID].periodLength and !self.Info[branchID].creator and self.sendCashcoin(branchID, 47*2^64)):
        self.Info[branchID].typecode = BRANCH
        self.Info[branchID].creator = tx.origin
        self.Info[branchID].creationFee = 47*2^64
        self.Info[branchID].descriptionLength = len(description)
        save(self.Info[branchID].description[0], description, chars=len(description))
        self.Branches[branchID].periodLength = periodLength
        self.Branches[branchID].repRequired = repRequired
        # subtract one period length because the current voting period should be one period behind what's currently expiring
        # current vote period is what we're actually voting on at the moment
        self.Branches[branchID].currentVotePeriod = (block.number - periodLength) / periodLength
        i = 0
        while i < self.Reporting[parent].numberReporters:
            self.Reporting[branchID].reputation[i].reporterID = self.Reporting[parent].reputation[i].reporterID
            self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
            i+=1
        self.Reporting[branchID].numberReporters = i
        return(branchID)
    else:
        return(0)

# numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0
# to 11.0 would be 11 outcomes (if incremented by 0.1)
def createEvent(branch, description:str, expDate, minValue, maxValue, numOutcomes):
    if(self.Branches[branch].periodLength and description!=0 and expDate>block.number):
        eventinfo = string((items=8)+len(description))
        eventinfo[0] = EVENT                                        #typecode
        eventinfo[1] = branch                                       #branchID
        eventinfo[2] = expDate                                      #expiration date
        eventinfo[3] = tx.origin                                    #creator address
        eventinfo[4] = 42*2^64                                      #creation fee
        eventinfo[5] = minValue                                     #minimum outcome value
        eventinfo[6] = maxValue                                     #maximum outcome value
        eventinfo[7] = numOutcomes                                  #number of outcomes
        mcopy(eventinfo+(items=8), description, len(description))
        eventID = sha256(eventinfo, chars=len(eventinfo))
    else:
        return(0)

    if (!self.Info[eventID].creator and !self.Events[eventID].branch and self.sendCashcoin(branch, 42*2^64)):
        self.Info[eventID].typecode = EVENT
        self.Info[eventID].creator = tx.origin
        self.Info[eventID].creationFee = 42*2^64
        self.Info[eventID].descriptionLength = len(description)
        save(self.Info[eventID].description[0], description, chars=len(description))
        self.Events[eventID].branch = branch
        self.Events[eventID].expirationDate = expDate
        self.Events[eventID].minValue = minValue
        self.Events[eventID].maxValue = maxValue
        self.Events[eventID].numOutcomes = numOutcomes
        # see which future period it expires in and put the event in that bin
        # event voting periods - expDate / periodLength gives you the voting period #
        futurePeriod = expDate / self.Branches[branch].periodLength
        self.Reporting[branch].eventsExpDates[futurePeriod].events[self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents] = eventID
        self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents += 1
        return(eventID)
    else:
        return(0)

# alpha is equal to v/(n*log(n)) where v is the max percent commission,
# and n is the number of outcomes people can trade. Alpha is set when
# a market is created.
macro lsLmsr($marketID):
    with $Bq = 0:
        with $l = self.Markets[$marketID].numOutcomes:
            with $i = 1:
                while $i <= $l:
                    $Bq += self.Markets[$marketID].sharesPurchased[$i]
                    $i += 1
                $Bq *= self.Markets[$marketID].alpha
                $Bq *= self.Markets[$marketID].cumulativeScale
                $i = 1
                with $sumExp = 0:
                    with $a = 0:
                            while $i <= $l:
                                $a = self.Markets[$marketID].sharesPurchased[$i]
                                $sumExp += self.exp($a*2^64/$Bq)
                                $i += 1
                            $Bq*self.log($sumExp)/2^64

# alpha is a fixedpoint number / calc. it in UI
# z is the optimal initial vector for each outcome
# z = liquidity / (1+(alpha*n*ln(n)))
# initialLiquidity is initial number of shares of each outcome you want to buy/initialize/set
def createMarket(branch, description:str, alpha, initialLiquidity, events:arr):
    if(!self.Branches[branch].periodLength or description==0 or !initialLiquidity or !alpha or alpha <= (2^64 / 132)):
        return(0)
    # check that events have same exp. dates and branch
    i = 0
    eventNum = len(events)
    # only supports 3 dimensional markets atm
    if(eventNum > 3):
        return(0)
    numOutcomes = 0
    eventsConcat = 0
    cumulativeScale = 0
    tradingPeriod = 0
    while i < eventNum:
            event = events[i]
            if(self.Events[event].expirationDate > tradingPeriod):
                tradingPeriod = self.Events[event].expirationDate
            eventsConcat += event
            if (self.Events[event].branch != branch or !self.Info[eventID].creator):
                return(0)
            #scalars
            if(self.Events[event].maxValue!=1):
                # not a scalar but also not categorical or binary - invalid event
                if(self.Events[event].numOutcomes!=2):
                    return(0)
                # is a valid scalar
                cumulativeScale += self.Events[event].maxValue - self.Events[event].minValue
            if(i==0):
                numOutcomes += self.Events[event].numOutcomes
            else:
                numOutcomes *= self.Events[event].numOutcomes
            i += 1
    if(numOutcomes > 200):
        return(0)
    tradingPeriod = tradingPeriod / self.Branches[branch].periodLength
    # formation of marketID (hash)
    marketinfo = string((items=10)+len(description))
    marketinfo[0] = MARKET
    marketinfo[1] = tx.origin
    marketinfo[2] = initialLiquidity
    marketinfo[3] = branch
    marketinfo[4] = eventsConcat
    marketinfo[5] = len(events)
    marketinfo[6] = cumulativeScale
    marketinfo[7] = alpha
    marketinfo[8] = numOutcomes
    marketinfo[9] = tradingPeriod
    mcopy(marketinfo+(items=10), description, chars=len(description))
    marketID = sha256(marketinfo, chars=len(marketinfo))

    # buy some of all outcomes
    # ls-lmsr needs at least a very small initial liquidity
    y = 1
    while y <= numOutcomes:
        self.Markets[marketID].sharesPurchased[y] += initialLiquidity
    cost = lsLmsr(marketID)

    if(self.sendCashcoin(marketID, cost)):
        # add event list to the market
        z = 0
        while z < eventNum:
            # initialize market events array with eventIDs from the eventList
            self.Markets[marketID].events[z] = events[eventNum]
            z+=1
            
        self.Info[marketID].typecode = MARKET
        self.Info[marketID].creator = tx.origin
        self.Info[marketID].creationFee = initialLiquidity
        self.Info[marketID].descriptionLength = len(description)
        save(self.Info[marketID].description[0], description, chars=len(description))
        self.Markets[marketID].branch = branch
        self.Markets[marketID].alpha = alpha
        self.Markets[marketID].lenEvents = len(events)
        self.Markets[marketID].cumulativeScale = cumulativeScale
        self.Markets[marketID].numOutcomes = numOutcomes
        self.Markets[marketID].tradingPeriod = tradingPeriod
        # add the market to the branch
        marketCount = self.Branches[branch].marketCount
        self.Branches[branch].markets[marketCount] = marketID
        self.Branches[branch].marketCount += 1
        return(marketID)
    else:
        # revert shares bought
        y = 1
        while y <= numOutcomes:
            self.Markets[marketID].sharesPurchased[y] -= initialLiquidity
        return(0)

# amount of shares should be an integer
def buyShares(branch, market, outcome, amount):
    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)
    if (self.Markets[market].branch!=branch or outcome==0 or self.Branches[branch].currentVotePeriod>=self.Markets[marketID].tradingPeriod):
        return(0)
    # lmsr cost calcs
    oldCost = lsLmsr(market)
    self.Markets[market].sharesPurchased[outcome] += amount
    newCost = lsLmsr(market)

    # these prices are in fixed point
    pricePerShare = newCost - oldCost
    participantNumber = self.Markets[market].currentParticipant
  
    # send shares of the event to user address
    # if user doesn't have enough money, revert
    if(self.cashcoinBalances[tx.origin]<amount*pricePerShare):
        self.Markets[market].sharesPurchased[outcome] -= amount
        return(0)
    else:
        # send money from user acc. to market address/account
        self.sendCashcoin(market, pricePerShare*amount)
        self.Markets[market].participants[participantNumber].participantID = tx.origin
        self.Markets[market].participants[participantNumber].shares[outcome] += amount
        self.Markets[market].currentParticipant += 1
        return(participantNumber)

# amount is amount of shares to buy
# instead of inputting particip. num could just loop through array if dont have it
def sellShares(branch, market, outcome, amount, participantNumber):
    # can trade up until the event has started to be voted on (e.g. currentVotePeriod is >= to the latest expDate/periodLength)
    if (self.Markets[market].participants[participantNumber].participantID != tx.origin or self.Markets[market].branch!=branch or outcome==0 or self.Branches[branch].currentVotePeriod>=self.Markets[marketID].tradingPeriod):
        return(0)
    # lmsr cost calcs
    oldCost = lsLmsr(market)
    self.Markets[market].sharesPurchased[outcome] -= amount
    newCost = lsLmsr(market)

    # these prices are in fixed point
    pricePerShare = oldCost - newCost
    participantNumber = self.Markets[market].currentParticipant

    # remove shares from the user's account
    # if user actually doesn't have the shares, revert
    if(self.Markets[market].participants[participantNumber].shares[outcome] < amount):
        self.Markets[market].sharesPurchased[outcome] += amount
        return(0)
    else:
        # send bitcoin from the market to the user acc.
        self.cashcoinBalances[market] -= priceToPayPerShare*amount
        self.cashcoinBalances[tx.origin] += priceToPayPerShare*amount
        self.Markets[market].participants[participantNumber].shares[outcome] -= amount
        return(1)

# a no vote is -2^64, a yes vote is 2^64 and a can't determine vote is 2^63 (a empty ballot is 0)
# atm voters who do vote are req. to vote on all things in their respective ballots (rest just auto .5 them)
# ui should handle this by filling in things you didn't vote on automatically & ask to be sure you didn't want to vote on them
# UI makeBallot function does this
    # ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[votePeriod].numberEvents
    # and loop through the events[] array from 0 to numberEvents -1 for the votes list / order
# people could report something like 16027*2^64 for a scalar
def vote(branch, report:arr):
    # make sure the branch exists
    repIndex = self.Reporting[branch].repIDtoIndex[tx.origin]
    # need report length to be same as number of items in the current eventexpdates voting period events!
    if(len(report)!=self.Reporting[branch].eventsExpDates[self.Branches[branch].currentVotePeriod].numberEvents):
        return(0)

    # if current period is more than 2 periods past the vote period
    # then there can be no more voting for that voting period
    # (reasoning being: >1 period past means all the events in that period have expired)
    # (>2 periods past mean the events have exp. & people have had 1 full period to vote)
    # currently requires events to expire to vote
    currentPeriod = block.number / self.Branches[branch].periodLength
    if (self.Reporting[branch].reputation[repIndex].reporterID != tx.origin | currentPeriod > (self.Branches[branch].currentVotePeriod+2) | currentPeriod < (self.Branches[branch].currentVotePeriod+1)):
        return(0)

    reputation = self.Reporting[branch].reputation[repIndex].repValue
    # need to update stuff for quorem
    # and store the report and the rep value
    while i < len(report):
        self.Reporting[branchID].eventsExpDates[self.Branches[branch].currentVotePeriod].reporters[tx.origin][i] = report[i]
        i+=1
    self.Reporting[branchID].eventsExpDates[self.Branches[branchID].currentVotePeriod].totalRepReported += reputation
    return(1)

# returns whether a quorem has a matured event and whether
# the number of required reports are met
def checkQuorum(branch):
    currentPeriod = block.number / self.Branches[branch].periodLength
    # provided the currentPeriod is >2 periods past the things we're going to rbcr on
    # we can then conclude it has matured and people have had time to vote
    if (currentPeriod > (self.Branches[branch].currentVotePeriod+2)):
        matured = true
    else:
        matured = false
    currentVotePeriod = self.Branches[branchID].currentVotePeriod
    # check that enough people actually did vote
    if (self.Reporting[branch].eventsExpDates[currentVotePeriod].totalRepReported >= self.Branches[branch].repRequired):
        met = true
    else:
        met = false
    if(met and matured):
        return(1)
    else:
        return(0)
      
# 25% of fees already distributed to market creators
# so 2/3 of remaining fees to voters = 50%
# and 1/3 of remaining fees to event creators = 25%
# what if not enough consensus or not enough events expiring upcoming
def redeem(branch):
    if(!self.checkQuorum(branch)):
        return(text("quorem not satisfied yet"): str)
    currentVotePeriod = self.Branches[branchID].currentVotePeriod
    # loop through reputation and check if in reporters, if so use their report, if not use the fillin / not reported report (all zeroes)
    # use this to make a giant array of votes to pass to self.consensus
    # want to pass votes for each 0 indexed event in order (so we get votes from an actual reporter)
    # (if they didn't vote we set their array for each event to 0,0,0,0,0,0, etc...)
    numReporters = self.Reporting[branch].numberReporters
    reputation = array(numReporters)
    numberEvents = self.Reporting[branch].eventsExpDates[currentvotePeriod].numberEvents
    votes = array(numReporters * numberEvents)

    i = 0
    while i < numReporters:
        reporterID = self.Reporting[branch].reputation[i].reporterID
        reputation[i] = self.Reporting[branch].reputation[i].repValue
        # checks to see if each reporter actually voted on events
        # if they didn't vote (simply check if they voted on first event) do nothing (these values will be 0 by default due to Serpent array styles)
        # else if the reporter did report on events put their ballot into the votes array
        if(self.Reporting[branch].eventsExpDates[currentVotePeriod].reporters[reporterID][0] != 0):
            x = 0
            while x < numberEvents:
                votes[x + i*numberEvents] = self.Reporting[branch].eventsExpDates[currentVotePeriod].reporters[reporterID][x]
                x += 1
        i += 1
    # populate returned arrays
    # pass votes and rep vector to consensus
    megaArray = self.consensus(votes, reputation)
    outcomesFinal = array(numberEvents)
    eventBonus = array(numberEvents)
    voterBonus = array(numReporters)
    a = 0
    while a < numberEvents:
        outcomesFinal[a] = megaArray[a]
        a+=1
    b = numberEvents
    while b < (2*numberEvents):
        eventBonus[b] = megaArray[b]
        b+=1
    c = (2*numberEvents)
    while c < numReporters:
        voterBonus[c] = megaArray[c]
        c+=1
    # get event ID for each event by taking the x index in the votes arrays - shoving it in reporting.events[]
    # and getting the cooresponding ID
    n = 0
    while n < numberEvents:
        eventID = self.Reporting[branch].eventsExpDates[currentVotePeriod].events[n]
        # then take outcomes_final and set each event outcome to -1 if false or 1 if true (if 0 it's undecided)
        # a scalar could have a number like say 47
        self.Events[eventID].outcome = outcomesFinal[n]
        # need to loop through eventid holders and distribute 25% coins using the event_bonus to determine how much
        # of the 25% each get
        #self.cashcoin_balances[self.Info[eventID].creator] += fixed_multiply(event_bonus[n], self.cashcoin_balances[branch]) / 3
        #self.cashcoin_balances[branch] -= fixed_multiply(event_bonus[n], self.cashcoin_balances[branch]) / 3
    # need to loop through rep holders and distribute 50% of branch fees to reporters' cashcoin addresses 
    # (use 2/3 because 25% was distributed in market creation)
    # also need to take voter_bonus and redistribute reputation in the Reporting structure accordingly
    z = 0
    while z < numReporters:
        self.Reporting[branch].reputation[z].repValue += (voterBonus[z]*21000000)/2^64
        self.cashcoinBalances[self.Reporting[branch].reputation[z].reporterID] += 2*self.cashcoinBalances[branch]*voterBonus[z] / (3*2^64)
        self.cashcoinBalances[branch] -= 2*self.cashcoinBalances[branch]*voterBonus[z] / (3*2^64)
    self.Branches[branch].currentVotePeriod += 1
    return(self.Branches[branch].currentVotePeriod)


# loop through events in the market, get their outcomes and use those to determine the winning events!
# distribute coins among winning events
# when multidimen fancy payouts we report on the events separately per usual, but combine them to determine winning state of a fancy market and then payout that state
def closeMarket(branch, market):
    if(self.cashcoinBalances[market]<=0):
        return(0)
    currentPeriod = block.number / self.Branches[branch].periodLength
    numberEvents = self.Markets[market].lenEvents
    eventVotePeriod = self.Events[self.Markets[market].events[numberEvents-1]].expirationDate / self.Branches[branch].periodLength
    if(currentPeriod > (eventVotePeriod+2) && self.Reporting[branch].eventsExpDates[currentPeriod].totalRepReported >= self.Branches[branch].repRequired):
        # loop through events in the market, get their outcomes and use those to determine the winning events!
        n = 0
        winningOutcomes = array(200)
        while n < numberEvents:
            outcome = self.Events[self.Markets[market].events[n]].outcome
            if(outcome==2^63):
                # return all t3h $$$
            elif(outcome==0):
                return(0)
            if(n==0):
                #scalar
                if(self.Events[self.Markets[market].events[n]].maxValue!=1):
                    winningOutcomes[0] = 1
                    winningOutcomes[1] = 2
                # anything besides scalar
                else:
                    winningOutcomes[0] += outcome
            elif(n==1):
                if(self.Events[self.Markets[market].events[n]].maxValue!=1):
                    # scalar, scalar
                    if(winningOutcomes[1]):
                        winningOutcomes[2] = 3
                        winningOutcomes[3] = 4
                    # nonscalar, scalar
                    else:
                      # winningOutcomes[0] = winningOutcomes[0]
                        winningOutcomes[1] = winningOutcomes[0] + self.Events[self.Markets[market].events[n-1]].numOutcomes
                # scalar, nonscalar
                elif(winningOutcomes[1] and self.Events[self.Markets[market].events[n]].maxValue==1):
                    winningOutcomes[0] += self.Events[self.Markets[market].events[n-1]].numOutcomes*(outcome-1)
                    winningOutcomes[1] += self.Events[self.Markets[market].events[n-1]].numOutcomes*(outcome-1)
                # nonscalar, nonscalar
                else:
                    winningOutcomes[0] += self.Events[self.Markets[market].events[n-1]].numOutcomes*(outcome-1)
            elif(n==2):
                if(self.Events[self.Markets[market].events[n]].maxValue!=1):
                    #scalar, scalar, scalar
                    if(winningOutcomes[3]):
                        winningOutcomes[4] = 5
                        winningOutcomes[5] = 6
                        winningOutcomes[6] = 7
                        winningOutcomes[7] = 8

                    #scalar, nonscalar, scalar
                    winningOutcomes[2] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes
                    winningOutcomes[3] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes

                    #nonscalar, scalar, scalar
                    winningOutcomes[2] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes
                    winningOutcomes[3] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes

                    #nonscalar, nonscalar, scalar
                    winningOutcomes[1] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes 

                    #scalar, nonscalar, nonscalar
                    #nonscalar, scalar, nonscalar
                    winningOutcomes[0] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                    winningOutcomes[1] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)

                    #scalar, scalar, nonscalar
                    winningOutcomes[0] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1) 
                    winningOutcomes[1] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                    winningOutcomes[2] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)
                    winningOutcomes[3] += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes * (outcome-1)

                # nonscalar, nonscalar, nonscalar
                # if(outcome==1) we're set, else...
                if(outcome==2):
                    # fix this
                    # += numOutcomesinfirstevent*numOutcomesinsecondevent
                    winningOutcome += self.Events[self.Markets[market].events[n-2]].numOutcomes * self.Events[self.Markets[market].events[n-1]].numOutcomes
            n+=1


        winningShares = 0
        winningEvent = self.Markets[market].winningEvents[e-1]
        winningShares = 0
        if(winningOutcome==1):
           # winning outcome in a binary market is 2, no is 1
            winningShares = self.Markets[market].sharesPurchased[(2*(n-1) + 1)]
            winningSharesIndex = 1
        elif(winningOutcome==-1):
            winningShares = self.Markets[market].sharesPurchased[2*(n-1)]
            winningSharesIndex = 0
        elif(winningOutcome==0):
            return(text("outcome hasn't been decided yet"): str)
        elif(winningOutcome==2^63):
            return(0)
            # return funds to people

        # distribute cashcoin to the people who won money by holding winning shares
        i = 0
        while i <= self.Markets[market].currentParticipant:
            sharesOwned = self.Markets[market].participants[i].shares[winningSharesIndex]
            participant = self.Markets[market].participants[i].participantID
            # winning price is $1 / share unless scalar
            # pricePerShare = 2^64
            #moneyWon = sharesOwned*pricePerShare
            pricePerShare = (self.Events[winningEvent].outcome - self.Events[winningEvent].minValue)*2^64/(self.Events[winningEvent].maxValue - self.Events[winningEvent].minValue)
            self.cashcoinBalances[market] -= sharesOwned*pricePerShare
            self.cashcoinBalances[participant] += sharesOwned*pricePerShare

        # give back initial liquidity (or as much of it/profits are left)
        self.cashcoinBalances[self.Info[market].creator] += self.cashcoinBalances[market]
        self.cashcoinBalances[market] -= self.cashcoinBalances[market]
        return(text("Market closed"): str)

### P2P parimutuel betting
def makeBet(eventID, amtToBet):
    betData = array(2)
    betData[0] = eventID
    betData[1] = block.number
    betID = sha256(branchinfo, 2)
    self.p2pBets[betID].eventID = betData[0]
    self.p2pBets[betID].amtToBet = amtToBet

# should add a fee to market
# outcome is 0 or 1
def sendMoneytoBet(betID, outcome):
    if(self.cashcoinBalances[betID+outcome]==0):
        self.sendCashcoin(betID+outcome, self.p2pBets[betID].amtToBet)
    else:
        return(0)
    if(outcome):
        self.p2pBets[betID].outcomeOneBettor = tx.origin
    else:
        self.p2pBets[betID].outcomeZeroBettor = tx.origin

# add support for a .5 outcome
def closeBet(betID):
    # outcome not determined yet
    if(self.Events[self.p2pBets[betID].eventID].outcome == 0):
        return(0)
    # pay out depending on outcome
    if(self.cashcoinBalances[betID+0]==self.p2pBets[betID].amtToBet && self.cashcoin_balances[betID+1]==self.p2pBets[betID].amtToBet):
        self.cashcoinBalances[betID+0] -= self.cashcoin_balances[betID+0]
        self.cashcoinBalances[betID+1] -= self.cashcoin_balances[betID+1]
        if(self.Events[self.p2pBets[betID].eventID].outcome):
            self.cashcoinBalances[self.p2pBets[betID].outcomeOneBettor] += self.p2pBets[betID].amtToBet*2
        elif(self.Events[self.p2pBets[betID].eventID].outcome == -1):
            self.cashcoinBalances[self.p2pBets[betID].outcomeZeroBettor] += self.p2pBets[betID].amtToBet*2
    # someone didn't pay their side of the bet, refund funds
    else:
        self.cashcoinBalances[self.p2pBets[betID].outcomeZeroBettor] += self.cashcoinBalances[betID+0]
        self.cashcoinBalances[self.p2pBets[betID].outcomeOneBettor] += self.cashcoinBalances[betID+1]
        self.cashcoinBalances[betID+0] -= self.cashcoinBalances[betID+0]
        self.cashcoinBalances[betID+1] -= self.cashcoinBalances[betID+1]
    return(1) 
### API (for UI)

# atm voters who do vote are req. to vote on all things in their respective ballots (even if just a 0 / no vote)
# ui should handle this ^
# ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents
# and loop through the events[] array from 0 to numberEvents -1 for the votes list / order
# UI will need a function to get the items in that array above so it can make a report!
# w/ this function you can get the eventIDs, look them up and report on outcomes (probably w/ another function to look them up) -- make sure in this function to check that the report value is not >maxvalue or <minvalue for the event
def makeBallot(branch):
    numEvents = self.Reporting[branch].eventsExpDates[self.Branches[branch].currentVotePeriod].numberEvents
    eventArray = array(numEvents)
    i = 0
    while i < numEvents:
        eventID = self.Reporting[branch].eventsExpDates[self.Branches[branch].currentVotePeriod].events[numEvents]
        eventArray[i] = eventID
    return(eventArray: arr)

# arrayIndex only matters if array
def api(dataStructure, itemNumber, arrayIndex, ID):
    if(dataStructure==0):
        if(itemNumber==0):
            return(self.Info[ID].typecode)
        #elif(itemNumber==1):
        #length=self.Info[ID].descriptionLength
        #return(load(self.Info[ID].description[0], chars=length):a)
        #length=self.Info[ID].descriptionLength
        #data = load(self.Info[ID].description[0], chars=length)
        #return(data, length/32 + if(length%32,1,0))
        #    return(self.Info[ID].description[])
        elif(itemNumber==2):
            return(self.Info[ID].descriptionLength)
        elif(itemNumber==3):
            return(self.Info[ID].creator)
        elif(itemNumber==4):
            return(self.Info[ID].creationFee)
    elif(dataStructure==1):
        if(itemNumber==0):
            return(self.Branches[ID].currentVotePeriod)
        elif(itemNumber==1):
            return(self.Branches[ID].markets[arrayIndex])
        elif(itemNumber==2):
            return(self.Branches[ID].marketCount)
        elif(itemNumber==3):
            return(self.Branches[ID].periodLength)
        elif(itemNumber==4):
            return(self.Branches[ID].repRequired)
    elif(dataStructure==2):
        if(itemNumber==0):
            return(self.Events[ID].branch)
        elif(itemNumber==1):
            return(self.Events[ID].expirationDate)
        elif(itemNumber==2):
            return(self.Events[ID].outcome)
        elif(itemNumber==3):
            return(self.Events[ID].minValue)
        elif(itemNumber==4):
            return(self.Events[ID].maxValue)
    elif(dataStructure==3):
        if(itemNumber==0):
            return(text("Please call the eventsExpApi function"): str)
        elif(itemNumber==1):
            return(text("Please call the reputation api function"): str)
        elif(itemNumber==2):
            return(self.Reporting[ID].numberReporters)
        elif(itemNumber==3):
            return(self.Reporting[ID].repIDtoIndex[arrayIndex])
    elif(dataStructure==4):
        if(itemNumber==0):
            return(self.Markets[ID].branch)
        elif(itemNumber==1):
            return(self.Markets[ID].events[arrayIndex])
        elif(itemNumber==2):
            return(self.Markets[ID].sharesPurchased[arrayIndex])
        elif(itemNumber==3):
            return(text("Please call the participants api function"): str)
        elif(itemNumber==4):
            return(self.Markets[ID].lossLimit)
        elif(itemNumber==5):
            return(self.Markets[ID].tradingFee)
        elif(itemNumber==6):
            return(self.Markets[ID].numberEvents)
        elif(itemNumber==7):
            return(self.Markets[ID].currentParticipant)
        #remove this
        elif(itemNumber==8):
            return(self.Markets[ID].winningOutcome)
        elif(itemNumber==9):
            return(self.Markets[ID].alpha)
        elif(itemNumber==10):
            return(self.Markets[ID].probabilities[arrayIndex])
        elif(itemNumber==11):
            return(self.Markets[ID].cumulativeScale)
    elif(dataStructure==5):
        if(itemNumber==0):
            return(self.p2pBets[ID].eventID)
        elif(itemNumber==1):
            return(self.p2pBets[ID].amtToBet)
        elif(itemNumber==2):
            return(self.p2pBets[ID].outcomeOneBettor)
        elif(itemNumber==3):
            return(self.p2pBets[ID].outcomeZeroBettor)

def eventsExpApi(expDateIndex, itemNumber, arrayIndexOne, arrayIndexTwo, ID):
    if(itemNumber==0):
        return(self.Reporting[ID].eventsExpDates[expDateIndex].numberEvents)
    elif(itemNumber==1):
        return(self.Reporting[ID].eventsExpDates[expDateIndex].events[arrayIndexOne])
    elif(itemNumber==2):
        return(self.Reporting[ID].eventsExpDates[expDateIndex].totalRepReported)
    elif(itemNumber==3):
        return(self.Reporting[ID].eventsExpDates[expDateIndex].reporters[arrayIndexOne][ArrayIndexTwo])

def reputationApi(reputationIndex, itemNumber, branchID):
    if(itemNumber==0):
        return(self.Reporting[branchID].reputation[reputationIndex].repValue)
    elif(itemNumber==1):
        return(self.Reporting[branchID].reputation[reputationIndex].reporterID)

# eventID and outcomeNumber only needed if itemNumber is 1
# remove this
def marketParticipantsApi(participantIndex, itemNumber, eventID, outcomeNumber, marketID):
    if(itemNumber==0):
        return(self.Markets[marketID].participants[participantIndex].participantID)
    elif(itemNumber==1):
        return(self.Markets[marketID].participants[participantIndex].event[eventID].shares[outcomeNumber])

inset('fixedpoint.se')
inset('consensus.se')