# This code uses a 256 bit fixedpoint format.
# The bottom 64 bits of each number is the
# "decimal" part; the highest bit represents
# the multiple of 1/2, the next bit 1/4, etc.
# the top 192 bits represent the "integer" part,
# in the usual binary way.
# So the fixedpoint version of 1 is 1 << 64, a.k.a. 2**64.
#
# This code is written to work on both python and serpent.

def exp_e(x):
    # Computes e^x by switching to base 2.
    # Let y = x/ln2, a = floor(y), and b = y - a.
    # Then e^x = 2^(a+b) = 2^a*2^b.
    # 2^a is a bit shit, and 2^b is approximated
    # with a lagrange interpolation (recall that b
    # is the decimal part of y, so 0 <= b < 1.
    one = 0x10000000000000000
    ln2 = 0xb17217f7d1cf79ac
    y = x * one / ln2
    shift = 2**(y / one)
    z = y % one
    zpow = z
    result = one
    result += 0xb172182739bc0e46 * zpow / one
    zpow = zpow * z / one
    result += 0x3d7f78a624cfb9b5 * zpow / one
    zpow = zpow * z / one
    result += 0xe359bcfeb6e4531 * zpow / one
    zpow = zpow * z / one
    result += 0x27601df2fc048dc * zpow / one
    zpow = zpow * z / one
    result += 0x5808a728816ee8 * zpow / one
    zpow = zpow * z / one
    result += 0x95dedef350bc9 * zpow / one
    zpow = zpow * z / one
    result += 0x16aee6e8ef346 * zpow / one
    return(shift*result)

def ln(x):
    # Computes natural log by switching to base 2.
    # Let y = floor(log2(x)), and z = x/y.
    # Then ln(x) = (y + log2(z))/log2(e),
    # with 1 <= z < 2. y is computed with a binary
    # search, and log2(z) is computed using a
    # lagrange interpolation.
    one = 0x10000000000000000

    #binary search for integral part
    y = x / one
    lo = 0
    hi = 191
    mid = (lo + hi)/2:
    while lo < hi:
        if 2**mid > y:
            hi = mid - 1
        else:
            lo = mid + 1
        mid = (lo + hi)/2
    ilog2 = lo

    #lagrange interpolation for log2


macro fxp_log($x):
    with $y = fxp_ilog2($x):
        with $z = $x / 2^$y:
            ($y*2^64 + fxp_log2($z))*2^64/0x171547652b82fe177

macro fxp_log2($x):
    with $xpow = 2^64:
        with $result = 0:
            $result += -0x443b9c5adb08cc45f*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += 0xf0a52590f17c71a3f*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += -0x2478f22e787502b023*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += 0x48c6de1480526b8d4c*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += -0x70c18cae824656408c*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += 0x883c81ec0ce7abebb2*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += -0x81814da94fe52ca9f5*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += 0x616361924625d1acf5*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += -0x39f9a16fb9292a608d*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += 0x1b3049a5740b21d65f*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += -0x9ee1408bd5ad96f3e*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += 0x2c465c91703b7a7f4*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += -0x918d2d5f045a4d63*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += 0x14ca095145f44f78*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result += -0x1d806fc412c1b99*$xpow/2^64
            $xpow = $xpow*$x/2^64
            $result + 0x13950b4e1e89cc*$xpow/2^64

    return(fxp_log(x))

inset('fxp_macros_lagrange.se')
