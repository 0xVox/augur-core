# extern fixedpoint: [new, mul, div, fracpart, intpart, exp, log, pow, sqrt]
# FixedPoint = create("fixedpoint.se")

def mean(u:a):
    # [0] Calculates the arithmetic mean.
    #
    total = 0
    i = 0
    size = arglen(u)
    while i < size:
        total += u[i]
        i += 1
    return([total / size, total * 2^64 / size], 2)

def dot(u:a, v:a):
    # [1] Calculates the dot (inner) product of vectors.
    #
    prod = 0
    i = 0
    while i < size:
        prod += u[i] * v[i]
        i += 1
    return(prod)

def test_outer():
    # [2] 
    u = [2, 5, 7]
    v = [6, 2, 3]
    size = 3
    expected = array(3)
    expected[0] = [12, 4, 6]
    expected[1] = [30, 10, 15]
    expected[2] = [42, 14, 21]
    actual = outer_product(u:size, v:size)
    match = 1
    i = 0
    while i < size:
        j = 0
        while j < size:
            if actual[i][j] != expected[i][j]:
                match = 0
            j += 1
        i += 1
    return(match)

# Calculates the outer product of vectors.
macro outer_product($u:$usz, $v:$vsz):
    $p = array($usz)
    $i = 0
    while $i < $usz:
        $p[$i] = array($usz)
        $j = 0
        while $j < $usz:
            $p[$i][$j] += $u[$i] * $v[$j]
            $j += 1
        $i += 1
    $p

# Sum elements of array
macro array_sum($a:$asz):
    $s = 0
    $i = 0
    while $i < $asz:
        $s += $a[$i]
        $i += 1
    $s

# macro transpose($a:$asz):
#     # [3] Swaps rows and columns of a matrix.
#     # m: # rows in a
#     # n: # colunms in a
#     $at = array($asz)
#     $i = 0
#     while $i < $asz:
#         at[i] = array(m)
#         i += 1
#     i = 0
#     while i < m:
#         j = 0
#         while j < n:
#             at[j][i] = a[i][j]
#             j += 1
#         i += 1
#     return(at)

def multiply(a:a, b:a, am, bm, an, bn):
    # [4] Matrix multiplication
    # am: # rows in a
    # bm: # rows in b
    # an: # columns in a
    # bn: # columns in b
    cm = am
    cn = bn
    c = array(cm)
    if bn > 1:
        i = 0
        while i < cm:
            c[i] = array(cn)
            i += 1
    i = 0
    while i < cm:
        j = 0
        while j < cn:
            k = 0
            while k < an:
                if bn == 1:
                    c[i] += a[i][k] * b[k]
                else:
                    c[i][j] += a[i][k] * b[k][j]
                k += 1
            j += 1
        i += 1
    return(c)

def kron(u:a, v:a, size):
    # [5] Calculates the Kronecker product.
    #
    # Args:
    #   u: numeric array (vector)
    #   v: numeric array (vector)
    #   size (int): number of elements in u
    #
    prod = array(size**2)
    i = 0
    while i < size:
        j = 0
        while j < size:
            prod[size*i + j] += u[i] * v[j]
            j += 1
        i += 1
    return(prod)
