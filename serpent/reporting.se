# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation 
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

# Reporting index is the branchID
# Reporters index is the rep. address
# We 0 index reputation so can walk thru for consensus
# EventsExpDates index is the currentVotePeriod or in the future if an event expires in the future
# RepIDtoIndex returns a reporter's reporters[] index given their reputationID as the key
# Events is 0 indexed as well
data Reporting[](reputation[](repValue, reporterID), numberReporters, repIDtoIndex[])

def init():
    self.Reporting[1010101].repIDtoIndex[tx.origin] = 0
    self.Reporting[1010101].reputation[0].repValue = 470*2^64
    self.Reporting[1010101].reputation[0].reporterID = tx.origin
    self.Reporting[1010101].numberReporters = 1

def faucet():
    index = self.Reporting[1010101].numberReporters
    self.Reporting[1010101].repIDtoIndex[tx.origin] = index
    self.Reporting[1010101].reputation[index].repValue = 47*2^64
    self.Reporting[1010101].reputation[index].reporterID = tx.origin
    self.Reporting[1010101].numberReporters += 1

# @return reputation value        
def getRepBalance(branch, address):
    repIndex = self.Reporting[branch].repIDtoIndex[address]
    if(repIndex==0 && self.Reporting[branch].reputation[repIndex].reporterID!=address):
        return(0)
    return(self.Reporting[branch].reputation[repIndex].repValue)

# will return 0s for array values after it's looped through all the ones you
# have an actual balance in
def getReputation(address):
    if(address):
        branches = array(2*self.branchListCount)
        i = 0
        b = 0
        while i < self.branchListCount:
            branch = self.branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    else:
        address = tx.origin
        branches = array(2*self.branchListCount)
        i = 0
        b = 0
        while i < self.branchListCount:
            branch = self.branchList[i]
            balance = self.getRepBalance(branch, address)
            if(balance!=0):
                branches[b] = branch
                branches[b+1] = balance
                b += 2
            i += 1
    return(branches: arr)

def hashReport(report: arr, salt):
        hashInfo = array(len(report) + 2)
        hashInfo[0] = tx.origin
        hashInfo[1] = salt
        i = 2
        while i < (len(report) + 2):
            hashInfo[i] = report[i]
            i += 1
        reportHash = sha256(hashInfo, items=len(hashInfo))
        return(reportHash)

# atm voters who do vote are req. to vote on all things in their respective ballots (even if just a 0 / no vote)
# ui should handle this ^
# ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents
# && loop through the events[] array from 0 to numberEvents -1 for the votes list / order
# UI will need a function to get the items in that array above so it can make a report!
# w/ this function you can get the eventIDs, look them up && report on outcomes (probably w/ another function to look them up) -- make sure in this function to check that the report value is not >maxvalue or <minvalue for the event
# voteperiod is an optional parameter only used in the scenario that we get behind on voting periods - ui will want to alert users of this and say hey we're behind but atm you should really be voting on this voting period (anything meeting the req. of vote if we were caught up)
# @returns a ballot of events (UI needs to vote w/ a ballot of reports in this order per corresponding event)
def makeBallot(branch, votePeriod):
    if(votePeriod):
        numEvents = self.EventsExpDates[branch][votePeriod].numberEvents
        eventArray = array(numEvents)
        i = 0
        while i < numEvents:
            eventID = self.EventsExpDates[branch][votePeriod].events[numEvents]
            eventArray[i] = eventID
    else:
        numEvents = self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].numberEvents
        eventArray = array(numEvents)
        i = 0
        while i < numEvents:
            eventID = self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].events[numEvents]
            eventArray[i] = eventID
    return(eventArray: arr)

def reputationApi(reputationIndex, itemNumber, branchID):
    if(itemNumber==0):
        return(self.Reporting[branchID].reputation[reputationIndex].repValue)
    elif(itemNumber==1):
        return(self.Reporting[branchID].reputation[reputationIndex].reporterID)

elif(itemNumber==2):
    return(self.Reporting[ID].numberReporters)
elif(itemNumber==3):
    return(self.Reporting[ID].repIDtoIndex[arrayIndex])

# check that msg.sender is one of our function contracts

def setInitialReporters(parent, branchID):
    # first vote period won't be until after the current (in this case first) basket of things has expired
        # if floor(blockNum / periodLength) is say 5 and eventsExpDates[5]
        # the current vote period should be on things from eventsExpDates 4 (when making a new branch this vote period will just fail quorem, and current vote period will be incrememented)
        # then once blockNum / periodLength is say 6 and eventsExpDates[6]
        # votePeriod 4 should close and the currentVotePeriod should be from
        # eventsExpDates 5 (anyone can call the consensus function for voteperiod 4 at this point)
    i = 0
    while i < self.Reporting[parent].numberReporters:
        reporterID = self.Reporting[parent].reputation[i].reporterID
        self.Reporting[branchID].reputation[i].reporterID = reporterID
        self.Reporting[branchID].reputation[i].repValue = self.Reporting[parent].reputation[i].repValue
        self.Reporting[branchID].repIDtoIndex[reporterID] = i
        i+=1
    self.Reporting[branchID].numberReporters = i
    return(1)

def addReporter(branch):
    return(1)