# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation 
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

# Markets' index is the marketID
# Events is a 0 indexed array of events in the market in the format of
    # [1, event, event, 2, event, 3, event, event, event]
    # 1 means dimension 1, 2 is events in dimension 2, 3 is the dimension 3 events
# Sharespurchased keeps track of the number of shares purchased for each outcome
    # sharesPurchased states starts at 1 - (same for participants[].shares[] array)
# Participants is a 0 indexed array of participants, their cashIDs, && the shares in each outcome they've purchased of an event
# a binary outcome state 1 is no, 2 is true, 0 if not determined
# tradingFee is a percent in fixedPoint
# tradingPeriod is which eventexpperiod market expires in
data Markets[](events[], sharesPurchased[], addr2participant[], participants[](participantID, shares[]), lenEvents, currentParticipant, winningOutcomes[], alpha, cumulativeScale, numOutcomes, tradingPeriod, tradingFee, branch)

data nonces[]



# @return cost - how much it costs you to buy
#         price - current share price of that outcome after buy
def getSimulatedBuy(market, outcome):
    # lmsr cost calcs
    oldCost = lsLmsr(market)
    sharesPurchased(market)[outcome] += amount
    newCost = lsLmsr(market)
    if newCost <= oldCost:
        sharesPurchased(market)[outcome] -= amount
        return(-2)
    cost = (newCost - oldCost)
    price = self.price(market, outcome)
    sharesPurchased(market)[outcome] -= amount
    return([cost, price], items=2)

# @return cost - how much you get paid to sell
#         price - current share price of that outcome after sell
def getSimulatedSell(market, outcome):
    # lmsr cost calcs
    oldCost = lsLmsr(market)
    sharesPurchased(market)[outcome] -= amount
    newCost = lsLmsr(market)
    if oldCost <= newCost:
        sharesPurchased(market)[outcome] += amount
        return(-2)
    # these prices are in fixed point
    cost = oldCost - newCost
    price = self.price(market, outcome)
    sharesPurchased(market)[outcome] += amount
    return([cost, price], items=2)


def getMarketInfo(market):
    info = array(8)
    info[0] = self.Info[market].creator
    info[1] = self.Info[market].creationFee
    info[2] = self.Markets[market].currentParticipant
    info[3] = self.Markets[market].alpha
    info[4] = self.Markets[market].cumulativeScale
    info[5] = self.Markets[market].numOutcomes
    info[6] = self.Markets[market].tradingPeriod
    info[7] = self.Markets[market].tradingFee
    return(info: arr)

def getMarketEvents(market):
    i = 0
    lenEvents = self.Markets[market].lenEvents
    events = array(lenEvents)
    while i < lenEvents:
        events[i] = self.Markets[market].events[i]
        i += 1
    return(events: arr)

# eventID && outcomeNumber only needed if itemNumber is 1
def marketParticipantsApi(participantIndex, itemNumber, eventID, outcomeNumber, marketID):
    if(itemNumber==0):
        return(self.Markets[marketID].participants[participantIndex].participantID)
    elif(itemNumber==1):
        return(self.Markets[marketID].participants[participantIndex].shares[outcomeNumber])==4):
        if(itemNumber==0):
            return(self.Markets[ID].events[arrayIndex])
        elif(itemNumber==1):
            return(self.Markets[ID].sharesPurchased[arrayIndex])
        elif(itemNumber==2):
            return(-5)
        elif(itemNumber==3):
            return(self.Markets[ID].lenEvents)
        elif(itemNumber==4):
            return(self.Markets[ID].currentParticipant)
        elif(itemNumber==5):
            return(self.Markets[ID].winningOutcomes[arrayIndex])
        elif(itemNumber==6):
            return(self.Markets[ID].alpha)
        elif(itemNumber==7):
            return(self.Markets[ID].cumulativeScale)
        elif(itemNumber==8):
            return(self.Markets[ID].numOutcomes)
        elif(itemNumber==9):
            return(self.Markets[ID].tradingPeriod)
        elif(itemNumber==10):
            return(self.Markets[ID].tradingFee)


# alpha is equal to v/(n*log(n)) where v is the max percent commission
# && n is the number of outcomes people can trade. Alpha is set when
# a market is created.
macro lsLmsr($marketID):
    with $bq = Bq($marketID):
        with $i = 1:
            with $sumExp = 0:
                while $i <= numOutcomes($marketID):
                    $sumExp += fx_exp(sharesPurchased($marketID)[$i] * 2**64 / $bq)
                    $i += 1
                $bq*fx_log($sumExp)/2**64

macro sumList($q, $a, $b):
    $i = $a + 1
    $result = $q[$a]
    while $i <= $b:
        $result += $q[$i]
        $i += 1
    $result

macro market($marketID):
    self.Markets[$marketID]

macro alpha($marketID):
    market($marketID).alpha

macro cumScale($marketID):
    market($marketID).cumulativeScale

macro numOutcomes($marketID):
    market($marketID).numOutcomes

macro sharesPurchased($marketID):
    market($marketID).sharesPurchased

macro particpant($marketID, $addr):
    market($marketID).participants[$addr]

macro Bq($marketID):
   alpha($marketID) * cumScale($marketID) * sumList(sharesPurchased($marketID), 1, numOutcomes($marketID)) / 2**64

def price(market, outcome):
    a = lsLmsr(market)
    sharesPurchased(market)[outcome] += 2**32
    b = lsLmsr(market)
    sharesPurchased(market)[outcome] -= 2**32
    return((b - a) * 2**32)
