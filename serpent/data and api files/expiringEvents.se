# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation 
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

# [branchID][votingPeriod]
# v_size = numReports * numEvents
# reportsFilled, reportsMask, weightedCenteredData, loadingVector, scores, set1, set2, old,
# new1, new2, adjPrinComp, smoothRep, outcomesFinal, consensusReward is all consensus data
# reporters is [reporterID][eventNum]
# reporthash is [reporterID] = hash
data EventsExpDates[][](numberEvents, events[], totalRepReported, reporters[][], reportHash[], vSize, reportsFilled[], reportsMask[], weightedCenteredData[], loadingVector[], scores[], set1[], set2[], old[], new1[], new2[], adjPrinComp[], smoothRep[], outcomesFinal[])

# @return all events in a branch and expiration period
def getEvents(branch, expDateIndex):
    numEvents = self.EventsExpDates[branch][expDateIndex].numberEvents
    events = array(numEvents)
    i = 0
    while i < numEvents:
        events[i] = self.EventsExpDates[branch][expDateIndex].events[i]
        i += 1
    return(events: arr)

def getNumberEvents(branch, expDateIndex):
	return(self.EventsExpDates[branch][expDateIndex].numberEvents)

def getEvent(branch, expDateIndex, expDateIndex):
	return(self.EventsExpDates[branch][expDateIndex].events[eventIndex])

def getTotalRepReported(branch, expDateIndex):
	return(self.EventsExpDates[branch][expDateIndex].totalRepReported)

def getReporterBallot(branch, expDateIndex, reporterID):
	return(load(self.EventsExpDates[branch][expDateIndex].reporters[reporterID][0], items=self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

def getReport(branch, expDateIndex, reporter, reportNum):
	return(self.EventsExpDates[branch][expDateIndex].reporters[reporter][reportNum])

def getVSize(branch, expDateIndex):
    return(self.EventsExpDates[branch][expDateIndex].vSize)

def getReportsFilled(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].reportsFilled[0], items=self.EventsExpDates[branch][expDateIndex].vSize): arr)

def getReportsMask(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].reportsMask[0], items=self.EventsExpDates[branch][expDateIndex].vSize): arr)

def getWeightedCenteredData(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].weightedCenteredData[0], items=self.EventsExpDates[branch][expDateIndex].vSize): arr)

def getLoadingVector(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].loadingVector[0], items=self.EventsExpDates[branch][expDateIndex].numberEvents+1): arr)

def getScores(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].scores[0], items=(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)

def getSetOne(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].set1[0], items=(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)

def getSetTwo(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].set2[0], items=(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)

def returnOld(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].old[0], items=self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

def getNewOne(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].new1[0], items=self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

def getNewTwo(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].new2[0], items=self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

def getAdjPrinComp(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].adjPrinComp[0], items=(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)

def getSmoothRep(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].smoothRep[0], items=(self.EventsExpDates[branch][expDateIndex].vSize/self.EventsExpDates[branch][expDateIndex].numberEvents)): arr)

def getOutcomesFinal(branch, expDateIndex):
	return(load(self.EventsExpDates[branch][expDateIndex].outcomesFinal[0], items=self.EventsExpDates[branch][expDateIndex].numberEvents): arr)

# check that msg.sender is one of our function contracts
def addEvent(branch, expDateIndex, eventID):
	# do some event adding stuff here
	return(1)

def setTotalRepReported(branch, expDateIndex, repReported):
	self.EventsExpDates[branch][expDateIndex].totalRepReported = repReported
	return(1)

def setReporterBallot(branch, expDateIndex, reporterID, report: arr):
	save(self.EventsExpDates[branch][expDateIndex].reporters[reporterID][0], report, items=len(report))
	return(1)

def setVSize(branch, expDateIndex, vSize):
	self.EventsExpDates[branch][expDateIndex].vSize = vSize
	return(1)

def setReportsFilled(branch, expDateIndex, reportsFilled: arr):
	save(self.EventsExpDates[branch][expDateIndex].reportsFilled[0], reportsFilled, items=len(reportsFilled))
	return(1)

def setReportsMask(branch, expDateIndex, reportsMask: arr):
	save(self.EventsExpDates[branch][expDateIndex].reportsMask[0], reportsMask, items=len(reportsMask))
	return(1)	

def setWeightedCenteredData(branch, expDateIndex, weightedCenteredData: arr):
	save(self.EventsExpDates[branch][expDateIndex].weightedCenteredData[0], weightedCenteredData, items=len(weightedCenteredData))
	return(1)

def setLoadingVector(branch, expDateIndex, loadingVector: arr):
	save(self.EventsExpDates[branch][expDateIndex].loadingVector[0], loadingVector, items=len(loadingVector))
	return(1)

def setScores(branch, expDateIndex, scores: arr):
	save(self.EventsExpDates[branch][expDateIndex].setScores[0], scores, items=len(scores))
	return(1)

def setSetOne(branch, expDateIndex, setOne: arr):
	save(self.EventsExpDates[branch][expDateIndex].set1[0], setOne, items=len(setOne))
	return(1)

def setSetTwo(branch, expDateIndex, setTwo: arr):
	save(self.EventsExpDates[branch][expDateIndex].set2[0], setTwo, items=len(setTwo))
	return(1)

def setOld(branch, expDateIndex, setOld: arr):
	save(self.EventsExpDates[branch][expDateIndex].old[0], setOld, items=len(setOld))
	return(1)

def setNewOne(branch, expDateIndex, newOne: arr):
	save(self.EventsExpDates[branch][expDateIndex].new1[0], newOne, items=len(newOne))
	return(1)

def setNewTwo(branch, expDateIndex, newTwo: arr):
	save(self.EventsExpDates[branch][expDateIndex].new2[0], newTwo, items=len(newTwo))
	return(1)

def setAdjPrinComp(branch, expDateIndex, adjPrinComp: arr):
	save(self.EventsExpDates[branch][expDateIndex].adjPrinComp[0], adjPrinComp, items=len(adjPrinComp))
	return(1)

def setSmoothRep(branch, expDateIndex, smoothRep: arr):
	save(self.EventsExpDates[branch][expDateIndex].smoothRep[0], smoothRep, items=len(smoothRep))
	return(1)

def setOutcomesFinal(branch, expDateIndex, outcomesFinal: arr):
	save(self.EventsExpDates[branch][expDateIndex].outcomesFinal[0], outcomesFinal, items=len(outcomesFinal))
	return(1)

# atm voters who do vote are req. to vote on all things in their respective ballots (even if just a 0 / no vote)
# ui should handle this ^
# ballot should be all votes for events in order of the events from self.Reporting[branch].eventsExpDates[futurePeriod].numberEvents
# && loop through the events[] array from 0 to numberEvents -1 for the votes list / order
# UI will need a function to get the items in that array above so it can make a report!
# w/ this function you can get the eventIDs, look them up && report on outcomes (probably w/ another function to look them up) -- make sure in this function to check that the report value is not >maxvalue or <minvalue for the event
# voteperiod is an optional parameter only used in the scenario that we get behind on voting periods - ui will want to alert users of this and say hey we're behind but atm you should really be voting on this voting period (anything meeting the req. of vote if we were caught up)
# @returns a ballot of events (UI needs to vote w/ a ballot of reports in this order per corresponding event)
def makeBallot(branch, votePeriod):
    if(votePeriod):
        numEvents = self.EventsExpDates[branch][votePeriod].numberEvents
        eventArray = array(numEvents)
        i = 0
        while i < numEvents:
            eventID = self.EventsExpDates[branch][votePeriod].events[numEvents]
            eventArray[i] = eventID
    else:
        numEvents = self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].numberEvents
        eventArray = array(numEvents)
        i = 0
        while i < numEvents:
            eventID = self.EventsExpDates[branch][self.Branches[branch].currentVotePeriod].events[numEvents]
            eventArray[i] = eventID
    return(eventArray: arr)