# This software (Augur) allows buying and selling event options in Ethereum.
#
# Copyright (c) 2015 Forecast Foundation 
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# If you have questions, please contact Joey Krug (joey@augur.net) or
# Jack Peterson (jack@augur.net).

extern whitelist.se: [addAddress:ii:s, check:i:i, checkaddr:ii:i, replaceAddress:iii:s]
extern resolve.se: [resolve:aaaaaii:a, smooth:aaii:a]
extern events.se: [getEventBranch:i:i, getEventInfo:i:a, getExpiration:i:i, getMaxValue:i:i, getMinValue:i:i, getNumOutcomes:i:i, getOutcome:i:i, initializeEvent:iiiiii:i, setOutcome:ii:i]
extern expiringEvents.se: [addEvent:iii:i, getAdjPrinComp:ii:a, getEvent:iii:i, getEvents:ii:a, getLoadingVector:ii:a, getNewOne:ii:a, getNewTwo:ii:a, getNumberEvents:ii:i, getOutcomesFinal:ii:a, getReport:iiii:i, getReportHash:iii:i, getReporterBallot:iii:a, getReportsFilled:ii:a, getReportsMask:ii:a, getScores:ii:a, getSetOne:ii:a, getSetTwo:ii:a, getSmoothRep:ii:a, getTotalRepReported:ii:i, getVSize:ii:i, getWeightedCenteredData:ii:a, makeBallot:ii:a, moveEventsToCurrentPeriod:iii:i, returnOld:ii:a, setAdjPrinComp:iia:i, setDeflated:iia:i, setLoadingVector:iia:i, setNewOne:iia:i, setNewTwo:iia:i, setOld:iia:i, setOutcomesFinal:iia:i, setReportHash:iiii:i, setReporterBallot:iiiai:i, setReportsFilled:iia:i, setReportsMask:iia:i, setScores:iia:i, setSetOne:iia:i, setSetTwo:iia:i, setSmoothRep:iia:i, setTotalRepReported:iii:i, setVSize:iii:i, setWeightedCenteredData:iia:i]
extern branches.se: [addMarket:ii:i, getBranch:i:i, getBranches:_:a, getMarkets:i:a, getMinTradingFee:i:i, getNumBranches:_:i, getNumMarkets:i:i, getPeriodLength:i:i, getStep:i:i, getSubstep:i:i, getVotePeriod:i:i, incrementPeriod:i:i, incrementStep:i:i, incrementSubstep:i:i, initializeBranch:iiii:i, setStep:ii:i, setSubstep:ii:i]
extern reporting.se: [addRep:iii:i, addReporter:ii:i, faucet:_:_, getNumberReporters:i:i, getRepBalance:ii:i, getRepByIndex:ii:i, getReporterID:ii:i, getReputation:i:a, hashReport:ai:i, repIDToIndex:ii:i, setInitialReporters:ii:i, subtractRep:iii:i]

WHITELIST = 0xf1e4b1b0d357ded7a34c08dcac1a5d8d1eda795c
EVENTS = 0xe34fd8a3840cba70fdd73a01c75302de959aa5a9
EXPIRING_EVENTS = 0xb7b617b776e66cbae79606d2b6221501ad110090
BRANCHES = 0x2440e4769deb9fd3fd528884b95dc76e4e3482cf
REPORTING = 0x175d90d83deec9e5b75cef6b0659958fe2fd24b1
RESOLVE = create("../consensus/resolve.se")

def smooth(branch, period, num_events, num_reports, v_size):
    if !WHITELIST.check(msg.sender):
        return(-1)
    with reputation = array(num_reports):
        with i = 0:
            while i < num_reports:
                reputation[i] = self.Reporting[branch].reputation[i].repValue
                i += 1
            with adjusted_scores = load(self.EventsExpDates[branch][period].adjPrinComp[0], items=num_reports):
                with smooth_rep = RESOLVE.smooth(adjusted_scores, reputation, num_reports, num_events, outsz=num_reports):
                    save(self.EventsExpDates[branch][period].smoothRep[0], smooth_rep, items=num_reports)
                    return(1)

def resolve(branch, period, num_events, num_reports, v_size):
    if !WHITELIST.check(msg.sender):
        return(-1)
    with reports_filled = load(self.EventsExpDates[branch][period].reportsFilled[0], items=v_size):
        with smooth_rep = load(self.EventsExpDates[branch][period].smoothRep[0], items=num_reports):
            with scaled = array(num_events):
                with scaled_max = array(num_events):
                    with scaled_min = array(num_events):
                        with j = 0:
                            while j < num_events:
                                if self.Events[self.EventsExpDates[branch][period].events[j]].maxValue != 1 && self.Events[self.EventsExpDates[branch][period].events[j]].numOutcomes == 2:
                                    scaled[j] = 1
                                    scaled_max[j] = self.Events[self.EventsExpDates[branch][period].events[j]].maxValue * ONE
                                    scaled_min[j] = self.Events[self.EventsExpDates[branch][period].events[j]].minValue * ONE
                                else:
                                    scaled[j] = 0
                                    scaled_min[j] = ONE
                                    scaled_max[j] = 2 * ONE
                                j += 1
                            with result = RESOLVE.resolve(smooth_rep, reports_filled, scaled, scaled_max, scaled_min, num_reports, num_events, outsz=num_events):
                                save(self.EventsExpDates[branch][period].outcomesFinal[0], result, items=num_events)
                                return(1)

# inset('../consensus/logging.se')
inset('../consensus/constants.se')
