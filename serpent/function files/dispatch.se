# This software (Augur) allows buying and selling event options in Ethereum.
#
# Copyright (c) 2015 Forecast Foundation 
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# If you have questions, please contact Joey Krug (joey@augur.net) or
# Jack Peterson (jack@augur.net).

extern redeem_interpolate.se: [redeem_interpolate:iiiii:i]
extern redeem_center.se: [redeem_center:iiiii:i, redeem_covariance:iiiii:i]
extern redeem_score.se: [redeem_blank:iiiii:i, redeem_loadings:iiiii:i, redeem_latent:iiiii:i, redeem_deflate:iiiii:i, redeem_score:iiiii:i]
extern redeem_adjust.se: [redeem_reputation_delta:iiiii:i, redeem_weighted_delta:iiiii:i, redeem_select_scores:iiiii:i]
extern redeem_resolve.se: [redeem_smooth:iiiii:i, redeem_resolve:iiiii:i]
extern redeem_payout.se: [redeem_payout:iiiii:i]

# inset('../consensus/logging.se')

# replace these with contract addresses once loaded onto the chain!
REDEEM_INTERPOLATE = create("../function files/redeem_interpolate.se")
REDEEM_CENTER = create("../function files/redeem_center.se")
REDEEM_SCORE = create("../function files/redeem_score.se")
REDEEM_ADJUST = create("../function files/redeem_adjust.se")
REDEEM_RESOLVE = create("../function files/redeem_resolve.se")
REDEEM_PAYOUT = create("../function files/redeem_payout.se")

# - 50% of fees already distributed to market creators
#   all remaining fees go to reporters
# - what if not enough consensus or not enough events expiring upcoming
# @return step we're on of redeem function, for final call return new voting period
def dispatch(branch):
    with period = self.Branches[branch].currentVotePeriod:
        with num_events = self.EventsExpDates[branch][period].numberEvents:
            with v_size = self.EventsExpDates[branch][period].vSize:
                with num_reports = v_size / num_events:
                    with step = self.Branches[branch].step:
                        if step == 0:
                            return(REDEEM_A.redeem_interpolate(branch, period, num_events, num_reports, v_size))
                        elif step == 1:
                            return(REDEEM_B.redeem_center(branch, period, num_events, num_reports, v_size))
                        elif step == 2 || step == 3 || step == 4 || step == 5 || step == 6:
                            return(REDEEM_B.redeem_2_6(branch, period, num_events, num_reports, v_size))
                        elif step == 7:
                            return(REDEEM_B.redeem_7(branch, period, num_events, num_reports, v_size))
                        elif step == 8:
                            return(REDEEM_B.redeem_8(branch, period, num_events, num_reports, v_size))
                        elif step == 9:
                            return(REDEEM_C.redeem_9(branch, period, num_events, num_reports, v_size))
                        elif step == 10:
                            return(REDEEM_C.redeem_10(branch, period, num_events, num_reports, v_size))
                        elif step == 11:
                            return(REDEEM_C.redeem_11(branch, period, num_events, num_reports, v_size))
                        elif step == 12:
                            return(REDEEM_C.redeem_12(branch, period, num_events, num_reports, v_size))
                        elif step == 13:
                            return(REDEEM_D.redeem_13(branch, period, num_events, num_reports, v_size))
