# This software (Augur) allows buying && selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation 
#    This program is free software; you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it &&/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

extern whitelist: [addAddress:ii:s, check:i:i, checkaddr:ii:i, replaceAddress:iii:s]
extern interpolate: [interpolate:aaaaa:a]
extern center: [center:aaaaaii:a, tokenize:ai:a, covariance:aaii:a]
extern score: [blank:iii:a, loadings:aaaii:a, latent:aai, deflate:aaii, score:aaaiii]
extern adjust: [reputation_delta:aii:a, weighted_delta:aaaaii:a, select_scores:aaaaaaii:a]
extern resolve: [smooth:aaii:a, resolve:aaaaaii:a]
extern payout: [payout:aaaii]

inset('../consensus/logging.se')
inset('../consensus/macros.se')

macro BRANCH: 0
macro EVENT: 1
macro MARKET: 2

# - 50% of fees already distributed to market creators
#   all remaining fees go to reporters
# - what if not enough consensus or not enough events expiring upcoming
# @return step we're on of redeem function, for final call return new voting period
def redeem(branch):
    with currentVotePeriod = self.Branches[branch].currentVotePeriod:
        with step = self.Branches[branch].step:
            if step == 0:
                # - loop through reputation && check if in reporters, if so use their
                #   report, if not use the fillin / not reported report (all zeroes)
                # - use this to make a giant array of votes to pass to self.consensus
                # - want to pass votes for each 0 indexed event in order (so we get
                #   votes from an actual reporter)
                # (if they didn't vote we set their array for each event to 0,0,0,0,0,0, etc...)
                numReporters = self.Reporting[branch].numberReporters
                reputation = array(numReporters)
                numberEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
                (self.EventsExpDates[ID][expDateIndex].numberEvents)
                votes = array(numReporters * numberEvents)
                with i = 0:
                    while i < numReporters:
                        reporterID = self.Reporting[branch].reputation[i].reporterID
                        reputation[i] = self.Reporting[branch].reputation[i].repValue
                        # checks to see if each reporter actually voted on events
                        # if they didn't vote (simply check if they voted on first event) do nothing (these values will be 0 by default due to Serpent array styles)
                        # else if the reporter did report on events put their ballot into the votes array
                        if self.EventsExpDates[branch][currentVotePeriod].reporters[reporterID][0] != 0:
                            with x = 0:
                                while x < numberEvents:
                                    votes[x + i*numberEvents] = self.EventsExpDates[branch][currentVotePeriod].reporters[reporterID][x]
                                    x += 1
                        i += 1
                vSize = len(votes)
                scaled = array(numberEvents)
                scaledMaxFixed = array(numberEvents)
                scaledMinFixed = array(numberEvents)
                with j = 0:
                    while j < numberEvents:
                        if self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue != 1:
                            scaled[j] = 1
                            scaledMaxFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue*2^64
                            scaledMinFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].minValue*2^64
                        else:
                            scaled[j] = 0
                            scaledMinFixed[j] = 1*2^64
                            scaledMaxFixed[j] = 2*2^64
                        j += 1
                result = interpolate.interpolate(votes, reputation, scaled, scaledMaxFixed, scaledMinFixed, outsz=2*vSize)
                self.EventsExpDates[branch][currentVotePeriod].vSize = vSize
                save(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], result, items=vSize)
                save(self.EventsExpDates[branch][currentVotePeriod].reportsMask[0], slice(result, items=vSize, items=2*vSize), items=vSize)
                self.Branches[branch].step = 1
                return(1)
    elif step == 1:
        with vSize = self.EventsExpDates[branch][currentVotePeriod].vSize:
            with numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents:
                with numReporters = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents:
                    with reputation = array(numReporters):
                        with i = 0:
                            while i < numReporters:
                                reputation[i] = self.Reporting[branch].reputation[i].repValue
                                i += 1
                        scaled = array(numEvents)
                        scaledMaxFixed = array(numEvents)
                        scaledMinFixed = array(numEvents)
                        with j = 0:
                            while j < numEvents:
                                if self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue != 1:
                                    scaled[j] = 1
                                    scaledMaxFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue*2^64
                                    scaledMinFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].minValue*2^64
                                else:
                                    scaled[j] = 0
                                    scaledMinFixed[j] = -1*2^64
                                    scaledMaxFixed[j] = 1*2^64
                                j += 1
                        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
                        reportsFilled = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
                        reportsFilled = load(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
                        result = center.center(reportsFilled, reputation, scaled, scaledMaxFixed, scaledMinFixed, 5, outsz=vSize+numEvents+1)
                        save(self.EventsExpDates[branch][currentVotePeriod].weightedCenteredData[0], result, items=vSize)
                        save(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], slice(result, items=vSize, items=len(result)), items=(len(result)-vSize))
                        self.Branches[branch].step = 2
                        return(2)
    elif step == 2 || step == 3 || step == 4 || step == 5 || step == 6:
        with vSize = self.EventsExpDates[branch][currentVotePeriod].vSize:
            # loading vector is numEvents + 1 long, the last element says how many iterations of it are left, should check this
            with numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents:
                with numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents:
                    #if(self.EventsExpDates[branch][currentVotePeriod].loadingVector[numEvents]==0):
                    #    return(0)
                    with loadingVector = array(numEvents+1):
                        loadingVector = load(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], items=numEvents+1)
                        weightedCenteredData = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
                        weightedCenteredData = load(self.EventsExpDates[branch][currentVotePeriod].weightedCenteredData[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
                        reputation = array(numReports)
                        with i = 0:
                            while i < numReports:
                                reputation[i] = self.Reporting[branch].reputation[i].repValue
                                i += 1
                        # multistep pca
                        # call this 5 times
                        loadingVector = score.loadings(loadingVector, weightedCenteredData, reputation, numReports, numEvents, outsz=numEvents+1)
                        save(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], loadingVector, items=len(loadingVector))
                        if step == 6:
                            self.Branches[branch].step = 7
                        else:
                            self.Branches[branch].step += 1
                        return(self.Branches[branch].step)
    elif step == 7:
        with vSize = self.EventsExpDates[branch][currentVotePeriod].vSize:
            with numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents:
                with numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents:
                    with loadingVector = array(numEvents+1):
                        loadingVector = load(self.EventsExpDates[branch][currentVotePeriod].loadingVector[0], items=numEvents+1)
                        weightedCenteredData = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
                        weightedCenteredData = load(self.EventsExpDates[branch][currentVotePeriod].weightedCenteredData[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
                        scores = score.score(loadingVector, weightedCenteredData, numReports, numEvents, outsz=numReports)
                        save(self.EventsExpDates[branch][currentVotePeriod].scores[0], scores, items=len(scores))
                        self.Branches[branch].step = 8
                        return(8)
    elif step == 8:
        with numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents:
            with numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents:
                with scores = array(numReports):
                    scores = load(self.EventsExpDates[branch][currentVotePeriod].scores[0], items=numReports)
                    result = adjust.reputation_delta(scores, numReports, numEvents, outsz=2*numReports)
                    # loads the first set of numReports items from result
                    save(self.EventsExpDates[branch][currentVotePeriod].set1[0], result, items=numReports)
                    save(self.EventsExpDates[branch][currentVotePeriod].set2[0], slice(result, items=numReports, items=2*numReports), items=numReports)
                    self.Branches[branch].step = 9
                    return(9)
    elif step == 9:
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        reportsFilled = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        reportsFilled = load(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
         # loading vector is numEvents + 1 long, the last element says how many iterations of it are left, should check this
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        reputation = array(numReports)
        i = 0
        while i < numReports:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i += 1
        set1 = array(numReports)
        set2 = array(numReports)
        set1 = load(self.EventsExpDates[branch][currentVotePeriod].set1[0], items=numReports)
        set2 = load(self.EventsExpDates[branch][currentVotePeriod].set2[0], items=numReports)
        result = adjust.weighted_delta(set1, set2, reputation, reportsFilled, numReports, numEvents, outsz=3*numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].old[0], result, items=numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].new1[0], slice(result, items=numEvents, items=2*numEvents), items=numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].new2[0], slice(result, items=2*numEvents, items=3*numEvents), items=numEvents)
        self.Branches[branch].step = 10
        return(10)
    elif step == 10:
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        old = array(numEvents)
        new1 = array(numEvents)
        new2 = array(numEvents)
        set1 = array(numReports)
        set2 = array(numReports)
        scores = array(numReports)
        old = load(self.EventsExpDates[branch][currentVotePeriod].old[0], items=numEvents)
        new1 = load(self.EventsExpDates[branch][currentVotePeriod].new1[0], items=numEvents)
        new2 = load(self.EventsExpDates[branch][currentVotePeriod].new2[0], items=numEvents)
        set1 = load(self.EventsExpDates[branch][currentVotePeriod].set1[0], items=numReports)
        set2 = load(self.EventsExpDates[branch][currentVotePeriod].set2[0], items=numReports)
        scores = load(self.EventsExpDates[branch][currentVotePeriod].scores[0], items=numReports)
        adjPrinComp = adjust.select_scores(old, new1, new2, set1, set2, scores, numReports, numEvents, outsz=numReports)
        save(self.EventsExpDates[branch][currentVotePeriod].adjPrinComp[0], adjPrinComp, items=len(adjPrinComp))
        self.Branches[branch].step = 11
        return(11)
    elif step == 11:
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        reputation = array(numReports)
        i = 0
        while i < numReports:
            reputation[i] = self.Reporting[branch].reputation[i].repValue
            i += 1
        adjPrinComp = array(numReports)
        adjPrinComp = load(self.EventsExpDates[branch][currentVotePeriod].adjPrinComp[0], items=numReports)
        smoothRep = resolve.smooth(adjPrinComp, reputation, numReports, numEvents, outsz=numReports)
        save(self.EventsExpDates[branch][currentVotePeriod].smoothRep[0], smoothRep, items=len(smoothRep))
        self.Branches[branch].step = 12
        return(12)
    elif step == 12:
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        reportsFilled = array(self.EventsExpDates[branch][currentVotePeriod].vSize)
        reportsFilled = load(self.EventsExpDates[branch][currentVotePeriod].reportsFilled[0], items=self.EventsExpDates[branch][currentVotePeriod].vSize)
        smoothRep = array(numReports)
        smoothRep = load(self.EventsExpDates[branch][currentVotePeriod].smoothRep[0], items=numReports)
        j = 0
        scaled = array(numEvents)
        scaledMaxFixed = array(numEvents)
        scaledMinFixed = array(numEvents)
        while j < numEvents:
            if(self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue!=1 && self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].numOutcomes==2):
                scaled[j] = 1
                scaledMaxFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].maxValue*2^64
                scaledMinFixed[j] = self.Events[self.EventsExpDates[branch][currentVotePeriod].events[j]].minValue*2^64
            else:
                scaled[j] = 0
                scaledMinFixed[j] = 1*2^64
                scaledMaxFixed[j] = 2*2^64
            j+=1
        result = resolve.resolve(smoothRep, reportsFilled, scaled, scaledMaxFixed, scaledMinFixed, numReports, numEvents, outsz=numEvents)
        save(self.EventsExpDates[branch][currentVotePeriod].outcomesFinal[0], result, items=numEvents)
        log(5)
        self.Branches[branch].step = 13
        return(13)
    elif step == 13:
        vSize = self.EventsExpDates[branch][currentVotePeriod].vSize
        numEvents = self.EventsExpDates[branch][currentVotePeriod].numberEvents
        numReports = self.EventsExpDates[branch][currentVotePeriod].vSize / numEvents
        smoothRep = array(numReports)
        smoothRep = load(self.EventsExpDates[branch][currentVotePeriod].smoothRep[0], items=numReports)
        reportsMask = array(vSize)
        reportsMask = load(self.EventsExpDates[branch][currentVotePeriod].reportsMask[0], items=vSize)
        outcomesFinal = array(numEvents)
        outcomesFinal = load(self.EventsExpDates[branch][currentVotePeriod].outcomesFinal[0], items=numEvents)
        reporterBonus = payout.payout(outcomesFinal, smoothRep, reportsMask, numReports, numEvents, outsz=numReports)

        # get event ID for each event by taking the x index in the votes arrays - shoving it in reporting.events[]
        # && getting the cooresponding ID
        n = 0
        while n < numEvents:
            eventID = self.EventsExpDates[branch][currentVotePeriod].events[n]
            # then take outcomes_final && set each event outcome
            self.Events[eventID].outcome = outcomesFinal[n]
            if(outcomesFinal[n]!=3*2^63):
                # return bond
                self.cashcoinBalances[eventID] -= 42*2^64
                self.cashcoinBalances[self.Info[eventID].creator] += 42*2^64
            else:
                # give event bond money to reporters
                self.cashcoinBalances[eventID] -= 42*2^64
                self.cashcoinBalances[branch] += 42*2^64
            n += 1
        # need to loop through rep holders && distribute 50% of branch fees to reporters' cashcoin addresses 
        # also need to take reporterBonus && redistribute reputation in the Reporting structure accordingly
        z = 0
        while z < numReports:
            self.Reporting[branch].reputation[z].repValue = (reporterBonus[z]*21000000)/2^64
            self.cashcoinBalances[self.Reporting[branch].reputation[z].reporterID] += self.cashcoinBalances[branch]*reporterBonus[z] / 2^64
            z += 1
        self.Branches[branch].currentVotePeriod += 1
        self.cashcoinBalances[branch] -= self.cashcoinBalances[branch]
        self.Branches[branch].step = 0
        return(self.Branches[branch].currentVotePeriod)
