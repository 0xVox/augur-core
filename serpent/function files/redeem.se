# This software (Augur) allows buying and selling event options in Ethereum.
#
# Copyright (c) 2015 Forecast Foundation 
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# If you have questions, please contact Joey Krug (joey@augur.net) or
# Jack Peterson (jack@augur.net).

extern whitelist: [addAddress:ii:s, check:i:i, checkaddr:ii:i, replaceAddress:iii:s]
extern interpolate: [interpolate:aaaaa:a]
extern center: [center:aaaaaii:a, tokenize:ai:a, covariance:aaii:a]
extern score: [blank:iii:a, loadings:aaaii:a, latent:aai, deflate:aaii, score:aaaiii]
extern adjust: [reputation_delta:aii:a, weighted_delta:aaaaii:a, select_scores:aaaaaaii:a]
extern resolve: [smooth:aaii:a, resolve:aaaaaii:a]
extern payout: [payout:aaaii]

inset('../consensus/logging.se')
inset('../consensus/macros.se')

macro BOND: 42 * ONE

# - 50% of fees already distributed to market creators
#   all remaining fees go to reporters
# - what if not enough consensus or not enough events expiring upcoming
# @return step we're on of redeem function, for final call return new voting period
def dispatch(branch):
    with period = self.Branches[branch].currentVotePeriod:
        with num_events = self.EventsExpDates[branch][period].numberEvents:
            with v_size = self.EventsExpDates[branch][period].vSize:
                with num_reports = v_size / num_events:
                    with step = self.Branches[branch].step:
                        if step == 0:
                            return(self.redeem_0(branch, period, num_events, num_reports, v_size))
                        elif step == 1:
                            return(self.redeem_1(branch, period, num_events, num_reports, v_size))
                        elif step == 2 || step == 3 || step == 4 || step == 5 || step == 6:
                            return(self.redeem_2_6(branch, period, num_events, num_reports, v_size))
                        elif step == 7:
                            return(self.redeem_7(branch, period, num_events, num_reports, v_size))
                        elif step == 8:
                            return(self.redeem_8(branch, period, num_events, num_reports, v_size))
                        elif step == 9:
                            return(self.redeem_9(branch, period, num_events, num_reports, v_size))
                        elif step == 10:
                            return(self.redeem_10(branch, period, num_events, num_reports, v_size))
                        elif step == 11:
                            return(self.redeem_11(branch, period, num_events, num_reports, v_size))
                        elif step == 12:
                            return(self.redeem_12(branch, period, num_events, num_reports, v_size))
                        elif step == 13:
                            return(self.redeem_13(branch, period, num_events, num_reports, v_size))

# - loop through reputation && check if in reporters, if so use their
#   report, if not use the fillin / not reported report (all zeroes)
# - use this to make a giant array of reports to pass to self.consensus
# - want to pass reports for each 0 indexed event in order (so we get
#   reports from an actual reporter)
# (if they didn't vote we set their array for each event to 0,0,0,0,0,0, etc...)
def redeem_0(branch, period, num_events, num_reports, v_size):
    with reputation = array(num_reports):
        with report_matrix = array(v_size):
            with i = 0:
                while i < num_reports:
                    with reporterID = self.Reporting[branch].reputation[i].reporterID:
                        reputation[i] = self.Reporting[branch].reputation[i].repValue
                        # - checks to see if each reporter actually voted on events
                        # - if they didn't vote (simply check if they voted on first event)
                        #     do nothing (these values will be 0 by default due to Serpent array styles)
                        #     else if the reporter did report on events put their ballot into the reports array
                        if self.EventsExpDates[branch][period].reporters[reporterID][0] != 0:
                            with j = 0:
                                while j < num_events:
                                    report_matrix[i*num_events + j] = self.EventsExpDates[branch][period].reporters[reporterID][j]
                                    j += 1
                    i += 1
            with scaled = array(num_events):
                with scaled_max_fixed = array(num_events):
                    with scaled_min_fixed = array(num_events):
                        with j = 0:
                            while j < num_events:
                                if self.Events[self.EventsExpDates[branch][period].events[j]].maxValue != 1:
                                    scaled[j] = 1
                                    scaled_max_fixed[j] = self.Events[self.EventsExpDates[branch][period].events[j]].maxValue * ONE
                                    scaled_min_fixed[j] = self.Events[self.EventsExpDates[branch][period].events[j]].minValue * ONE
                                else:
                                    scaled[j] = 0
                                    scaled_min_fixed[j] = ONE
                                    scaled_max_fixed[j] = 2 * ONE
                                j += 1
                        with result = interpolate.interpolate(report_matrix, reputation, scaled, scaled_max_fixed, scaled_min_fixed, outsz=2*v_size):
                            self.EventsExpDates[branch][period].v_size = v_size
                            save(self.EventsExpDates[branch][period].reportsFilled[0], result, items=v_size)
                            save(self.EventsExpDates[branch][period].reportsMask[0], slice(result, items=v_size, items=2*v_size), items=v_size)
                            self.Branches[branch].step = 1
                            return(1)

def redeem_1(branch, period, num_events, num_reports, v_size):
    with reputation = array(num_reports):
        with i = 0:
            while i < num_reports:
                reputation[i] = self.Reporting[branch].reputation[i].repValue
                i += 1
        with scaled = array(num_events):
            with scaledMaxFixed = array(num_events):
                with scaledMinFixed = array(num_events):
                    with j = 0:
                        while j < num_events:
                            if self.Events[self.EventsExpDates[branch][period].events[j]].maxValue != 1:
                                scaled[j] = 1
                                scaledMaxFixed[j] = self.Events[self.EventsExpDates[branch][period].events[j]].maxValue * ONE
                                scaledMinFixed[j] = self.Events[self.EventsExpDates[branch][period].events[j]].minValue * ONE
                            else:
                                scaled[j] = 0
                                scaledMinFixed[j] = -ONE
                                scaledMaxFixed[j] = ONE
                            j += 1
                    with reportsFilled = load(self.EventsExpDates[branch][period].reportsFilled[0], items=self.EventsExpDates[branch][period].vSize):
                        with result = center.center(reportsFilled, reputation, scaled, scaledMaxFixed, scaledMinFixed, 5, outsz=v_size+num_events+1):
                        save(self.EventsExpDates[branch][period].weightedCenteredData[0], result, items=v_size)
                        save(self.EventsExpDates[branch][period].loadingVector[0], slice(result, items=v_size, items=len(result)), items=(len(result)-v_size))
                        self.Branches[branch].step = 2
                        return(2)

def redeem_2_6(branch, period, num_events, num_reports, v_size):
    # loading vector is num_events + 1 long, the last element says how many iterations of it are left, should check this
    # if self.EventsExpDates[branch][period].loadingVector[num_events] == 0:
    #     return(0)
    with loadings = load(self.EventsExpDates[branch][period].loadingVector[0], items=num_events+1):
        with wcd = load(self.EventsExpDates[branch][period].weightedCenteredData[0], items=v_size):
            with reputation = array(num_reports):
                with i = 0:
                    while i < num_reports:
                        reputation[i] = self.Reporting[branch].reputation[i].repValue
                        i += 1
                # multistep pca
                # call this 5 times
                loadings = score.loadings(loadings, wcd, reputation, num_reports, num_events, outsz=num_events+1)
                save(self.EventsExpDates[branch][period].loadingVector[0], loadings, items=num_events+1)
                if step == 6:
                    self.Branches[branch].step = 7
                else:
                    self.Branches[branch].step += 1
                return(self.Branches[branch].step)

def redeem_7(branch, period, num_events, num_reports, v_size):
    with loadings = load(self.EventsExpDates[branch][period].loadingVector[0], items=num_events+1):
        with wcd = load(self.EventsExpDates[branch][period].weightedCenteredData[0], items=v_size):
            with scores = score.score(loadings, wcd, num_reports, num_events, outsz=num_reports):
                save(self.EventsExpDates[branch][period].scores[0], scores, items=num_reports)
                self.Branches[branch].step = 8
                return(8)

def redeem_8(branch, period, num_events, num_reports, v_size):
    with scores = load(self.EventsExpDates[branch][period].scores[0], items=num_reports):
        with result = adjust.reputation_delta(scores, num_reports, num_events, outsz=2*num_reports):
            # loads the first set of num_reports items from result
            save(self.EventsExpDates[branch][period].set1[0], result, items=num_reports)
            save(self.EventsExpDates[branch][period].set2[0], slice(result, items=num_reports, items=2*num_reports), items=num_reports)
            self.Branches[branch].step = 9
            return(9)

def redeem_9(branch, period, num_events, num_reports, v_size):
    with reportsFilled = load(self.EventsExpDates[branch][period].reportsFilled[0], items=v_size):
        with reputation = array(num_reports):
            with i = 0:
                while i < num_reports:
                    reputation[i] = self.Reporting[branch].reputation[i].repValue
                    i += 1
                with set1 = load(self.EventsExpDates[branch][period].set1[0], items=num_reports):
                    with set2 = load(self.EventsExpDates[branch][period].set2[0], items=num_reports):
                        with result = adjust.weighted_delta(set1, set2, reputation, reportsFilled, num_reports, num_events, outsz=3*num_events):
                            save(self.EventsExpDates[branch][period].old[0], result, items=num_events)
                            save(self.EventsExpDates[branch][period].new1[0], slice(result, items=num_events, items=2*num_events), items=num_events)
                            save(self.EventsExpDates[branch][period].new2[0], slice(result, items=2*num_events, items=3*num_events), items=num_events)
                            self.Branches[branch].step = 10
                            return(10)

def redeem_10(branch, period, num_events, num_reports, v_size):
    with old = load(self.EventsExpDates[branch][period].old[0], items=num_events):
        with new1 = load(self.EventsExpDates[branch][period].new1[0], items=num_events):
            with new2 = load(self.EventsExpDates[branch][period].new2[0], items=num_events):
                with set1 = load(self.EventsExpDates[branch][period].set1[0], items=num_reports):
                    with set2 = load(self.EventsExpDates[branch][period].set2[0], items=num_reports):
                        with scores = load(self.EventsExpDates[branch][period].scores[0], items=num_reports):
                            with adjPrinComp = adjust.select_scores(old, new1, new2, set1, set2, scores, num_reports, num_events, outsz=num_reports):
                                save(self.EventsExpDates[branch][period].adjPrinComp[0], adjPrinComp, items=len(adjPrinComp))
                                self.Branches[branch].step = 11
                                return(11)

def redeem_11(branch, period, num_events, num_reports, v_size):
    with reputation = array(num_reports):
        with i = 0:
            while i < num_reports:
                reputation[i] = self.Reporting[branch].reputation[i].repValue
                i += 1
            with adjPrinComp = load(self.EventsExpDates[branch][period].adjPrinComp[0], items=num_reports):
                with smoothRep = resolve.smooth(adjPrinComp, reputation, num_reports, num_events, outsz=num_reports):
                    save(self.EventsExpDates[branch][period].smoothRep[0], smoothRep, items=len(smoothRep))
                    self.Branches[branch].step = 12
                    return(12)

def redeem_12(branch, period, num_events, num_reports, v_size):
    with reportsFilled = load(self.EventsExpDates[branch][period].reportsFilled[0], items=v_size):
        with smoothRep = load(self.EventsExpDates[branch][period].smoothRep[0], items=num_reports):
            with scaled = array(num_events):
                with scaledMaxFixed = array(num_events):
                    with scaledMinFixed = array(num_events):
                        with j = 0:
                            while j < num_events:
                                if self.Events[self.EventsExpDates[branch][period].events[j]].maxValue != 1 && self.Events[self.EventsExpDates[branch][period].events[j]].numOutcomes == 2:
                                    scaled[j] = 1
                                    scaledMaxFixed[j] = self.Events[self.EventsExpDates[branch][period].events[j]].maxValue * ONE
                                    scaledMinFixed[j] = self.Events[self.EventsExpDates[branch][period].events[j]].minValue * ONE
                                else:
                                    scaled[j] = 0
                                    scaledMinFixed[j] = ONE
                                    scaledMaxFixed[j] = 2 * ONE
                                j += 1
                            with result = resolve.resolve(smoothRep, reportsFilled, scaled, scaledMaxFixed, scaledMinFixed, num_reports, num_events, outsz=num_events):
                                save(self.EventsExpDates[branch][period].outcomesFinal[0], result, items=num_events)
                                self.Branches[branch].step = 13
                                return(13)

def redeem_13(branch, period, num_events, num_reports, v_size):
    with smooth_rep = load(self.EventsExpDates[branch][period].smoothRep[0], items=num_reports):
        with reports_mask = load(self.EventsExpDates[branch][period].reportsMask[0], items=v_size):
            with outcomes = load(self.EventsExpDates[branch][period].outcomesFinal[0], items=num_events):
                with reporter_payouts = payout.payout(outcomes, smooth_rep, reports_mask, num_reports, num_events, outsz=num_reports):
                    # get event ID for each event by taking the x index in the reports arrays
                    # - shoving it in reporting.events[]
                    # && getting the cooresponding ID
                    with j = 0:
                        while j < num_events:
                            eventID = self.EventsExpDates[branch][period].events[j]
                            # then take outcomes_final && set each event outcome
                            self.Events[eventID].outcome = outcomes[j]
                            if outcomes[j] != BAD:
                                # return bond
                                self.cashcoinBalances[eventID] -= BOND
                                self.cashcoinBalances[self.Info[eventID].creator] += BOND
                            else:
                                # give event bond money to reporters
                                self.cashcoinBalances[eventID] -= BOND
                                self.cashcoinBalances[branch] += BOND
                            j += 1
                    # - need to loop through rep holders && distribute 50% of branch fees to
                    #   reporters' cashcoin addresses 
                    # - also need to take reporter_payouts && redistribute reputation in the
                    #   Reporting structure accordingly
                    with i = 0:
                        while i < num_reports:
                            # what is 21000000?
                            self.Reporting[branch].reputation[i].repValue = fixed_multiply(reporter_payouts[i], 21000000)
                            self.cashcoinBalances[self.Reporting[branch].reputation[i].reporterID] += fixed_multiply(self.cashcoinBalances[branch], reporter_payouts[i])
                            i += 1
                        self.Branches[branch].currentVotePeriod += 1
                        self.cashcoinBalances[branch] -= self.cashcoinBalances[branch]
                        self.Branches[branch].step = 0
                        return(self.Branches[branch].currentVotePeriod)
