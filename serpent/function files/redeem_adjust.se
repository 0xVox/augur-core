# This software (Augur) allows buying and selling event options in Ethereum.
#
# Copyright (c) 2015 Forecast Foundation 
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# If you have questions, please contact Joey Krug (joey@augur.net) or
# Jack Peterson (jack@augur.net).

extern adjust.se: [reputation_delta:aii:a, weighted_delta:aaaaii:a, select_scores:aaaaaaii:a]

# inset('../consensus/logging.se')
inset('../consensus/macros.se')

ADJUST = create("../consensus/adjust.se")

def redeem_reputation_delta(branch, period, num_events, num_reports, v_size):
    with scores = load(self.EventsExpDates[branch][period].scores[0], items=num_reports):
        with result = ADJUST.reputation_delta(scores, num_reports, num_events, outsz=2*num_reports):
            # loads the first set of num_reports items from result
            save(self.EventsExpDates[branch][period].set1[0], result, items=num_reports)
            save(self.EventsExpDates[branch][period].set2[0], slice(result, items=num_reports, items=2*num_reports), items=num_reports)
            self.Branches[branch].step += 1
            return(self.Branches[branch].step)

def redeem_weighted_delta(branch, period, num_events, num_reports, v_size):
    with reports_filled = load(self.EventsExpDates[branch][period].reportsFilled[0], items=v_size):
        with reputation = array(num_reports):
            with i = 0:
                while i < num_reports:
                    reputation[i] = self.Reporting[branch].reputation[i].repValue
                    i += 1
                with set1 = load(self.EventsExpDates[branch][period].set1[0], items=num_reports):
                    with set2 = load(self.EventsExpDates[branch][period].set2[0], items=num_reports):
                        with result = ADJUST.weighted_delta(set1, set2, reputation, reports_filled, num_reports, num_events, outsz=3*num_events):
                            save(self.EventsExpDates[branch][period].old[0], result, items=num_events)
                            save(self.EventsExpDates[branch][period].new1[0], slice(result, items=num_events, items=2*num_events), items=num_events)
                            save(self.EventsExpDates[branch][period].new2[0], slice(result, items=2*num_events, items=3*num_events), items=num_events)
                            self.Branches[branch].step += 1
                            return(self.Branches[branch].step)

def redeem_select_scores(branch, period, num_events, num_reports, v_size):
    with old = load(self.EventsExpDates[branch][period].old[0], items=num_events):
        with new1 = load(self.EventsExpDates[branch][period].new1[0], items=num_events):
            with new2 = load(self.EventsExpDates[branch][period].new2[0], items=num_events):
                with set1 = load(self.EventsExpDates[branch][period].set1[0], items=num_reports):
                    with set2 = load(self.EventsExpDates[branch][period].set2[0], items=num_reports):
                        with scores = load(self.EventsExpDates[branch][period].scores[0], items=num_reports):
                            with adjusted_scores = ADJUST.select_scores(old, new1, new2, set1, set2, scores, num_reports, num_events, outsz=num_reports):
                                save(self.EventsExpDates[branch][period].adjPrinComp[0], adjusted_scores, items=num_reports)
                                self.Branches[branch].step += 1
                                return(self.Branches[branch].step)
