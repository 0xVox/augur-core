# Arithmetic mean of an array, takes fixed-point inputs
macro mean($a, $asz):
    with total = 0:
        with i = 0:
            while i < $asz:
                total += $a[i]
                i += 1
        total / $asz

# Sum elements of array
macro sum($a):
    with $asz = len($a):
        with $total = 0:
            with $i = 0:
                while $i < $asz:
                    $total += $a[$i]
                    $i += 1
                $total

# Proportional distance from zero, inputs are fixed point
macro get_weight($a, $asz):
    with total = 0:
        with i = 0:
            while i < $asz:
                $a[i] = abs($a[i])
                total += $a[i]
                i += 1
        with wt = array($asz):
            with i = 0:
                while i < $asz:
                    wt[i] = $a[i] * 2^64 / total
                    i += 1
            wt

# Bins values to -1, 0, and 1
macro catch($x):
    if $x < -2^64 / 10:
        caught = -2^64
    elif $x > 2^64 / 10:
        caught = 2^64
    else:
        caught = 0
    caught

# Absolute value
macro abs($x):
    with absval = $x:
        if $x < 0:
            absval = -$x
        absval

# Absolute value of all array elements
macro array_abs($a, $asz):
    with absval = array($asz):
        with i = 0:
            while i < $asz:
                absval[i] = abs($a[i])
                i += 1
        absval

# Minimum value of array
macro minimum($a, $asz):
    with minval = $a[0]:
        with i = 1:
            while i < $asz:
                if $a[i] < minval:
                    minval = $a[i]
                i += 1
        minval

# Maximum value of array
macro maximum($a, $asz):
    with maxval = $a[0]:
        with i = 1:
            while i < $asz:
                if $a[i] > maxval:
                    maxval = $a[i]
                i += 1
        maxval

macro fixed_multiply($x, $y):
    $x * $y / 2^64

macro fixed_divide($x, $y):
    $x * 2^64 / $y

# funid: 0
def consensus(votes:a, reputation:a, max_iterations):
    ONE = 2^64
    TRUE = ONE
    FALSE = -ONE
    INDETERMINATE = 2^63  # 0.5
    NO_RESPONSE = 0       # 0

    startgas = tx.gas
    num_voters = len(reputation)
    v_size = len(votes)
    num_events = v_size / num_voters

    # use existing data and reputations to fill missing observations
    # (weighted average over all non-missing data)
    with votes_mask = array(v_size):
        with missing_values = 0:
            with i = 0:
                while i < v_size:
                    if votes[i] == NO_RESPONSE:
                        votes_mask[i] = ONE
                        missing_values += 1
                    else:
                        votes_mask[i] = 0
                    i += 1

            with votes_filled = array(v_size):
                if missing_values:
                    with outcomes_raw = array(num_events):
                        with j = 0:
                            while j < num_events:
                                with present = array(num_voters):

                                    # reputation of the users who voted, rescaled to sum to 1
                                    with total_active_rep = 0:
                                        with i = 0:
                                            while i < num_voters:
                                                if votes[i*num_events + j] != NO_RESPONSE:
                                                    total_active_rep += reputation[i]
                                                    present[i] = 1
                                                i += 1
                                            with num_present = sum(present):
                                                with active_rep = array(num_present):
                                                    with i = 0:
                                                        with m = 0:
                                                            while i < num_voters:
                                                                if present[i]:
                                                                    active_rep[i - m] = fixed_divide(reputation[i], total_active_rep)
                                                                else:
                                                                    m += 1
                                                                i += 1

                                                    # current best-guess for this event's outcome is a weighted sum
                                                    # (votes weighted by reputation)
                                                    with active_events = array(num_present):
                                                        with i = 0:
                                                            with m = 0:
                                                                while i < num_voters:
                                                                    if present[i]:
                                                                        active_events[i - m] = votes[i*num_events + j]
                                                                        outcomes_raw[j] += fixed_multiply(active_rep[i - m], active_events[i - m])
                                                                    else:
                                                                        m += 1
                                                                    i += 1

                                j += 1

                        with to_fill = array(v_size):
                            with i = 0:
                                while i < num_voters:
                                    with j = 0:
                                        while j < num_events:
                                            with pos = i*num_events + j:
                                                to_fill[pos] += fixed_multiply(votes_mask[pos], outcomes_raw[j])
                                                votes_filled[pos] = catch(votes[pos] + to_fill[pos])
                                            j += 1
                                        i += 1

                else:
                    votes_filled = votes

                # weighted pca: project votes onto principal component
                with weighted_means = array(num_events):
                    with total_weight = 0:
                        with i = 0:
                            while i < num_voters:
                                with j = 0:
                                    while j < num_events:
                                        weighted_means[j] += reputation[i] * votes_filled[i * num_events + j]
                                        j += 1
                                total_weight += reputation[i]
                                i += 1

                            with j = 0:
                                while j < num_events:
                                    weighted_means[j] /= total_weight
                                    j += 1

                            weighted_centered_data = array(v_size)
                            with i = 0:
                                while i < v_size:
                                    weighted_centered_data[i] = votes_filled[i] - weighted_means[i % num_events]
                                    i += 1

                # weighted_centered_data: [0, v_size-1]
                # votes_filled: [v_size, 2*v_size - 1]
                # votes_mask: [2*v_size, 3*v_size - 1]
                with two_v_size = 2*v_size:
                    with three_v_size = 3*v_size:
                        with retval = array(three_v_size):
                            with i = 0:
                                while i < v_size:
                                    retval[i] = weighted_centered_data[i]
                                    i += 1
                                while i < two_v_size:
                                    retval[i] = votes_filled[i - v_size]
                                    i += 1
                                while i < three_v_size:
                                    retval[i] = votes_mask[i - two_v_size]
                                    i += 1
                                # log(tx.gas)
                                return(retval, three_v_size)

# funid: 1
def pca_init(num_voters, num_events, max_iterations):
    # initialize the loading vector (extra element at end is to store iterations left)
    with lv_size = num_events + 1:
        with loading_vector = array(lv_size):
            loading_vector[0] = 2^64
            loading_vector[num_events] = max_iterations
            # log(tx.gas)
            return(loading_vector, lv_size)

# funid: 2
def pca_loadings(loading_vector:a, weighted_centered_data:a, reputation:a, num_voters, num_events, max_iterations):
    with ONE = 2^64:
        with lv_size = len(loading_vector):
            with s = array(num_events):
                with j = 0:
                    while j < num_voters:
                        with d_dot_lv = 0:
                            with k = 0:
                                while k < num_events:
                                    d_dot_lv += weighted_centered_data[j*num_events + k] * loading_vector[k]
                                    k += 1
                                d_dot_lv /= ONE
                            with k = 0:
                                while k < num_events:
                                    s[k] -= d_dot_lv * weighted_centered_data[j*num_events + k] * reputation[j]
                                    k += 1
                        j += 1

                # loading_vector = normalize(s)
                # (first rejig s to account for double fixed multiplication in loop)
                with j = 0:
                    while j < num_events:
                        s[j] /= 2^128
                        j += 1

                # QQ
                with s_dot_s = 0:
                    with j = 0:
                        while j < num_events:
                            s_dot_s += s[j] * s[j]
                            j += 1
                    s_dot_s /= ONE

                    # QQ!!!!
                    with norm_s = s_dot_s / 2:
                        with j = 0:
                            while j < 11:
                                norm_s = (norm_s + s_dot_s*ONE/norm_s) / 2
                                j += 1

                        # fuggin assign
                        with j = 0:
                            while j < num_events:
                                loading_vector[j] = s[j]*ONE/norm_s
                                j += 1
                loading_vector[num_events] -= 1
                # log(tx.gas)
                return(loading_vector, lv_size)

# funid: 3
def pca_scores(loading_vector:a, weighted_centered_data:a, num_voters, num_events):
    with scores = array(num_voters):
        with i = 0:
            while i < num_voters:
                with k = 0:
                    while k < num_events:
                        scores[i] += fixed_multiply(weighted_centered_data[i*num_events + k], loading_vector[k])
                        k += 1
                i += 1
            # log(tx.gas)
            return(scores, num_voters)

# funid: 4
def pca(weighted_centered_data:a, reputation:a, num_voters, num_events, max_iterations):
    ONE = 2^64
    TRUE = ONE
    FALSE = -ONE
    INDETERMINATE = 2^63  # 0.5
    NO_RESPONSE = 0       # 0

    # initialize the loading vector
    with loading_vector = array(num_events):
        loading_vector[0] = ONE
        with i = 0:
            while i < max_iterations:
                ##### pca_iter #####
                with s = array(num_events):
                    with j = 0:
                        while j < num_voters:
                            with d_dot_lv = 0:
                                with k = 0:
                                    while k < num_events:
                                        d_dot_lv += weighted_centered_data[j * num_events + k] * loading_vector[k]
                                        k += 1
                                    d_dot_lv /= ONE
                                with k = 0:
                                    while k < num_events:
                                        s[k] -= d_dot_lv * weighted_centered_data[j * num_events + k] * reputation[j]
                                        k += 1
                            j += 1

                    # loading_vector = normalize(s)
                    # (first rejig s to account for double fixed multiplication in loop)
                    with j = 0:
                        while j < num_events:
                            s[j] /= 2^128
                            j += 1

                    # QQ
                    with s_dot_s = 0:
                        with j = 0:
                            while j < num_events:
                                s_dot_s += s[j] * s[j]
                                j += 1
                        s_dot_s /= ONE

                        # QQ!!!!
                        with norm_s = s_dot_s / 2:
                            with j = 0:
                                while j < 11:
                                    norm_s = (norm_s + s_dot_s*ONE/norm_s) / 2
                                    j += 1

                            # fuggin assign
                            with j = 0:
                                while j < num_events:
                                    loading_vector[j] = s[j]*ONE/norm_s
                                    j += 1
                ##### end pca_iter #####
                i += 1

        with scores = array(num_voters):
            with i = 0:
                while i < num_voters:
                    with k = 0:
                        while k < num_events:
                            scores[i] += fixed_multiply(weighted_centered_data[i*num_events + k], loading_vector[k])
                            k += 1
                    i += 1
            # log(tx.gas)
            return(scores, num_voters)

# funid: 5
def consensus2(reputation:a, scores:a, votes_filled:a, votes_mask:a, num_voters, num_events):
    ONE = 2^64
    TRUE = ONE
    FALSE = -ONE
    INDETERMINATE = 2^63  # 0.5
    NO_RESPONSE = 0       # 0

    startgas = tx.gas
    v_size = len(votes_filled)

    # Which of the two possible 'new' reputation vectors had more opinion in common
    # with the original 'old' reputation.
    with old = array(num_events):
        with new1 = array(num_events):
            with new2 = array(num_events):
                with set1 = array(num_voters):
                    with set2 = array(num_voters):
                        with i = 0:
                            while i < num_voters:
                                set1[i] = scores[i] + abs(minimum(scores, num_voters))
                                set2[i] = scores[i] - maximum(scores, num_voters)
                                i += 1

                        # return(set1, num_voters)
                        # return(set2, num_voters)

                        with wset1 = get_weight(set1, num_voters):
                            with wset2 = get_weight(set2, num_voters):
                                with i = 0:
                                    while i < num_events:
                                        with k = 0:
                                            while k < num_voters:
                                                with pos = k*num_events + i:
                                                    old[i] += fixed_multiply(reputation[k], votes_filled[pos])
                                                    new1[i] += fixed_multiply(wset1[k], votes_filled[pos])
                                                    new2[i] += fixed_multiply(wset2[k], votes_filled[pos])
                                                k += 1
                                        i += 1

                        # return(old, num_events)
                        # return(new1, num_events)
                        # return(new2, num_events)

                        # Difference in sum of squared errors. If > 0, then new1 had higher
                        # errors (use new2); conversely if < 0, then use new1.
                        with sse1 = 0:
                            with sse2 = 0:
                                with i = 0:
                                    while i < num_events:
                                        sse1 += fixed_multiply(new1[i] - old[i], new1[i] - old[i])
                                        sse2 += fixed_multiply(new2[i] - old[i], new2[i] - old[i])
                                        i += 1
                                with ref_ind = sse1 - sse2:
                                    if ref_ind <= 0:
                                        adj_prin_comp = set1
                                    else:
                                        adj_prin_comp = set2

    # Set this to uniform if you want a passive diffusion toward equality
    # when people cooperate.  Instead diffuses towards previous reputation.
    with outcomes_final = array(num_events):
        with rep_weights = get_weight(reputation, num_voters):
            with row_reward_weighted = array(num_voters):
                with i = 0:
                    while i < num_voters:
                        row_reward_weighted[i] = rep_weights[i]
                        i += 1

                # Overwrite the inital declaration IFF there wasn't perfect consensus.
                if maximum(array_abs(adj_prin_comp, num_voters), num_voters) != 0:
                    with mean_weight = mean(row_reward_weighted, num_voters):
                        with i = 0:
                            while i < num_voters:
                                row_reward_weighted[i] = adj_prin_comp[i] * row_reward_weighted[i] / mean_weight
                                i += 1
                    row_reward_weighted = get_weight(row_reward_weighted, num_voters)

                # Freshly-calculated reward (in reputation) using exponential smoothing
                # New Reward: row_reward_weighted
                # Old Reward: rep_weights
                # (0.2 is the adjustable parameter "alpha", hard-coding it for now)
                with smooth_rep = array(num_voters):
                    with i = 0:
                        while i < num_voters:
                            smooth_rep[i] = row_reward_weighted[i]/10 + rep_weights[i]*9/10
                            i += 1

                    # return(smooth_rep, num_voters)

                    with outcomes_raw = array(num_events):
                        with i = 0:
                            while i < num_events:
                                with k = 0:
                                    while k < num_voters:
                                        outcomes_raw[i] += fixed_multiply(smooth_rep[k], votes_filled[k*num_events + i])
                                        k += 1
                                    outcomes_final[i] = catch(outcomes_raw[i])
                                    i += 1

                        # return(votes_filled, v_size)
                        # return(outcomes_raw, num_events)

                        # Smoothing function travels from 0 to 1 with a minimum at .5
                        with certainty = array(num_events):
                            with i = 0:
                                while i < num_events:
                                    with j = 0:
                                        while j < num_voters:
                                            if votes_filled[j*num_events + i] == outcomes_final[i]:
                                                certainty[i] += smooth_rep[j]
                                            j += 1
                                    i += 1
                            # return(outcomes_final, num_events)
                            # return(smooth_rep, num_voters)
                            # return(certainty, num_events)
                            consensus_reward = get_weight(certainty, num_events)

                            # return(outcomes_raw, num_events)
                            # return(certainty, num_events)
                            # return(consensus_reward, num_events)

                    # Event participation (within columns): proportion of reputation
                    # that answered each event
                    with participation_events = array(num_events):
                        with i = 0:
                            while i < num_events:
                                with k = 0:
                                    while k < num_voters:
                                        participation_events[i] += fixed_multiply(smooth_rep[k] votes_mask[k*num_events + i])
                                        k += 1
                                participation_events[i] = ONE - participation_events[i]
                                i += 1

                        # Voter participation (within rows): all events treated equally
                        with participation_voters = array(num_voters):
                            with i = 0:
                                while i < num_voters:
                                    with total = 0:
                                        with j = 0:
                                            while j < num_events:
                                                total += votes_mask[i*num_events + j]
                                                j += 1
                                            participation_voters[i] = ONE - total / num_events
                                    i += 1

                                # General participation
                                with total = 0:
                                    with i = 0:
                                        while i < num_events:
                                            total += participation_events[i]
                                            i += 1
                                    with participation = ONE - total / num_events:

                                        # Bringing it all together!
                                        with voter_bonus = array(num_voters):
                                            with na_bonus_voters = get_weight(participation_voters, num_voters):
                                                with i = 0:
                                                    while i < num_voters:
                                                        voter_bonus[i] = fixed_multiply(na_bonus_voters[i], participation) + fixed_multiply(smooth_rep[i], ONE - participation)
                                                        i += 1
                                            with author_bonus = array(num_events):
                                                with na_bonus_events = get_weight(participation_events, num_events):    
                                                    with i = 0:
                                                        while i < num_events:
                                                            author_bonus[i] = fixed_multiply(na_bonus_events[i], participation) + fixed_multiply(consensus_reward[i], ONE - participation)
                                                            i += 1

                                                    retval = array(2*num_events + num_voters)
                                                    i = 0
                                                    while i < num_events:
                                                        retval[i] = outcomes_final[i]
                                                        i += 1
                                                    i = 0
                                                    while i < num_events:
                                                        retval[num_events + i] = author_bonus[i]
                                                        i += 1
                                                    i = 0
                                                    while i < num_voters:
                                                        retval[2*num_events + i] = voter_bonus[i]
                                                        i += 1
                                                    retval[2*num_events + num_voters] = startgas
                                                    retval[2*num_events + num_voters + 1] = tx.gas
                                                    # log(tx.gas)
                                                    return(retval, 2*num_events + num_voters + 2)

